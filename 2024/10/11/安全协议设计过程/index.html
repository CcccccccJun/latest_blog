<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="设计思路安全协议的目的就是传输数据 并且实现两个基础目标 安全性和可靠性 前者指数据不会被泄露 后者指数据不会被篡改所以数据的传输过程 可以归类于四个阶段“发”  “传“ ”收“ ”验“发送阶段 需要对数据进行加密这里有两种思路 一种是使用对称加密 还有一种是选择非对称加密 从安全性上 个人更倾向使用后者传输阶段 这里打算使用socket来负责两个设备之间的通讯 同时还需要考虑进行身份验证 防止非">
<meta property="og:type" content="article">
<meta property="og:title" content="安全协议设计过程">
<meta property="og:url" content="http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="C12en">
<meta property="og:description" content="设计思路安全协议的目的就是传输数据 并且实现两个基础目标 安全性和可靠性 前者指数据不会被泄露 后者指数据不会被篡改所以数据的传输过程 可以归类于四个阶段“发”  “传“ ”收“ ”验“发送阶段 需要对数据进行加密这里有两种思路 一种是使用对称加密 还有一种是选择非对称加密 从安全性上 个人更倾向使用后者传输阶段 这里打算使用socket来负责两个设备之间的通讯 同时还需要考虑进行身份验证 防止非">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301530.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301497.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011046913.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011809966.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411032223778.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041822760.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827877.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827424.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042034813.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042040695.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042044434.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042107756.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042110907.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051453985.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051457428.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051516319.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411071143676.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411102146493.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111425924.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111457614.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111512583.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111526024.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121401702.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121436529.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121556238.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121944479.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122030673.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122050247.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131014001.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131028279.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131103104.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131105114.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132010995.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132027681.gif">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132028298.png">
<meta property="article:published_time" content="2024-10-11T09:58:59.000Z">
<meta property="article:modified_time" content="2024-11-22T13:17:59.675Z">
<meta property="article:author" content="C12en">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301530.png">
    
    
      
        
          <link rel="shortcut icon" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309142232390.png&#39;">
        
      
      
        
          <link rel="icon" type="image/png" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309142232390.png&#39;" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309142232390.png&#39;">
        
      
    
    <!-- title -->
    <title>安全协议设计过程</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="C12en" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/11/19/house-of-some/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/10/10/arm%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&text=安全协议设计过程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&is_video=false&description=安全协议设计过程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=安全协议设计过程&body=Check out this article: http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&name=安全协议设计过程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&t=安全协议设计过程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%9D%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">传输阶段的一些尝试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-1"><span class="toc-number">2.1.</span> <span class="toc-text">v0.1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">身份验证的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-2"><span class="toc-number">3.1.</span> <span class="toc-text">v0.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-3"><span class="toc-number">3.2.</span> <span class="toc-text">v0.3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-number">4.</span> <span class="toc-text">传输阶段的数据加密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-4"><span class="toc-number">4.1.</span> <span class="toc-text">v0.4</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.</span> <span class="toc-text">代码迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-5"><span class="toc-number">5.1.</span> <span class="toc-text">v0.5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-6"><span class="toc-number">5.2.</span> <span class="toc-text">v0.6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.2.1.</span> <span class="toc-text">多线程实现的学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">多线程应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-7"><span class="toc-number">5.3.</span> <span class="toc-text">v0.7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-8"><span class="toc-number">5.4.</span> <span class="toc-text">v0.8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-9"><span class="toc-number">5.5.</span> <span class="toc-text">v0.9</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v1-0"><span class="toc-number">5.6.</span> <span class="toc-text">v1.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tkinter%E9%83%A8%E5%88%86%E6%8E%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.6.1.</span> <span class="toc-text">tkinter部分控件学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lable"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">lable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#entry"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grid"><span class="toc-number">5.6.1.3.</span> <span class="toc-text">grid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#button"><span class="toc-number">5.6.1.4.</span> <span class="toc-text">button</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#frame"><span class="toc-number">5.6.1.5.</span> <span class="toc-text">frame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#text"><span class="toc-number">5.6.1.6.</span> <span class="toc-text">text</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scrollbar"><span class="toc-number">5.6.1.7.</span> <span class="toc-text">scrollbar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#canvas"><span class="toc-number">5.6.1.8.</span> <span class="toc-text">canvas</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tkinter%E5%AE%9E%E9%99%85%E5%88%A9%E7%94%A8"><span class="toc-number">5.6.2.</span> <span class="toc-text">tkinter实际利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pyside6%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.6.3.</span> <span class="toc-text">pyside6学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA"><span class="toc-number">5.6.3.1.</span> <span class="toc-text">简单窗口显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qt-designer"><span class="toc-number">5.6.3.2.</span> <span class="toc-text">qt designer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">5.6.3.3.</span> <span class="toc-text">函数绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81"><span class="toc-number">5.6.4.</span> <span class="toc-text">最终代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v1-1"><span class="toc-number">5.7.</span> <span class="toc-text">v1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93"><span class="toc-number">5.7.1.</span> <span class="toc-text">优化数据包传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2ui%E4%BB%A5%E5%8F%8A%E5%A5%BD%E5%8F%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.7.2.</span> <span class="toc-text">添加个人界面ui以及好友系统</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        安全协议设计过程
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">C12en</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-10-11T09:58:59.000Z" class="dt-published" itemprop="datePublished">2024-10-11</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/extra/">extra</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>安全协议的目的就是传输数据 并且实现两个基础目标 安全性和可靠性 前者指数据不会被泄露 后者指数据不会被篡改<br>所以数据的传输过程 可以归类于四个阶段<br>“发”  “传“ ”收“ ”验“<br>发送阶段 需要对数据进行加密<br>这里有两种思路 一种是使用对称加密 还有一种是选择非对称加密 从安全性上 个人更倾向使用后者<br>传输阶段 这里打算使用socket来负责两个设备之间的通讯 同时还需要考虑进行身份验证 防止非法用户传输<br>接受阶段 为了防止攻击者使用过量的数据来瘫痪通讯 也许需要加入过滤机制来接受数据 这一点考虑到实现的复杂 是否加入还有待考虑<br>验证阶段 需要对接受到的数据进行检测 以防止数据被篡改或者是传输不完整</p>
<h1 id="传输阶段的一些尝试"><a href="#传输阶段的一些尝试" class="headerlink" title="传输阶段的一些尝试"></a>传输阶段的一些尝试</h1><p>对于socket的使用并不是非常熟练 打算先通过一些简单的交互来加深一下<br>本机的ubuntu虚拟机同时充当客户端和服务端  使用python语言编写</p>
<h2 id="v0-1"><a href="#v0-1" class="headerlink" title="v0.1"></a>v0.1</h2><p>服务端代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">s = socket.socket() #创建套接字 默认使用TCP协议</span><br><span class="line">s.bind((&quot;127.0.0.1&quot;,6666))</span><br><span class="line">s.listen(5) #最多连接5个客户端</span><br><span class="line">print(&quot;等待连接中&quot;)</span><br><span class="line">while 1:</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    print(sock,addr)</span><br><span class="line">    while 1:</span><br><span class="line">        text = sock.recv(1024) #接受的最大字节数为1024</span><br><span class="line">        if len(text.strip()) == 0:</span><br><span class="line">            print(&quot;服务端接收到客户端的数据为空&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;收到客户端发送的数据为：&#123;&#125;&quot;.format(text.decode()))</span><br><span class="line">            content = input(&quot;请输入发送给客户端的信息：&quot;)</span><br><span class="line">            sock.send(content.encode())</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((&quot;127.0.0.1&quot;,6666))</span><br><span class="line">print(&quot;成功连接&quot;)</span><br><span class="line">while 1:</span><br><span class="line">    data = input(&quot;需要向服务端传输的数据 :&quot;)</span><br><span class="line">    s.send(data.encode())</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    print(&quot;服务端发送的数据为:&#123;&#125;&quot;,format(text))</span><br></pre></td></tr></table></figure>
<p>实现效果<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301530.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301530.png" alt="image.png"></a><br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301497.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301497.png" alt="image.png"></a></p>
<h1 id="身份验证的实现"><a href="#身份验证的实现" class="headerlink" title="身份验证的实现"></a>身份验证的实现</h1><p>目前思考的是采用哪种身份验证方案<br>一种是采用第三方验证 比如auth0 这种的虽然实现起来更加高级且安全<br>第二种就是只需要做到安全的密钥交换 然后采用静态的用户密码库存储(也可以更换成sql) 然后加密传输用户名密码即可<br>考虑到第一种方法工作量太大 而且实现起来复杂(其实就是不会得边学边写) 还是乖乖采用第二种方法吧<br>这里采用dh算法 来实现在不安全的通讯中传输共享密钥  获得到共享密钥后 使用aes加密算法来加密用户名和密码<br>暂时是通过静态的用户名和密码库来实现身份验证 同时这里还存在一个攻击漏洞 对于密码的检测是遍历密码库中的所有密码 有满足的即可 并没有检验是否对应该用户</p>
<h2 id="v0-2"><a href="#v0-2" class="headerlink" title="v0.2"></a>v0.2</h2><p>服务端代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import random</span><br><span class="line">import math</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]</span><br><span class="line">passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def Authentication(sock,shared_key):</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    decrypted_username = aes.decrypt(username)</span><br><span class="line">    username = (unpad(decrypted_username, 16)).decode()</span><br><span class="line">    if username in users:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        if password in passwds:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            return</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            exit()</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 0xB7E4DE6A253A6E3A1F7F6E2A8F9FBA6E8C6F1A8F9C7D7F7AA6A3E1E9B7EAE4E8C6F7F6B7E4D6E8C6A3E2E9E8F9F7E5E8C2D1E8F8C6D2E5A1F5E2A5E8D8C5D8A5E5B7A5F5A8D7A5F1E5B4D5A1</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(&quot;等待连接中&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print(sock,addr)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        Authentication(sock,shared_key)</span><br><span class="line">        while 1:</span><br><span class="line">            text = sock.recv(1024) #接受的最大字节数为1024</span><br><span class="line">            if len(text.strip()) == 0:</span><br><span class="line">                print(&quot;服务端接收到客户端的数据为空&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(f&quot;收到客户端发送的数据为：&#123;text.decode()&#125;&quot;)</span><br><span class="line">                content = input(&quot;请输入发送给客户端的信息：&quot;)</span><br><span class="line">                sock.send(content.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;进行身份验证&quot;)</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    username_bytes = pad(username.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_username = aes.encrypt(username_bytes)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        password_bytes = pad(password.encode(&#x27;utf-8&#x27;),AES.block_size)</span><br><span class="line">        encrypt_password = aes.encrypt(password_bytes)</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 0xB7E4DE6A253A6E3A1F7F6E2A8F9FBA6E8C6F1A8F9C7D7F7AA6A3E1E9B7EAE4E8C6F7F6B7E4D6E8C6A3E2E9E8F9F7E5E8C2D1E8F8C6D2E5A1F5E2A5E8D8C5D8A5E5B7A5F5A8D7A5F1E5B4D5A1</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        data = input(&quot;需要向服务端传输的数据 :&quot;)</span><br><span class="line">        s.send(data.encode())</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        print(f&quot;服务端发送的数据为:&#123;text&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>针对账号密码的问题 进行了一波优化<br>使用sqlite3模块和sql数据库配合使用  实现账号密码的校验<br>暂时只打算把注册账号的权限给admin用户 在权限校验这块还存在问题 使用的是username的检测 严谨一点的应该加入数据库的参数 这样方便后面更改用户的操作权限<br>这一版大致优化了一些交互 不过还是很简陋 预计后面要增加窗口化界面<br>同时目前最关键的问题是 dh算法的g参数 我还没去跑出来一个较大的数 还是使用的2</p>
<h2 id="v0-3"><a href="#v0-3" class="headerlink" title="v0.3"></a>v0.3</h2><p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import random</span><br><span class="line">import math</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]</span><br><span class="line">passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode()</span><br><span class="line">    return data</span><br><span class="line">    </span><br><span class="line">def Authentication(sock,shared_key,cursor):</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1</span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0</span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            exit()</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;&quot;&quot;</span><br><span class="line">    菜单选项:</span><br><span class="line">    1. 传输文本数据</span><br><span class="line">    2. 传输附件</span><br><span class="line">    3. 注册新用户</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt():</span><br><span class="line">    #还没写</span><br><span class="line">    return</span><br><span class="line">def transfer_file():</span><br><span class="line">    #还没写</span><br><span class="line">    return</span><br><span class="line">def register(permission_value,sock,shared_key,cursor):</span><br><span class="line">    if permission_value == 0:</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :</span><br><span class="line">        sock.send(&quot;输入注册用户名&quot;.encode())</span><br><span class="line">        username = (sock.recv(1024))</span><br><span class="line">        username = decrypt_data(shared_key,username)</span><br><span class="line">        sock.send(&quot;输入密码&quot;.encode())</span><br><span class="line">        password = sock.recv(1024)</span><br><span class="line">        password = decrypt_data(shared_key,password)</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(&quot;等待连接中&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print(sock,addr)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        permission_value = Authentication(sock,shared_key,cursor)</span><br><span class="line">        while 1:</span><br><span class="line">            menu(sock)</span><br><span class="line">            choice = (sock.recv(1024)).decode()</span><br><span class="line">            if choice == &quot;1&quot;:</span><br><span class="line">                transfer_txt()</span><br><span class="line">            elif choice == &quot;2&quot;:</span><br><span class="line">                transfer_file()</span><br><span class="line">            elif choice == &quot;3&quot;:</span><br><span class="line">                register(permission_value,sock,shared_key,cursor)</span><br><span class="line">            else:</span><br><span class="line">                sock.send(&quot;输入的选项错误 请重新输入&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;进行身份验证&quot;)</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password)</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    print((s.recv(1024)).decode())</span><br><span class="line">    username = input(&quot;输入用户名&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    password = input(&quot;输入密码&quot;)</span><br><span class="line">    encrypt_password = encrypt_data(shared_key,password)</span><br><span class="line">    s.send(encrypt_password)</span><br><span class="line">    print((s.recv(1024)).decode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(&quot;输入选项:&quot;)</span><br><span class="line">        s.send(choice.encode())</span><br><span class="line">        if choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="传输阶段的数据加密"><a href="#传输阶段的数据加密" class="headerlink" title="传输阶段的数据加密"></a>传输阶段的数据加密</h1><p>这一章节的目的是设计出来一个数据包格式<br>常规的应该是由这几个部分组成 包头+密文长度+密文+校验和<br>这就要设计到两个算法 消息加密算法以及消息摘要算法<br>加密还是老样子 使用dh算法得到的共享密钥来进行aes加密<br>摘要算法的目的是为了保证消息的完整性<br>这里就使用md5算法<br>目前打算将数据包格式定义成下图所示<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011046913.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011046913.png" alt="image.png"></a><br>消息类型负责优化原本的服务端和客户端 原本的服务端针对传输数据类型不同以及新增用户的功能 是采用了菜单形式 过于简单且多了许多额外的交互 这里选择将choice变量融合到数据中一起传输<br>然后还得完善上一章节预留的 传输文件 这里打算暂时只包括传输图像 音频 文本文件 更多的格式和文件类型由于没有经过测试 不知道能不能完整的传输过去<br>对于服务端来说 接受到文件后 还需要判断属于哪种类型的文件 方便保存<br>想到的是两种方案  一种是客户端发送文件的时候额外发送文件的类型 服务端接受后按照类型保存文件<br>第二种是 在服务端接受数据后利用magic库来判断文件类型<br>但是这两种方法 似乎都很容易被绕过 要是客户端将马伪造成正常格式的文件传过来就不好玩了<br>虽然但是 本次只是打算设计一个能用的安全协议 所以安全性这里就只是预警一下 不去研究如何改进了 这里采用第二种方法<br>在编写传输图像文件的时候 遇到了一个新的问题<br>按照上面的数据包 单个数据包最多传输0xffffbytes 但是一个图像不止这些字节 所以就需要分段传输  那么我们就需要在数据包格式中的消息类型 加入是否属于切片传输的位置 来供服务端判断<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011809966.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011809966.png" alt="image.png"></a><br>迭代了数据包格式 前面的判断位之所以给了4byte 考虑到服务端处理切片数据的时候 需要确定当前是否属于最后一个切片(常规的协议一般在数据包中增加当前切片对于整段数据的偏移 这里我打算做简单一点) 所以前2个byte用来存储一共有多少个切片 后两个byte用来存储当前是第几个切片<br>而检测是否属于切片数据包也很容易 只要这4个byte不为\x00即可<br>同时 这个版本还优化了之前代码中的一些逻辑漏洞 容易造成服务端的server运行中断</p>
<h2 id="v0-4"><a href="#v0-4" class="headerlink" title="v0.4"></a>v0.4</h2><p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]</span><br><span class="line">passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line">conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    # 创建 MD5 哈希对象</span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    # 更新哈希对象</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line"></span><br><span class="line">    # 获取十六进制的哈希值</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode() </span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    base_data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    data = base64.b64decode(base_data.encode())</span><br><span class="line">    value = verify_md5(data,data_md5,sock)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send(f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;.encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send(f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;.encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,value</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,cursor):</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1</span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0</span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输 请按照规定格式发送数据&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    if data_type == &quot;text/plain&quot;:</span><br><span class="line">        with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data.encode())</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key):</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(2048))</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    if data_type == &quot;image/png&quot;:</span><br><span class="line">        with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line">    # if data_type == &quot;text/plain&quot;:</span><br><span class="line">    #     with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">    #         f.write(data_bytes)</span><br><span class="line">    # sock.send(&quot;成功接受到文件&quot;.encode())</span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,shared_key,cursor,data):</span><br><span class="line">    if permission_value == 0:</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5,sock):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">        print(&quot;公钥交换成功&quot;)</span><br><span class="line">        print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">        shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">        print(&quot;等待连接中&quot;)</span><br><span class="line">        print(sock,addr)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        permission_value = Authentication(sock,shared_key,cursor)</span><br><span class="line">        if permission_value == 3:</span><br><span class="line">            continue</span><br><span class="line">        while 1:</span><br><span class="line">            menu(sock)</span><br><span class="line">            orign_data = (sock.recv(2048))</span><br><span class="line">            if len(orign_data) == 0:</span><br><span class="line">                break</span><br><span class="line">            sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">            if data_type == 1:</span><br><span class="line">                transfer_txt(addr,data)</span><br><span class="line">            elif data_type == 2:</span><br><span class="line">                if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                    transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">                else:</span><br><span class="line">                    transfer_file(sock,data)</span><br><span class="line">            elif data_type ==3:</span><br><span class="line">                register(permission_value,sock,shared_key,cursor,data)</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">1.传输文本数据</span><br><span class="line">2.传输文件数据</span><br><span class="line">3.新增用户</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    # 创建 MD5 哈希对象</span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    # 更新哈希对象</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line"></span><br><span class="line">    # 获取十六进制的哈希值</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,base_data,shared_key,sliced,sum,data):</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,base_data.decode())</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp</span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;进行身份验证&quot;)</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password)</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    base_data = base64.b64encode(data.encode())</span><br><span class="line">    transfer_data = pack_data(3,base_data,shared_key,0,0,data.encode())</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)</span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        base64_text = base64.b64encode(text.encode())</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(base64_text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text.encode())</span><br><span class="line">        transfer_data = pack_data(1,base_text,shared_key,sliced,sliced_sum,text.encode())</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;)</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced_basedata = base64.b64encode(sliced_data[i])</span><br><span class="line">            transfer_data = pack_data(2,sliced_basedata,shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text)</span><br><span class="line">        transfer_data = pack_data(2,base_text,shared_key,sliced,sliced_sum,text)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="代码迭代"><a href="#代码迭代" class="headerlink" title="代码迭代"></a>代码迭代</h1><p>针对一个简单协议所需要的功能已经大体实现了 接下来的任务就是优化服务端和客户端的代码<br>主要的目标大致如下<br>1.添加图形化界面 优化交互过程<br>2.优化代码逻辑 增加注释 提高代码美观度<br>3.完善程序功能</p>
<h2 id="v0-5"><a href="#v0-5" class="headerlink" title="v0.5"></a>v0.5</h2><p>该版本优化了代码逻辑 完善了注释<br>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,base_data,shared_key,sliced,sum,data):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,base_data.decode())</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    base_data = base64.b64encode(data.encode())</span><br><span class="line">    transfer_data = pack_data(3,base_data,shared_key,0,0,data.encode())</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        base64_text = base64.b64encode(text.encode())</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(base64_text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text.encode())</span><br><span class="line">        transfer_data = pack_data(1,base_text,shared_key,sliced,sliced_sum,text.encode())</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced_basedata = base64.b64encode(sliced_data[i])</span><br><span class="line">            transfer_data = pack_data(2,sliced_basedata,shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text)</span><br><span class="line">        transfer_data = pack_data(2,base_text,shared_key,sliced,sliced_sum,text)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line">conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;等待客户机连接&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    print(f&quot;客户机&#123;sock&#125;&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr  #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode() </span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    base_data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    data = base64.b64decode(base_data.encode())</span><br><span class="line">    value = verify_md5(data,data_md5,sock)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,value</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,cursor):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1</span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0</span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    if data_type == &quot;text/plain&quot;:</span><br><span class="line">        with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data.encode())</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(2048))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(&quot;客户机意外中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    if data_type == &quot;image/png&quot;:</span><br><span class="line">        with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">        with open(&quot;output.mp3&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,shared_key,cursor,data):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5,sock):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">        print(&quot;公钥交换成功&quot;)</span><br><span class="line">        print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">        shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        permission_value = Authentication(sock,shared_key,cursor)</span><br><span class="line">        if permission_value == 3:</span><br><span class="line">            print(&quot;客户机意外中断连接&quot;)</span><br><span class="line">            continue</span><br><span class="line">        while 1:</span><br><span class="line">            menu(sock)</span><br><span class="line">            orign_data = (sock.recv(2048))</span><br><span class="line">            if len(orign_data) == 0:</span><br><span class="line">                print(&quot;客户机意外中断连接&quot;)</span><br><span class="line">                break</span><br><span class="line">            sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">            if data_type == 1:</span><br><span class="line">                transfer_txt(addr,data)</span><br><span class="line">            elif data_type == 2:</span><br><span class="line">                if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                    transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">                else:</span><br><span class="line">                    transfer_file(sock,data)</span><br><span class="line">            elif data_type ==3:</span><br><span class="line">                register(permission_value,sock,shared_key,cursor,data)</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="v0-6"><a href="#v0-6" class="headerlink" title="v0.6"></a>v0.6</h2><p>这一版针对传输过慢的原因进行了排除 感觉是因为传之前过了一遍base64的原因 这里进行了删除<br>以前的代码实际上是没有考虑过多端连接的 所以这一版的代码主要针对多端连接进行优化<br>原本的代码 client1连接后  client2能够连接上服务器 但是交换公钥的时候会阻塞<br>这是因为公钥交换相关的代码没有考虑到多端的情况<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411032223778.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411032223778.png" alt="image.png"></a><br>来假设一种情况 客户机A连接上服务端后 进行密钥交换完成后 开始进入数据传输阶段<br>按照原本的程序设计 此时的服务端程序已经进入了while循环处理数据传输的请求<br>但是如果此时有客户机B想要连接服务端 服务端就不会去处理客户机B的密钥交换<br>为了解决这个问题 应该要使用线程池来处理多线程的情况<br>多线程的实现难点应该在于确保多个线程之间的共享数据同步 在设计程序之间并没有这方面的经验 所以打算先通过编写几个简单的程序来熟悉一下</p>
<h3 id="多线程实现的学习"><a href="#多线程实现的学习" class="headerlink" title="多线程实现的学习"></a>多线程实现的学习</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line">    print(threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p>通过定义一个thread对象 并且赋值target 即需要该线程执行的函数 同时给予参数<br>定义完成后thread对象完成初始化 通过start来运行线程<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041822760.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041822760.png" alt="image.png"></a><br>主进程和线程是同时运行的 如果想要让主进程阻塞 等待线程运行结束后再运行主线程<br>这时候可以使用join来让主进程等待线程执行完毕</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    # thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    print(f&quot;thread1线程当前存活情况&#123;thread1.is_alive()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827877.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827877.png" alt="image.png"></a><br>接下来加入join</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    # thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join(1)</span><br><span class="line">    print(f&quot;thread1线程当前存活情况&#123;thread1.is_alive()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827424.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827424.png" alt="image.png"></a><br>join的原理是等待对应thread对象执行完毕 或者给予参数 等待参数时间<br>所以也可以用来规划两个进程的执行先后顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p>上述代码应该是先执行thread1 但是由于thread2调用了join 此时应该会先等待thread2执行完毕再执行其他线程  这里print_name函数的sleep也是为了防止thread1执行过快导致还没主进程还没执行thread2.join()就结束了<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042034813.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042034813.png" alt="image.png"></a><br>接着来看下面的程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">        print(f&quot;现在是线程&#123;threading.current_thread().name&#125;第&#123;i&#125;次执行循环&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;主进程即将结束&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p>按照预期的效果 在输出”主进程即将结束”后 主进程应该就结束了 同时thread1执行全部循环至少需要5s 而主进程执行时间应该在2-5以内 但是事实是主进程要一直等到thread1执行完毕才能结束<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042040695.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042040695.png" alt="image.png"></a><br>这一点是由定义thread对象的时候 一个叫daemon的参数决定的<br>其默认值为False 即主进程等待thread1线程执行完毕后才能结束 如果改为True 主进程结束时 线程就会结束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">        print(f&quot;现在是线程&#123;threading.current_thread().name&#125;第&#123;i&#125;次执行循环&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,),daemon=True)</span><br><span class="line">    thread1.start()</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;主进程即将结束&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042044434.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042044434.png" alt="image.png"></a><br>如果想要让线程1执行两个函数呢<br>即执行完函数A后再执行函数B 这一点实现起来也很简单 只需要在函数A的最后调用函数B即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def next_task():</span><br><span class="line">    print(&quot;这是第二个任务&quot;)</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(&quot;这是第一个任务&quot;)</span><br><span class="line">    next_task()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042107756.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042107756.png" alt="image.png"></a><br>但是这一操作的弊端也很明显 那就是假如此时我们需要创建两个线程<br>线程1需要先执行函数A再执行函数B<br>线程2需要先执行函数B再执行函数A<br>这时候就会产生冲突 这又得去编写一个中转函数来识别需求 然后做if分支了 显然十分麻烦<br>这时候就可以自定义thread类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class myself_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;这是线程&#123;self.name&#125;在运行&quot;)</span><br><span class="line"></span><br><span class="line">    def test(self):</span><br><span class="line">        print(&quot;这是一个测试函数&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = myself_thread()</span><br><span class="line">    thread1.run()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.test()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure>
<p>如上述代码 我们自定义了一个myself_thread类 并且继承了threading.Thread 这个类的run函数以及其他函数都可以由我们自定义 针对不同的需求来调用函数也变得十分简单<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042110907.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042110907.png" alt="image.png"></a><br>如果服务端采用这种方式来新增线程 考虑到如果遭受ddos攻击 那么处理的线程数就会过多<br>这时候应该考虑采用线程池的方法来处理<br>线程池在程序启动时就创建大量空闲线程 在程序需要线程来执行函数的时候 就会分配一个线程出来 当线程执行完毕后 又会回到线程池 因此使用线程池可以有效的控制程序中并发线程的数量<br>运行下面这个程序 创建一个含有10个空闲线程的线程池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name():</span><br><span class="line">    print(f&quot;现在是线程&#123;threading.current_thread().name&#125;正在执行&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=10)</span><br><span class="line"></span><br><span class="line">thread1 = pool.submit(print_name)</span><br><span class="line">thread2 = pool.submit(print_name)</span><br></pre></td></tr></table></figure>
<p>输出的结果为<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051453985.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051453985.png" alt="image.png"></a><br>说明执行时间过短 在线程0执行完毕后 就作为空闲线程返回线程池 随后第二次需要执行print_name函数的时候 就又被分配出来了<br>为了印证猜想 在print_name函数中加入time.sleep(0.5)<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051457428.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051457428.png" alt="image.png"></a><br>这时就是由两个线程来处理了<br>还可以使用map方法来并发的调用线程 不过需要注意的是 (1,2,3)是赋予给print_name函数的参数 但是实际上print_name不需要参数 这一点暂时还没找到方法来优化 总感觉有点多余 但是不给予参数 map又无法指定调用多少个线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(number):</span><br><span class="line">    print(f&quot;现在是线程&#123;threading.current_thread().name&#125;正在执行&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=10)</span><br><span class="line"></span><br><span class="line">thread = pool.map(print_name,(1,2,3))</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051516319.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051516319.png" alt="image.png"></a><br>最后的输出结果仍然是全部由线程0来负责 说明map方法就是简化了多个submit方法</p>
<h3 id="多线程应用"><a href="#多线程应用" class="headerlink" title="多线程应用"></a>多线程应用</h3><p>目前的整改思路如下:<br>服务端:<br>主进程负责处理accpet 有客户机连接就调用一个线程来处理密钥交换和数据传输  然后这个线程就专门负责这台客户机 如果客户机中断连接 那就释放线程 回到线程池<br>客户端:<br>这块的整改还在考虑中 因为就目前来说 传输效率确实有点感人了 传一个10mb的音频都需要十来分钟 如果客户端改成 可以并发的传输数据 即同时传输音频和图像 或者是把一个音频拆成多个线程来传输 这样效率应该可以大大提高 但是感觉编写难度有点大啊 看着来吧<br>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">import base64</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode(&#x27;latin1&#x27;)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):  #处理非切片数据</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode( )</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    if data_type == &quot;text/plain&quot;:</span><br><span class="line">        with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data)</span><br><span class="line">    sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">    print(f&quot;成功接受到文件&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(&quot;客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    if data_type == &quot;image/png&quot;:</span><br><span class="line">        with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">        with open(&quot;output.mp3&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">    print(f&quot;成功接受到文件&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行身份验证&quot;)</span><br><span class="line">    permission_value = Authentication(sock,shared_key,query_thread1)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            transfer_txt(addr,data)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">            else:</span><br><span class="line">                transfer_file(sock,data)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            register(permission_value,sock,data,query_thread1)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="v0-7"><a href="#v0-7" class="headerlink" title="v0.7"></a>v0.7</h2><p>程序到这一版已经设计的比较完善了 可能还存在一些逻辑漏洞可以造成服务端宕机等问题 这个就留到后续的安全性分析吧 这一版本主要还是想优化一下文件传输的问题<br>目前的问题在于  校验数据完整性没有进行处理 比如如果失败 应该记录下失败的数据组序号 然后返回给客户机<br>然后就是识别文件类别的那块代码 现在用的是python-magic库来识别是属于什么文件 然后创建对应的文件用来存储接收到的数据<br>不过不是很确定这个库他是不是只是对文件头进行识别 如果是的话感觉还是相当好伪造的 这里应该有一个比较大的安全隐患<br>同时原本的类型处理也比较少 只适配了txt png mp3这三个最常见的格式 需要增加如果识别文件类型失败 就进行临时存储 同时报错<br>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        failure_msg = &quot;第&quot;</span><br><span class="line">        failure_number = None</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            if &quot;失败&quot; in text:</span><br><span class="line">                start_index = text.find(&#x27;&#123;&#x27;) + 1</span><br><span class="line">                end_index = text.find(&#x27;&#125;&#x27;)</span><br><span class="line">                failure_number = text[start_index:end_index]</span><br><span class="line">                failure_msg += failure_number+&quot;,&quot;</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        failure_msg += &quot;组传输失败&quot;</span><br><span class="line">        if failure_number != None:</span><br><span class="line">            print(failure_msg)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode(&#x27;latin1&#x27;)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+threading.current_thread().name</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_bytes = data_bytes.encode(&#x27;latin1&#x27;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+threading.current_thread().name</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value = Authentication(sock,shared_key,query_thread1)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            transfer_txt(addr,data)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">            else:</span><br><span class="line">                transfer_file(sock,data)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            register(permission_value,sock,data,query_thread1)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="v0-8"><a href="#v0-8" class="headerlink" title="v0.8"></a>v0.8</h2><p>这一版本的目的在于增加日志功能 因为就目前来说 一旦连接的客户机多了 服务端那边的输出就会比较混乱<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411071143676.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411071143676.png" alt="image.png"></a><br>具体的实现应该也比较简单  在accpet连接后就创建一个文件以及字符串(作为记录该客户机操作记录的缓冲区)<br>然后在检测客户机中断连接后就把缓冲区的内容写入日志 并且加入时间 来方便朔源<br>或者直接在执行对应操作后就写入日志 不过从理论上来说应该是前者的方案更加节省资源<br>预计难点在于在哪里塞入判断来check什么时候写入日志 所以还是选择后者吧<br>同时还把原本写的和屎一样的传输数据类型转化优化了一下 变成了好闻的屎<br>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data,log_file,addr):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;).encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输数据过程中第&#123;sliced_num+1&#125;组数据校验失败&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    if len(username) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return             </span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    username = username.decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        if len(password) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            sock.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        password = decrypt_data(shared_key,password)</span><br><span class="line">        password = password.decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;   &quot;+current_time</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != (sliced_sum-1):</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)       </span><br><span class="line">            sock.close()     </span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            transfer_txt(addr,data,log_file)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file)</span><br><span class="line">            else:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file(sock,data,addr,log_file)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            register(permission_value,sock,data,query_thread1,log_file,addr,username)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        failure_msg = &quot;第&quot;</span><br><span class="line">        failure_number = None</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            if &quot;失败&quot; in text:</span><br><span class="line">                start_index = text.find(&#x27;&#123;&#x27;) + 1</span><br><span class="line">                end_index = text.find(&#x27;&#125;&#x27;)</span><br><span class="line">                failure_number = text[start_index:end_index]</span><br><span class="line">                failure_msg += failure_number+&quot;,&quot;</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        failure_msg += &quot;组传输失败&quot;</span><br><span class="line">        if failure_number != None:</span><br><span class="line">            print(failure_msg)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="v0-9"><a href="#v0-9" class="headerlink" title="v0.9"></a>v0.9</h2><p>这个版本的目的是修修bug 尽量优化一下代码 准备在1.0版本实现图形化管理界面 然后就正式结束了这个项目<br>针对传输速率过慢的问题 大概有了头绪了 原因出在客户端输出当前组数据校验是否正确 这一功能是利用客户端和服务端高频send和recv的 所以会造成卡顿<br>取消掉了以后发送速度明显提高 但是接受速度跟不上了 这里想到的解决办法是专门给大文件收发开一个新线程 看看能不能实现 然后关于切片那一块可能也要优化一下了<br>11&#x2F;9记<br>mlgb 我觉得用socket作为这个协议的基础框架根本就是个错误的选择 服务端运行在服务器上的时候 会因为各种奇奇怪怪的原因导致丢包 最后只能通过sleep来控制客户端发包的速度<br>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data,log_file,addr):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == False:</span><br><span class="line">        fail_number = sliced_num</span><br><span class="line">    else:</span><br><span class="line">        fail_number = None</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,fail_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    if len(username) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return             </span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    username = username.decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        if len(password) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            sock.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        password = decrypt_data(shared_key,password)</span><br><span class="line">        password = password.decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;   &quot;+current_time</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,first_data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据</span><br><span class="line">    data_bytes = first_data</span><br><span class="line">    orign_data = []</span><br><span class="line">    fail_number = []</span><br><span class="line">    </span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        text = sock.recv(1084)</span><br><span class="line">        orign_data.append(text)</span><br><span class="line">        if len(text) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)    </span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)       </span><br><span class="line">            sock.close()     </span><br><span class="line">            return</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行数据处理&quot;)</span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data[i],log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    </span><br><span class="line">    if len(fail_number)&gt;0:</span><br><span class="line">        fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        fail_number = []</span><br><span class="line">        orign_data = (sock.recv(1084))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        if len(fail_number)&gt;0:</span><br><span class="line">            fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">        </span><br><span class="line">        if data_type == 1:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            transfer_txt(addr,data,log_file)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file)</span><br><span class="line">            else:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file(sock,data,addr,log_file)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            register(permission_value,sock,data,query_thread1,log_file,addr,username)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            time.sleep(0.06)</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+f&quot;正在传输第&#123;i&#125;组 当前运行了&#123;temp:.2f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        # print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="v1-0"><a href="#v1-0" class="headerlink" title="v1.0"></a>v1.0</h2><p>最终版本! 最大的更新就是给客户端增加了图形化界面 看起来更高级一点<br>而且为了服务图形化界面的逻辑 所以一些客户机和服务机的交互也更改了</p>
<h3 id="tkinter部分控件学习"><a href="#tkinter部分控件学习" class="headerlink" title="tkinter部分控件学习"></a>tkinter部分控件学习</h3><p>第一次尝试编写图形化界面 这里就选用tkinter库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p>这样短短三行 即可生成一个根窗口 子窗口关闭后根窗口不会关闭 根窗口关闭后子窗口会关闭<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411102146493.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411102146493.png" alt="image.png"></a><br>可以对窗口进行一些简单的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;1000x800&quot;)  #设置窗口大小</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;) #设置窗口左上角图标</span><br><span class="line">root.config(bg=&quot;green&quot;)  #设置窗口背景颜色</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111425924.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111425924.png" alt="image.png"></a><br>接下来可以使用相关控件来帮助我们构建</p>
<h4 id="lable"><a href="#lable" class="headerlink" title="lable"></a>lable</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">meg = Label(root,text=&quot;this is a test&quot;)</span><br><span class="line">meg.pack(padx=100,side=&quot;left&quot;)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p>lable控件可以在窗口上显示文字或者图像<br>size可以控制控件在哪里显示 默认是top<br>padx和pady则是代表着和x轴或者y轴的偏移是多少<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111457614.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111457614.png" alt="image.png"></a><br>显示图片的话 最好再加上pillow库来配合 因为tk本身支持的图片格式有点少 只支持png</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">temp = Image.open(&quot;1.png&quot;)</span><br><span class="line">temp.thumbnail((100,100)) #如果图片过大的话 可以利用thumbnail来限制图片大小</span><br><span class="line">image = ImageTk.PhotoImage(temp)</span><br><span class="line">meg = Label(root,image=image)</span><br><span class="line">meg.pack(side=&quot;left&quot;,padx=250)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111512583.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111512583.png" alt="image.png"></a></p>
<h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>这个控件可以在窗口上显示一个输入框 配合lable控件就可以实现引导程序使用者输入变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">control1 = Label(root,text=&quot;测试输出&quot;)</span><br><span class="line">control1.pack(side=&quot;left&quot;)</span><br><span class="line">control2 = Entry(root)</span><br><span class="line">control2.pack(side=&quot;left&quot;)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111526024.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111526024.png" alt="image.png"></a><br>不过这样需要两个控件的位置相匹配 用pack中的padx,pady,side处理一对还好 要是界面需要设计的点多 就会比较杂乱 这里可以使用grid控件来配合</p>
<h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><p>grid插件相当于把整个窗口界面转化成了一个二维坐标系<br>row参数用来规定行数 column用来规定列数<br>于是上面用pack需要计算padx和pady来实现的效果 可以简单的用这两个参数来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">control1 = Label(root,text=&quot;测试输出&quot;)</span><br><span class="line">control1.grid(row=0)</span><br><span class="line">control2 = Entry(root)</span><br><span class="line">control2.grid(row=0,column=1)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121401702.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121401702.png" alt="image.png"></a></p>
<h4 id="button"><a href="#button" class="headerlink" title="button"></a>button</h4><p>上述控件和button控件组合起来 就可以实现一个简单的账号密码登录界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">var=IntVar()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line"># root.geometry(&quot;200x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">def check():</span><br><span class="line">    username = entry1.get()</span><br><span class="line">    password = entry2.get()</span><br><span class="line">    if username == &quot;admin&quot; and password == &quot;admin&quot;:</span><br><span class="line">        print(&quot;账号密码正确&quot;)</span><br><span class="line"></span><br><span class="line">Label(root,text=&quot;用户名&quot;,padx=10,pady=10).grid(row=0,sticky=W)</span><br><span class="line">Label(root,text=&quot;密码&quot;).grid(row=1,sticky=E,padx=10,pady=10)</span><br><span class="line"></span><br><span class="line">entry1 = Entry(root)</span><br><span class="line">entry1.grid(row=0,column=1)</span><br><span class="line">entry2 = Entry(root)</span><br><span class="line">entry2.grid(row=1,column=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">button1 = Button(root,text=&quot;登录&quot;,command=check)</span><br><span class="line">button1.grid(row=0,column=2,rowspan=2,columnspan=2,padx=10)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121436529.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121436529.png" alt="image.png"></a></p>
<h4 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h4><p>大部分时候  主窗口的大小都需要提前设置 而非由控件大小来自动规划窗口大小 这个时候控件相对于主窗口就会较小 造成界面的不美观<br>下面这个示例 frame1容器收纳了三个控件 这三个控件的grid控制的是在frame1容器中的位置<br>而frame1的grid控制的则是在主窗口中的位置 这样可以更加方便的设置不同控件的相对位置<br>不过最好使用grid_propagate方法来固定容器的位置 不然随着后续容器中的控件位置发生变化 容器的位置也会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x100&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    </span><br><span class="line">    frame1 = Frame(root)</span><br><span class="line">    </span><br><span class="line">    Label(frame1,text=&quot;ip地址&quot;).grid(row=0,column=0)</span><br><span class="line">    Entry(frame1).grid(row=0,column=1)</span><br><span class="line">    Button(frame1,text=&quot;连接&quot;).grid(row=0,column=2,padx=10)</span><br><span class="line">    </span><br><span class="line">    frame1.grid(padx=50,pady=30)</span><br><span class="line">    </span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121556238.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121556238.png" alt="image.png"></a></p>
<h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p>这一个控件的作用和entry相似 只不过entry只能支持一行的输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    </span><br><span class="line">    text = Text(root,width=40,height=10)</span><br><span class="line">    text.grid(padx=7)</span><br><span class="line">    text.insert(&#x27;1.0&#x27;,&quot;test&quot;)</span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>上述代码中insert负责给文本框写入数据<br>这里的1.0代表的是第一行第0个字符开始写入<br>你也可以使用1.end来表示第一行的最后一个字符<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121944479.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121944479.png" alt="image.png"></a></p>
<h4 id="scrollbar"><a href="#scrollbar" class="headerlink" title="scrollbar"></a>scrollbar</h4><p>这个控件主要是配合text使用 在最右边加一个滚动条 看起来美观一点 也方便用户更直观的知道当前文本框中的所处位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    s1 = Scrollbar(root,width=20)</span><br><span class="line">    s1.grid(row=0,column=1,sticky=NS)</span><br><span class="line">    text = Text(root,width=35,height=10,yscrollcommand=s1.set,wrap=CHAR)</span><br><span class="line">    text.grid(row=0,column=0,padx=7)</span><br><span class="line">    text.insert(&#x27;1.0&#x27;,&quot;test&quot;)</span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>yscrollcommand用来绑定滚动条和text wrap参数用来规定是否自动换行 参数有WORD CHAR NONE三种 第一种是单词换行 第二种是字符换行 第三种是不自动换行<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122030673.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122030673.png" alt="image.png"></a></p>
<h4 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h4><p>这个控件主要用于显示文本 图片等 主要是可以绑定scrollbar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    c1 = Canvas(root,width=280)</span><br><span class="line">    c1.grid(row=0,column=0,sticky=W)</span><br><span class="line">    s1 = Scrollbar(root,width=20,command=c1.yview)</span><br><span class="line">    s1.grid(row=0,column=1,sticky=NS)</span><br><span class="line">    c1.config(yscrollcommand=s1.set)</span><br><span class="line">    </span><br><span class="line">    frame1 = Frame(c1)</span><br><span class="line"></span><br><span class="line">    c1.create_window((0, 0), window=frame1, anchor=&#x27;nw&#x27;)</span><br><span class="line"></span><br><span class="line">    for i in range(20):</span><br><span class="line">        Label(frame1, text=f&quot;Label &#123;i+1&#125;&quot;).pack()</span><br><span class="line">        </span><br><span class="line">    frame1.update_idletasks()</span><br><span class="line">    c1.config(scrollregion=c1.bbox(&quot;all&quot;))</span><br><span class="line">    </span><br><span class="line">    root.mainloop()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>创建出一个canvas控件后 还需要创建一个内部窗口 用来显示文本或者图片<br>scrollbar绑定的是canvas 但是输出的文本还是依靠label<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122050247.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122050247.png" alt="image.png"></a></p>
<h3 id="tkinter实际利用"><a href="#tkinter实际利用" class="headerlink" title="tkinter实际利用"></a>tkinter实际利用</h3><p>基于tk来实现图形化界面 现在主要是卡在滚动条的实现 本来预期是打算设计成<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131014001.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131014001.png" alt="image.png"></a><br>上面部分用来显示操作界面 下面用来输出信息<br>然后下面的部分本来想着是加一个滚动条来查看输出信息过多的情况下以往的输出信息<br>但是tk的滚动条实现起来实在有点太麻烦了 而且tk的美观程度也很差 就是因为他的控件布局太难用了 所以写到这里就烂尾了 看看后面还有没有兴趣搞下去吧 暂时是打算转用pyside6了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from tkinter.ttk import Separator</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_message_to_frame2(frame2, text, row=None, column=0, sticky=W):</span><br><span class="line">    &quot;&quot;&quot;统一处理向frame2添加消息的函数&quot;&quot;&quot;</span><br><span class="line">    if not hasattr(frame2, &#x27;current_row&#x27;):</span><br><span class="line">        frame2.current_row = 0</span><br><span class="line">    if not hasattr(frame2, &#x27;max_rows&#x27;):</span><br><span class="line">        frame2.max_rows = 5</span><br><span class="line">    </span><br><span class="line">    if row is None:</span><br><span class="line">        row = frame2.current_row</span><br><span class="line">    </span><br><span class="line">    # 如果超过最大行数，清除所有控件并重置行计数</span><br><span class="line">    if frame2.current_row &gt;= frame2.max_rows:</span><br><span class="line">        for widget in frame2.winfo_children():</span><br><span class="line">            widget.destroy()</span><br><span class="line">        frame2.current_row = 0</span><br><span class="line">        </span><br><span class="line">    Label(frame2, text=text, bg=&quot;white&quot;).grid(row=frame2.current_row, column=column, sticky=sticky)</span><br><span class="line">    frame2.current_row += 1</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client):   #交换公钥</span><br><span class="line">    ip = ipaddr.get()</span><br><span class="line">    s.connect((ip,6666))</span><br><span class="line">    add_message_to_frame2(frame2, &quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    </span><br><span class="line">    for widget in frame1.winfo_children():</span><br><span class="line">        widget.destroy()</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    public_key_server = serialization.load_pem_public_key(public_key_server)</span><br><span class="line">    add_message_to_frame2(frame2, &quot;公钥交换成功,开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key,frame1,frame2)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def finish_connect(s):</span><br><span class="line">    s.close()</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">def menu(s,shared_key,frame1,frame2):</span><br><span class="line">    for widget in frame1.winfo_children():</span><br><span class="line">        widget.destroy()</span><br><span class="line">    button1 = Button(frame1,text=&quot;传输文本&quot;,command=lambda:transfer_txt(s,shared_key,frame1,frame2)).grid(row=0,column=0,padx=60,pady=20)</span><br><span class="line">    button2 = Button(frame1,text=&quot;传输文件&quot;,command=lambda:transfer_file(s,shared_key)).grid(row=0,column=1)</span><br><span class="line">    button3 = Button(frame1,text=&quot;注册用户&quot;,command=lambda:register(s,shared_key)).grid(row=1,column=0)</span><br><span class="line">    button4 = Button(frame1,text=&quot;退出程序&quot;,command=lambda:finish_connect(s)).grid(row=1,column=1)</span><br><span class="line"></span><br><span class="line">def login(entry1,entry2,s,shared_key,frame2,frame1):</span><br><span class="line">    username = entry1.get()</span><br><span class="line">    password = entry2.get()</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = encrypt_data(shared_key,data)  #使用aes加密账号密码</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line">    text = (s.recv(1024)).decode()</span><br><span class="line">    </span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        add_message_to_frame2(frame2, text)</span><br><span class="line">        s.close()</span><br><span class="line">    elif text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">        add_message_to_frame2(frame2, text)</span><br><span class="line">        s.close()</span><br><span class="line">    else:</span><br><span class="line">        add_message_to_frame2(frame2, text)</span><br><span class="line">        menu(s,shared_key,frame1,frame2)</span><br><span class="line"></span><br><span class="line">def focus_next(entry):</span><br><span class="line">    entry.focus()</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key,frame1,frame2):</span><br><span class="line">    add_message_to_frame2(frame2, &quot;开始进行身份验证&quot;)</span><br><span class="line">    Label(frame1,text=&quot;用户名&quot;).grid(row=0,pady=30)</span><br><span class="line">    Label(frame1,text=&quot;密码&quot;).grid(row=1)</span><br><span class="line">    entry1 = Entry(frame1)</span><br><span class="line">    entry1.grid(row=0,column=1,padx=10)</span><br><span class="line">    entry2 = Entry(frame1)</span><br><span class="line">    entry1.bind(&quot;&lt;Return&gt;&quot;,lambda event:focus_next(entry2))</span><br><span class="line">    entry2.grid(row=1,column=1,padx=10)</span><br><span class="line">    entry2.bind(&quot;&lt;Return&gt;&quot;,lambda event:login(entry1,entry2,s,shared_key,frame2,frame1))</span><br><span class="line">    Button(frame1,text=&quot;登录&quot;,height=3,width=7,command=lambda : login(entry1,entry2,s,shared_key,frame2,frame1)).grid(row=0,column=2,rowspan=2,pady=(30,0))</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt1(entry1,s,shared_key,frame2):</span><br><span class="line">    text = entry1.get(&#x27;1.0&#x27;,END)</span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            try:</span><br><span class="line">                s.send(transfer_data)</span><br><span class="line">                add_message_to_frame2(frame2, &quot;发送成功&quot;)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                add_message_to_frame2(frame2, f&quot;发送失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        try:</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            add_message_to_frame2(frame2, &quot;发送成功&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            add_message_to_frame2(frame2, f&quot;发送失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key,frame1,frame2):  #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    for widget in frame1.winfo_children():</span><br><span class="line">        widget.destroy()</span><br><span class="line">    s1 = Scrollbar(frame1,width=20)</span><br><span class="line">    Label(frame1,text=&quot;传输数据:&quot;).grid(row=0,column=0,sticky=W,padx=5)</span><br><span class="line">    s1.grid(row=1,column=1,sticky=NS)</span><br><span class="line">    text = Text(frame1,width=38,height=6,yscrollcommand=s1.set,wrap=CHAR)</span><br><span class="line">    text.grid(row=1,column=0,padx=5)</span><br><span class="line">    Button(frame1,command=lambda:transfer_txt1(text,s,shared_key,frame2),text=&quot;发送&quot;).grid(row=2,column=0,pady=5,sticky=E)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            time.sleep(0.06)</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+f&quot;正在传输第&#123;i+1&#125;组 当前运行了&#123;temp:.2f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    root = Tk()</span><br><span class="line">    root.title(&quot;协议大作业-第六组&quot;)</span><br><span class="line">    root.geometry(&quot;300x300&quot;)</span><br><span class="line">    </span><br><span class="line">    frame1 = Frame(root,width=300,height=150)</span><br><span class="line">    frame2 = Frame(root,width=300,height=150,bg=&quot;white&quot;)</span><br><span class="line">    frame2.current_row = 0</span><br><span class="line">    frame2.max_rows = 6  # 设置最大显示行数</span><br><span class="line">    </span><br><span class="line">    Label(frame1,text=&quot;ip地址:&quot;).grid(row=0,padx=10,pady=50)  #输入ip地址</span><br><span class="line">    ipaddr = Entry(frame1)</span><br><span class="line">    ipaddr.bind(&quot;&lt;Return&gt;&quot;,lambda event:key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client))</span><br><span class="line">    ipaddr.grid(row=0,column=1)</span><br><span class="line">    Button(frame1,text=&quot;连接&quot;,command=lambda: key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client),width=10).grid(row=0,column=2,padx=10)</span><br><span class="line">    </span><br><span class="line">    frame1.grid(row=0)</span><br><span class="line">    frame1.grid_propagate(0)</span><br><span class="line">    frame2.grid(row=2)</span><br><span class="line">    frame2.grid_propagate(0)</span><br><span class="line">    </span><br><span class="line">    separator = Frame(root, height=2, bd=1, relief=SUNKEN) #分割线</span><br><span class="line">    separator.grid(row=1, column=0, sticky=EW)</span><br><span class="line">    </span><br><span class="line">    root.mainloop()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="pyside6学习"><a href="#pyside6学习" class="headerlink" title="pyside6学习"></a>pyside6学习</h3><h4 id="简单窗口显示"><a href="#简单窗口显示" class="headerlink" title="简单窗口显示"></a>简单窗口显示</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from PySide6.QtWidgets import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    window = QWidget()</span><br><span class="line">    </span><br><span class="line">    window.setWindowTitle(&quot;安全协议大作业&quot;)</span><br><span class="line">    window.setFixedSize(400,300)</span><br><span class="line">    </span><br><span class="line">    label = QLabel(&quot;测试输出&quot;,window)</span><br><span class="line">    label.move(175,125)</span><br><span class="line">    </span><br><span class="line">    window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>上述程序可以创建出一个窗口后简单的输出文字 总体的逻辑是和tk差不多的<br>需要创建一个窗口对象 然后给窗口增加控件<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131028279.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131028279.png" alt="image.png"></a></p>
<h4 id="qt-designer"><a href="#qt-designer" class="headerlink" title="qt designer"></a>qt designer</h4><p>我觉得pyside6相较于tk最显著的优势就是 可以使用编辑工具来简化ui的设计<br>如图所示 设计一个简单的ui<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131103104.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131103104.png" alt="image.png"></a><br>保存ui文件 在程序中载入ui 然后加载到一个窗口上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from PySide6.QtCore import QFile, QIODevice</span><br><span class="line">from PySide6.QtUiTools import QUiLoader</span><br><span class="line">from PySide6.QtWidgets import QApplication</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ui_file = QFile(&quot;test.ui&quot;)</span><br><span class="line">    loader = QUiLoader()</span><br><span class="line">    </span><br><span class="line">    app = QApplication()</span><br><span class="line">    window = loader.load(ui_file)</span><br><span class="line">    </span><br><span class="line">    window.setWindowTitle(&quot;安全协议大作业&quot;)</span><br><span class="line">    # window.setFixedSize(400,300)</span><br><span class="line">    </span><br><span class="line">    ui_file.close()</span><br><span class="line">    </span><br><span class="line">    window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131105114.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131105114.png" alt="image.png"></a><br>可以看到非常简单的就实现了这几个控件 比tk挪半天位置好用多了  tk是人用的吗???</p>
<h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p>解决了ui设计的难题后 接下来的重点就是放在函数的绑定上 其实也很简单 就是要注意自己在qt designer中定义的控件名称<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132010995.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132010995.png" alt="image.png"></a><br>然后需要把ui文件转化成py文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyside6-uic filename.ui -o filename.py</span><br></pre></td></tr></table></figure>
<p>随后在程序中直接导入即可<br>然后函数绑定的大体上是和tk一致的 具体到各个控件的方法有些不太一样 就有需求的自己查询 这里放一个我自己弄的账号密码登录程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from ui import Ui_Form</span><br><span class="line"></span><br><span class="line">class mywindow(QMainWindow,Ui_Form):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        </span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        </span><br><span class="line">        hide_pwd = self.checkBox.stateChanged.connect(lambda:self.hide_password())</span><br><span class="line">        login_button = self.b1.clicked.connect(lambda:self.login())</span><br><span class="line">        exit_button = self.pushButton_2.clicked.connect(lambda:self.exit_process())</span><br><span class="line">    </span><br><span class="line">    def exit_process(self):</span><br><span class="line">        exit()</span><br><span class="line">    </span><br><span class="line">    def hide_password(self):</span><br><span class="line">        state = self.lineEdit_2.echoMode()</span><br><span class="line">        if str(state) == &quot;EchoMode.Password&quot;:</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Normal)</span><br><span class="line">        else :</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password)</span><br><span class="line">    </span><br><span class="line">    def login(self):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        password = self.lineEdit_2.text()</span><br><span class="line">        if username == &quot;admin&quot; and password == &quot;admin&quot;:</span><br><span class="line">            msg = &quot;登录成功&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif len(username)==0:</span><br><span class="line">            msg = &quot;必须输入账号&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif len(password) ==0:</span><br><span class="line">            msg = &quot;必须输入密码&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif username != &quot;admin&quot;:</span><br><span class="line">            msg = &quot;账号不存在&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif password != &quot;admin&quot;:</span><br><span class="line">            msg = &quot;密码错误&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    w1 = mywindow()</span><br><span class="line">    w1.show()</span><br><span class="line">    app.exec()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>写这么久博客第一次放gif图 看起来画质一般般 而且也捕获不到弹出的第二个窗口 哎下次改进吧<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132027681.gif" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132027681.gif" alt="image.png"></a><br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132028298.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132028298.png" alt="image.png"></a></p>
<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>v1.0版本最后采用了pyside6作为图形化界面框架 把客户端用图形化界面包了起来<br>同时为了配合客户端的优化 服务端也作了一些修改<br>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始传输数据&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(self,sock,username,password,addr,login_username,log_file):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (str(username), str(password)))</span><br><span class="line">            conn.commit()</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;已存在,注册失败&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)失败 因为用户已存在&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line">        sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data,log_file,addr):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == False:</span><br><span class="line">        fail_number = sliced_num</span><br><span class="line">    else:</span><br><span class="line">        fail_number = None</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,fail_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    en_data = (sock.recv(1024))</span><br><span class="line">    if len(en_data) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    data = decrypt_data(shared_key,en_data)</span><br><span class="line">    parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">    username = parts[0].decode()</span><br><span class="line">    password = parts[1].decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;   &quot;+current_time</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,first_data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据</span><br><span class="line">    data_bytes = first_data</span><br><span class="line">    orign_data = []</span><br><span class="line">    fail_number = []</span><br><span class="line">    </span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        text = sock.recv(1084)</span><br><span class="line">        orign_data.append(text)</span><br><span class="line">        if len(text) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)    </span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)       </span><br><span class="line">            sock.close()     </span><br><span class="line">            return</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行数据处理&quot;)</span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        print(f&quot;\r&#123;threading.current_thread().name&#125;:正在处理第&#123;i+1&#125;组数据&quot;,end=&quot;&quot;)</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data[i],log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    </span><br><span class="line">    if len(fail_number)&gt;0:</span><br><span class="line">        fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0].decode()</span><br><span class="line">        password = parts[1].decode()</span><br><span class="line">        try:</span><br><span class="line">            query_thread1.add_user(sock,username,password,addr,login_username,log_file)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        fail_number = []</span><br><span class="line">        orign_data = (sock.recv(1084))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        if len(fail_number)&gt;0:</span><br><span class="line">            fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">        </span><br><span class="line">        if data_type == 1:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            transfer_txt(addr,data,log_file)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file)</span><br><span class="line">            else:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file(sock,data,addr,log_file)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            register(permission_value,sock,data,query_thread1,log_file,addr,username)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;192.168.220.130&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">from ip_connect import Ipwindow</span><br><span class="line">from login import loginwindow</span><br><span class="line">from main import mainwindow</span><br><span class="line">from progressbar import barwindow</span><br><span class="line">from register import registerwindow</span><br><span class="line"></span><br><span class="line">class ipwindow(QMainWindow,Ipwindow):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.ip_connect())</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.ip_connect())</span><br><span class="line">        </span><br><span class="line">    def ip_connect(self):</span><br><span class="line">        ipaddr = self.lineEdit.text()</span><br><span class="line">        key_switch(ipaddr,self)</span><br><span class="line">        </span><br><span class="line">class loginwindow(QMainWindow,loginwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.login(s,shared_key))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.move_focus(self.lineEdit_2))</span><br><span class="line">        l2 = self.lineEdit_2.returnPressed.connect(lambda:self.login(s,shared_key))</span><br><span class="line">    </span><br><span class="line">    def move_focus(self,lineEdit):</span><br><span class="line">        lineEdit.setFocus()</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line"></span><br><span class="line">    def login(self,s,shared_key):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                Authentication(s,shared_key,username,password,self)</span><br><span class="line"></span><br><span class="line">class mainwindow(QMainWindow,mainwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        self.current_number = 1</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.choose_mode(1,s,shared_key)) </span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.choose_mode(2,s,shared_key))</span><br><span class="line">        b3 = self.pushButton_3.clicked.connect(lambda:self.choose_mode(3,s,shared_key))</span><br><span class="line">        b4 = self.pushButton_4.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        b5 = self.pushButton_5.clicked.connect(lambda:self.handle_send(s,shared_key))</span><br><span class="line">        b6 = self.pushButton_6.clicked.connect(lambda:self.clear_text())</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line">    </span><br><span class="line">    def clear_text(self):</span><br><span class="line">        self.textEdit.clear()</span><br><span class="line"></span><br><span class="line">    def choose_mode(self,mode,s,shared_key):</span><br><span class="line">        self.current_number = mode</span><br><span class="line">        if mode == 1:</span><br><span class="line">            self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==2:</span><br><span class="line">            self.pushButton_2.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==3:</span><br><span class="line">            self.pushButton_3.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            register(s,shared_key,self)</span><br><span class="line"></span><br><span class="line">    def handle_send(self,s,shared_key):</span><br><span class="line">        if self.current_number == 1:</span><br><span class="line">            transfer_txt(s,shared_key,self)</span><br><span class="line">        elif self.current_number == 2:</span><br><span class="line">            transfer_file(s,shared_key,self)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">class barwindow(QMainWindow,barwindow):</span><br><span class="line">    def __init__(self,text,sliced_sum,transfer_data,s,main_window):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.progressBar.setValue(0)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        l1 = self.label.setText(text)</span><br><span class="line">        b1 = self.pushButton_2.clicked.connect(lambda:self.start_transfer(sliced_sum,transfer_data,s,main_window))</span><br><span class="line">        b2 = self.pushButton.clicked.connect(lambda:self.end_transfer(s))</span><br><span class="line">    </span><br><span class="line">    def start_transfer(self,sliced_sum,transfer_data,s,main_window):</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            time.sleep(0.06)</span><br><span class="line">            self.progressBar.setValue((i/(sliced_sum-1))*100)</span><br><span class="line">            QApplication.processEvents()</span><br><span class="line">        self.pushButton_2.setText(&quot;再次发送&quot;)</span><br><span class="line">        QMessageBox.information(None,&quot;输出信息&quot;,&quot;信息发送成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    def end_transfer(self,s):</span><br><span class="line">        s.send(b&quot;&quot;)</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">class registerwindow(QMainWindow,registerwindow):</span><br><span class="line">    def __init__(self,s,shared_key,main_window):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.register(s,shared_key,main_window))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_mainwindow())</span><br><span class="line">    </span><br><span class="line">    def register(self,s,shared_key,main_window):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        password = self.lineEdit_2.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">                return</span><br><span class="line">            data = username+&quot;;&quot;+password</span><br><span class="line">            transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = s.recv(1024).decode()</span><br><span class="line">            if &quot;成功&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;输出信息&quot;,&quot;用户注册成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            elif &quot;存在&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户已存在&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    def return_mainwindow(self):</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(ipaddr,ip_window):   #交换公钥</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        s.connect((ipaddr,6666))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,str(e),QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    public_key_server = serialization.load_pem_public_key(public_key_server)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    login_window = loginwindow(s,shared_key)</span><br><span class="line">    ip_window.close()</span><br><span class="line">    login_window.show()</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key,username,password,login_window):</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = encrypt_data(shared_key,data)  #使用aes加密账号密码</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line">    text = (s.recv(1024)).decode()</span><br><span class="line">    </span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    elif text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        main_window = mainwindow(s,shared_key)</span><br><span class="line">        login_window.close()</span><br><span class="line">        main_window.show()</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key,main_window):</span><br><span class="line">    register_window = registerwindow(s,shared_key,main_window)</span><br><span class="line">    register_window.show()</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key,main_window):</span><br><span class="line">    text = main_window.textEdit.toPlainText()</span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">    main_window.textBrowser.append(&quot;文本数据传输成功&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key,main_window):</span><br><span class="line">    file_addr = main_window.textEdit.toPlainText()</span><br><span class="line">    file_addr = file_addr.replace(&quot;file:///&quot;,&quot;&quot;)</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    ip_window = ipwindow()</span><br><span class="line">    ip_window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="v1-1"><a href="#v1-1" class="headerlink" title="v1.1"></a>v1.1</h2><p>这个版本主要是继续增加一些功能<br>1.原本的只是简单的实现客户端向服务端传输数据 并且ui的设计中上半部分显然也是预留给双端通讯(以服务端为媒介 客户机a与客户机b实时通讯)的  缺乏了这个功能总感觉有点遗憾<br>2.登录和注册界面的功能也不是特别完善 再加上每次运行程序都需要重新输入ip地址和账号密码感觉不是特别方便 所以考虑优化一下这些东西<br>3.作为一个合格的协议 目前还缺少的一点就是数字签名部分 需要提供不可抵赖性 证明消息是由对应客户机发送的 而非被劫持后的<br>第二点的实现比较简单 稍微更改一下login.ui和ip_connect.ui和对应的类就可以了<br>要实现第一点的话 就要对目前的ui界面进行大改动了  而且还要给服务端增加处理与好友私聊以及群聊的功能  客户端这边也要处理好发送和接收 感觉是一个比较大的工程<br>总结下为了实现第一点需要去补充的功能<br>1.客户端新增好友功能  以登录时的username为账号 添加好友(或者干脆不做这个 实现起来没啥必要)后可以进行通讯<br>第一点的实现问题在于 如果客户端B离线 那么服务端那边就需要缓存A传输给B的数据 然后在B上线后发送给B<br>如果两者都在线的情况 如何处理好数据的转发也是一种难题 毕竟现在的代码就因为高频的send和recv的时候会因为网络延迟导致丢包 偷懒没有去写处理丢包的逻辑 而是人为控制客户端发包的速率来解决这个问题 本来速率就比较慢了 如果这个时候还需要把数据从服务端发送给客户端B 这个时间就比较久了  没办法实现实时通讯<br>按理来说 解决这一个方法也比较简单 大概可以从两个方面来实现<br>(1)加一个检测丢包的机制 如果发现丢包就重传<br>(2)经过测试 如果是一个体型较小的文件传输程序 是可以做到快速传输的 不需要手动添加发包延迟也可以 所以如果在传输大数据前新分配一个线程专门负责 会不会改善网络延迟、丢包的影响<br>2.服务端需要和数据库进行交互来记录不同用户之间的好友列表 还要写添加好友的功能<br>3.ui界面需要进行更新 这里依然是偷懒的选择抄袭qq的聊天界面 打算再原本左侧的选项栏的右边增加选择在哪个频道(群聊or私聊)发送消息<br>如果把上面提到的全部解决  这会是一个庞大的工程量 接下来优先解决丢包重传的问题<br>然后还有一点最关键的就是 如果想要实现一个基本的通讯软件的功能 即文件文本同时传输 例如表情包加文字的情况  那还需要优化服务端  需要把对于每一个数据包的data_type都进行校验</p>
<h3 id="优化数据包传输"><a href="#优化数据包传输" class="headerlink" title="优化数据包传输"></a>优化数据包传输</h3><p>这一点的优化原本是打算更改一下程序现有的逻辑<br>目前是 如果是无切片情况 那么就根据数据包中的data_byte来决定处理函数<br>如果是切片情况 先处理第一个切片的data_byte 然后选择处理函数<br>那么切片情况的处理就比较不理想了 如果攻击者伪造第一个包的data_type 就有可能导致服务端进入错误的处理函数 导致负责的进程陷入死机 所以理想情况应该是 服务端先接收所有的包 然后再根据每个包的data_type来分别处理<br>然后就是如果是单线程处理切片数据的话 会比较慢 往往传输完毕后过个几十秒才能把数据全部处理完<br>所以打算给处理数据的也加一个线程池 最多10个线程来同时处理<br>同时新增了重传机制 当服务端接收到了大小不满足一个切片长的数据包(除开最后一个数据包) 就会向客户端发送重传请求 客户端接收到后 就会从错误切片编号开始重新传输<br>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">from ip_connect import ipwindow</span><br><span class="line">from login import loginwindow</span><br><span class="line">from main import mainwindow</span><br><span class="line">from progressbar import barwindow</span><br><span class="line">from register import registerwindow</span><br><span class="line"></span><br><span class="line">class ipwindow(QMainWindow,ipwindow):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        with open(&quot;tempfile/ip.txt&quot;,&quot;r&quot;) as file:</span><br><span class="line">            ipaddr = file.read()</span><br><span class="line">            if len(ipaddr) != 0:</span><br><span class="line">                self.lineEdit.setText(ipaddr)</span><br><span class="line">                self.checkBox.setChecked(True)</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.ip_connect())</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.ip_connect())</span><br><span class="line">        </span><br><span class="line">    def ip_connect(self):</span><br><span class="line">        if self.checkBox.isChecked():</span><br><span class="line">            with open(&quot;tempfile/ip.txt&quot;,&quot;w&quot;) as file:</span><br><span class="line">                ipaddr = self.lineEdit.text()</span><br><span class="line">                file.write(ipaddr)</span><br><span class="line">        else:</span><br><span class="line">            with open(&quot;tempfile/ip.txt&quot;,&quot;w&quot;) as file:</span><br><span class="line">                file.write(&quot;&quot;)</span><br><span class="line">        ipaddr = self.lineEdit.text()</span><br><span class="line">        key_switch(ipaddr,self)</span><br><span class="line">        </span><br><span class="line">class loginwindow(QMainWindow,loginwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password)</span><br><span class="line">        with open(&quot;tempfile/user.txt&quot;,&quot;r&quot;) as file:</span><br><span class="line">            user_info = file.read()</span><br><span class="line">            if len(user_info) != 0:</span><br><span class="line">                self.lineEdit.setText(user_info.split(&quot;;&quot;)[0])</span><br><span class="line">                self.lineEdit_2.setText(user_info.split(&quot;;&quot;)[1])</span><br><span class="line">                self.checkBox_2.setChecked(True)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.login(s,shared_key))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.move_focus(self.lineEdit_2))</span><br><span class="line">        l2 = self.lineEdit_2.returnPressed.connect(lambda:self.login(s,shared_key))</span><br><span class="line">        c1 = self.checkBox.stateChanged.connect(lambda:self.hide_password())</span><br><span class="line"></span><br><span class="line">    def hide_password(self):</span><br><span class="line">        if self.checkBox.isChecked():</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Normal)</span><br><span class="line">        else:</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password)</span><br><span class="line"></span><br><span class="line">    def move_focus(self,lineEdit):</span><br><span class="line">        lineEdit.setFocus()</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line"></span><br><span class="line">    def login(self,s,shared_key):</span><br><span class="line">        if self.checkBox_2.isChecked():</span><br><span class="line">            username = self.lineEdit.text()</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            with open(&quot;tempfile/user.txt&quot;, &quot;w&quot;) as file:</span><br><span class="line">                file.write(username + &quot;;&quot; + password)</span><br><span class="line">        else:</span><br><span class="line">            with open(&quot;tempfile/user.txt&quot;,&#x27;w&#x27;) as file:</span><br><span class="line">                file.write(&quot;&quot;)</span><br><span class="line">        </span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                Authentication(s,shared_key,username,password,self)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">class mainwindow(QMainWindow,mainwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        self.current_number = 1</span><br><span class="line">        self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">        self.textEdit.dropEvent = self.dropEvent</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.choose_mode(1,s,shared_key)) </span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.choose_mode(2,s,shared_key))</span><br><span class="line">        b3 = self.pushButton_3.clicked.connect(lambda:self.choose_mode(3,s,shared_key))</span><br><span class="line">        b4 = self.pushButton_4.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        b5 = self.pushButton_5.clicked.connect(lambda:self.handle_send(s,shared_key))</span><br><span class="line">        b6 = self.pushButton_6.clicked.connect(lambda:self.clear_text())</span><br><span class="line">        b7 = self.pushButton_7.clicked.connect(lambda:self.edit_userprofile())</span><br><span class="line">        b9 = self.pushButton_9.clicked.connect(lambda:self.clear_log())</span><br><span class="line">        t1 = self.toolButton.clicked.connect(lambda:self.open_file())</span><br><span class="line">    </span><br><span class="line">    def edit_userprofile(self):</span><br><span class="line">        #尚未施工</span><br><span class="line">        exit()</span><br><span class="line">    def dropEvent(self,event):</span><br><span class="line">        files = event.mimeData().urls()</span><br><span class="line">        file_addr = files[0].toLocalFile()</span><br><span class="line">        if self.current_number == 1:</span><br><span class="line">            with open(file_addr,&#x27;r&#x27;) as file:</span><br><span class="line">                text = file.read()</span><br><span class="line">                self.textEdit.setText(text)</span><br><span class="line">        elif self.current_number == 2:</span><br><span class="line">            self.textEdit.setText(file_addr)</span><br><span class="line"></span><br><span class="line">    def open_file(self):</span><br><span class="line">        file_addr = QFileDialog.getOpenFileName(None,&quot;选择文件&quot;,&quot;F:\作业\python程序&quot;,&quot;所有文件(*);&quot;)</span><br><span class="line">        if self.current_number == 2:</span><br><span class="line">            self.textEdit.setText(file_addr[0])</span><br><span class="line">        else:</span><br><span class="line">            with open(file_addr[0],&#x27;r&#x27;) as file:</span><br><span class="line">                text = file.read()</span><br><span class="line">                self.textEdit.setText(text)</span><br><span class="line"></span><br><span class="line">    def clear_log(self):</span><br><span class="line">        self.textBrowser.clear()</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line">    </span><br><span class="line">    def clear_text(self):</span><br><span class="line">        self.textEdit.clear()</span><br><span class="line"></span><br><span class="line">    def choose_mode(self,mode,s,shared_key):</span><br><span class="line">        self.current_number = mode</span><br><span class="line">        if mode == 1:</span><br><span class="line">            self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==2:</span><br><span class="line">            self.pushButton_2.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==3:</span><br><span class="line">            self.pushButton_3.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            register(s,shared_key,self)</span><br><span class="line"></span><br><span class="line">    def handle_send(self,s,shared_key):</span><br><span class="line">        if self.current_number == 1:</span><br><span class="line">            transfer_txt(s,shared_key,self)</span><br><span class="line">        elif self.current_number == 2:</span><br><span class="line">            transfer_file(s,shared_key,self)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">class barwindow(QMainWindow,barwindow):</span><br><span class="line">    def __init__(self,text,sliced_sum,transfer_data,s,main_window,full_name):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.progressBar.setValue(0)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        l1 = self.label.setText(text)</span><br><span class="line">        b1 = self.pushButton_2.clicked.connect(lambda:self.start_transfer(sliced_sum,transfer_data,s,main_window,full_name))</span><br><span class="line">        b2 = self.pushButton.clicked.connect(lambda:self.end_transfer(s))</span><br><span class="line">    </span><br><span class="line">    def start_transfer(self,sliced_sum,transfer_data,s,main_window,full_name):</span><br><span class="line">        a_time = time.time()</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            self.progressBar.setValue((i/(sliced_sum-1))*100)</span><br><span class="line">            QApplication.processEvents()</span><br><span class="line">        </span><br><span class="line">        count = 0</span><br><span class="line">        while 1:   #设置最大连接时间为2s  用来接收服务端的重传请求 如果数据无误则过2s提示传输成功</span><br><span class="line">            try:</span><br><span class="line">                s.settimeout(2.0)</span><br><span class="line">                text = s.recv(1024).decode()</span><br><span class="line">                if &quot;重传&quot; in text:</span><br><span class="line">                    self.progressBar.setValue(0)</span><br><span class="line">                    count += 1</span><br><span class="line">                    information = f&quot;传输出现丢包 需要进行重传\n当前重传次数:&#123;count&#125;&quot;</span><br><span class="line">                    self.label.setText(information)</span><br><span class="line">                    start = text.find(&quot;[&quot;)+1</span><br><span class="line">                    end = text.find(&quot;]&quot;)</span><br><span class="line">                    number = text[start:end]</span><br><span class="line">                    number = int(number,10)</span><br><span class="line">                    for i in range(number-1,sliced_sum):</span><br><span class="line">                        s.sendall(transfer_data[i])</span><br><span class="line">                        self.progressBar.setValue((i/(sliced_sum-1))*100)</span><br><span class="line">                        QApplication.processEvents()</span><br><span class="line">            except socket.timeout:</span><br><span class="line">                break  </span><br><span class="line">            finally:</span><br><span class="line">                s.settimeout(None)</span><br><span class="line">        </span><br><span class="line">        b_time = time.time()</span><br><span class="line">        self.pushButton_2.setText(&quot;再次发送&quot;)</span><br><span class="line">        QMessageBox.information(None,&quot;输出信息&quot;,f&quot;文件发送成功\n耗时&#123;b_time-a_time:.2f&#125;s&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        main_window.textBrowser.append(f&quot;&#123;full_name&#125;传输成功&quot;)</span><br><span class="line">    def end_transfer(self,s):</span><br><span class="line">        s.send(b&quot;&quot;)</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">class registerwindow(QMainWindow,registerwindow):</span><br><span class="line">    def __init__(self,s,shared_key,main_window):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.register(s,shared_key,main_window))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_mainwindow())</span><br><span class="line">    </span><br><span class="line">    def register(self,s,shared_key,main_window):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        password = self.lineEdit_2.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">                return</span><br><span class="line">            data = username+&quot;;&quot;+password</span><br><span class="line">            transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = s.recv(1024).decode()</span><br><span class="line">            if &quot;成功&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;输出信息&quot;,&quot;用户注册成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            elif &quot;存在&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户已存在&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    def return_mainwindow(self):</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(ipaddr,ip_window):   #交换公钥</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        s.connect((ipaddr,6666))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,str(e),QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    public_key_server = serialization.load_pem_public_key(public_key_server)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    login_window = loginwindow(s,shared_key)</span><br><span class="line">    ip_window.close()</span><br><span class="line">    login_window.show()</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key,username,password,login_window):</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = encrypt_data(shared_key,data)  #使用aes加密账号密码</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line">    text = (s.recv(1024)).decode()</span><br><span class="line">    </span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    elif text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        main_window = mainwindow(s,shared_key)</span><br><span class="line">        login_window.close()</span><br><span class="line">        main_window.show()</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key,main_window):</span><br><span class="line">    register_window = registerwindow(s,shared_key,main_window)</span><br><span class="line">    register_window.show()</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key,main_window):</span><br><span class="line">    text = main_window.textEdit.toPlainText()</span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 1</span><br><span class="line">        sliced_sum = 1</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">    main_window.textBrowser.append(&quot;文本数据传输成功&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key,main_window):</span><br><span class="line">    file_addr = main_window.textEdit.toPlainText()</span><br><span class="line">    file_addr = file_addr.replace(&quot;file:///&quot;,&quot;&quot;)</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    file_name, file_extension = os.path.splitext(os.path.basename(file_addr))</span><br><span class="line">    full_name = file_name+file_extension</span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window,full_name)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    else:</span><br><span class="line">        sliced = 1</span><br><span class="line">        sliced_sum = 1</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window,full_name)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    ip_window = ipwindow()</span><br><span class="line">    ip_window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(self,sock,username,password,addr,login_username,log_file):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (str(username), str(password)))</span><br><span class="line">            conn.commit()</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;已存在,注册失败&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)失败 因为用户已存在&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line">        sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == False:</span><br><span class="line">        fail_number = sliced_num</span><br><span class="line">    else:</span><br><span class="line">        fail_number = None</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,fail_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    en_data = (sock.recv(1024))</span><br><span class="line">    if len(en_data) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    data = decrypt_data(shared_key,en_data)</span><br><span class="line">    parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">    username = parts[0].decode()</span><br><span class="line">    password = parts[1].decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data_bytes,addr,log_file,fail_array): #处理切片数据</span><br><span class="line">    </span><br><span class="line">    if len(fail_array)&gt;0:</span><br><span class="line">        fail_meg = &quot;,&quot;.join(fail_array)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125; 数据疑似遭到篡改&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">def deal_data(shared_key,text,sliced_num,type1,type2,type3,data_bytes,fail_array):</span><br><span class="line">    try:</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail_number = unpack_data(shared_key,text)</span><br><span class="line">        data_bytes.append(data)</span><br><span class="line">        if fail_number is not None:</span><br><span class="line">            fail_array.append(fail_number)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            type1.append(&quot;1&quot;)</span><br><span class="line">        elif sliced_num==1 and sliced_sum ==1 and data_type == 2:</span><br><span class="line">            type2.append(&quot;1&quot;)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            type3.append(&quot;1&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;第&#123;sliced_num&#125;组数据处理有问题 报错:&#123;e&#125;&quot;)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;错误切片长度为&#123;len(text)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0].decode()</span><br><span class="line">        password = parts[1].decode()</span><br><span class="line">        try:</span><br><span class="line">            query_thread1.add_user(sock,username,password,addr,login_username,log_file)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=10)</span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        fail_array = []</span><br><span class="line">        sliced_num = 1</span><br><span class="line">        sliced_sum = 1</span><br><span class="line">        data_list = []</span><br><span class="line">        count = 0</span><br><span class="line">        unpack_text = []</span><br><span class="line">        wrong_number = []</span><br><span class="line">        futures = []</span><br><span class="line">        </span><br><span class="line">        type1 = []</span><br><span class="line">        type2 = []</span><br><span class="line">        type3 = []</span><br><span class="line"></span><br><span class="line">        #先接收数据 再统一处理</span><br><span class="line">        while sliced_num &lt;= sliced_sum:</span><br><span class="line">            text = sock.recv(1084)</span><br><span class="line">            if len(text) == 0:</span><br><span class="line">                print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;中断连接&quot;)</span><br><span class="line">                text = f&quot;客户机中断连接&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                sock.close()</span><br><span class="line">                return</span><br><span class="line">            elif len(text) != 1084:</span><br><span class="line">                if sliced_sum != sliced_num:</span><br><span class="line">                    wrong_number.append(sliced_num)</span><br><span class="line">            unpack_text.append(text)</span><br><span class="line">            if count == 0:</span><br><span class="line">                sliced_sum,sliced_num,_,_,_ = unpack_data(shared_key,text)</span><br><span class="line">                sliced_num += 1</span><br><span class="line">                count = 1</span><br><span class="line">            else :</span><br><span class="line">                sliced_num += 1</span><br><span class="line">        </span><br><span class="line">        #判断切片大小是否符合 否则记录第一个不合格的切片编号</span><br><span class="line">        while 1:</span><br><span class="line">            if len(wrong_number) != 0:</span><br><span class="line">                while True:  #清空缓存区</span><br><span class="line">                    try:</span><br><span class="line">                        sock.settimeout(0.5)</span><br><span class="line">                        data = sock.recv(1084)</span><br><span class="line">                    except socket.timeout:</span><br><span class="line">                        break</span><br><span class="line">                    finally:</span><br><span class="line">                        sock.settimeout(None)</span><br><span class="line">                wrong = wrong_number[0]</span><br><span class="line">                text = f&quot;第[&#123;wrong&#125;]组切片传输发生错误 需要进行重传&quot;</span><br><span class="line">                try:</span><br><span class="line">                    write_log(log_file,text)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(e)</span><br><span class="line">                sock.send(text.encode())</span><br><span class="line">                print(f&quot;&#123;threading.current_thread().name&#125;&quot;+text)</span><br><span class="line">                sliced_num = wrong_number[0]</span><br><span class="line">                wrong_number.clear()</span><br><span class="line">                while sliced_num &lt;= sliced_sum:</span><br><span class="line">                    text = sock.recv(1084)</span><br><span class="line">                    if len(text) != 1084:</span><br><span class="line">                        if sliced_sum != sliced_num:</span><br><span class="line">                            wrong_number.append(sliced_num)</span><br><span class="line">                    unpack_text[sliced_num-1] = text</span><br><span class="line">                    sliced_num += 1</span><br><span class="line">                if len(wrong_number) != 0:</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            else :</span><br><span class="line">                break</span><br><span class="line">        </span><br><span class="line">        if sliced_sum &lt;= 1:</span><br><span class="line">            pool.submit(deal_data,shared_key,unpack_text[0],sliced_num,type1,type2,type3,data_list,fail_array)</span><br><span class="line">        else:</span><br><span class="line">            for i in range(sliced_sum):</span><br><span class="line">                try:</span><br><span class="line">                    future = pool.submit(deal_data,shared_key,(unpack_text[i]),sliced_num,type1,type2,type3,data_list,fail_array)</span><br><span class="line">                    futures.append(future)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(e)        </span><br><span class="line">        </span><br><span class="line">        for future in futures:</span><br><span class="line">            future.result()</span><br><span class="line">        </span><br><span class="line">        data_bytes = b&quot;&quot;.join(data for data in data_list)</span><br><span class="line">        </span><br><span class="line">        if len(type1) == sliced_sum:</span><br><span class="line">            transfer_txt(addr,data_bytes,log_file)</span><br><span class="line">        elif len(type2) == sliced_sum:</span><br><span class="line">            transfer_file(sock,data_bytes,addr,log_file)</span><br><span class="line">        elif len(type3) == sliced_sum:</span><br><span class="line">            transfer_file2(sock,data_bytes,addr,log_file,fail_array)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:传输过程中 data_type疑似被篡改或者发生丢包&quot;)</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;192.168.220.130&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="添加个人界面ui以及好友系统"><a href="#添加个人界面ui以及好友系统" class="headerlink" title="添加个人界面ui以及好友系统"></a>添加个人界面ui以及好友系统</h3><p>这一版本主要是添加一下个人界面的ui设计以及好友系统<br>好友系统的实现 目前是打算客户端这边显示好友列表之前 先向服务端发送请求 服务端根据客户端登录的user来查询存储于数据库中的好友列表并且返回<br>然后就是完善了一下程序运行环境的配置 使得用户使用起来更加方便<br>目前的进度是卡在了用户头像的设置 设想是客户端本地缓存 如果需要更换头像 则传输至服务端 这样在客户端之间互相通讯的时候 可以及时更新</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">categories</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%9D%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">传输阶段的一些尝试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-1"><span class="toc-number">2.1.</span> <span class="toc-text">v0.1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">身份验证的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-2"><span class="toc-number">3.1.</span> <span class="toc-text">v0.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-3"><span class="toc-number">3.2.</span> <span class="toc-text">v0.3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-number">4.</span> <span class="toc-text">传输阶段的数据加密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-4"><span class="toc-number">4.1.</span> <span class="toc-text">v0.4</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.</span> <span class="toc-text">代码迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-5"><span class="toc-number">5.1.</span> <span class="toc-text">v0.5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-6"><span class="toc-number">5.2.</span> <span class="toc-text">v0.6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.2.1.</span> <span class="toc-text">多线程实现的学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">多线程应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-7"><span class="toc-number">5.3.</span> <span class="toc-text">v0.7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-8"><span class="toc-number">5.4.</span> <span class="toc-text">v0.8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0-9"><span class="toc-number">5.5.</span> <span class="toc-text">v0.9</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v1-0"><span class="toc-number">5.6.</span> <span class="toc-text">v1.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tkinter%E9%83%A8%E5%88%86%E6%8E%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.6.1.</span> <span class="toc-text">tkinter部分控件学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lable"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">lable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#entry"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grid"><span class="toc-number">5.6.1.3.</span> <span class="toc-text">grid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#button"><span class="toc-number">5.6.1.4.</span> <span class="toc-text">button</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#frame"><span class="toc-number">5.6.1.5.</span> <span class="toc-text">frame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#text"><span class="toc-number">5.6.1.6.</span> <span class="toc-text">text</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scrollbar"><span class="toc-number">5.6.1.7.</span> <span class="toc-text">scrollbar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#canvas"><span class="toc-number">5.6.1.8.</span> <span class="toc-text">canvas</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tkinter%E5%AE%9E%E9%99%85%E5%88%A9%E7%94%A8"><span class="toc-number">5.6.2.</span> <span class="toc-text">tkinter实际利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pyside6%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.6.3.</span> <span class="toc-text">pyside6学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA"><span class="toc-number">5.6.3.1.</span> <span class="toc-text">简单窗口显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qt-designer"><span class="toc-number">5.6.3.2.</span> <span class="toc-text">qt designer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">5.6.3.3.</span> <span class="toc-text">函数绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81"><span class="toc-number">5.6.4.</span> <span class="toc-text">最终代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v1-1"><span class="toc-number">5.7.</span> <span class="toc-text">v1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93"><span class="toc-number">5.7.1.</span> <span class="toc-text">优化数据包传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2ui%E4%BB%A5%E5%8F%8A%E5%A5%BD%E5%8F%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.7.2.</span> <span class="toc-text">添加个人界面ui以及好友系统</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&text=安全协议设计过程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&is_video=false&description=安全协议设计过程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=安全协议设计过程&body=Check out this article: http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&title=安全协议设计过程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&name=安全协议设计过程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/&t=安全协议设计过程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2025
    C12en
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'c12en';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
